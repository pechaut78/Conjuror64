question,answer
"In the context of the C64, Cursor jumps back to home position.",possible cause: 6510
"In the context of the C64, Abnormal colours appear in the letters.",possible cause: PLA
"In the context of the C64, Different characters are displayed and cursor is locked when turned on and off.","possible cause: 6510, 6567"
"In the context of the C64, System does not reset and the 'RESTORE' key does not work.","possible cause: 6510,PLA, ROM 227"
"In the context of the C64, Cursor disappears after the system warms up.",possible cause: 6526
"In the context of the C64, SYNTAX ERROR displayed after system warms up.",possible cause: ROM 226
"In the context of the C64, The system resets when it warms up and long programs do not load.","possible cause: 6510, ROM 226"
"In the context of the C64, Keyboard does not operate correctly when the system warms up.","possible cause: 6526,ROM 226"
"In the context of the C64, Cassette motor keeps running.",possible cause: 6510
"In the context of the C64, The cursor disappears when the cassette is plugged in.",possible cause: 6510
"In the context of the C64, Cassette runs extremely slow. The program seems to load but willnot run.",possible cause: 6510
"In the context of the C64, Blank screen on power up.","possible cause: 6510, 6567, PLA, 8701 [, RAM ]"
"In the context of the C64, No cursor displayed. Intermittent blank screen. Intermittent graphics.",possible cause: 6510
"In the context of the C64, Powers up with 'PRESS PLAY ON TAPE' message and the display blanks.",possible cause: 6510
"In the context of the C64, On power up the cursor locks up.",possible cause: 6510
"In the context of the C64, When 'RETURN' is pressed after a run command, the cursor goes back to home position.",possible cause: ROM 226
"In the context of the C64, Poke command does not work.",possible cause: ROM 226
"In the context of the C64, Joystick does not operate correctly.",possible cause: 6526
"In the context of the C64, No character lettering is displayed on the screen.","possible cause: 6526, 6567,PLA, ROM 225"
"In the context of the C64, Graphic characters instead of letters displayed.","possible cause: 6526, 6567"
"In the context of the C64, Power up message appears but no cursor.","possible cause: 6526, ROM 226"
"In the context of the C64, DEVICE NOT PRESENT ERROR is displayed when disk is used.","possible cause: 6510,6526"
"In the context of the C64, Disk drives continue to search when trying to load.",possible cause: 6526
"In the context of the C64, Incorrect screen colours or no colour at all.","possible cause: 6567, PLA"
"In the context of the C64, Keyboard does not function.",possible cause: 6526
"In the context of the C64, Cassette recorder problem.","possible cause: 6510, 6526"
"In the context of the C64, Flashing colour or blocks.",possible cause: PLA
"In the context of the C64, Game Cartridge does not function.","possible cause: PLA, ROM 227"
"In the context of the C64, Unit dead (30-40% possibility PLA).",possible cause: PLA
"In the context of the C64, User port does not function (eg. modem).",possible cause: 6526
"In the context of the C64, No sound.","possible cause: 6581 [, Bad RF Modulator ]"
"In the context of the C64, Missing notes.",possible cause: 6581
"In the context of the C64, Game paddles do not function.","possible cause: 6526, 6581"
"In the context of the C64, White band scrolls down the screen (60 HZ HUM).",possible cause: Check power supply and VR2 regulator.
"In the context of the C64, Wavy screen after the system warms up.",Check external power supply and 6567 chip.
"In the context of the C64, Black band scrolls through screen when system warms up.",Check external power supply and VR2 regulator.
"In the context of the C64, Out of memory error on power up.","Check Rams 4146 U1-U12,U21-U24. [ May be Hot! ]"
"In the context of the C64, Powers up with graphic display and blinking cursor.",Check U14.
"In the context of the C64, Powers up with all the characters displayed as blocks.",Check U26.
"In the context of the C64, Unit completely dead.",Possible power supply failure.
"In the context of the C64, After a few minutes, characters are all over the screen, then the unit locks up.",Possible power supply problem.
"In the context of the C64, Error LED stays on all the time.""","possible cause: 6501,ROM 32530201, ROM 90122905"
"In the context of the C64, Drive motor runs continuously and red LED stays on.","possible cause: 6522 [, LED Flashes: UC7 ]"
"In the context of the C64, Drive motor runs continuously and red LED stays off.","possible cause: 6502, ROM 90122905"
"In the context of the C64, After the drive warms up the motor runs continuously.",possible cause: 6522
"In the context of the C64, Does not load when hot or LED flashed 3 times.","possible cause: ROM 90122905, LM311"
"In the context of the C64, Searches with LED flashing continuously.",possible cause: ROM 90122905
"In the context of the C64, Searching with no red LED.",possible cause: ROM 3253021
"In the context of the C64, Drive fails to read.","possible cause: LM311, 592, 9602"
"In the context of the C64, Fails to format disk.","possible cause: 6522, ROM 32557201"
"In the context of the C64, Stepper Motor does not step forward.","possible cause: 6502, 6522"
"In the context of the C64, Will not save when the drive heats up.",possible cause: 6502
"In the context of the C64, Lights stay on, motor runs continuously.",Is Power cord plugged into wall outlet correctly? Is Power cord plugged into disk drive correctly?  Check line fuse and power switch.  Check +5/12 volt lines.
"In the context of the C64, No LED's on power up.",Check all RAM and ROM locations.
"In the context of the C64, Drive motor runs continuously with no red or green LED'S.",Check VR2. Check Power Transformer. [ Hint: No Reg. +5V ]
"In the context of the C64, Loads programs with red LED flashing. Check drive speed.",Check stepper motor.
"In the context of the C64, Loading is intermittent.",Check ROM's and drive alignment.
"In the context of the C64, Message of 'FILE NOT FOUND' is displayed.",Clean drive head w/alcohol. Check 0 stop adjustment. Check alignment. [ Check for sticky slide rails. 1571: Check head lifter release mech. ]
"In the context of the C64, Drive speed will not stabilize.",Check DC motor. [ Check belt (oldVdrives)] Locks-up when loading. Check serial port components. CheckV 901229-05.
"In the context of the C64, Fails the performance test and displays a 21 read error.",Check test diskette. Check Drive Motor.
"In the context of the C64, Fails the performance test and displays a 27 read error.",Check stop adjust.
"In the context of the C64, Passes performance test to track 18 then displays 21 read errors.",Check read/write head.
"In the context of the C64, Passes the performance test but will not load certain programs.",Check stepper motor.
"In the context of the C64, Flashing light on and off during loading.",An alignment problem or bad diskette.
"In the context of the C64, What is the function of the bit 0 of the I/O address $DD0D?",address $DD0D bit 0 is:	Timer A Interrupt
"In the context of the C64, What is the purpose of the memory range $DE00-DEFF?",address $DE00-DEFF are: 	Reserved for Future I/O Expansion
"In the context of the C64, What is tat address $DC01 bit 1?",address $DC01 bit 7	Timer B Toggle/Pulse Output
"In the context of the C64, What is the description of address $D41A in the Commodore 64 memory map?",address $D41A	is:	Analog/Digital Converter Game Paddle 2 (0-255)
"In the context of the C64, What is the description of the register located at address $DC0D?",address $DC0D	is: CIA Interrupt Control Register (ReadIRQs/Write Mask)
"In the context of the C64, What is the description of the register at address $4283?","address $4283	bits		6	is: Select Pulse Waveform, 1 = On"
"In the context of the C64, What is the function of bit 1 at address $4276?","address $4276	bit 1 is 	Synchronize Osc. 1 with Osc. 3 Frequency, 1 = On"
"In the context of the C64, What is the function of the bit 2 at address $DD00 in a Commodore 64?",address $DD00 bit 2 is: 	RS-232 Data Output (User Port)
"In the context of the C64, What is the description of memory address $3291?",address $3291		is:			Sprite 4 Color
"In the context of the C64, What is the function of bit 2 of the $DC0E address ?","address $DC0E bit 2 is:	Timer A Output Mode to PB6: 1 = Toggle,0 = Pulse"
"In the context of the C64, What is the description of the address $0001 bit 4 in a c64?",address $0001 bit 4	is: Cassette Switch Sense: 1 = Switch Closed
"In the context of the C64, What is the description of memory address $3277?",address $3277		is:			Sprites 0-7 Expand 2x Horizontal (X)
"In the context of the C64, What is the function of address D016 bit 2-0?",address D016 bit 2-0 is:	Smooth Scroll to X Pos
"In the context of the C64, What is the description of the USRADD command?","USRADD    address $0311-0312   is: USR Address ($LB,$MB)."
"In the context of the C64, What is the description of SFDX  with the address $00CB?",SFDX      address $00CB        is: Flag: Print shifted Characters.
"In the context of the C64, What is the description of the address $00B9?",SA        address $00B9        is: Current File - Secondary Address.
"In the context of the C64, What is the description of the memory address range $030A-030B in the Commodore 64?",IEVAL     address $030A-030B   is: Vector: Indirect entry to BASIC Token  evaluation ($AE86).
"In the context of the C64, What is the purpose and usage of the memory address range $02C0-$02FE in Commodore 64 programming?","SPR11     address $02C0-02FE   is: Sprite #11 Data Area.  (SCREEN + $03F8 + SPR number) POKE 1024+1016+0,11  to use Sprite#0 DATA from ($02C0-$02FE)."
"In the context of the C64, What is the description of the memory location $028B?",KOUNT     address $028B        is: Repeat Key: Speed Counter ($04).
"In the context of the C64, What is the purpose of the memory region from address $013F to $01FF ?",BSTACK    address $013F-01FF   is: BASIC Stack Area.
"In the context of the C64, What is the function of the memory address range $0200-0258 in a Commodore 64 computer?",BUF       address $0200-0258   is: BASIC Input Buffer (Input Line from Screen).
"In the context of the C64, What is the description of the memory location $028C?",DELAY     address $028C        is: Repeat Key: First repeat delay Counter ($10).
"In the context of the C64, What is the description of the memory region from address $02A7 to $02FF?",TEMP      address $02A7-02FF   is: Unused.
"In the context of the C64, What is the description of the memory location $00B8?",LA        address $00B8        is: Current File - Logical File number.
"In the context of the C64, What is the description of the memory location $0308-0309 in the Commodore 64?",IGONE     address $0308-0309   is: Vector: Indirect entry to BASIC Character dispatch Routine ($A7E4).
"In the context of the C64, What is the description of the USRPOK at address $0310?",USRPOK    address $0310        is: USR Function JMP Instruction ($4C).
"In the context of the C64, What is stored at memory address $00C9-00CA?",LXSP      address $00C9-00CA   is: Cursor X/Y (Line/Column) position at start of  Input.
"In the context of the C64, What is the description of memory address $D017 in the C64 memory map?",address $D017	is:		Sprites 0-7 Expand 2x Vertical (Y)
"In the context of the C64, What is the description of the address $0001 bit 5 in the C64?","address $0001 bit 5	is: Cassette Motor Control O = ON, 1 = OFF"
"In the context of the C64, What is stored at memory address $3278?",address $3278		is:			Sprite to Sprite Collision Detect
"In the context of the C64, What is the function of bit 1 at address $DC0E ?","address $DC0E bit 1 is:	Timer A Output on PB6: 1 = Yes, 0 = No"
"In the context of the C64, What is the function of address $DD00 bits 1-0 ?",address $DD00 bit 1-0 is:	VIC Chip System Memory Bank Select (Default = 11)
"In the context of the C64, What is the description of memory address $3292?",address $3292		is:			Sprite 5 Color
"In the context of the C64, What does bit 2 of address $4276 control ?","address $4276	bit 2 is 	Ring Modulate Osc. 1 with Osc. 3 Output, 1 = On"
"In the context of the C64, What is the description of the memory location $DC0C ?",address $DC0C	is: Synchronous Serial I/O Data Buffer
"In the context of the C64, What is the function of address $4283 ?","address $4283	bits		7	Select Random Noise Waveform, 1 = On"
"In the context of the C64, What is the description of memory address $D419 in the Commodore 64?",address $D419	is:	Analog/Digital Converter: Game Paddle 1 (0-255)
"In the context of the C64, What is the description of the address $DC01?",address $DC01 bits 7-0	Read Keyboard Row Values for Keyboard Scan
"In the context of the C64, What is at address $DD0F bits 6-5?","address $DD0F bits 6-5	is: Timer B Mode Select:
00 = Count System 02 Clock Pulses
01 = Count Positive CNT Transitions
10 = Count Timer A Underflow Pulses
11 = Count Timer A Underflows While CNT Positive"
"In the context of the C64, What is the function of the bit 1 of the I/O address $DD0D?",address $DD0D bit 1 is:	Timer B Interrupt
"In the context of the C64, What does bit 7 of address $DD0F represent ?","address $DD0F bit 7 is:	Set Alarm/TOD-Clock: 1 = Alarm, 0 = Clock"
"In the context of the C64, What is the function of bit 4 at address $DD0D?",address $DD0D bit 4 is:	FLAG1 NMI (User/RS-232 Received Data Input)
"In the context of the C64, What is the function of the memory location $DD03 ?",address $DD03 is:	Data Direction Register - Port B
"In the context of the C64, What is the description of memory location $D41B?",address $D41B	is:	Oscillator 3 Random Number Generator
"In the context of the C64, What is the description of the bit 6 of the $DC01 register ?",address $DC01 bit 6	Timer A: Toggle/Pulse Output
"In the context of the C64, What is the function of bit 4 at address $4276?","address $4276	bit 4 is 	Select Triangle Waveform, 1 = On"
"In the context of the C64, What is the description of the address $4282 bits 7-4?",address $4282	bits	7-4	is: Unused
"In the context of the C64, What does bit 3 of address $DC0E represent ?","address $DC0E bit 3 is:	Timer A Run Mode: 1 = One-Shot,0 = Continuous"
"In the context of the C64, What is the function of the bit 3 of the I/O address $DD00 in a Commodore 64?",address $DD00 bit 3 is: 	Serial Bus ATN Signal Output
"In the context of the C64, What is the function of bits 3-1 at address $D018 ?",address $D018 bits 3-1 is: Character Dot-Data Base	Address (inside VIC)
"In the context of the C64, What is the description of the memory address $3280 in the Commodore 64?",address $3280		is:			Border Color
"In the context of the C64, What is the description of the address $0001 bit 3 in a Commodore 64 computer?",address $0001 bit 3	is: Cassette Data Output Line
"In the context of the C64, What is the purpose of the memory location $030C in a Commodore 64 computer?",SAREG     address $030C        is: Storage for 6510 Accumulator during SYS.
"In the context of the C64, What is the description of the memory location at address $00B6?",RODATA    address $00B6        is: RS232 Output Byte Buffer/Tape Read Error Flag.
"In the context of the C64, What is the function and possible values of the flag located at address $00C7?","RVS       address $00C7        is: Flag: Reverse On/Off; On = $01, Off = $00."
"In the context of the C64, What is the description of the memory location at address $0313?",TEMP      address $0313        is: Unused.
"In the context of the C64, What is the function of the memory location at address $00D7 ?",SCHAR     address $00D7        is: Screen value of current Input Character/Last Character Output.
"In the context of the C64, What is the description of the FAT address $0263-026C in the Kernal Table?",FAT       address $0263-026C   is: Kernal Table: Active File First Addresses  (Device numbers).
"In the context of the C64, What is the purpose of the register located at address $028E ?",LSTSHF    address $028E        is: Last Shift Key used for debouncing.
"In the context of the C64, What is the description of the SHFLAG at memory address $028D?","SHFLAG    address $028D        is: Flag: Shift Keys: Bit 1 = Shift, Bit 2 = CBM, Bit 3 = CTRL; ($00 = None, $01 = Shift, etc.)."
"In the context of the C64, What is the description of the memory address range $0259-0262 in the Commodore 64 Kernal?",LAT       address $0259-0262   is: Kernal Table: Active logical File numbers.
"In the context of the C64, What is the purpose of the memory location at address $00D8?",INSRT     address $00D8        is: Count of number of inserts outstanding.
"In the context of the C64, What is the purpose of the INDX address $00C8 ?",INDX      address $00C8        is: Pointer: End of Line for Input (Used to suppress trailing spaces).
"In the context of the C64, What is the description of the CINV address $0314-0315?",CINV      address $0314-0315   is: Vector: Hardware IRQ Interrupt Address ($EA31).
"In the context of the C64, What is the purpose of the memory location at address $030D in a Commodore 64 computer?",SXREG     address $030D        is: Storage for 6510 X-Register during SYS.
"In the context of the C64, What does the FNLEN at address $00B7?",FNLEN     address $00B7        is: Number of Characters in Filename.
"In the context of the C64, What is the description of memory address $3279?",address $3279		is:			Sprite to Background Collision Detect
"In the context of the C64, What is the description of the memory address $0001 bit 2?",address $0001 bit 2	is: /CHAREN Signal (0=Swith Char. ROM In)
"In the context of the C64, What is the function of bits 7-4 at address $D018?",address $D018 bits 7-4 is: Video Matrix Base Address (inside VIC)
"In the context of the C64, What is the function of the bit 4 at address $DD00?",address $DD00 bit 4 is: 	Serial Bus Clock Pulse Output
"In the context of the C64, What does bit 4 of address $DC0E represent ?",address $DC0E bit 4 is:	Force Load Timer A: 1 = Yes
"In the context of the C64, What is the description of the register located at address $4283 ?","address $4283	bits 3-0 is: Voice 2: Pulse Waveform Width - High-Nybble


address $4283			Voice 2: Control Register"
"In the context of the C64, What is the function of bit 3 at address $4276?",address $4276	bit 3 is 	Test Bit: 1 = Disable Oscillator 1
"In the context of the C64, What is the description of the address $DC01 ?",address $DC01 bit 4	Joystick 1 Fire Button: 1 = Fire 3-2	Paddle Fire Buttons 3-0	Joystick 1 Direction
"In the context of the C64, What is the description of memory location $D41C?",address $D41C	is:	Envelope Generator 3 Output
"In the context of the C64, What is the description of memory address $DD04 in the Commodore 64?",address $DD04 is:	Timer A: Low-Byte
"In the context of the C64, What is the function of bit 3 of the I/O address $DD0D?",address $DD0D bit 3 is:	Serial Port Interrupt
"In the context of the C64, What is the function of bits 4-0 of address $DD0F?",address $DD0F bits 4-0 is:	Same as CIA Control Reg. A - for Timer B
"In the context of the C64, What is the function of bit 7 in the address $DD0D?",address $DD0D bit 7 is:	NMI Flag (1 = NMI Occurred) / Set-Clear Flag
"In the context of the C64, What is the function of bit 1 at address $DD0E ?","address $DD0E bit 1 is:	Timer A Output on PB6: 1 = Yes, 0 = No"
"In the context of the C64, What does bit 7 of address $DD0E represent?","address $DD0E bit 7 is:	Time-of-Day Clock Frequency: 1 = 50 Hz, 0 = 60 Hz"
"In the context of the C64, What is the function of memory address $4277 ?",Address $4277		is:	Envelope Generator 1: Attack / Decay Cycle Control
"In the context of the C64, What is the description of memory address $4279 ?",address $4279	is:		Voice 2: Frequency Control - Low-Byte
"In the context of the C64, What is the function of memory address $DC00 in a Commodore 64 computer?","address $DC00 is:	Data Port A (Keyboard, Joystick, Paddles,Light-Pen)"
"In the context of the C64, What is the description of address $DC01 in a Commodore 64 system?","address $DC01 is:	Data Port B (Keyboard, Joystick, Paddles): Game Port 1"
"In the context of the C64, What is the function of bit 7 at memory address $D019?",address $D019 Bit 7	is: Set on Any Enabled VIC IRQ Condition
"In the context of the C64, What is the description of the MOS 6510 Data Direction Register at address $0000?","address - BITS - DESCRIPTION
$0000	0		7-0	MOS 6510 Data Direction
Register (xx101111) Bit= 1: Output, Bit=0: Input, x=Don't Care"
"In the context of the C64, What is the function of the address $3275?",address $3275		is:			Sprite to Background Display Priority:	1 = Sprite
"In the context of the C64, What is the function of bit 0 at address $DC0E ?","address $DC0E bit 0 is:	Start/Stop Timer A: 1 = Start, 0 = Stop"
"In the context of the C64, What is the function of the address $DD00 in the Commodore 64?","address $DD00 is: Data Port A (Serial Bus, RS-232, VIC Memory Control)"
"In the context of the C64, What is the purpose of the memory region from address $0100 to $01FF?",STACK     address $0100-01FF   is: 6510 Hardware Stack Area.
"In the context of the C64, What is the function of the address range $00BB-00BC?",FNADR     address $00BB-00BC   is: Pointer: Current File name Address.
"In the context of the C64, What is the description of the memory location $0306-0307 in the Commodore 64?",IQPLOP    address $0306-0307   is: Vector: Indirect entry to BASIC LIST  Routine ($A71A).
"In the context of the C64, What is the description of the ICLOSE vector at address $031C-031D in the Kernal?",ICLOSE    address $031C-031D   is: Vector: Indirect entry to Kernal CLOSE Routine ($F291).
"In the context of the C64, What is the description of the memory location $00C3-00C4?",MEMUSS    address $00C3-00C4   is: Pointer: Type 3 Tape LOAD and general use.
"In the context of the C64, What is the description of the memory location at address $0281-0282?",MEMSTR    address $0281-0282   is: Pointer: Bottom of Memory for Operating System ($0800).
"In the context of the C64, What is the function of the XMAX address $0289?",XMAX      address $0289        is: Maximum number of Bytes in Keyboard Buffer ($0A).
"In the context of the C64, What is the function and behavior of the RPTFLG at address $028A?","RPTFLG    address $028A        is: Flag: Repeat keys; $00 = Cursors, INST/DEL &  Space repeat, $40 no Keys repeat, $80 all  Keys repeat ($00)."
"In the context of the C64, What is the description of the memory location at address $0283-0284?",MEMSIZ    address $0283-0284   is: Pointer: Top of Memory for Operating   System ($A000).
"In the context of the C64, What is the description of the memory location $031A-031B in the Commodore 64 Kernal?",IOPEN     address $031A-031B   is: Vector: Indirect entry to Kernal OPEN Routine ($F34A).
"In the context of the C64, What is the function of the memory address $00C1-00C2 ?",STAL      address $00C1-00C2   is: Start Address for LOAD and Cassette Write.
"In the context of the C64, What is at address $00BA","FA        address $00BA        is: Current File - First Address (Device number). OPEN LA,FA,SA;  OPEN 1,8,15,'I0':CLOSE 1"
"In the context of the C64, What is the description of the memory location $0304-0305 in the Commodore 64?",ICRNCH    address $0304-0305   is: Vector: Indirect entry to BASIC Tokenise Routine ($A57C).
"In the context of the C64, What is the purpose of the memory location $0100-013E?",BAD       address $0100-013E   is: Tape Input Error log.
"In the context of the C64, What is the function of the bit 7 of the I/O register at address $DD00 in the Commodore 64?",address $DD00 bit 7is	Serial Bus Data Input
"In the context of the C64, What is the description of the memory address $DC0F in the Commodore 64?",address $DC0F	is:		CIA Control Register B
"In the context of the C64, What is the description of the memory location $0001 in the Commodore 64?",address $0001 bit	1			MOS 6510 Micro-Processor On-Chip I/O Port
"In the context of the C64, What is the description of memory address $3276 in the Commodore 64?",address $3276		is:			Sprites 0-7 Multi-Color Mode Select:1 = M.C.M.
"In the context of the C64, What is the description of the flag located at address $D019 Bit 3?",address $D019 Bit 3	is: Light-Pen Triggered IRQ Flag
"In the context of the C64, What is the function of bits 3-0 at address $DC00?",address $DC00 bits 3-0	is: Joystick A Direction (0-15)
"In the context of the C64, What is the function of the addresses DC00-DCFF in a Commodore 64 computer?",addesszq DC00-DCFF	are 	MOS 6526 Complex Interface Adapter (CIA) #1
"In the context of the C64, What is the description of the address $4278 in the context of a microcontroller's configuration?",address $4278      bits        3-0  is:   Select Release Cycle Duration: 0-15
"In the context of the C64, What is the function of bit 0 at address $4276?","address $4276	bit 0 is 	Gate Bit: 1 = Start Att/Dec/Sus, 0 = Start Release"
"In the context of the C64, What is the description of the memory location $DD0E in the Commodore 64?",address $DD0E	is:		CIA Control Register A
"In the context of the C64, What is the function of bit 2 of the $DD0E address ?","address $DD0E bit 2 is:	Timer A Output Mode to PB6: 1 = Toggle,0 = Pulse"
"In the context of the C64, What is the function of the memory address $DD0D in the Commodore 64?",address $DD0D is:	CIA Interrupt Control Register (Read NMls/Write Mask)
"In the context of the C64, What is the function of bit 6 of the address $DD0E ?","address $DD0E bit 6 is:	Serial Port I/O Mode Output, 0 = Input"
"In the context of the C64, What is the function of bit 0 at address $DD0E ?","address $DD0E bit 0 is:	Start/Stop Timer A: 1 = Start, 0 = Stop"
"In the context of the C64, What is the description of the memory address $4280 ?",address $4280	is:		Voice 2: Frequency Control - High-Byte
"In the context of the C64, What is the function of bit 6 in the $DC0E address ?","address $DC0E bit 6 is:	Serial Port I/O Mode Output, 0 = Input"
"In the context of the C64, What is the function of bits 7-4 at address $4277?",Address $4277    bits          7-4  is:   Select Attack Cycle Duration: 0-15
"In the context of the C64, What is the description of the memory address $DC00 bits 4 in a Commodore 64?",address $DC00 bits 4	is: Joystick A Fire Button: 1 = Fire
"In the context of the C64, What is at addresses D500-D7FF",addresses D500-D7FF	are 	SID IMAGES
"In the context of the C64, What is the description of the register located at address $D01A?",address $D01A	is:			IRQ Mask Register: 1 = Interrupt Enabled
"In the context of the C64, What is the description of the memory address $0001 bit 1 in the Commodore 64?",is: /HIRAM Signal (0=Switch Kernal ROM Out)
"In the context of the C64, What is the function of the bit at memory address $D019?",address $D019 Bit 1 is: VIC Interrupt Flag Register (Bit = 1: IRQ Occurred)
"In the context of the C64, What is the function of the bit 5 at address $DD00 in the Commodore 64?",address $DD00 bit 5 is: 	Serial Bus Data Output
"In the context of the C64, What does the Timer B Mode Select bits 6-5 in the $DC0F address control?","address $DC0F bits 6-5	is: Timer B Mode Select: 00 = Count System 02 Clock Pulses, 01 = Count Positive CNT Transitions, 10 = Count Timer A Underflow Pulses, 11 = Count Timer A Underflows While CNT Positive"
"In the context of the C64, What is the function of bit 5 at address $4276 ?","address $4276	bit 5 is 	Select Sawtooth Waveform, 1 = On"
"In the context of the C64, What is the function of the RIDBS register at address $029C ?",RIDBS     address $029C        is: RS232 Pointer: High Byte of Address of Input Buffer.
"In the context of the C64, What is the purpose of the memory location at address $00C5 in a keyboard matrix?",LSTX      address $00C5        is: Matrix value of last Key pressed; No Key = $40.
"In the context of the C64, What is the description of the memory location at address $0316-0317?",CNBINV    address $0316-0317   is: Vector: BRK Instruction Interrupt Address  ($FE66).
"In the context of the C64, What is the description of the IERROR vector at address $0300-0301 in a Commodore 64 computer?","IERROR    address $0300-0301   is: Vector: Indirect entry to BASIC Error Message, (X) points to Message ($E38B)."
"In the context of the C64, What is the function of the ROPRTY register at address $00BD?",ROPRTY    address $00BD        is: RS232 Output Parity/Tape Byte to be Input or Output.
"In the context of the C64, What is the description of the HIBASE address $0288 in the context of Commodore 64 memory layout?",HIBASE    address $0288        is: High Byte of Screen Memory Address ($04).
"In the context of the C64, What is the function of the memory location $0277-0280 ?",KEYD      address $0277-0280   is: Keyboard Buffer Queue (FIFO).
"In the context of the C64, What is the description of the memory address range $026D-0276 in the Commodore 64's Kernal?",SAT       address $026D-0276   is: Kernal Table: Active File Secondary Addresses.
"In the context of the C64, What is the function of the memory location at address $0287?",GDCOL     address $0287        is: Background Colour under Cursor.
"In the context of the C64, What is the description of the IMAIN address $0302-0303 in a Commodore 64 computer?",IMAIN     address $0302-0303   is: Vector: Indirect entry to BASIC Input Line and Decode ($A483).
"In the context of the C64, What is the function of the FSBLK at address $00BE?",FSBLK     address $00BE        is: Tape Input/Output Block count.
"In the context of the C64, What is stored at memory address $00C6 in the C64?",NDX       address $00C6        is: Number of Characters in Keyboard Buffer queue.
"In the context of the C64, What is the description of the memory address range $0318-0319?",NMINV     address $0318-0319   is: Vector: Hardware NMI Interrupt Address ($FE47).
"In the context of the C64, What is the function of the RODBS register at address $029D ?",RODBS     address $029D        is: RS232 Pointer: High Byte of Address of Output  Buffer.
"In the context of the C64, What does the bit 7 of address $DC0F represent?","address $DC0F bits 7	is: Set Alarm/TOD-Clock: 1 = Alarm, 0 = Clock"
"In the context of the C64, What is the function of bit 6 at address $4276?","address $4276	bit 6 is 	Select Pulse Waveform, 1 = On"
"In the context of the C64, What is the function of the bit 6 of the address $DD00?",address $DD00 bit 6 is: 	Serial Bus Clock Pulse Input
"In the context of the C64, What is the function of bit 0 at memory address $D018?",address $D018 bits 0 is:	Select upper/lower Character Set
"In the context of the C64, What is the function of Bit 0 at memory address $D019?",address $D019 Bit 0	is: Raster Compare IRQ Flag
"In the context of the C64, What is the function of bit 0 at address $0001?",address $0001 bit 0	is: /LORAM Signal (0=Switch	BASIC ROM Out)
"In the context of the C64, What type of memory is stored in the address range D800-DBFF?",addresses D800-DBFF	are	Color RAM (Nybbles)
"In the context of the C64, What is the description of the address $DC00 bits 3-2 in aC64controller?",address $DC00 bits 3-2	is: Paddle Fire Buttons
"In the context of the C64, What is the function of bit 5 at address $DC0E?","address $DC0E bit 5 is:	Timer A Counts: 1 = CNT Signals, 0 = System 02 Clock"
"In the context of the C64, What is the function of the bits 3-0 at address $4277?",Address $4277 bits	3-0	is: Select Decay Cycle Duration: 0-15
"In the context of the C64, What is the description of the address $4281 ?",address $4281	is		Voice 2: Pulse Waveform Width - Low-Byte
"In the context of the C64, What is the description of the memory location $DD0F in the Commodore 64?",address $DD0F	is: CIA Control Register B
"In the context of the C64, What is the function of bit 5 at address $DD0E?","address $DD0E bit 5 is:	Timer A Counts: 1 = CNT Signals, 0 = System 02 Clock"
"In the context of the C64, What is the description of the register located at address $0001?",R6510  address  $0001       is:   6510 On-chip 8-bit Input/Output Register.
"In the context of the C64, What is the description of the SUBFLG directive with address $0010?",SUBFLG address  $0010       is:   Flag: Subscript reference/User Function call.
"In the context of the C64, What is the description of the memory address range $002F-0030 in a Commodore 64 computer?",ARYTAB address  $002F-0030  is:   Pointer: Start of BASIC Arrays.
"In the context of the C64, What is the purpose of the OPMASK at address $004D?",OPMASK address  $004D       is:   Mask used during FRMEVL.
"In the context of the C64, What is the description of the address range $006A-006D?",ARGHO  address  $006A-006D  is:   AFAC Mantissa.
"In the context of the C64, What does bit 6 of address $D418 control in a device?",address $D418 bit 6	is: Select Filter High-Pass Mode: 1 = On
"In the context of the C64, What is the function of memory address $D413 ?",address $D413 is:	Envelope Generator 3: Attac/Decay Cycle Control
"In the context of the C64, What is the recommended setting for bit 5 of address D016?",address D016 bit 5 is	ALWAYS SET THIS BIT TO 0 !
"In the context of the C64, What is the description of the memory address $D00E in the C64 memory map?",address $D00E is Sprite 7 X Pos
"In the context of the C64, What is the function of the memory address $00AC-00AD?",SAL       address $00AC-00AD   is: Pointer: Tape Buffer/Screen scrolling.
"In the context of the C64, What is the description of the sprite located at address $0380-03BE?",SPR14     address $0380-03BE   is: Sprite #14.
"In the context of the C64, What is the description of the User Defined Vector located at address $032E-032F?",USRCMD    address $032E-032F   is: User Defined Vector ($FE66).
"In the context of the C64, What does the MSGFLG at address $009D control in a program?","MSGFLG    address $009D        is: Flag: $00 = Program mode: Suppress Error  Messages, $40 = Kernal Error Messages only, $80 = Direct mode: Full Error Messages."
"In the context of the C64, What is the description of the memory location $0092?",SVXT      address $0092        is: Timing Constant for Tape.
"In the context of the C64, What is the memory address of the kernel routine for the TALK command in Commodore 64 BASIC?",kernal routine address for talk	= $ffb4
"In the context of the C64, What is the kernel routine address for the SETLFS command in Commodore 64 BASIC?",kernal routine address for setlfs	= $ffba
"In the context of the C64, What is the kernel routine address for the second interrupt vector in the 6502 microprocessor?",kernal routine address for second	= $ff93
"In the context of the C64, What is the address of the kernel routine for stopping the computer in the Commodore 64?",kernal routine address for stop	= $ffe1
"In the context of the C64, What is the format and description of the VERCKK command?","VERCKK    address $0093        is: Flag: 0 = Load, 1 = Verify."
"In the context of the C64, What is the description of the ILOAD instruction at address $0330-0331 in the Commodore 64 Kernal?",ILOAD     address $0330-0331   is: Vector: Indirect entry to Kernal LOAD    Routine ($F4A5).
"In the context of the C64, What is the purpose of the FNMIDX address $009E?",FNMIDX    address $009E        is: Index to Cassette File name/Header ID for Tape write.
"In the context of the C64, What is the function of the address $00AE-00AF?",EAL       address $00AE-00AF   is: Tape End Address/End of Program.
"In the context of the C64, What is the description of the memory range $03C0-03FE?",SPR15     address $03C0-03FE   is: Sprite #15.
"In the context of the C64, What is the description of the address $D00D in the memory map of C64?",address $D00D is Sprite 6 Y Pos
"In the context of the C64, What is the purpose of bits 7-6 in address D016?",address D016 bit 7-6 is	Unused
"In the context of the C64, What does the $D413 bits 7-4 register control ?",address $D413 bits 7-4 is:	Select Attack Cycle Duration: 0-15
"In the context of the C64, What is the function of bit 5 at address $D418?",address $D418 bit 5	is: Select Filter Band-Pass Mode: 1 = On
"In the context of the C64, What is the explanation for the address $0069?",ARGEXP address  $0069       is:   AFAC Exponent.
"In the context of the C64, What is the purpose of the memory address $004B-004C ?","VARTXT address  $004B-004C  is:   Temporary storage for TXTPTR during READ, INPUT and GET."
"In the context of the C64, What is the description of the memory address range $0031-0032 in a Commodore 64 computer?",STREND address  $0031-0032  is:   Pointer: End of BASIC Arrays + 1.
"In the context of the C64, What does the INPFLG address $0011 represent ?","INPFLG address  $0011       is:   Input Flag: $00 = INPUT, $40 = GET, $98 = READ."
"In the context of the C64, What is the description of the memory location $0002?",TEMP   address  $0002       is:   Unused. Free for user programs.
"In the context of the C64, What is the purpose of the CHANNL address $0013 ?",CHANNL address  $0013       is:   File number of current Input Device.
"In the context of the C64, What is the function of the ADRAY2 address $0005-0006 in the CPU?",ADRAY2 address  $0005-0006  is:   Jump Vector: Convert Integer in (A/Y) to Floating point in (FAC); ($B391).
"In the context of the C64, What is the purpose of the memory location at address $0068?",BITS   address  $0068       is:   Bit Overflow Area during normalisation Routine.
"In the context of the C64, What does the VARPNT address $0047-0048 contain?","VARPNT address  $0047-0048  is:   Pointer: to value of (VARNAM) if Integer, to descriptor if String."
"In the context of the C64, What is the description of the address $D40D in a MIDI controller?","address $D40D	bits			0 is	Gate Bit: 1 = Start Att/Dec/Sus, 0 = Start Release"
"In the context of the C64, What is the function of bit 7 at address $D418?","address $D418 bit 7	is: Cut-Off Voice 3 Output: 1 = Off, 0 = On"
"In the context of the C64, What is the description of memory address $D40E ?",address $D40E	is 			Voice 3: Frequency Control - Low-Byte
"In the context of the C64, What is the description of the memory address $D00B in the C64 memory map?",address $D00B is Sprite 5 Y Pos
"In the context of the C64, What is the description of address D014?",address D014 is:	Light-Pen Latch Y Pos
"In the context of the C64, What is the description of the PTR2 address $009F?",PTR2      address $009F        is: Tape Error log pass 2.
"In the context of the C64, What is the description of the memory location $032C-032D?",ICLALL    address $032C-032D   is: Vector: Indirect entry to Kernal CLALL     Routine ($F32F).
"In the context of the C64, What is the description of the memory block located at addresses $0340-037E?",SPR13     address $0340-037E   is: Sprite #13.
"In the context of the C64, What is the description of the memory location $00B2-00B3?",TAPE1     address $00B2-00B3   is: Pointer: Start Address of Tape Buffer ($033C).
"In the context of the C64, What is the address of the kernel routine for the readst function in a Commodore 64?",kernal routine address for readst	= $ffb7
"In the context of the C64, What is the kernel routine address for the setmsg function in a certain computer system?",kernal routine address for setmsg	= $ff90
"In the context of the C64, What is the kernel routine address for TKS-A?",kernal routine address for tksa	= $ff96
"In the context of the C64, What is the kernel routine address for UDTIM in the Commodore 64?",kernal routine address for udtim	= $ffea
"In the context of the C64, What is the memory address of the kernel routine for setting the filename in Commodore 64?",kernal routine address for setnam	= $ffbd
"In the context of the C64, What is the kernel routine address for RDTIM?",kernal routine address for rdtim	= $ffde
"In the context of the C64, What is the function of the memory region located at address $033C-03FB?",TBUFFR    address $033C-03FB   is: Tape I/O Buffer.
"In the context of the C64, What is the function of the memory address $00B0-00B1?",CMPO      address $00B0-00B1   is: Tape timing Constants.
"In the context of the C64, What is the description of the PTR1 address $009E?",PTR1      address $009E        is: Tape Error log pass 1.
"In the context of the C64, What is the description of the IGETIN vector in the Commodore 64 Kernal?",IGETIN    address $032A-032B   is: Vector: Indirect entry to Kernal GETIN     Routine ($F13E).
"In the context of the C64, What does address D015 control on a C64?",address D015 is:	Sprite display Enable: 1 = Enable
"In the context of the C64, What is the description of the memory address $D00C in the C64 memory map?",address $D00C is Sprite 6 X Pos
"In the context of the C64, What does the address $D40D bits 3-0 control in a device?",address $D40D	bits 3-0 is:	Select Release Cycle Duration: O-15
"In the context of the C64, What is the instruction associated with memory address $D418?",address $D418	Select Filter Mode and Volume
"In the context of the C64, What is the function of bit $D40D in the device's configuration?","address $D40D	bits			1 is	Synchronize Osc. 3 with Osc. 2 Frequency, 1 = On"
"In the context of the C64, What is the purpose of the address $0049-004A?",FORPNT address  $0049-004A  is:   Pointer: Index Variable for FOR/NEXT loop.
"In the context of the C64, What is the description of the memory address range $0069-006E ?",AFAC   address  $0069-006E  is:   Auxiliary Floating point Accumulator.
"In the context of the C64, What is the description of the memory address $0003-0004?",ADRAY1 address  $0003-0004  is:   Jump Vector: Convert FAC to Integer in (A/Y) ($B1AA).
"In the context of the C64, What is the description of the TANSGN address $0012?",TANSGN address  $0012       is:   Flag: TAN sign/Comparative result.
"In the context of the C64, What does the INTFLG at address $000E represent in a data type?","INTFLG address  $000E       is:   Data type Flag: $00 = Floating point, $80 = Integer."
"In the context of the C64, What is the purpose of the memory address $0007-0008 ?",INTEGR address  $0007-0008  is:   Temporary Integer during OR/AND.
"In the context of the C64, What is the description of the FACHO address $0062-0065?",FACHO  address  $0062-0065  is:   FAC Mantissa.
"In the context of the C64, What does the FOUR6 address $0053 represents?",FOUR6  address  $0053       is:   Length of String Variable during Garbege collection.
"In the context of the C64, What is the description of the address $D40D?",address $D40D	bits			3 is	Test Bit: 1 = Disable Oscillator 1
"In the context of the C64, What does the $D413 address bits 3-0 control ?",address $D413 bits 3-0 is:	Select Decay Cycle Duration: 0-15
"In the context of the C64, What is the function of bits 7-4 at address $D417 ?",address $D417	bits 7-4 is	Select Filter Resonance: 0-15
"In the context of the C64, What is the function of memory address $D010 in the context of Commodore 64 graphics?",address $D010 is Sprites 0-7 X Pos (msb of X coord.)
"In the context of the C64, What is the function of the D011 register bits 2-0?",Address	D011	BIT 2-0	is Smooth Scroll to Y Dot-Position (0-7)
"In the context of the C64, What is the description of the memory address $D00A in the C64 memory map?",address $D00A is Sprite 5 X Pos
"In the context of the C64, What is the memory address of the kernel routine for the GETIN function in the Commodore 64?",kernal routine address for getin	= $ffe4
"In the context of the C64, What is the description of the ICLCHR address $0322-0323 in the Kernal routine?",ICLRCH    address $0322-0323   is: Vector: Indirect entry to Kernal CLRCHN     Routine ($F333).
"In the context of the C64, What is the function of the TBTCNT at address $00A4?",TBTCNT    address $00A4        is: Pulse Counter Tape Read or Write/Serial Bus shift Counter.
"In the context of the C64, What is the description of the memory location at address $00AA?",RIDATA    address $00AA        is: RS232 Input Byte Buffer/Tape temporary.
"In the context of the C64, What is the description of the memory address range $03FC-03FF?",TEMP      address $03FC-03FF   is: Unused.
"In the context of the C64, What is the address of the kernel routine for the screen in a Commodore 64?",kernal routine address for screen	= $ffed
"In the context of the C64, What is the address of the kernel routine for the vector table in a typical 6502-based system?",kernal routine address for vector	= $ff8d
"In the context of the C64, What is the kernel routine address for SCNKEY?",kernal routine address for scnkey	= $ff9f
"In the context of the C64, What is the function of the RIPRTY register at address $00AB?",RIPRTY    address $00AB        is: RS232 Input parity/Tape temporary.
"In the context of the C64, What is the description of the memory range $0400-07E7 ?",VICSCN    address $0400-07E7   is: Default Screen Video Matrix.
"In the context of the C64, What is the description of the memory location $0324-0325 in the Commodore 64 Kernal?",IBASIN    address $0324-0325   is: Vector: Indirect entry to Kernal CHRIN     Routine ($F157).
"In the context of the C64, What is the function of the CNTDN at address $00A5?",CNTDN     address $00A5        is: Tape Synchronising count down.
"In the context of the C64, What is the address of the kernel routine for I/O base in hexadecimal notation?",kernal routine address for iobase	= $fff3
"In the context of the C64, What is the description of memory address $D009 in the C64 memory map?",address $D009 is Sprite 4 Y Pos
"In the context of the C64, What is the function of BIT 3 at Address D011?",Address	D011	BIT 3 is Select 24/25 Row Text Display: 1 = 25 Rows
"In the context of the C64, What is the description of the memory address $D00F in the C64 memory map?",address $D00F is Sprite 7 Y Pos
"In the context of the C64, What does the bit 3 of address $D417 represent in the device configuration?","address $D417	bits 3 is: 	Filter External Input: 1 = Yes, 0 = No"
"In the context of the C64, What is the function of memory address $D414 ?",address $D414 is			Envelope Generator 3: Sustain / Release Cycle Control
"In the context of the C64, What does the address $D40D control ?","address $D40D	bits			2 is	Ring Modulate Osc. 3 with Osc. 2 Output, 1 = On"
"In the context of the C64, What is the purpose of the memory address $004E-0052?",TEMPF3 address  $004E-0052  is:   Temporary storage for FLPT value.
"In the context of the C64, What is the description of the FACEXP address $0061?",FACEXP address  $0061       is:   FAC Exponent.
"In the context of the C64, What is the purpose of the TRMPOS address $0009?",TRMPOS address  $0009       is:   Screen Column for last TAB.
"In the context of the C64, What is the description of the memory address $000F?",GARBFL address  $000F       is:   Flag: DATA scan/List Quote/Garbage collection.
"In the context of the C64, What is the address of VARNAM?",VARNAM address  $0045-0046  is:   Name of Variable being sought in Variable Table.
"In the context of the C64, What is the description of the ENDCHR address $0008?",ENDCHR address  $0008       is:   Flag: Scan for Quote at end of String.
"In the context of the C64, What is the format of the Valtyp address $000D?","VALTYP address  $000D       is:   Data type Flag: $00 = Numeric, $FF = String."
"In the context of the C64, What is the purpose of the JMPER address $0054-0056?","JMPER  address  $0054-0056  is:   Jump Vector used in Function Evaluation -  JMP followed by Address ($4C,$LB,$MB)."
"In the context of the C64, What is the description of the address $0066 in the FACSGN?",FACSGN address  $0066       is:   FAC Sign.
"In the context of the C64, What is the description of the register at address $D417?","address $D417	bits 0	is Filter Voice 1 Output: 1 = Yes, 0 = No"
"In the context of the C64, What are the functions of memory addresses $D414 and $D415 ?","address $D414  bits 3-0	is: Select Release Cycle Duration: 0-15


address $D415 is Filter Cutoff Frequency: Low-Nybble (Bits 2-0)"
"In the context of the C64, What is the description of address D012 on C64?",address D012 is:	Read Raster / Write Raster Value for Compare IRQ
"In the context of the C64, What is the function of bit 7 in address D011?",Address	D011	BIT 7 is Raster Compare: (Bit 8)	See 53266
"In the context of the C64, What is the description of the DPSW at address $009C?",DPSW      address $009C        is: Flag: Byte received from Tape.
"In the context of the C64, What is the purpose of the memory address range $07F8-07FF?",SPNTRS    address $07F8-07FF   is: Default Sprite Data Pointers.
"In the context of the C64, What is the description of the RINONE address $00A9?",RINONE    address $00A9        is: RS232 Flag: Start Bit check/Tape temporary.
"In the context of the C64, What is the function of the TSFCNT at address $00A3?",TSFCNT    address $00A3        is: Bit Counter Tape Read or Write/Serial Bus EOI (End Of Input) Flag.
"In the context of the C64, What is the description of the ISTOP vector in the Commodore 64 Kernal?",ISTOP     address $0328-0329   is: Vector: Indirect entry to Kernal STOP     Routine ($F6ED).
"In the context of the C64, What is the address of the kernel routine for unloading the system nucleus in Commodore 64?",kernal routine address for unlsn	= $ffae
"In the context of the C64, What is the address of the kernel routine that restores the system?",kernal routine address for restor	= $ff8a
"In the context of the C64, What is the address of the kernel routine for saving in a Commodore 64?",kernal routine address for save	= $ffd8
"In the context of the C64, What is the address of the kernel routine for untalking in Commodore 64?",kernal routine address for untlk	= $ffab
"In the context of the C64, What is the description of the memory address $00A0-00A2?",TIME      address $00A0-00A2   is: Real-time jiffy Clock (Updated by IRQ Interrupt approx. every 1/60 of Second);  Update Routine: UDTIMK ($F69B).
"In the context of the C64, What is the description of the memory location $0326-0327 in the Commodore 64's Kernal ROM?",IBSOUT    address $0326-0327   is: Vector: Indirect entry to Kernal CHROUT     Routine ($F1CA).
"In the context of the C64, What is the description of the memory range $07E8-07F7?",TEMP      address $07E8-07F7   is: Unused.
"In the context of the C64, What is the description of the BITC1 register located at address $00A8?",BITC1     address $00A8        is: RS232 Input Bit count/Tape temporary.
"In the context of the C64, What is the function of the PRTY address $009B?",PRTY      address $009B        is: Parity of Byte Output to Tape.
"In the context of the C64, What does BIT 6 of address D011 control in a Commodore 64 computer?",Address	D011	BIT 6 is Extended Color Text Mode 1 = Enable
"In the context of the C64, What is the description of address D013?",address D013 is:	Light-Pen Latch X Pos
"In the context of the C64, What does the address $D414 bits 7-4 control in a device?",address $D414 bits 7-4	is: Select Sustain Cycle Duration: 0-15
"In the context of the C64, What is the description of the register at address $D417?","address $D417	bits 2 is:	Filter Voice 3 Output: 1 = Yes, 0 = No Filter Voice 2 Output: 1 = Yes, 0 = No"
"In the context of the C64, What is the description of memory address $0067?",SGNFLG address  $0067       is:   Pointer: Series Evaluation Constant.
"In the context of the C64, What is the purpose of the memory address $0057-005B?",TEMPF1 address  $0057-005B  is:   Temporary storage for FLPT value.
"In the context of the C64, What is the description of the DIMFLG at address $000C?",DIMFLG address  $000C       is:   Flag: Default Array dimension.
"In the context of the C64, What is role of the CHARAC routine?",CHARAC address  $0007       is:   Search Character/Temporary Integer during INT.
"In the context of the C64, What is the purpose of the INPPTR address $0043-0044?",INPPTR address  $0043-0044  is:   Pointer: Temporary storage of Pointer during  INPUT Routine.
"In the context of the C64, What is the purpose of the memory address range $0019-0021 ?",TEMPST address  $0019-0021  is:   Stack for temporary Strings.
"In the context of the C64, What is the description of the memory location $003D-$003E in a Commodore 64 computer?",OLDTXT address  $003D-003E  is:   Pointer: BASIC Statement for CONT.
"In the context of the C64, What is the function of the address $000B ?",COUNT  address  $000B       is:   Input Buffer Pointer/Number of Subscripts.
"In the context of the C64, What is the function of the address $D40D ?","address $D40D	bits			4 is	Select Triangle Waveform, 1 = On"
"In the context of the C64, What is the function of memory location $D40C?",address $D40C	is		Envelope Generator 2: Attack / Decay Cycle Control
"In the context of the C64, What is the description of the memory address $D007 in the C64 memory map?",address $D007 is Sprite 3 Y Pos
"In the context of the C64, What is stored at memory address $0098 ?",LDTND     address $0098        is: Number of Open Files/Index to File Table.
"In the context of the C64, What is the address of the kernel routine for the memory bot in the Commodore 64?",kernal routine address for membot	= $ff9c
"In the context of the C64, What is the kernel routine address for the CLRCHN function in the Commodore 64?",kernal routine address for clrchn	= $ffcc
"In the context of the C64, What is the purpose of the FBUFPT address $0071-0072?",FBUFPT address  $0071-0072  is:   Pointer: Used during CRUNCH/ASCII conversion.
"In the context of the C64, What is the description of the INBIT register at address $00A7?",INBIT     address $00A7        is: RS232 temporary for received Bit/Tape temporary.
"In the context of the C64, What is the purpose of the memory location at address $00A6 in a Commodore 64 computer?",BUFPNT    address $00A6        is: Pointer: Tape I/O buffer.
"In the context of the C64, What is the kernel routine address for the close function in the Commodore 64?",kernal routine address for close	= $ffc3
"In the context of the C64, What is the description of the FACOV address $0070 ?",FACOV  address  $0070       is:   FAC low-order rounding.
"In the context of the C64, What is the purpose of the memory location at address $0097?",TEMPY     address $0097        is: Temporary storage of Y Register during RS232 fetch.
"In the context of the C64, What is the memory address of the Commodore 64's kernal routine for loading?",kernal routine address for load	= $ffd5
"In the context of the C64, What is the description of the memory address $D008 in the Commodore 64?",address $D008 is Sprite 4 X Pos
"In the context of the C64, What is the function of the bits1"" parameter at memory address $4283 ?""","address $4283	bits1 = On is:	Synchronize Osc. 2 with Osc. 1 Frequency,"
"In the context of the C64, What is the function of address $D40D ?","address $D40D	bits			5 is	Select Sawtooth Waveform, 1 = On"
"In the context of the C64, What is the format and description of the VERCK command ?","VERCK  address  $000A       is:   Flag: 0 = Load, 1 = Verify."
"In the context of the C64, What does the OLDLIN address $003B-003C?",OLDLIN address  $003B-003C  is:   Previous BASIC Line number.
"In the context of the C64, What is the description of the LASTPT address $0017-0018?",LASTPT address  $0017-0018  is:   Last temporary String Address.
"In the context of the C64, What is the description of the DATLIN address $003F-0040?",DATLIN address  $003F-0040  is:   Current DATA Line number.
"In the context of the C64, What is the description of the memory address range $0022-0025?",INDEX  address  $0022-0025  is:   Utility Pointer Area.
"In the context of the C64, What is the function of the address $0061-0066 ?",FAC    address  $0061-0066  is:   Main Floating point Accumulator.
"In the context of the C64, What is the description of the address $4283 bits3?",address $4283	bits3 is:	Test Bit: 1 = Disable Oscillator 1
"In the context of the C64, What is the function of address $D40D ?","address $D40D	bits			7 is	Select Random Noise Waveform, 1 = On"
"In the context of the C64, What is the description of the address $D416 in a MIDI synthesizer?",address $D416	is:	Filter Cutoff Frequency: High-Byte
"In the context of the C64, What does BIT 4 of address D011 control in a Commodore 64?",Address	D011	BIT 4 is Blank Screen to Border Color: 0 = Blank
"In the context of the C64, What is the description of the memory address $D006 in the Commodore 64?",address $D006 is Sprite 3 X Pos
"In the context of the C64, What is the function of the CHRGET routine?",CHRGET address  $0073-008A  is:   Subroutine: Get next Byte of BASIC Text.
"In the context of the C64, What is the kernel routine address for CINT in a Commodore 64?",kernal routine address for cint	= $ff81
"In the context of the C64, What is the address of the kernel routine for ioinit in the Commodore 64?",kernal routine address for ioinit	= $ff84
"In the context of the C64, What is the configuration of the default input device at address $0099?",DFLTN     address $0099        is: Default Input Device (0).
"In the context of the C64, What is the kernel routine address for ACPTR in a Commodore 64?",kernal routine address for acptr	= $ffa5
"In the context of the C64, What is the address of the kernel routine for the CHKin vector in a Commodore 64?",kernal routine address for chkin	= $ffc6
"In the context of the C64, What is the address of the kernel routine for the 'listen' function in a Commodore 64?",kernal routine address for listen	= $ffb1
"In the context of the C64, What is the description of the address $009A?",DFLTO     address $009A        is: Default Output Device (3).
"In the context of the C64, What is the description of the CHRGOT instruction with address $0079?",CHRGOT    address $0079        is: Entry to Get same Byte again.
"In the context of the C64, What is the address of the kernel routine that handles the CLALL instruction?",kernal routine address for clall	= $ffe7
"In the context of the C64, What is the description of the memory address $D005 in the C64 memory map?",address $D005 is Sprite 2 Y Pos
"In the context of the C64, What does BIT 5 of address D011 control in bit map mode?",Address	D011	BIT 5 is Bit Map Mode. 1 = Enable
"In the context of the C64, What is the description of the address $D417 ?",address $D417	is:	Filter Resonance Control / Voice Input Control
"In the context of the C64, What is the function of address $D40D in a pulse waveform controller?","address $D40D	bits			6 is	Select Pulse Waveform, 1 = On"
"In the context of the C64, What is the function of address $4283 ?","address $4283	bits2 is:	Ring Modulate Osc. 2 with Osc. 1 Output,"
"In the context of the C64, What is the purpose of the memory location at address $005C-0060?",TEMPF2 address  $005C-0060  is:   Temporary storage for FLPT value.
"In the context of the C64, What is the description of the memory address range $0022-0023?",INDEX1 address  $0022-0023  is:   First Utility Pointer.
"In the context of the C64, What is the function of the DATPTR address $0041-0042?",DATPTR address  $0041-0042  is:   Pointer: Used by READ - current DATA Item Address.
"In the context of the C64, What does the CURLIN address $0039-003A represents?",CURLIN address  $0039-003A  is:   Current BASIC Line number.
"In the context of the C64, What is the description of the memory address range $002D-$002E in a typical Commodore 64 system?",VARTAB address  $002D-002E  is:   Pointer: Start of BASIC Variables.
"In the context of the C64, What is the description of the address $006E?",ARGSGN address  $006E       is:   AFAC Sign.
"In the context of the C64, What do the lower 4 bits of address $D418 control?",address $D418 bits 3-0 are	Select Output Volume: 0-15
"In the context of the C64, What is the function of the bits 3-0 at address $D40C?",address $D40C bits 3-0	is: Select Decay Cycle Duration: 0-15
"In the context of the C64, What is the description of memory address $D410 ?",address $D410	is 			Voice 3: Pulse Waveform Width - Low-Byte
"In the context of the C64, What is the description of the memory address $D001 in the C64 memory map?",address $D001 is Sprite 0 Y Pos
"In the context of the C64, What does bit 4 of address D016 control?",address D016 bit 4	is Multi-Color Mode: 1 = Enable (Text or Bit-Map)
"In the context of the C64, What is the description of the memory region located at addresses $0334-$033B?",TEMP      address $0334-033B   is: Unused.
"In the context of the C64, What is the address of the kernel routine for CHRIN in the Commodore 64?",kernal routine address for chrin	= $ffcf
"In the context of the C64, What is the description of the STKEY at address $0091?",STKEY     address $0091        is: Flag: $7F = STOP key.
"In the context of the C64, What is the purpose of the memory location at address $0097?",TEMPX     address $0097        is: Temporary storage of X Register during CHRIN.
"In the context of the C64, What is the address of the kernel routine for the open function in a Commodore 64?",kernal routine address for open	= $ffc0
"In the context of the C64, What is the description of the address $0096?",SYNO      address $0096        is: Cassette Sync. number.
"In the context of the C64, What is the kernel routine address for memtop?",kernal routine address for memtop	= $ff99
"In the context of the C64, What is the kernel routine address for the CHKOUT function in a Commodore 64?",kernal routine address for chkout	= $ffc9
"In the context of the C64, What is the description of the memory location $0090 in the Commodore 64?",STATUS    address $0090        is: Kernal I/O Status Word  ST.
"In the context of the C64, What is the description of the ISAVE vector in the Commodore 64 Kernal?",ISAVE     address $0332-0333   is: Vector: Indirect entry to Kernal SAVE     Routine ($F5ED).
"In the context of the C64, What does address D016 bit 3 control?",address D016 bit 3 is Select 38/40 Column Text Display: 1 = 40 Cols
"In the context of the C64, What is the description of the memory address $D002 in the Commodore 64?",address $D002 is Sprite 1 X Pos
"In the context of the C64, What is the description of memory address $D40F ?",address $D40F	is 			Voice 3: Frequency Control - High-Byte
"In the context of the C64, What does the address $D40C bits 7-4 control in a game?",address $D40C bits 7-4	is: Select Attack Cycle Duration: O-15
"In the context of the C64, What is the function of bit 4 at address $D418?",address $D418 bit 4	is: Select Filter Low-Pass Mode: 1 = On
"In the context of the C64, What is the purpose of the ARISGN address $006F?",ARISGN address  $006F       is:   Sign of result of Arithmetic Evaluation.
"In the context of the C64, What is the description of the memory address range $002B-$002C in a Commodore 64 computer?",TXTTAB address  $002B-002C  is:   Pointer: Start of BASIC Text Area ($0801).
"In the context of the C64, What is the description of the memory location $0037-0038 in a Commodore 64 computer?",MEMSIZ address  $0037-0038  is:   Pointer: Highest Address available to BASIC ($A000).
"In the context of the C64, What is the description of the LINNUM address $0014-0015?",LINNUM address  $0014-0015  is:   Temporary: Integer value.
"In the context of the C64, What is the description of the memory location at address $0024-0025?",INDEX2 address  $0024-0025  is:   Secong Utility Pointer.
"In the context of the C64, What is the description of the FRETOP address $0033-0034?",FRETOP address  $0033-0034  is:   Pointer: Bottom of String space.
"In the context of the C64, What is the description of register $D411 in a certain microcontroller?",address $D411	is 		7-4	Unused 3-0	Voice 3: Pulse Waveform Width - High-Nybble
"In the context of the C64, What is the function of the address $D40D ?",address $D40D	is:	Envelope Generator 2: Sustain / Release Cycle Control
"In the context of the C64, What is the description of the memory address $D004 in the Commodore 64?",address $D004 is Sprite 2 X Pos
"In the context of the C64, What is the function of the BITTS register located at address $00B4?",BITTS     address $00B4        is: RS232 Write bit count/Tape Read timing Flag.
"In the context of the C64, What is the address of the kernel routine for plotting in the Commodore 64?",kernal routine address for plot	= $fff0
"In the context of the C64, What is the description of the memory location $0094?",C3PO      address $0094        is: Flag: Serial Bus - Output Character buffered.
"In the context of the C64, What is the function of the memory location $007A-007B in Commodore BASIC?",TXTPTR    address $007A-007B   is: Pointer: Current Byte of BASIC Text.
"In the context of the C64, What is the memory address of the KERNAL routine for outputting a character to the default output device in a Commodore 64?",kernal routine address for chrout	= $ffd2
"In the context of the C64, What is the kernel routine address for the SETMO instruction in a Commodore 64?",kernal routine address for settmo	= $ffa2
"In the context of the C64, What is the address of the kernel routine for setting the time in the Commodore 64?",kernal routine address for settim	= $ffdb
"In the context of the C64, What is the purpose of the memory location $008B-008F?",RNDX      address $008B-008F   is: Floating RND Function Seed Value.
"In the context of the C64, What is the address of the kernel routine for CIOUT in a Commodore 64?",kernal routine address for ciout	= $ffa8
"In the context of the C64, What is the kernel routine address for RAMTAS?",kernal routine address for ramtas	= $ff87
"In the context of the C64, What is the description of the BSOUR address $0095 ?",BSOUR     address $0095        is: Buffered Character for Serial Bus.
"In the context of the C64, What is the function of the NXTBIT register located at address $00B5?",NXTBIT    address $00B5        is: RS232 Next Bit to send/Tape Read - End of Tape.
"In the context of the C64, What is the description of the memory address $D003 in the Commodore 64?",address $D003 is Sprite 1 Y Pos
"In the context of the C64, What does the bits 7-4 of address $D40D represent ?",address $D40D	bits 7-4 is:	Select Sustain Cycle Duration: O-15
"In the context of the C64, What is the description of the memory location $D40D-$D412 ?",address $D40D	 $D412 is:			Voice 3: Control Register
"In the context of the C64, What is the description of the FRESPC address $0035-0036?",FRESPC address  $0035-0036  is:   Utility String Pointer.
"In the context of the C64, What is the description of the RESHO address $0026-002A?",RESHO  address  $0026-002A  is:   Floating point product of Multiply and Divide.
"In the context of the C64, What is the description of the memory address $0016 in a Commodore 64 computer?",TEMPPT address  $0016       is:   Pointer: Temporary String Stack.
"In the context of the C64, What is the function of the bit 4 of the I/O port address $DD01 in a Commodore 64?",address $DD01 bit 4 is	User / RS-232 Carrier Detect
"In the context of the C64, What is stored at memory address $DD0B?",address $DD0B is:	Time-of-Day Clock: Hours + AM/PM Flag (Bit 7)
"In the context of the C64, What is the function of the bit 1 in the $DC0D address?",address $DC0D bit 1 is	Timer B Interrupt
"In the context of the C64, What is the description of the memory location $DC04 ?",address $DC04	is: Timer A: Low-Byte
"In the context of the C64, What is the function of the address $DC00 bits 7-0 in a keyboard scan?",address $DC00 bits 7-0	is: Write Keyboard Column Values for Keyboard Scan
"In the context of the C64, What is the description of the flag located at address $D019 Bit 1?",address $D019 Bit 1	is: Sprite to Background Collision IRQ Flag
"In the context of the C64, What is the description of the address $4275 ?",address $4275			is:	    bits 7-4	Unused 3-0	Voice 1: Pulse Waveform Width - High-Nybble
"In the context of the C64, What is the description of the address $3284?",address $3284		is:			Background Color 3
"In the context of the C64, What is the function of the register located at address $029E?",RODBE     address $029E        is: RS232 Index to End of Output Buffer.
"In the context of the C64, What is the purpose of the memory location addressed by $00FF?",BASZPT    address $00FF        is: BASIC temporary Data Area.
"In the context of the C64, What is the description of the CRSW address $00D0?","CRSW      address $00D0        is: Flag: Input from Screen = $03, or Keyboard =  $00."
"In the context of the C64, What is the description of the RSSTAT at address $0297?",RSSTAT    address $0297        is: RS232 Pseudo 6551 Status Register Image.
"In the context of the C64, What is the description of the ICHKIN vector at address $031E-031F?",ICHKIN    address $031E-031F   is: Vector: Indirect entry to Kernal CHKIN  Routine ($F20E).
"In the context of the C64, What is stored at memory address $0286?",COLOR     address $0286        is: Current Character Colour code.
"In the context of the C64, What is the function of the flag located at address $0285?",TIMOUT    address $0285        is: Serial IEEE Bus timeout defeat Flag.
"In the context of the C64, What is the description of the memory location $0320-0321 in the Commodore 64 Kernal?",ICKOUT    address $0320-0321   is: Vector: Indirect entry to Kernal CHKOUT Routine ($F250).
"In the context of the C64, What is the function of the memory address $00D1-00D2 ?",PNT       address $00D1-00D2   is: Pointer: Current Screen Line Address.
"In the context of the C64, What is the description of the BITNUM variable located at address $0298?",BITNUM    address $0298        is: RS232 Number of Bits left to send.
"In the context of the C64, What is the purpose of the memory location $029F-02A0?",IRQTMP    address $029F-02A0   is: Temporary store for IRQ Vector during Tape  operations.
"In the context of the C64, What is the purpose of the memory location $00FF-010A ?",ASCWRK    address $00FF-010A   is: Assembly Area for Floating point to ASCII     conversion.
"In the context of the C64, What is the description of memory address $3283?",address $3283		is:			Background Color 2
"In the context of the C64, What is the description of memory address $4274 ?",address $4274		is:			Voice 1: Pulse Waveform	Width - Low-Byte
"In the context of the C64, What is the description of the flag located at address $D019 Bit 2?",address $D019 Bit 2	is: Sprite to Sprite Collision IRQ Flag
"In the context of the C64, What does the address $DC00 bits 7-6 represent ?","address $DC00 bits 7-6	is: Read Paddles on Port A / B (01 = Port A, 10 = Port B)"
"In the context of the C64, What is the description of memory location $DC05?",address $DC05	is: Timer A: High-Byte
"In the context of the C64, What is the function of the bit 0 in the $DC0D address?",address $DC0D bit 0 is	Timer A Interrupt
"In the context of the C64, What is the description of the memory address $DD0C in a Commodore 64 computer?",address $DD0C is:	Synchronous Serial I/O Data Buffer
"In the context of the C64, What is the function of the bit 3 of the I/O address $DD01 in a Commodore 64?",address $DD01 bit 3 is	User / RS-232 Ring Indicator
"In the context of the C64, What is stored at memory address $DD0A?",address $DD0A is:	Time-of-Day Clock: Minutes
"In the context of the C64, What is at address $DD01 bit 5?",address $DD01 bit 5 is	User
"In the context of the C64, What is the function of bit 3 at address $DD0E ?","address $DD0E bit 3 is:	Timer A Run Mode: 1 = One-Shot, s"
"In the context of the C64, What is the description of the memory location $DC07 ?",address $DC07	is: Timer B: High-Byte
"In the context of the C64, What is the description of the address $4278 ?",address $4278      bits        7-4  is:   Select Sustain Cycle Duration: 0-15
"In the context of the C64, What does bit 7 of address $DC0E represent?","address $DC0E bit 7	is: Time-of-Day Clock Frequency: 1 = 50 Hz, 0 = 60 Hz"
"In the context of the C64, What is the description of memory address $3285 in the Commodore 64?",address $3285			is:		Sprite Multi-Color Register 0
"In the context of the C64, What is the description of memory address $4276 ?",address $4276		is: 	Voice 1: Control Register
"In the context of the C64, What is the description of the address $DC0F bits 4-0?",address $DC0F bits 4-0	is: Same as CIA Control Reg. A - for Timer B
"In the context of the C64, What is the function of the register located at address $029B?",RIDBE     address $029B        is: RS232 Index to End of Input Buffer.
"In the context of the C64, What is the meaning and possible values of the Flag at memory address $00CF?","BLNON     address $00CF        is: Flag: Cursor Status; $00 = Off, $01 = On."
"In the context of the C64, What is the purpose of the memory space located at addresses $00FB-00FE?",FREKZP    address $00FB-00FE   is: Free Zero Page space for User Programs.
"In the context of the C64, What is the function of the address $02A2 ?",TODSNS    address $02A2        is: TOD sense during Tape I/O.
"In the context of the C64, What is the function of the component located at address $00C0?",CAS1      address $00C0        is: Tape Motor Switch.
"In the context of the C64, What is the function of the memory location at address $00BF?",MYCH      address $00BF        is: Serial Word Buffer.
"In the context of the C64, What is the function of the register located at address $00F9-00FA?",ROBUF     address $00F9-00FA   is: RS232 Output Buffer Pointer.
"In the context of the C64, What is the function of the ENABL command at address $02A1?",ENABL     address $02A1        is: RS232 Enables.
"In the context of the C64, What is the description of the memory location $0299-029A?",BAUDOF    address $0299-029A   is: RS232 Baud Rate; Full Bit time microseconds.
"In the context of the C64, What does the GDBLN at address $00CE represent ?",GDBLN     address $00CE        is: Character under Cursor while Cursor Inverted.
"In the context of the C64, What does bit 7 of address $4276 control ?","address $4276	bit 7 is 	Select Random Noise Waveform, 1 = On"
"In the context of the C64, What is the function of memory addresses $DD00-DDFF in a Commodore 64 computer?",addresses $DD00-DDFF	are:		MOS 6526 Complex Interface Adapter (CIA) #2
"In the context of the C64, What is the description of memory address $3286 in the Commodore 64?",address $3286		is:			Sprite Multi-Color Register 1
"In the context of the C64, What is the function of memory address $4278 ?",address $4278			Envelope Generator 1: Sustain / Release Cycle Control
"In the context of the C64, What is the description of the memory location $DC0E in the Commodore 64?",address $DC0E	is	CIA Control Register A
"In the context of the C64, What is the description of memory location $DC06 ?",address $DC06	is: Timer B: Low-Byte
"In the context of the C64, What is the function of bit 4 of the $DD0E address ?",address $DD0E bit 4 is:	Force Load Timer A: 1 = Yes
"In the context of the C64, What is the function of the bit 6 of the I/O port $DD01 in a Commodore 64?",address $DD01 bit 6 is	User / RS-232 Clear to Send
"In the context of the C64, What is stored at memory address $DD09 in the Commodore 64?",address $DD09 is:	Time-of-Day Clock: Seconds
"In the context of the C64, What is the purpose of the address range $DF00-DFFF ?",address $DF00-DFFF are	Reserved for Future I/O Expansion
"In the context of the C64, What is the description of memory address $DD05 in the Commodore 64?",address $DD05 is:	Timer A: High-Byte
"In the context of the C64, What is the function of the bit 2 of the I/O address $DD01 in a Commodore 64?",address $DD01 bit 2 is	User / RS-232 Data Terminal Ready
"In the context of the C64, What is the description of the address $4283 ?","address $4283	bits5 is:	Select Sawtooth Waveform, 1 = On"
"In the context of the C64, What is the description of the address $DC0A?",address $DC0A	is: Time-of-Day Clock: Minutes
"In the context of the C64, What is the function of the bit 3 in the $DC0D address?",address $DC0D bit 3 is	Serial Port Interrupt
"In the context of the C64, What is the description of memory address $3290 in the context of a Commodore 64?",address $3290		is:			Sprite 3 Color
"In the context of the C64, What is the function of the bit 7 of the I/O port address $DD01 in a Commodore 64 computer?",address $DD01 bit 7 is	User / RS-232 Data Set Ready
"In the context of the C64, What is the description of memory address $4273 ?",address $4273		is:			Voice 1: Frequency Control - High-Byte
"In the context of the C64, What is the memory location that stores the horizontal position of the first sprite in Commodore 64 graphics?",address $D000 is Sprite 0 X Pos
"In the context of the C64, What is the function and possible values of the BLNSW address $00CC?","BLNSW     address $00CC        is: Flag: Cursor blink; $00 = Enabled, $01 =  Disabled."
"In the context of the C64, What does the PNTR at address $00D3 represent ?","PNTR      address $00D3        is: Cursor Column on current Line, including Wrap-round Line, if any."
"In the context of the C64, What is the description of the M51CDR register at address $0294?",M51CDR    address $0294        is: RS232 Pseudo 6551 command Register Image.
"In the context of the C64, What is the description of the memory location at address $02A5?",TLNIDX    address $02A5        is: Temporary for Line Index.
"In the context of the C64, What is the purpose and contents of the memory location $00D9-00F2?",LDTB1     address $00D9-00F2   is: Screen Line link Table/Editor temporaries.  High Byte of Line Screen Memory Location.
"In the context of the C64, What does the TVSFLG flag at address $02A6 ?","TVSFLG    address $02A6        is: Flag: TV Standard: $00 = NTSC, $01 = PAL."
"In the context of the C64, What is the function of the memory location addressed by $00F3-00F4 ?",USER      address $00F3-00F4   is: Pointer: Current Colour RAM Location.
"In the context of the C64, What is the meaning and usage of the address $00D4?",QTSW      address $00D4        is: Flag: Editor in Quote Mode; $00 = Not.
"In the context of the C64, What is the description of the address $0295-0296?",M51AJB    address $0295-0296   is: RS232 Non-standard Bits/Second.
"In the context of the C64, What is the purpose of the memory location at address $00CD in the system?",BLNCT     address $00CD        is: Timer: Count down for Cursor blink toggle.
"In the context of the C64, What information is stored in bits 6-7 of address $0001?",address $0001 bit 6-7 is:	Undefined
"In the context of the C64, What is the description of memory address $4272?",address $4272		is:			Voice 1: Frequency Control - Low-Byte
"In the context of the C64, What is the description of memory address $3289 in the context of a Commodore 64?",address $3289		is:			Sprite 2 Color
"In the context of the C64, What is the function of the address $DD01 in the Commodore 64?","address $DD01 is:		Data Port B (User Port, RS-232)"
"In the context of the C64, What is the function of the bit 2 in the $DC0D address?",address $DC0D bit 2 is	Time-of-Day Clock Alarm Interrupt
"In the context of the C64, What is the description of the address $4283 ?","address $4283	bits4 is:	Select Triangle Waveform, 1 = On"
"In the context of the C64, What is the description of the address $DC0B ?",address $DC0B	is: Time-of-Day Clock: Hours + AM/PM Flag (Bit 7)
"In the context of the C64, What is the function of the bit 1 of the I/O port address $DD01 in a Commodore 64?",address $DD01 bit 1 is	User / RS-232 Request to Send
"In the context of the C64, What is the description of memory address $DD06?",address $DD06 is:	Timer B: Low-Byte
"In the context of the C64, What is the description of the register located at address $0000?",D6510  address  $0000       is:   6510 On-chip Data Direction Register.
"In the context of the C64, What is the function of memory address $DD02 ?",address $DD02 is:	Data Direction Register - Port A
"In the context of the C64, What is stored at memory address $DD08 in the Commodore 64?",address $DD08 is:	Time-of-Day Clock: 1/10 Seconds
"In the context of the C64, What is the description of the address $DC03 ?",address $DC03	is: Data Direction Register - Port B (56321)
"In the context of the C64, What is the function of bit 4 of the $DC0D address in a Commodore 64 computer?",address $DC0D bit 4 is	FLAG1 IRQ (Cassette Read / Serial Bus SRQInput)
"In the context of the C64, What is the description of the address $DC09?",address $DC09	is: Time-of-Day Clock: Seconds
"In the context of the C64, What is the description of memory address $3293?",address $3293		is:			Sprite 6 Color
"In the context of the C64, What is the description of memory address $3287 in the Commodore 64 memory map?",address $3287		is:			Sprite 0 Color
"In the context of the C64, What is the description of memory address $3281?",address $3281		is:			Background Color 0
"In the context of the C64, What is the purpose of the memory location at address $030F in a Commodore 64 computer?",SPREG     address $030F        is: Storage for 6510 Status Register during SYS.
"In the context of the C64, What is the function of the RIBUF address $00F7-00F8 ?",RIBUF     address $00F7-00F8   is: RS232 Input Buffer Pointer.
"In the context of the C64, What is the function of the TD1IRQ at address $02A4?",TD1IRQ    address $02A4        is: Temporary D1IRQ Indicator during Tape READ.
"In the context of the C64, What is the description of the M51CTR at address $0293?",M51CTR    address $0293        is: RS232 Pseudo 6551 control Register Image.
"In the context of the C64, What is stored at memory address $00D6 ?",TBLX      address $00D6        is: Current Screen Line number of Cursor.
"In the context of the C64, What is the purpose of the KEYLOG routine located at address $028F-0290?",KEYLOG    address $028F-0290   is: Vector: Routine to determine Keyboard table to use based on Shift Key Pattern ($EB48).
"In the context of the C64, What is the function and configuration of the mode at address $0291?","MODE      address $0291        is: Flag: Upper/Lower Case change: $00 = Disabled, $80 = Enabled ($00)."
"In the context of the C64, What is the configuration setting for the AUTODN address $0292?",AUTODN    address $0292        is: Flag: Auto scroll down: $00 = Disabled ($00).
"In the context of the C64, What is the description of the LNMX address $00D5?",LNMX      address $00D5        is: Current logical Line length: 39 or 79.
"In the context of the C64, What is the function and location of the KEYTAB command ?",KEYTAB    address $00F5-00F6   is: Vector: Current Keyboard decoding Table. ($EB81)
"In the context of the C64, What is the purpose of the TRDTMP address $02A3 ?",TRDTMP    address $02A3        is: Temporary storage during Tape READ.
"In the context of the C64, What is the purpose of the memory location at address $030E in a Commodore 64 computer?",SYREG     address $030E        is: Storage for 6510 Y-Register during SYS.
"In the context of the C64, What is the description of the address located at $3282?",address $3282		is:			Background Color 1
"In the context of the C64, What is the description of the memory address $3288 in the Commodore 64?",address $3288		is:			Sprite 1 Color
"In the context of the C64, What is the description of memory address $3294?",address $3294		is:			Sprite 7 Color
"In the context of the C64, What is the description of the address $DC08?",address $DC08	is: Time-of-Day Clock: 1/10 Seconds
"In the context of the C64, What is the function of bit 7 in the $DC0D address?",address $DC0D bit 7 is	IRQ Flag (1 = IRQ Occurred) / Set-Clear Flag
"In the context of the C64, What is the description of the address $DC02 ?",address $DC02	is: Data Direction Register - Port A (56320)
"In the context of the C64, What is the description of memory address $DD07 in the Commodore 64?",address $DD07 is:	Timer B: High-Byte
"In the context of the C64, What is the function of the bit 0 of the I/O address $DD01 in a Commodore 64?",address $DD01 bit 0 is	User / RS-232 Received Data
"In the context of the C64, What is the meaning of error code 21: READ ERROR (drive not ready) on a disk controller?","1581 disk: Controller commands error code  21: READ ERROR (drive not ready)
    The  disk  controller  is unable to detect a sync mark on the
    desired track.  Caused by misalignment, or a diskette that is
    absent,  unformatted or improperly seated.  Can also indicate
    hardware  failure.  Unless  caused by one of the above simple
    causes, this error is usually unrecoverable."
"In the context of the C64, What is the function of the TREAD_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: TREAD_DV
      $AA     Reads  logical address without transferring
                      to the job queue buffer."
"In the context of the C64, What error message is generated when the data to be written exceeds the record size?","1581 disk: Controller commands error code 51: OVERFLOW IN RECORD
    The  data  to  be  written  in the current record exceeds the
    record size. The excess has been truncated (cut off). Be sure
    to include all special characters  (such as carriage returns)
    in calculating record sizes."
"In the context of the C64, What is the list of Kernal ROM subroutines for disk-related operations in a computer, along with an example program that reads a sequential file into memory from disk?","1581 disk:  MACHINE LANGUAGE PROGRAMS


  Here  is  a  list  of  host  computer  disk-related  Kernal ROM
subroutines  and  a  practical  example of their use in a program
that reads a sequential file into memory from disk.  Most require
advance  setup  of  one  or  more  processor  registers or memory
locations  and  all  are  called  with  the assembly language JSR
command.
  For a more  complete  description  as to what each routine does
and how parameters are set for each routine, see the Programmer's
Reference Guide for your specific computer.


                 DISK-RELATED KERNAL SUBROUTINES

Label        Address                    Functions
-----------------------------------------------------------------
SETLFS  =    $FFBA     ; SET LOGICAL, FIRST & SECOND ADDRESSES
SETNAM  =    $FFBD     ; SET LENGTH & ADDRESS OF FILENAME
OPEN    =    $FFC0     ; OPEN LOGICAL FILE
CLOSE   =    $FFC3     ; CLOSE LOGICAL FILE
CHKIN   =    $FFC6     ; SELECT CHANNEL FOR INPUT
CHKOUT  =    $FFC9     ; SELECT CHANNEL FOR OUTPUT
CLRCHN  =    $FFCC     ; CLEAR ALL CHANNELS & RESTORE DEFAULT I/O
CHRIN   =    $FFCF     ; GET BYTE FROM CURRENT INPUT DEVICE
CHROUT  =    $FFD2     ; OUTPUT BYTE TO CURRENT OUTPUT DEVICE
        ;
START   LDA  #4        ; SET LENGTH & ADDRESS
        LDX  #<FNADR   ; OF FILE NAME, LOW
        LDY  #>FNADR   ; & HIGH BYTES
        JSR  SETNAM    ; FOR NAME SETTER
        LDA  #3        ; SET FILE NUMBER
        LDX  #8        ; DISK DEVICE NUMBER
        LDY  #0        ; AND SECONDARY ADDRESS
        JSR  SETLFS    ; AND SET THEM
        JSR  OPEN      ; OPEN 3,8,0,'TEST'
        LDX  #3
        JSR  CHKIN     ; SELECT FILE 3 FOR INPUT
NEXT    JSR  CHRIN     ; GET NEXT BYTE FROM FILE
        BEQ  END       ; UNTIL FINISH OR FAIL
        JSR  CHROUT    ; OUTPUT BYTE TO SCREEN
        JMP  NEXT      ; AND LOOP BACK FOR MORE
        ;
END     LDA  #3        ; WHEN DONE
        JSR  CLOSE     ; CLOSE FILE
        JSR  CLRCHN    ; RESTORE DEFAULT I/O
        RTS            ; BACK TO BASIC
        ;
FNADR   .BYT 'TEST'    ; STORE FILE NAME HERE"
"In the context of the C64, What is the purpose of the BLOCK-ALLOCATE command in direct access commands, and how is it used to mark a sector as 'already used' on a diskette?","1581 disk:  ALLOCATING BLOCKS

  Once  you  have  written  something in a particular sector on a
diskette  with  the  help of direct access commands, you may wish
to mark that sector as  'already used',  to keep other files from
being written there. Blocks thus allocated will be safe until the
diskette is validated.

FORMAT FOR BLOCK-ALLOCATE COMMAND:

  PRINT#15,'BLOCK-ALLOCATE';drive#;track#;sector#

usually abbreviated as: PRINT#15,'B-A';drive#;track#;sector#

where  'drive#' is the drive number,  and  'track#' and 'sector#'
are  the track and sector containing the block of data to be read
into the file buffer.

ALTERNATE FORMAT:

  PRINT#15,'B-A:';drive#;track#;sector#

EXAMPLE:

  If  you  try  to allocate a block that isn't available, the DOS
will set the error message to number  65,  NO BLOCK,  and set the
track  and  sector  numbers  in  the  error  message  to the next
available track and sector number.  Therefore, before selecting a
block to write,  try  to allocate that block.  If the block isn't
available,  read  the next available block from the error channel
and allocate it instead.  However, do not allocate data blocks in
the  directory  track.  If  the  track  number returned is 0, the
diskette is full.
  Here is a program  that allocates a place to store a message on
a diskette.

  100 OPEN 15,8,15             Open command channel.
  110 OPEN 5,8,5,'#'           Open direct access channel.
  120 PRINT#5,'I THINK
      THEREFORE I AM'          Write a message to buffer.
  130 T=1: S=1                 Start at first track & sector.
  140 PRINT#15,'B-A';0;T;S     Try allocating it.
  150 INPUT#15,EN,EM$,ET,ES    See if it worked.
  160 IF EN=0 THEN 210         If so, we're almost done.
  170 IF EN<>65 THEN PRINT     'NO BLOCK'
      EN,EM$,ET,ES: STOP       means already allocated.
  180 IF ET=0 THEN PRINT       If next track is 0,
      'DISK FULL': STOP        we're out of room.
  190 IF ET=40 THEN ET=41:ES=0 Don't allocate the directory.
  200 T=ET: S=ES: GOTO 140     Try suggested track & sector next.
  210 PRINT#15,'U2';5;0;T;S    Write buffer to allocated
                               sector.
  220 PRINT 'STORED AT:';T,S   Say where message went
  220 CLOSE 5: CLOSE 15        and tidy up.
  230 END"
"In the context of the C64, What is the special character used by DOS to fill relative records as they are created, and how is it used when writing the last record in a relative file?","1581 disk:COMPLETING RELATIVE FILE CREATION

  Now that you have learned how to use both the  OPEN and RECORD#
commands,  you  are  almost  ready  to properly create a relative
file. The only additional fact you need to know is that CHR$(255)
is  a  special character in a relative file.  It is the character
used  by  the  DOS  to fill relative records as they are created,
before a program fills them with other information.  Thus, if you
want  to  write the last record,  you expect to need in your file
with  dummy  data  that  will not interfere with your later work,
CHR$(255)  is  the  obvious  choice."
"In the context of the C64, What does the DOS MISMATCH"" error code 3 on a Commodore 1581 disk indicate?""","1581 disk: Controller commands error code 3: DOS MISMATCH (COPYRIGHT CBM DOS V10 1581)
    If  the  disk-error status is checked when the drive is first
    turned  on,  before  a  directory  or  other command has been
    given,  this message will appear.  In that use,  it is not an
    error,  but rather an easy way to see which version of DOS is
    in use. If the message appears at other times, an attempt has
    been made to write to a diskette with an incompatible format."
"In the context of the C64, What are splat files"" and how should they be handled on a diskette?""","SPLAT FILES

  One  indicator you may occasionally notice on a directory line,
after  you  begin  saving  programs  and  files,  is  an asterisk
appearing  just  before  the file type of a file that is 0 blocks
long.  This  indicates  the file was not properly closed after it
was created, and that it should not be relied upon. These 'splat'
files normally need to be erased from the diskette and rewritten.
However,  do not use the SCRATCH command to get rid of them. They
can  only  be  safely erased by the VALIDATE or COLLECT commands.
One  of  these  should  normally be used whenever a splat file is
noticed on a diskette. All of these commands are described in the
following chapters.
  There  are  two  exceptions  to the above warning:  one is that
VALIDATE  and  COLLECT  cannot  be  used  on  some diskettes that
include direct access  (random) files  (Chapter 6).  The other is
that  if  the information in the splat file was crucial and can't
be  replaced,  there is a way to rescue whatever part of the file
was  properly  written.  This  option  is  described  in the next
chapter."
"In the context of the C64, What is the syntax and usage of the INPUT# statement in BASIC, and how can it be used to read data from a file?","1581 disk with basic 7,0: FORMAT FOR THE INPUT# STATEMENT:

  INPUT#file#,variable list

where 'file#' is the same file number given in the desired file's
current OPEN statement,  and 'variable list' is one or more valid
BASIC  variable  names.  If  more  than one data element is to be
input  by a particular INPUT# statement,  each variable name must
be separated from others by a comma.

EXAMPLES:

To read back in the grades written with the PRINT# example, use:

  300 FOR CLASS = 1 TO COURSES
  310 INPUT#1,GRADE$(CLASS)
  320 GOSUB 59990: REM CHECK FOR DISK ERRORS
  330 NEXT CLASS

assuming your program includes an error check subroutine like the
one in the last chapter.
  To  read  back  in  the  address data written by another PRINT#
example, it is safest to use:

  800 INPUT#5,NAME$
  810 GOSUB 59990: REM CHECK FOR DISK ERRORS
  820 INPUT#5,STREET$
  830 GOSUB 59990: REM CHECK FOR DISK ERRORS
  840 INPUT#5,CITY$
  850 GOSUB 59990: REM CHECK FOR DISK ERRORS

but many programs cheat on safety a bit and use

  800 INPUT#5,NAME$,STREET$,CITY$
  810 GOSUB 59990: REM CHECK FOR DISK ERRORS

This  is  done  primarily  when  top  speed  in  the  program  is
essential, and there is little risk of reading improper data from
the file."
"In the context of the C64, How do you erase a locked file on a diskette that cannot be deleted with the SCRATCH command?","1581 disk with basic 7,0:  Locked Files

  Occasionally,  a diskette will contain a locked file; one which
cannot  be  erased  with  the  SCRATCH command. Such files may be
recognized  by  the  '<'  character which immediately follows the
file type in their directory entry. If you wish to erase a locked
file,  you  will have to use a disk monitor to clear bit 6 of the
file-type   byte   in   the  directory  entry  on  the  diskette.
Conversely, to lock a file, you would set bit 6 of the same byte."
"In the context of the C64, What is the syntax and functionality of the RENAME command in a disk with BASIC 7.0?","1581 disk with basic 7,0: RENAME

  The RENAME command allows you to alter the name of a program or
other file in the diskette directory. Since only the directory is
affected, RENAME works very quickly.  If you try to RENAME a file
by using a file name already in the directory,  the computer will
respond  with  a  'FILE EXISTS'  error.  A file  must be properly
closed before it can be renamed.

FORMAT FOR RENAME COMMAND:

  RENAME [Ddrive#,] 'old name' TO [Ddrive#,] 'new name'
         [,Udevice#]

where both drive#s, if included, would be 0."
"In the context of the C64, What is the purpose of the error checking program in Basic 2.0 and how can it be used to diagnose and clear disk errors?","1581 disk: ERROR CHECKING

  In Basic 2.0,  when the red drive light flashes, you must write
a small program to find out what the error is. This causes you to
lose  any  program variables already in memory.  The following is
the error check program:

  10 OPEN 15,8,15
  20 INPUT#15,EN,EM$,ET,ES
  30 PRINT EN,EM$,ET,ES
  40 CLOSE 15

  This  little  program  reads  the error channel into four BASIC
variables  (described  below),  and  prints  the  results  on the
screen.  A message is displayed whether there is an error or not,
but if there was an error, the program clears it from disk memory
and stops the error light from blinking.
  Once  the  message  is  on  the  screen,  you can look it up in
Appendix B to see what it means, and what to do about it.
  For those of you who are writing programs,  the  following is a
small error-checking subroutine you can include in your programs:

  59980 REM READ ERROR CHANNEL
  59990 INPUT#15,EN,EM$,ET,ES
  60000 IF EN>1 THEN PRINT EN,EM$,ET,ES: STOP
  60010 RETURN

  This  assumes  file  15  was opened earlier in the program, and
that it will be closed at the end of the program.
  The  subroutine  reads  the  error channel and puts the results
into  the  named  variables  --  EN  (Error  Number),  EM$ (Error
Message),  ET (Error Track),  and ES (Error Sector). Of the four,
only  EM$  has  to  be a string.  You could choose other variable
names, although these have become traditional for this use.
  Two error numbers are harmless -- 0 means everything is OK, and
1  tells  how  many  files  were  erased  by  a  SCRATCH  command
(described  later  in  this  chapter).  If  the  error  status is
anything else,  line 60000 prints the error message and halts the
program.
  Because  this  is  a  subroutine,  you access it with the BASIC
GOSUB  command,  either  in immediate mode or from a program. The
RETURN  statement  in line 60010 will jump back to immediate mode
or the next statement in your program, whichever is appropriate."
"In the context of the C64, What are two common BASIC error messages that may occur when working with data files, and how do they relate to INPUT# and PRINT# statements?","1581 disk with basic 7,0:  MORE ABOUT INPUT#

  After you begin using data files regularly,  you  may encounter
two BASIC error messages.  They are  'STRING TOO LONG ERROR'  and
'FILE DATA ERROR'.  Both  are  likely  to halt your program at an
INPUT#  statement,  but  may also have been caused by errors in a
PRINT# statement when the file was written."
"In the context of the C64, What error message is displayed when trying to access a blank diskette in a 1581 disk controller without formatting it first?","1581 disk: Controller commands error code 74: DRIVE NOT READY
    An  attempt  has  been  made  to  access the 1581 single disk
    without a formatted diskette in place. Blank diskettes cannot
    be used until they have been formatted."
"In the context of the C64, What happens when you try to write to a non-existent record in a relative file in DOS?","1581 disk: EXPANDING A RELATIVE FILE

  If  you  underestimate your needs and want to expand a relative
file later, simply request the record number you need, even if it
doesn't  currently exist in the file.  If there is no such record
yet,  DOS  will create it as soon as you try to write information
in  it,  and  also automatically create any other missing records
below it in number.  When the first record beyond the current end
record  is  written,  the  DOS  returns  '50, RECORD NOT PRESENT'
error. This is expected and correct."
"In the context of the C64, What is the purpose of the buffer pointer in disk memory and how is it used to access and edit individual bytes within a block?","1581 disk:  THE BUFFER POINTER

  The buffer pointer points to where the next  READ or WRITE will
begin within a disk memory buffer.  By moving the buffer pointer,
you can access individual bytes within a block in any order. This
allows  you to edit any portion of a sector,  or organize it into
fields, like a relative record.

FORMAT FOR THE BUFFER-POINTER COMMAND:

  PRINT#15,'BUFFER-POINTER';channel#;byte

usually abbreviated as: PRINT#15,'B-P';channel#;byte

where  'channel#'  is  the channel number specified when the file
reserving the buffer was opened,  and  'byte'  is  the  character
number within the buffer at which to point (from 0 through 255).

ALTERNATE FORMATS:

  PRINT#15,'B-P:'channel#;byte
  PRINT#15,'B-P:channel#,byte'

EXAMPLE:

  Here  is  a  program  that locks the first program or file on a
diskette.  It works by reading the start of the directory  (Track
40, Sector 3) into disk memory, setting the buffer pointer to the
first  file  type  byte  (see Appendix C for details of directory
organization), locking it by setting bit 6 and rewriting it.

  110 OPEN 15,8,15                 Open command channel.
  120 OPEN 5,8,5,'#'               Open direct access channel.
  130 PRINT#15,'U1';5;0;40;3       Read Track 40, Sector 3.
  140 PRINT#15,'B-P';5;2           Point to Byte 2 of the buffer.
  150 GET#5,A$: IF A$=''
      THEN A$=CHR$(0)              Read it into memory.
  160 A=ASC(A$) OR 64              Turn on bit 6 to lock.
  170 PRINT#15,'B-P';5;2           Point to Byte 2 again.
  180 PRINT#5,CHR$(A);             Overwrite it in buffer.
  190 PRINT#15,'U2';5;0;40;3       Rewrite buffer to diskette.
  200 CLOSE 5                      Tidy up after.
  210 CLOSE 15
  220 END

After the above program is run,  the  first file on that diskette
can  no  longer be erased.  If you later need to erase that file,
rerun the same program, but substitute the revised line 160 below
to unlock the file again:

  160 A=ASC(A$) AND 191            Turn off bit 6 to unlock."
"In the context of the C64, What is the meaning of error code 50 RECORD NOT PRESENT"" in a disk controller command?""","1581 disk: Controller commands error code 50: RECORD NOT PRESENT
    The requested record number has not been created yet. This is
    not  an  error  in  a  new relative file or one that is being
    intentionally expanded. It results from reading past the last
    existing  record,  or  positioning  to  a non-existent record
    number with the RECORD# command."
"In the context of the C64, What is the purpose and behavior of the 'COPYRIGHT CBM 86' file on a 1581 disk?","1581 disk:  AUTO BOOT LOADER

  During some operations  (power-up reset,  burst INQUIRE,  burst
QUERY,  an  initialize command)  the 1581 will automatically look
for  a  file or the disk named  'COPYRIGHT CBM 86'  that is a USR
type-file.  The format of the file is the same  as that described
previously for the utility loader.  If it is present, the file is
automatically loaded and executed.

  The  automatic  loading  of this file can be disabled by either
renaming it, setting the appropriate flag in the RAM sectors (see
Appendix C),  or  by  setting  a  flag variable in RAM to disable
further autoboots (see JDEJAVU jump table vector in Chapter 10).

  At  the  end of the autobooted program it should return control
to the 1581 via the JCBMBOOTRTN jump table vector."
"In the context of the C64, What is the function of the PSEEK_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: PSEEK_DV
      $A8     Seeks to the specified physical track."
"In the context of the C64, What is the error message and explanation for a disk controller's inability to locate the header of a requested data block?","1581 disk: Controller commands error code READ ERROR (block header not found)
    The  disk  controller  is  unable to locate the header of the
    requested data block.  Caused by an illegal block or a header
    that has been destroyed. Usually unrecoverable."
"In the context of the C64, What is the function of the TWRT_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: TWRT_DV
       $AC     Writes    a    logical    address   without
                      transferring from the job queue buffer."
"In the context of the C64, What is the meaning of error code 22 in a disk controller command?","1581 disk: Controller commands error code 22: READ ERROR (data block not found)
    The  disk  controller  has been requested to read or verify a
    data   block  that  was  not  properly  written.   Occurs  in
    conjunction  with  BLOCK  commands  and  indicates an illegal
    track and/or sector request."
"In the context of the C64, What is the purpose of the BLOCK-WRITE command in DOS?","1581 disk:  BLOCK-WRITE

The  purpose  of  a BLOCK-WRITE is to save the contents of a file
buffer  into  a  specified sector.  It is thus the reverse of the
BLOCK-READ  command.  Although  the  BLOCK-WRITE command (B-W) is
still  part of the DOS command set,  it is nearly always replaced
by the U2 command.

FORMAT FOR THE BLOCK-WRITE COMMAND:

  PRINT#15,'U2';channel#;drive#;track#;sector#

where  'channel#'  is the channel number specified  when the file
into  which  the  block will be read was opened;  'drive#' is the
drive number;  and  'track#'  and  'sector#' are respectively the
track  and  sector  numbers that should receive the block of data
being saved from the file buffer.

ALTERNATE FORMATS:

  PRINT#15,'U2:'channel#;drive#;track#;sector#
  PRINT#15,'UB:'channel#;drive#;track#;sector#
  PRINT#15,'U2:channel#,drive#,track#,sector#'

EXAMPLES:

  To restore  Track 40,  Sector 3  of the directory from the disk
buffer filled by a BLOCK-READ, use:

  PRINT#15,'U2';5;0;40;3

You'll return to this example on the next page,  after  you learn
to alter the directory in a useful way.
  You  can  also  use  a  BLOCK-WRITE to write a name in Track 1,
Sector 1,  a  rarely-used  sector.  This  can be used as a way of
marking a diskette  as belonging to you.  Here is a program to do
it, using the alternate form of the BLOCK-WRITE command:

  110 INPUT'YOUR NAME';NA$            Enter a name.
  120 OPEN 15,8,15                    Open command channel.
  130 OPEN 4,8,4,'#'                  Open direct access channel.
  140 PRINT#4,NA$                     Write name to buffer.
  150 PRINT#15,'U2';4;0;1;1           Write buffer to Track1,
  160 CLOSE 4                         Sector 1 of diskette.
  170 CLOSE 15                        Tidy up after.
  180 END

As with the  BLOCK-READ command,  there is a  BLOCK-WRITE command
identical in function to  'U2'  that does not check the track and
sector parameters for valid bounds before attempting to write the
sector. Its format is:

  PRINT#15,'B-o';channel#;drive#;track#;sector#
  (The character after the B- is a shifted W.)

                       or

  PRINT#15,'B-';CHR$(215);channel#;drive#;track#;sector#"
"In the context of the C64, What are the USER commands available on the 1581 disk and what are their functions?","1581 disk:  USER COMMANDS

  Most  USER commands are intended to be used as machine language
JMP  or  BASIC  SYS  commands  to  machine language programs that
reside inside the disk memory.  However,  some of them have other
uses  as  well.  The USER1 and USER2 commands are used to replace
the  BLOCK-READ  and BLOCK- WRITE commands, UI re-starts the 1581
without  changing many variables,  UJ cold-starts the 1581 almost
as if it had been turned off and on again.

USER Command                       Function
-----------------------------------------------------------------
U0                     restores default user jump table
U0 + (CMD)             burst utility command
                       (see Chapter 9 Burst Commands)
U1 or UA               block read replacement
U2 or UB               block write replacement
U3 or UC               jump to $0500
U4 or UD               jump to $0503
U5 or UE               jump to $0506
U6 or UF               jump to $0509
U7 or UG               jump to $050C
U8 or UH               jump to $050F
U9 or UI               jump to ($FFFA) reset tables
U: or UJ               power up vector
-----------------------------------------------------------------

  By loading these memory locations with another machine language
JMP  command,  such as JMP $0520,  you can create longer routines
that  operate in the disk's memory along with an easy-to-use jump
table.

FORMAT FOR USER COMMANDS:

  PRINT#15,'Ucharacter';

where  'character' defines one of the preset user commands listed
above.

EXAMPLES:

  PRINT#15,'U:';             Form of DOS RESET command
  PRINT#15,'U3';             Execute program at start of buffer 2"
"In the context of the C64, What error message is displayed when a diskette or its directory is full and what actions can be taken to resolve the issue?","1581 disk: Controller commands error code 72: DISK FULL
    Either  the  diskette or its directory is full.  DISK FULL is
    sent  when  two  blocks  are  still  available,  allowing the
    current  file  to be closed.  If you get this message and the
    directory  shows any blocks left,  you have too many separate
    files  in  your  directory,  and  will  need to combine some,
    delete any that are no longer needed, or copy some to another
    diskette.

7"
"In the context of the C64, What is the purpose of the COLLECT command in BASIC 7.0?","1581 disk with basic 7,0: COLLECT

  The  COLLECT  command  recalculates  the Block Availability Map
(BAM)  of  the  current  diskette,  allocating only those sectors
still  being  used by valid,  properly closed files and programs.
All other sectors  (blocks) are left unallocated and free for re-
use, and all improperly closed files are automatically scratched.
However,  this  brief  description  of  COLLECT  doesn't indicate
either  the  power or the danger of the command.  Its power is in
restoring  to  good  health  many  diskettes whose directories or
Block Availability Maps have become muddled.  Any time the blocks
used  by  the  files  on a diskette plus the blocks shown as free
don't  add  up to the 3160 available on a fresh diskette, COLLECT
is  needed  (with  one  exception below).  Similarly,  any time a
diskette   contains  an  improperly  closed  file  (splat  file),
indicated  by  an  asterisk  (*)  next  to  its  file type in the
directory, that diskette needs to be collected.  In fact, but for
the one exception below,  it  is a good idea to COLLECT diskettes
whenever  you are concerned about their integrity.  Just note the
number  of  blocks  free  in  the diskette's directory before and
after  using  COLLECT.  If the totals differ,  there was indeed a
problem,  and the diskette should probably be copied onto a fresh
diskette  file-by-file,  using  a  copy  program described in the
previous section, rather than using backup program.
  The  exception  is diskettes containing direct access files, as
described in Chapter 6.  Most direct access (random) files do not
allocate  their  sectors  in a way COLLECT command can recognize.
Thus,  collecting  such a diskette may result in unallocating all
direct access files,  with  loss of all their contents when other
files are added.  Unless specifically instructed otherwise, never
COLLECT  a  diskette containing direct access files. (Note: these
are  not  the  same as the relative files described in Chapter 5.
COLLECT may be used on relative files without difficulty.)

FORMAT FOR THE COLLECT COMMAND:

  COLLECT [,Ddrive#][,Udevice#]"
"In the context of the C64, What is the cause and solution of the FILE DATA ERROR"" in BASIC programming?""","1581 disk with basic 7,0: 'FILE DATA' ERROR

  The  other  error  message   'FILE DATA ERROR'   is  caused  by
attempting  to  read  a  non-numeric  character  into  a  numeric
variable.  To a computer, a number is the characters 0 through 9,
the  '+'  and  '-'  signs,  the  decimal  point  (.),  the  SPACE
character, and the letter 'E' used in scientific notation. If any
other character appears in an INPUT# to a numeric variable, 'FILE
DATA ERROR'  will  be  displayed  and the program will halt.  The
usual  causes  of  this error are a mismatch between the order in
which variables are written to  and  read from a file,  a missing
carriage return within a  PRINT#  statement that writes more than
one data item,  or a data item  that includes either a comma or a
colon without a preceding quotation mark.  Once a file data error
has occurred, you should correct it by reading the data item into
a  string  variable,  and converting it back to a number with the
BASIC VAL() statement  after removing non-numeric characters with
the string functions described in your computer user's manual."
"In the context of the C64, What are the special pattern-matching characters used to load a program from a partial name or to provide selective directories, and how do they work?","1581 disk: PATTERN MATCHING

  You  can  use  special  pattern-matching  characters  to load a
program   from  a  partial  name  or  to  provide  the  selective
directories described earlier.
  The  two  characters  used in pattern matching are the asterisk
(*)  and  the question mark  (?).  They act something like a wild
card in a game of cards.  The difference between the two  is that
the  asterisk  makes  all  characters in  and beyond its position
wild,  while  the question mark makes only its own position wild.
Here are some examples and their results:

  LOAD'A*',8  loads the first file on disk that begins with an A,
  regardless of what follows

  DLOAD'SM?TH'  loads  the  first  file that starts with SM, ends
  with TH, and one other character between

  DIRECTORY'Q*'  loads  a  directory  of  files whose names begin
  with Q

  LOAD'*',8  is a special case. When an asterisk is used alone as
  a name,  it matches the last file used  (on the C64 and C128 in
  C64 mode).

  LOAD '0:*',8 loads the first file on the diskette (C64 and C128
  in C64 mode).

  DLOAD'*'  loads the first file on the diskette (Plus/4 and C128
  in C128 mode)."
"In the context of the C64, What is the reason behind the 'STRING TOO LONG' error in Commodore's BASIC 7.0 when reading data from a disk file?","1581 disk with basic 7,0: 'STRING TOO LONG' ERROR

  A BASIC string may be up to 255 characters long,  although  the
longest string you can enter via a single INPUT statement is just
under two lines of text. This lower limitation is due to the size
of the input buffer in Commodore's serial bus computers. The same
limit  applies  to  INPUT#  statements.  If a single data element
(string  or  number)  being  read from a disk file into an INPUT#
statement  contains  more  than  88  (BASIC 2)  and 160 (BASIC 7)
characters, BASIC will halt with a 'STRING TOO LONG ERROR'."
"In the context of the C64, What are the steps to print a directory in Commodore 64 BASIC?","1581 disk: PRINTING A DIRECTORY

  To printout a directory, use the following:

  LOAD'$',8
  OPEN 4,4:CMD 4:LIST
  PRINT#4:CLOSE 4"
"In the context of the C64, How do you handle renaming and deleting files with troublesome filenames, such as those containing commas, shifted spaces, or non-printing characters, in BASIC 7.0?","1581 disk with basic 7,0: RENAMING AND SCRATCHING TROUBLESOME FILES

  Eventually,  you  may  run  across  a  file  which  has a crazy
filename,  such as a comma by itself (',') or one that includes a
Shifted  Space.  Or  perhaps you will find one that includes non-
printing  characters.  Any  of  these  can be troublesome.  Comma
files,  for  instance,  are  an exception to the rule that no two
files can have the same name.  Since  it shouldn't be possible to
make  a  file whose name is only a comma,  the disk never expects
you to do it again.
  Files  with  a   Shifted  Space  in  their  name  can  also  be
troublesome,  because  the  disk  interprets the Shifted Space as
signaling  the end of the file name,  and prints whatever follows
after  the  quotation  mark  that  marks the end of a name in the
directory.  This  technique can be useful by allowing you to have
a long file name,  and  making the disk recognize a small part of
it  as  being  the same as the whole thing without using pattern-
matching characters.
  In any case,  if  you have a troublesome filename,  you can use
the  CHR$()  function  to  specify troublesome characters without
typing  them  directly.  This  may allow you to build them into a
RENAME  command.  If  this  fails,  you may also use the pattern-
matching characters  discussed for a SCRATCH command.  This gives
you  a  way  to  specify  the  name without using the troublesome
characters at all, but also means loss of your file.
  For  example,  if  you  have  managed  to  create  a file named
''MOVIES',  with an extra quotation mark at the front of the file
name,  you can rename it to  'MOVIES' using the CHR$() equivalent
of a quotation mark in the RENAME command:

  RENAME (CHR$(34)+'MOVIES') TO 'MOVIES'

The  CHR$(34)  forces  a  quotation  mark into the command string
without  upsetting  BASIC.  The  procedure  for  a file name that
includes a Shifted Space is similar, but uses CHR$(160).
  In cases  where even this doesn't work,  for  example,  if your
diskette contains a comma file,  (one named ',')  you can get rid
of it this way:

  SCRATCH '?'

  This example deletes all files with one-character names.

  Depending  on  the  exact  problem,  you  may  have  to be very
creative in choosing pattern-matching characters that will affect
only  the desired file,  and may have to rename other files first
to keep them from being scratched.
  In  some  cases,  it  may  be easier to copy desired files to a
different diskette and leave the troublesome files behind."
"In the context of the C64, What error message is displayed when the Block Availability Map (BAM) on a diskette does not match the copy in disk memory?","1581 disk: Controller commands error code 71: DIRECTORY ERROR
    The  BAM  (Block  Availability  Map) on the diskette does not
    match  the  copy in disk memory.  To correct,  Initialize the
    diskette."
"In the context of the C64, What is the format and requirements for using the UTILITY LOADER command to load a user-type file into drive RAM?","1581 disk:  UTILITY LOADER

  This command loads a user-type  (USR)  file into the drive RAM.
The  first  two  bytes  of the file must contain the low and high
addresses   respectively.   The  third  byte  is  the  amount  of
characters to follow.  In the addition,  a trailing checksum byte
must be included. The load address is the starting address.

FORMAT FOR THE UTILITY LOADER COMMAND:

  PRINT#15,'&0:filename'

  To return from this routine,  the  program  should  end with an
RTS."
"In the context of the C64, What are the original block-read and block-write commands, their formats, and how do they differ from the U1 and U2 commands?","1581 disk:  THE ORIGINAL BLOCK-READ AND BLOCK-WRITE COMMANDS

  Although  the  BLOCK-READ  and  BLOCK-WRITE commands are nearly
always  replaced  by  the  U1  and  U2 commands respectively, the
original  commands  can  still  be  used,  as  long  as you fully
understand their effects. Unlike U1 and U2, B-R and B-W allow you
to read or write less than a full sector. In the case of B-R, the
first  byte  of  the  selected  sector  is used to set the buffer
pointer (see next section), and determines how many bytes of that
sector are read into a disk memory buffer. A program may check to
be sure it  doesn't attempt to read past the end of data actually
loaded  into  the  buffer,  by watching for the value of the file
status  variable  ST  to change from 0 to 64.  When the buffer is
written  back  to diskette by B-W,  the first byte written is the
current  value  of  the buffer pointer.  Only that many bytes are
written into the specified sector. B-R and B-W may thus be useful
in working with custom-designed file structures.

FORMAT FOR THE ORIGINAL BLOCK-READ AND BLOCK-WRITE COMMANDS:

  PRINT#15,'BLOCK-READ';channel#;drive#;track#;sector#

abbreviated as: PRINT#15,'B-R';channel#;drive#;track#;sector#

and

  PRINT#15,'BLOCK-WRITE';channel#;drive#;track#;sector#

abbreviated as: PRINT#15,'B-W';channel#;drive#;track#;sector#

where  'channel#'  is  the channel number specified when the file
into  which  the  block will be read was opened,  'drive#' is the
drive number, and 'track#' and 'sector#' are the track and sector
numbers containing the desired block of data to be partially read
into or written from the file buffer.


|   In a true BLOCK-READ, the first byte of the selected sector |
| is  used  to  determine how many bytes of that sector to read |
| into the disk  memory buffer.  It thus cannot be used to read |
| an entire sector  into the buffer,  as the first data byte is |
| always  interpreted  as  being  number of characters to read, |
| rather than part of the data.                                 |
|   Similarly,  in  a  true  BLOCK-WRITE,  when  the  buffer is |
| written  back  to  diskette,  the  first  byte written is the |
| current value of the  buffer  pointer.  Only  that many bytes |
| are written into the specified  sector.  It cannot be used to |
| rewrite an entire sector onto diskette unchanged, because the |
| first data byte is overwritten by the buffer pointer.         |"
"In the context of the C64, What is the error message indicating a CRC error in a data block on a disk?","1581 disk: Controller commands error code 23: READ ERROR (CRC error in data block)
    There is an error in the data.  The sector has been read into
    disk memory, but its CRC is wrong."
"In the context of the C64, What is the function of the TPREAD_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: TPREAD_DV
     $B2     Reads    a    physical    address   without
                      transferring to the job queue buffer."
"In the context of the C64, What are the rules and procedures for creating and managing partitions and sub-directories on a 1581 disk?","1581 disk:  PARTITIONS AND SUB-DIRECTORIES

  The 1581 allows the user to create partition areas on the disk.
Partitions were originally implemented to provide a mechanism for
easily  protecting  a  particular  section  of  the disk. That is
useful  for  permanently  allocating  part of the disk for things
such as BOOT sectors, CP/M work area, or reserving space for user
defined random files.
  Normally,  sectors on the disk can be marked as used by setting
the appropriate bit in the RAM  (most easily done with the BLOCK-
ALLOCATE  command).  That prevents them from being overwritten. A
VALIDATE command, however, will de-allocate this area. To protect
these  special  blocks from being de-allocated during a VALIDATE,
place them in a user defined partition area. The VALIDATE command
in  the  1581  automatically  skips  over  file  entries that are
partition files (file type = CBM),  which guarantees the intended
area is, and remains, allocated.
  Partition areas are given names by the user when first created.
They appear in the main directory as file type CBM.
  A partition area is created by the following command:

  PRINT#15,'/0:partition name,'+CHR$(starting track)+CHR$
  (starting sector)+CHR$(<# of sectors)+CHR$(># of sectors)+',C'

  Large  enough  partitions  can also be used as sub-directories.
There are, however, certain limitations if a partition area is to
be used as a sub-directory area.

  1) The partition are must be at least 120 sectors in size.
  2) The starting sector must be 0.
  3) The ending sector must be a multiple of 40.
  4) The area to be allocated cannot contain track 40 (the
     original system track).

  Partitions  can  also  be  created with a partition. This means
that  sub-sub-directories can be created if their partitions meet
the above rules. 

  Partition  areas  which meet the qualifications of being a sub-
directory can then be selected by the following command:

  PRINT#15,'/0:partition name'

  Once  selected,  the  partition  are  cannot  be used as a sub-
directory until it is formatted.  The  HEADER or NEW commands are
used  to  format  this  sub-disk  area.  Make  sure that you have
successfully  selected  this partition area before formatting. If
not, the wrong directory area will be reformatted.  You can check
if  the  area  was  successfully  selected  by checking the error
channel. If everything went OK, the error channel would read:

  02, SELECTED PARTITION,first track#,last track#

  If   the   area  you  attempt  to  select  does  not  meet  the
qualifications of a sub-directory,  then  the error channel would
return:

  77, SELECTED PARTITION ILLEGAL,00,00

  Only  one  level of sub-directory can be selected at a time. To
get from the ROOT to PART21 you would have to execute the command
twice.

  PRINT#15,'/0:PART2'
  PRINT#15,'/0:PART21'

  Directories  can only be traversed in the forward direction. To
get  to  sub-directory  which  is  on  a node above the presently
selected node of the tree, you must select the ROOT directory and
work your way down the tree, selecting a branch at a time. To get
to the ROOT directory directly from any node type:

  PRINT#15,'/'

  When the user selects a particular sub-directory area,  it then
becomes  the  default  working  area.  Accesses  to  the disk for
directories, loading files, saving files, etc.,  will all be done
within  this  area.  Files  outside  of  the  selected  area  are
effectively invisible.
  File  and  local BAM information for sub-directories are stored
within  the  sub-directory  areas themselves.  The information is
stored  on  the  first allocated track of the partition area, and
has the same format as track 40.  When  creating  partitions  and
sub-directories  within  sub-directories it is the responsibility
of  the  user  to  make  sure  that  he  doesn't  overwrite  this
information!  The  DOS  only  checks  to make sure that you don't
attempt  to  overwrite  this  information  for the ROOT directory
(track 40).  It  is  up  to  the  user  to  make  sure  that this
information isn't corrupted in the sub-directories.
  Partitioned  areas  can  be freed up  simply by  SCRATCHING the
partition  file  entry  in  the  appropriate  directory.  If  the
partition was being used as a sub-directory,  all of the files in
that sub-directory will be lost."
"In the context of the C64, What is the purpose and syntax of the MEMORY-WRITE command in the context of the 1581 disk drive?","1581 disk:  MEMORY-WRITE

  The  MEMORY-WRITE  command is the equivalent of the  BASIC POKE
command,  but has its effect in disk memory instead of within the
computer.  M-W  allows you to write up to 35 bytes at a time into
disk  memory.  The  MEMORY-EXECUTE  and some USER commands can be
used to run any programs written this way:

FORMAT FOR THE MEMORY-WRITE COMMAND:

  PRINT#15,'M-W'CHR$(<address)CHR$(>address)CHR$(# of bytes)
           CHR$(data byte(s))

where  '<address'  is the low order part,  and  '>address' is the
high order part of the address  in disk memory  to begin writing,
'# of bytes'  is  the  number  of  memory  locations that will be
written (from 1-35),  and 'data byte' is 1 or more byte values to
be written into disk memory, each as a CHR$() value.

EXAMPLES:

We  can  use  this line to turn off the 'bumps' when loading DOS-
protected  programs  (i.e.,  programs  that  have  been protected
against  being  copied by creating and checking for specific disk
errors).

  PRINT#15,'M-W'CHR$(48)CHR$(0)CHR$(1)CHR$(133)

  The following line can be used to recover bad sectors,  such as
when  an  important  file  has  been  damaged  and cannot be read
normally:

  PRINT#15,'M-W'CHR$(48)CHR$(0)CHR$(1)CHR$(31)

  These two examples may be very useful under some circumstances.
They   are   the   equivalent   of   POKE 48,133  and  POKE 48,31
respectively,  but  in  disk memory,  not inside the computer. As
mentioned in the previous section's first example, location 48 in
the  1581  disk  drive  signifies  two separate activities to the
drive,  all related to error recovery.  Bit 7  (the high bit), if
set means no  'bumps'  (don't move the read head to track 1). The
bottom six bits are the count of how many times the disk will try
to  read  each  sector  before  and  after trying seeks and bumps
before  giving  up.  Since  31  is the largest number that can be
expressed  in  six  bits,  that  is  the  maximum number of tries
allowed.
  From this example,  you  can see the value of knowing something
about  PEEKS,  POKES,  and  machine-language before using direct-
access disk commands, as well as their potential power."
"In the context of the C64, What are the return codes and their descriptions for a disk controller job?","1581 disk:  Controller JOB Return Codes

Name            Code  Description
OK_DV            $0x  No error.
MISHD_DV_ER      $02  Can't find header block.
NOADAM_DV_ER     $03  No address mark detected.
MISDBLK_DV_ER    $04  Data block not present.
CRCDBLK_DV_ER    $05  CRC error encountered in data block.
FMT_DV_ER        $06  Format error.
VERERR_DV_ER     $07  Verify error.
WRTPR_DV_ER      $08  Attempt to write to a write protected disk.
CRCHD_DV_ER      $09  CRC error encountered in header block.
                 $0A  Reserved.
DSKCHG_DV_W      $0B  Disk was changed/disk ID mismatch.
DSKNTLOG_DV_ER   $0C  Disk format not logical.
CONTROLLER_DV_ER $0D  Floppy disk controller IC error.
SYNTAX_DV_ER     $0E  Syntax error. Invalid job number.
NODSKPRS_DV_ER   $0F  No disk is present in the drive."
"In the context of the C64, What is the meaning of the PARTITION SELECTED"" error code returned by a disk controller command?""","1581 disk: Controller commands error code PARTITION SELECTED (not an error)
    The disk partition requested has been selected."
"In the context of the C64, What is a sequential data file and how does it work on a diskette?","1581 disk with basic 7,0: SEQUENTIAL DATA FILES


  A file on a diskette is just like a file cabinet in your office
-- an organized place to put things. Nearly everything you put on
a diskette goes in one kind of file or another. So far all you've
used are program files,  but there are others.  In  this  chapter
you'll learn about sequential data files.
  The primary purpose of a data file  is to store the contents of
program variables, so they won't be lost when the program ends. A
sequential  data  file  is  one  in  which  the  contents  of the
variables are stored 'in sequence',  one right after another. You
may  already  be  familiar  with  sequential  files  from using a
DATASSETTE,  because  sequential  files on diskette are just like
the  data  files  used  on  cassettes.  Whether  on  cassette  or
diskette, sequential files must be read from beginning to end.
  When  sequential  files  are  created,  information  (data)  is
transferred  byte-by-byte,  through  a buffer,  onto the magnetic
media.  Once  in  the disk drive, program files,  sequential data
files,  and user files all work sequentially.  Even the directory
acts like a sequential file.
  To use sequential files properly, we will learn some more BASIC
words  in  the next few pages.  Then we'll put them together in a
simple but useful program.


|   Besides  sequential  data  files,  two other file types are |
| recorded sequentially on a diskette.  They are program files, |
| and user files.  When you save a program on a diskette, it is |
| saved  in  order  from  beginning  to  end,   just  like  the |
| information in a sequential data file. The main difference is |
| in the commands you use to access it.  User files can be even |
| more similar to sequential data files.  User files are almost |
| never used,  but like program files, they could be treated as |
| though  they  were  sequential  data  files  and  some can be |
| accessed with the same commands.                              |
|   For the advanced user,  the similarity  of the various file |
| types  offers  the possibility of reading a program file into |
| the computer a byte (character) at a time and rewriting it to |
| the diskette in a modified form.                              |"
"In the context of the C64, What are the key features and capabilities of the Commodore 1581 disk drive?","The  Commodore 1581  is a versatile 3.5' disk drive that can be
used with a variety of computers,  including  the  COMMODORE 128,
the COMMODORE 64, the Plus 4, COMMODORE 16, and VIC 20.
  Also,  in  addition to the convenience of 3.5' disks,  the 1581
offers the following features:

  o Standard  and  fast  serial data transfer rates  --  The 1581
    automatically selects the proper data transfer rate  (fast or
    slow) to match the operating modes available on the Commodore
    128 computer.

  o Double-sided, double-density MFM data recording  --  Provides
    more than 800K formatted storage capacity per disk (400K+ per
    side).

  o Special high-speed burst commands -- These commands, used for
    machine language programs, transfer data several times faster
    than the standard or fast serial rates."
"In the context of the C64, What is the syntax and usage of the CLOSE statement in BASIC 2.0 and BASIC 7.0, and how can you close all open files at once?","1581 disk with basic 7,0: FORMAT FOR THE CLOSE STATEMENT:

  BASIC 7.0:  DCLOSE#file#[,Udevice#]
  BASIC 2.0:  CLOSE file#

where 'file#' is the same file number given in the desired file's
current OPEN statement.

EXAMPLES:

  To  close  the  data file #5 used as an example on the previous
page, use:

  BASIC 7.0:  DCLOSE#5
  BASIC 2.0:  CLOSE 5

  In BASIC 7.0,  when the DCLOSE statement is used alone (no # or
file# parameters),  it closes all disk files at once.  With a bit
of planning, the same can be done via a program loop. Since there
is no harm in closing a file  that wasn't open,  close every file
you  even  think  might  be  open before ending a program. If you
always gave your files numbers  between 1 and 5,  you could close
them all with

  9950 FOR I=1 TO 5
  9960 CLOSE I
  9970 GOSUB 59990: REM CHECK FOR DISK ERRORS
  9980 NEXT I

assuming your program includes an error check subroutine like the
one in the last chapter."
"In the context of the C64, What is the error message displayed when a disk controller encounters a format error?",1581 disk: Controller commands error code 75: FORMAT ERROR
"In the context of the C64, What error message would indicate a problem with the floppy disk controller IC (WD177x)?","1581 disk: Controller commands error code 76: CONTROLLER ERROR
    The  floppy  disk controller  IC (WD177x)  is not functioning
    properly."
"In the context of the C64, What is the command to format a new diskette on a Commodore computer?","HOW TO PREPARE A NEW DISKETTE

  A diskette needs a pattern of circular magnetic tracks in order
for  the  drive's  read/write  head  to  find  things on it. This
pattern is not on your diskettes  when you buy them,  but you can
use  the  HEADER  command  or  the  NEW  command  to  add it to a
diskette.  That  is  known  as  formatting the disk.  This is the
command to use with the C128 in C128 mode or Plus/4:

  HEADER 'diskette name',Iid,Ddrive#[,Udevice#]

where 'diskette name' is any desired name for the diskette, up to
16  characters  long  (including spaces).  'id'  can  be  any two
characters as long as they don't form a BASIC keyword (such as IF
or  ON)  either  on  their own or with the capital I before them.
'drive#' is 0.  'device#' is 8, unless you have changed it as per
instructions in Appendix A  (the 1581 assumes 8 even if you don't
type it in).

  The command for the C64, VIC 20, or C128 in C64 mode is this:

  OPEN 15,device#,15,'NEWdrive#:diskette name,id'
  CLOSE 15

  The  device#,  drive#,  diskette  name,  and id are the same as
described above."
"In the context of the C64, How does the INPUT# statement in BASIC differ from the INPUT statement, and what are some limitations of using INPUT# to read data from a file?","1581 disk with basic 7,0: READING FILE DATA: USING INPUT#

  Once  information has been written properly to a diskette file,
it  may  be read back into the computer with an INPUT# statement.
Just  as  the  PRINT# statement is much like the PRINT statement,
INPUT#  is  nearly  identical to  INPUT,  except that the list of
items  following  the  command  word comes from a particular file
instead of the keyboard.  Both statements are subject to the same
limitations-halting  input after a comma or colon,  not accepting
data  items  too  large  to  fit in BASIC's input buffer, and not
accepting non-numeric data into a numeric variable."
"In the context of the C64, What is the purpose of the OPEN statement in Commodore BASIC and how does it interact with various devices in a Commodore computer system?","1581 disk with basic 7,0:  OPENING A FILE

  One  of  the most powerful tools in Commodore BASIC is the OPEN
statement.  With it, you may send data almost anywhere, much like
a telephone switchboard.  As you might expect, a command that can
do  this  much  is  fairly  complex.  You  have already used OPEN
statements regularly in some of your diskette commands.
  Before you study the format of the OPEN statement, let's review
some of the possible devices in a Commodore computer system.

Device#:  Name:   Used for:
-----------------------------------------------------------------
0     Keyboard    Receiving input from the computer operator
1     DATASSETTE  Sending and receiving information from cassette
2     RS232       Sending and receiving information from a modem
3     Screen      Sending output to a video display
4,5   Printer     Sending output to a hard copy printer
8-11  Disk Drive  Sending and receiving information from diskette
-----------------------------------------------------------------

  Because of the flexibility of the OPEN statement it is possible
for  a  single  program  statement  to  contact  any one of these
devices,  or  even  others,  depending  on  the value of a single
character in the command. If the character is kept in a variable,
the  device can even change each time that part of the program is
used,  sending  data alternately and with equal ease to diskette,
cassette, printer and screen.


|   In  the  last  chapter  you  learned  how to check for disk |
| errors  after  disk  commands  in  a  program.  It is equally |
| important  to check for disk errors after using file-handling |
| statements.  Failure  to  detect  a  disk  error before using |
| another file-handling statement could cause loss of data, and |
| failure of the BASIC program.                                 |
|   The  easiest  way  to check the disk is to follow all file- |
| handling statements with a GOSUB statement  to an error check |
| subroutine.                                                   |
|                                                               |
| EXAMPLE:                                                      |
|                                                               |
|   BASIC 7.0:  840 DOPEN#4,'DEGREE DAY DATA',D0,U8,W           |
|               850 GOSUB 59990: REM CHECK FOR DISK ERRORS      |
|                                                               |
|   BASIC 2.0:  840 OPEN 4,8,4,'0:DEGREE DAY DATA,S,W'          |
|               850 GOSUB 59990: REM CHECK FOR DISK ERRORS      |
|                                                               |
+---------------------------------------------------------------+"
"In the context of the C64, What message appears when the error channel is checked after using the SCRATCH command?","1581 disk: Controller commands error code FILES SCRATCHED

    This  is  the  message that appears when the error channel is
    checked  after  using  the SCRATCH command.  The track number
    tells how many files were erased."
"In the context of the C64, What is the function of the FORMATDK_DV command in a disk controller job?","1581 disk Controller Job commands: FORMATDK_DV
   $F0     Formats  the disk with the default physical
                      format."
"In the context of the C64, What is the format of the MEMORY-READ command in Commodore disk commands?","1581 disk: FORMAT FOR THE MEMORY-READ COMMAND:

  PRINT#15,'M-R'CHR$(<address)CHR$(>address)CHR$(# of bytes)

where  '<address'  is the low order part,  and  '>address' is the
high order part of the address in disk memory to be read.  If the
optional  '# of bytes'  is specified,  it selects how many memory
locations will be read in,  from 1-256  (# of bytes = 0 for 256).
Otherwise, 1 character will be read.

  The next byte read using the GET# statement through channel #15
(the  error  channel),  will  be  from  that  address in the disk
controller's memory, and successive bytes will be from successive
memory locations.
  Any  INPUT#  from  the error channel will give peculiar results
when you're using this command. This can be cleared up by sending
any other command to the disk, except another memory command.

EXAMPLES:

  To  see  how many tries the disk will make to read a particular
sector,  and  whether  'bumps'  to  track  one  and  back will be
attempted before declaring the sector unreadable, you can use the
following  lines.  They  will read a special variable in the zero
page  of  disk  memory,  called  REVCNT.  It  is  located  at $30
hexadecimal.

110 OPEN 15,8,15                            Open command channel.
120 PRINT#15,'M-R'CHR$(48)CHR$(0)           Same as G=PEEK(48).
130 GET#15,G$: IF G$='' THEN G$=CHR$(0)
140 G=ASC(G$)
150 B=G AND 128:B$='ON':IF B THEN B$='OFF'  Check bit 7.
160 T=G AND 31: PRINT'# OF TRIES IS';T      Check bits 0-5
170 PRINT 'BUMPS ARE';B$                    and give results.
180 CLOSE 15                                Tidy up after.
190 END

Here's  a  more  general  purpose  program that reads one or more
locations anywhere in disk memory:

110 OPEN 15,8,15                            Open command channel.
120 INPUT '# OF BYTES TO READ (0=END)';NL   Enter number of bytes
                                            wanted
130 IF NL<1 THEN CLOSE 15: END              unless done.
140 IF NL>255 THEN 120                      or way out of line.
150 INPUT 'STARTING AT ADDRESS';AD          Enter starting
                                            address.
160 AH=INT(AD/256): AL=AD-AH*256            Convert it into disk
                                            form.
170 PRINT#15,'M-R'CHR$(AL)CHR$(AH)CHR$(NL)  Actual Memory-Read.
180 FOR I=1 TO NL                           Loop until have all
                                            the data,
190 GET#15,A$: IF A$='' THEN A$=CHR$(0)
200 PRINT ASC(A$);                          printing it as we go,
210 NEXT I
220 PRINT
230 GOTO 120                                forever."
"In the context of the C64, What is the command to free a block of data on a disk in DOS, and what is its format?","1581 disk:  FREEING BLOCKS

  The  BLOCK-FREE  command is the opposite of  BLOCK-ALLOCATE. It
frees  a  block  that you don't need any more,  for re-use by the
DOS.  BLOCK-FREE  updates  the BAM to show a particular sector is
not in use, rather than actually erasing any data.

FORMAT FOR BLOCK-FREE COMMAND:

  PRINT#15,'BLOCK-FREE';drive#;track#;sector#

abbreviated as: PRINT#15,'B-F';drive#;track#;sector#

where  'drive#' is the drive number,  and  'track#' and 'sector#'
are  respectively  the  track  and  sector numbers containing the
desired block of data to be read into the file buffer.

ALTERNATE FORMAT:

  PRINT#15,'B-F:';drive#;track#;sector#

EXAMPLE:

  To  free  the  sector  in which we wrote our name in the BLOCK-
WRITE example, and allocated in the first BLOCK-ALLOCATE example,
we could use the following command:

  PRINT#15,'B-F';0;1;1"
"In the context of the C64, What is the command and format to execute a machine language program or subroutine stored in disk memory on a 1581 disk?","1581 disk:  MEMORY-EXECUTE

  Any routine in disk memory,  either  in  RAM  or  ROM,  can  be
executed with the MEMORY-EXECUTE command. It is the equivalent of
the  BASIC  SYS call to a machine language program or subroutine,
but works in disk memory instead of within the computer.

FORMAT FOR THE MEMORY-EXECUTE COMMAND:

  PRINT#15,'M-E'CHR$(<address)CHR$(>address)

where  '<address'  is the low order part,  and  '>address' is the
high order part of the address in disk memory  at which execution
is to begin.

  Most  uses  require intimate knowledge of the inner workings of
the  DOS,  and  preliminary  setup  with other commands,  such as
MEMORY-WRITE.

  The  routine  should  end  with an RTS to return control to the
1581."
"In the context of the C64, What does error code 67 on a disk controller indicate?","1581 disk: Controller commands error code 67: ILLEGAL SYSTEM T OR S
    This special error message indicates an illegal system  track
    or sector."
"In the context of the C64, How does a file-handling program using random files keep track of which blocks on the disk have been used?","1581 disk:  USING RANDOM FILES

  By combining the commands in this chapter,  it  is  possible to
develop a file-handling program that uses random files.  What you
need to know now is how to keep track of which blocks on the disk
such a file has used. (Even though you know a sector has not been
allocated by your random file,  you  must  also be sure it wasn't
allocated by another unrelated file on the diskette.)
  The  most  common way of recording which sectors have been used
by  a  random  file is in a sequential file.  The sequential file
stores a list of record numbers, with the track, sector, and byte
location of each record.  This means three channels are needed by
a random file:  one  for the command channel,  one for the random
data, and the last for the sequential data."
"In the context of the C64, What is the format for temporarily changing the disk device number in Commodore computers?","1581 disk: FORMAT FOR TEMPORARILY CHANGING THE DISK DEVICE NUMBER:

  PRINT#15,'U0>'+CHR$(n)

  Where n = 8 to 30

EXAMPLE:

  Here is a program that sets any device number:

   5 INPUT 'OLD DEVICE NUMBER';ODV
  10 INPUT 'NEW DEVICE NUMBER';DV
  20 IF DV<8 OR DV>30 THEN 10
  30 OPEN 15,ODV,15,'U0>'+CHR$(DV): CLOSE 15

+---------------------------- NOTE -----------------------------+
|   If  you  will  be  using  two  disk  drives,  and  want  to |
| temporarily change the device number of one, you will need to |
| run the above program with the disk drive whose device number |
| not to be changed turned off. After the program has been run, |
| you may turn that drive back on.  If you need to connect more |
| than  two  drives at once,  you will need to use the hardware |
| method of changing device numbers.                            |
+---------------------------------------------------------------+"
"In the context of the C64, What is the function of the TPWRT_DV command in a disk controller job?","1581 disk Controller Job commands: TPWRT_DV
      $B4     Writes    a    physical   address   without
                      transferring from the job queue buffer."
"In the context of the C64, What is the importance of closing a file after using it ?","1581 disk with basic 7,0: CLOSING A FILE

  After you finish using a data file,  it  is extremely important
that you CLOSE it.  During the process of writing a file, data is
accumulated  in  a  memory  buffer,  and  only written out to the
diskette when the buffer fills.
  Working this way, there is almost always a small amount of data
in  the  buffer  that  has  not been written to diskette yet, and
which would simply be lost if the computer system were tuned off.
Similarly,  there  are  diskette  housekeeping  matters,  such as
updating the BAM  (Block Availability Map) of sectors used by the
current file,  which are not performed during the ordinary course
of  writing  a  file.  This  is  the  reason  for  having a CLOSE
statement.  When  you  are done with a file,  the CLOSE statement
will  write  the  rest of the data buffer out to diskette, update
the  BAM,  and complete the file's entry in the directory. Always
close  a  data file when you are done using it.  Failure to do so
may cause loss of the entire file.
  However,  do not close the disk command channel until all other
files  have been closed.  The command channel should be the first
file opened, and the last file closed in any program."
"In the context of the C64, How can you create a sub-directory that lists a single selected type of file using the LOAD or DIRECTORY command?","1581 disk: SELECTIVE DIRECTORIES

  By altering the directory  LOAD command,  you can create a sub-
directory that lists a single selected type of file. For example,
you  could  request  a list of all sequential data files (Chapter
4), or one of all the relative data files (Chapter 5). The format
for this command is:

  LOAD'$0:pattern=filetype',8    (for the C64)

where pattern specifies a particular group of files, and filetype
is  the  one-letter  abbreviation  for  the types of files listed
below:

  P = Program
  S = Sequential
  R = Relative
  U = User

The command for the C128 and Plus/4 is this:

  DIRECTORY'pattern=filetype'

Some examples:

  LOAD'$0:*=R',8  and  DIRECTORY'*=R' display all relative files.

  LOAD'$0:Z*=R',8  and  DIRECTORY'Z*=R'  display  a sub-directory
  consisting of all relative files  that start with the letter Z.
  (the asterisk (*) is explained in the Section 1.10.)"
"In the context of the C64, What is the syntax and usage of the DCLEAR command in a CP/M system?","1581 disk with basic 7,0:FORMAT FOR THE DCLEAR COMMAND:

  DCLEAR [Ddrive#]"
"In the context of the C64, What is the purpose of the BLOCK-READ command in DOS?","1581 disk:  BLOCK-READ

  The  purpose  of  a  BLOCK-READ  is  to  load the contents of a
specified  sector  into  a  file buffer.  Although the BLOCK-READ
command (B-R) is still part of the DOS command set,  it is nearly
always replaced the U1 command (See Chapter 6).

FORMAT FOR THE BLOCK-READ COMMAND:

  PRINT#15,'U1';channel#;drive#;track#;sector#

where  'channel#'  is  the channel number specified when the file
into  which  the  block will be read was opened,  'drive#' is the
drive number,  and  'track#'  and  'sector#' are respectively the
track  and sector numbers containing the desired block of data to
be read into the file buffer.

ALTERNATE FORMATS:

  PRINT#15,'U1:'channel#;drive#;track#;sector#
  PRINT#15,'UA:'channel#;drive#;track#;sector#
  PRINT#15,'U1:channel#,drive#,track#,sector#'

EXAMPLE:

  Here  is  a  complete program to read a sector into disk memory
using  U1,  and  from  there into computer memory via GET#. (If a
carriage  return will appear at least once in every 88 characters
of data, INPUT# may be used in place of GET#).

  110 MB=7936: REM $1F00            Define a memory buffer.
  120 INPUT'TRACK TO READ';T        Select a track
  130 INPUT'SECTOR TO READ';S       and sector.
  140 OPEN 15,8,15                  Open command channel.
  150 OPEN 5,8,5,'#'                Open direct access channel.
  160 PRINT#15,'U1';5;0;T;S         Read sector into disk buffer.
  170 FOR I=MB TO MB+255            Use a loop to
  180 GET#5,A$: IF A$=''            copy disk buffer
      THEN A$=CHR$(0)               into computer memory.
  190 POKE I,ASC(A$)
  200 NEXT
  210 CLOSE 5:CLOSE 15              Tidy up after.
  220 END

  As the loop progresses, the contents of the specified track and
sector are copied into computer memory,  beginning at the address
set by variable MB in line 160,  and  may be examined and altered
there.

  The  DOS  always checks that the track and sector parameters of
the  BLOCK-READ  command are within the proper range.  If they're
not,  a '66, ILLEGAL TRACK AND SECTOR'  error occurs.  In certain
instances it might be necessary to access a track and sector that
are not within what the DOS considers the proper bounds.  This is
a  special  case  and,  unless  absolutely  necessary,  should be
avoided. Nonetheless, there is a command identical in function to
'U1' that doesn't check to see if the track and sector parameters
are within bounds before attempting to read it. Its format is:

  PRINT#15,'B-_';channel#;drive#;track#;sector#
  (The character following the B- is a shifted R.)

                        or

  PRINT#15,'B-';CHR$(210);channel#;drive#;track#;sector#"
"In the context of the C64, What error message is displayed when trying to select a partition that does not meet the criteria of a directory partition?","1581 disk: Controller commands error code 77: SELECTED PARTITION ILLEGAL
    An attempt has been made to select a partition  that does not
    meet the criteria of a directory partition."
"In the context of the C64, What is the format for opening a direct access file on a 1581 disk, and how do you specify the memory buffer to use?","1581 disk:  OPENING A DATA CHANNEL FOR DIRECT ACCESS

  When  working  with  direct access data,  you need two channels
open to the disk:  the  command channel we've used throughout the
book,  and  another for data.  The command channel is opened with
the  usual  OPEN 15,8,15  or  equivalent.  A  direct  access data
channel  is  opened  much like other files,  except that the hash
sign (#),  optionally followed by a memory buffer number, is used
as a file name.

FORMAT FOR DIRECT ACCESS FILE OPEN STATEMENTS:

  OPEN file#,device#,channel#,'#buffer#'

where 'file#' is the file number,  'device#' is the disk's device
number,  normally  8;  'channel#' is the channel number, a number
between  2 and 14  not used by other files open at the same time;
and  'buffer#',  if present,  is a 0,  1,  2,  3,  4,  5,  or  6,
specifying  the  memory  buffer  within  the 1581 to use for this
file's data.

EXAMPLES:

To specify which disk buffer to use:

  OPEN 4,8,4,'#2'

If  you  don't  specify  which to use  (OPEN 5,8,5,'#'), the 1581
selects one."
"In the context of the C64, What is the purpose of the DCLEAR command on a Commodore 1581 disk drive?","1581 disk with basic 7,0: DCLEAR

  One command that should not often be needed on the 1581, but is
still of occasional value is DCLEAR.  On the 1581, and nearly all
other Commodore drives, this function is performed automatically,
whenever a new diskette is inserted.
  The result of an DCLEAR,  whether forced by a command,  or done
automatically  by  the  disk,  is  a  re-reading  of  the current
diskette's BAM  into a disk buffer.  This information must always
be  correct  in  order  for the disk to store new files properly.
However,  since the chore is handled automatically, the only time
you'd  need  to  use the command is if something happened to make
the information in the drive buffers unreliable."
"In the context of the C64, What is the syntax and usage of the PRINT# command in BASIC, and how is it used to write data to a sequential disk file?","1581 disk with basic 7,0:FORMAT FOR THE PRINT# COMMAND:

  PRINT#file#,data list

where 'file#' is the same file number given in the desired file's
current  OPEN statement.  During any given access of a particular
file, the file number must remain constant because it serves as a
shorthand  way  of relating all other file-handling commands back
to the correct OPEN statement.  Given a file number, the computer
can look up everything else about a file that matters.
  The 'data list' is the same as for a PRINT statement  -- a list
of  constants,  variables and/or expressions,  including numbers,
strings or both. However, it's better if each PRINT# statement to
disk  include  only  one  data item.  If you wish to include more
items,  they  should be separated by a carriage return character,
not  a comma.  Semicolons are permitted,  but not recorded in the
file, and do not result in any added spaces in the file. Use them
to  separate  items in the list that might otherwise be confused,
such  as  a  string  variable  immediately  following  a  numeric
variable.

|   Do  not  leave  a  space between PRINT  and  #,  and do not |
| abbreviate  the  command as ?#.  The correct abbreviation for |
| PRINT# is pR.                                                 |

EXAMPLES:

  To record a few grades for John Paul Jones,  using a sequential
disk file #1 previously opened for writing, use:

  200 FOR CLASS=1 TO COURSES
  210 PRINT#1,GRADE$(CLASS)
  220 GOSUB 59990: REM CHECK FOR DISK ERRORS
  230 NEXT CLASS

assuming your program includes an error check subroutine like the
one in the last chapter.
  In  using  PRINT#,  there is an exception to the requirement to
check  for  disk errors after every file-handling statement. When
using PRINT#, a single check after an entire set of data has been
written  will  still  detect  the error,  so long as the check is
made before any other file-handling statement  or disk command is
used.  You may be familiar with PRINT statements in which several
items follow each other:

  400 PRINT NAME$,STREET$,CITY$

To  get  those  same variables onto sequential disk file number 5
instead  of  the screen,  the best approach would be to use three
separate PRINT# statements, as follows:

  400 PRINT#5,NAME$
  410 PRINT#5,STREET$
  420 PRINT#5,CITY$

If you need to combine them, here is a safe way to do it:

  400 PRINT#5,NAME$;CHR$(13);STREET$;CHR$(13);CITY$

CHR$(13)  is  the  carriage  return  character,  and has the same
effect  as  putting  the print items in separate lines. If you do
this  often,  some  space  and  time  may  be saved by previously
defining a variable as equal to CHR$(13):

   10 CR$=CHR$(13)
  400 PRINT#5,NAME$;CR$;STREET$;CR$;CITY$

  The  basic idea is that a proper sequential disk-file write, if
redirected  to  the  screen,  will display only one data item per
line, with each succeeding item on the next line."
"In the context of the C64, What is a diskette directory and how is it viewed on a Commodore computer?","DISKETTE DIRECTORY

  A directory is a list of the files on a diskette.  To  view the
directory on the  C128 or Plus/4,  type the word  DIRECTORY  on a
blank line and press the  [RETURN]  key or simply press the  [F3]
key  on  the C128.  That doesn't erase anything in memory, so you
can  call up a directory anytime  --  even from within a program.
The C64 directory command, LOAD'$',8 (press [RETURN]) LIST (press
[RETURN]), does erase what's in memory.
  If a directory doesn't all fit on the screen, it will scroll up
until  it  reaches the last line.  If you want to pause, stop, or
slow  down  the  scrolling,  refer  to your particular computer's
user's manual for instructions as to which keys to use.
  To  get  an  idea  of  what  a  directory  looks like, load the
directory from the Test/Demo diskette.
  The 0 on the left-hand side of the top line is the drive number
of the 1581.  The diskette name is next, followed by the diskette
id  --  both  of  which  are  determined  when  the  diskette  is
formatted.
  The  3D  at the end of the top line means the 1581 uses version
3D of Commodore's disk operating system (DOS).
  Each   of   the   remaining  lines  provides  three  pieces  of
information  about the files on the diskette.  At the left end of
each  line  is  the size of the file in blocks of 254 characters.
Four  blocks  are  equivalent  to  almost 1K of memory inside the
computer.  The  middle  of the line contains the name of the file
enclosed in quotation marks.  All characters within the quotation
marks  are  part  of  the  filename.  The right side of each line
contains a three-letter abbreviation of the file type.  The types
of files are described in later chapters.
  The  bottom  line  of  a  directory  shows  how many blocks are
available  for  use.  This  number  ranges  from  3160 on a newly
formatted diskette to 0 on one that is completely full."
"In the context of the C64, What does the DETWP_DV disk controller job command $B6 do?","1581 disk Controller Job commands: DETWP_DV
      $B6     Checks   if  the  disk  inserted  is  write
                      protected.  Returns  $00  if  disk  is  not
                      protected, else $08."
"In the context of the C64, What is the meaning of the Controller commands error code 00"" message on a disk?""","1581 disk: Controller commands error code 00 
	OK (not an error)
    This  is  the  message  that  usually  appears when the error
    channel is checked. It means there is no current error in the
    disk unit."
"In the context of the C64, What is the error message and explanation for error code 70: NO CHANNEL?","1581 disk: Controller commands error code 70: NO CHANNEL (available)
    The requested channel is not available or all channels are in
    use. A maximum of three sequential files or one relative file
    plus one sequential file may be opened at one time,  plus the
    command channel. Do not omit the drive number in a sequential
    OPEN command, or only two sequential files can be used. Close
    all files as soon as you no longer need them."
"In the context of the C64, What are the internal disk commands that expert programmers can use to directly alter the workings of the 1581 disk drive?","1581 disk:  INTERNAL DISK COMMANDS


  Expert  programmers  can  give commands that directly alter the
workings of the  1581,  much as skilled programmers can alter the
workings of BASIC inside the computer with PEEKs,  POKEs  and SYS
calls.  It  is  also  possible to write machine language programs
that  load  and  run entirely within the 1581,  either by writing
them into disk memory from  the  computer,  or  by  loading  them
directly  from diskette into the desired disk memory buffer. This
is  similar  to  loading and running machine language programs in
your computer.
  As when learning to use PEEK,  POKE  and  SYS in your computer,
extreme caution is advised in using the commands in this chapter.
They are essentially machine language commands,  and  lack all of
BASIC's safeguards.  If anything goes wrong, you may have to turn
the disk drive off and on again  (after removing the diskette) to
regain  control.  Do not practice these commands on any important
diskette.  Rather,  make a spare copy and work with that. Knowing
how  to program a 6502 in machine language will help greatly, and
you  will  also need a good memory map of the 1581.  A brief 1581
map appears below."
"In the context of the C64, What is the command and its format to load a machine language routine from a diskette into a memory buffer and execute it?","1581 disk:  BLOCK-EXECUTE

  This  rarely-used  command  will  load  a  sector  containing a
machine  language routine into a memory buffer from diskette, and
execute  it  from  the first location within the buffer,  until a
ReTurn from Subroutine (RTS) instruction ends the command.

FORMAT FOR THE BLOCK-EXECUTE COMMAND:

  PRINT#15,'B-E:';channel#;drive#;track#;sector#

where  'channel#'  is  the channel number specified when the file
into which the block will be loaded was opened,  'drive#'  is the
drive number,  and  'track#'  and  'sector#' are respectively the
track  and sector numbers containing the desired block of data to
be loaded into the file buffer and executed there.

ALTERNATE FORMATS:

  PRINT#15,'B-E:';channel#;drive#;track#;sector#
  PRINT#15,'B-E:channel#,drive#,track#,sector#'

EXAMPLES:

  Assuming  you've  written a machine language program onto Track
1,  Sector 8  of  a diskette,  and would like to run it in buffer
number 1  in  disk  memory  (starting  at $0400 hexadecimal), you
could do so as follows:

110 OPEN 15,8,15               Open command channel.
120 OPEN 2,8,2,'#1'            Open direct access channel to
                               buffer 1.
130 PRINT#15,'B-E:';2;0;1;8    Load Track1, Sector 8 in it
                               & execute.
140 CLOSE 2                    Tidy up after.
150 CLOSE 15
160 END"
"In the context of the C64, What is the purpose and functionality of the BUFMOVE_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: BUFMOVE_DV
    $9E     Moves data between the job queue buffer and
                      the track cache buffer. The track parameter
                      in  the  job  queue denotes the position in
                      the track cache buffer to transfer to/from.
                      The sector parameter denotes the following:
                        Bit 7 :  Direction  (1 = to  track  cache
                                 buffer)
                        Bit 6 :  Mark Flag  (set/clear the 'track
                                 cache modified' flag)
                        Bit 5 :  Transfer (1 = do the transfer)
                        Bits 4-0:# of 256 byte blocks to transfer
                      With bit 7 set,  the corresponding physical
                      track  position  in  the  job queue (HDRS2)
                      must  be updated for the purpose of telling
                      the  controller  what  physical  track  the
                      track cache buffer belongs to.  In addition
                      the side var (SIDS) must also be updated."
"In the context of the C64, What is the function of the EXBUF_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: EXBUF_DV
      $E0     Executes  the code in the corresponding job
                      queue buffer after the motor is up to speed
                      and the head is on track."
"In the context of the C64, What is the syntax and usage of the SCRATCH command in a disk with basic 7,0?","1581 disk with basic 7,0: FORMAT FOR THE SCRATCH COMMAND:

  SCRATCH 'pattern'[,Ddrive#][,Udevice#]

where  'pattern'  is  any  valid  file  name  or pattern-matching
character.

  You will be asked as a precaution:

  ARE YOU SURE?_

If you ARE sure, simply press Y and RETURN.  If not, press RETURN
alone or type any other answer, and the command will be canceled.
  The  number  of files that were scratched will be automatically
displayed.  For example,  if your diskette contains program files
named 'TEST',  'TRAIN',  'TRUCK', and 'TAIL', you may SCRATCH all
four,  along  with any other files beginning with the letter 'T',
by using the command:

  SCRATCH 'T*'

and  if  the  four listed were the only files beginning with 'T',
you will see:

  01, FILES SCRATCHED,04,00
  READY
  _

The '04' tells you 4 files were scratched.

  You can perform a  SCRATCH within a program,  but there will be
no prompt message displayed."
"In the context of the C64, What is the command to re-read the directory of a diskette into a disk buffer when the information becomes unreliable?","1581 disk: INITIALIZE

  When  a  diskette is inserted into the drive,  its directory is
automatically  re-read  into  a  disk  buffer.  You would use the
command only if that information became unreliable.

FORMAT FOR THE INITIALIZE COMMAND:

  PRINT#15,'INITIALIZEdrive#'

or it may be abbreviated to

  PRINT#15,'Idrive#'

EXAMPLE:

  PRINT#15,'I0'

  PRINT#15,'INITIALIZE0'

where the command channel is assumed to be opened by file 15, and
'drive#' is 0."
"In the context of the C64, What is the format for the validate command in a disk system, and how can it be abbreviated?","1581 disk: FORMAT FOR THE VALIDATE COMMAND:

  PRINT#15,'VALIDATE0'

or abbreviated as:

  PRINT#15,'V0'

where  '0'  is the drive number.  As usual, it is assumed file 15
has  been  opened to the command channel and will be closed after
the command has been executed."
"In the context of the C64, What is the purpose of the SCRATCH command in a disk with basic 7,0?","1581 disk with basic 7,0: SCRATCH

  The  SCRATCH  command allows you to erase unwanted programs and
files  from  your diskettes,  and free up the space they occupied
for  use  by  other  files and programs.  It can be used to erase
either  a  single  file,  or  several  files at once via pattern-
matching."
"In the context of the C64, What is the purpose of the RESET_DV command in a disk controller job?","1581 disk Controller Job commands: RESET_DV
      $82     Resets  the  disk controller and associated
                      variables."
"In the context of the C64, What is the function of the TRKWRT_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: TRKWRT_DV     $A2
     Dumps  the  track  cache buffer to the disk
                      (only  if  the track cache modified flag is
                      set)."
"In the context of the C64, What is the function of the JUMPC_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: JUMPC_DV
      $D0     Executes  the code in the corresponding job
                      queue buffer."
"In the context of the C64, What is the purpose of the $9C command in the disk controller job commands?","1581 disk Controller Job commands: SIDE_DV
       $9C     Sets  up the side select electronics to the
                      value specified (in SIDS)."
"In the context of the C64, What is the protocol and code for burst read and write operations in a 1581 disk system?","1581 disk: BURST TRANSFER PROTOCOL

  Before  using  the following burst transfer routines,  you must
determine  whether  or  not the peripheral is a fast device.  The
Fast   Serial  (byte  mode)  protocol  makes  that  determination
internally  when  you  include a query routine (send-cmd-string).
This  routine  addresses the peripheral as a listener and thereby
determines its speed.


BURST READ

send-cmd-string;                      (*determine speed*)
if device-fast then
    serial-in;                        (*serial port input*)
    repeat                            (*repeat for all sectors*)
        read-error;                   (*retrieve error byte*)
    toggle-clock;                     (*wait for status*)
    wait-byte;                        (*wait for byte*)
    if status = ok then
        toggle-clock;                 (*start double buffer*)
        repeat                        (*repeat for sector-size*)
            wait-byte;                (*get data*)
            toggle-clock;             (*start next*)
            store-byte;               (*save data*)
        until last-byte;              (*last byte ?*)
    until last-sector;                (*until last sector*)
    set-clock-high;                   (*restore clock*)
else
    read-1581;                        (*send unit read*)


BURST WRITE

send-cmd-string;                      (*determine speed*)
if device-fast then
    repeat                            (*repeat for all sectors*)
        serial-out;                   (*serial port out*)
            repeat                    (*repeat for sector-size*)
                send-byte;            (*send byte*)
            until last-byte;          (*last byte ?*)
        serial-in;                    (*serial port in*)
        set-clock-low;                (*ready for status*)
        read-err;                     (*controller error ?*)
        set-clock-high;               (*restore clock*)
    until last-sector;                (*until last sector*)
else
    write-1581;                       (*send unit write*)"
"In the context of the C64, What is the syntax and usage of the COPY command on a Commodore 1581 disk drive?","1581 disk:  COPY

  The COPY command allows you to make a spare copy of any program
or file on a diskette.  On a single drive like the 1581, the copy
must  be  on  the  same diskette,  which means it must be given a
different name from the file copied. It's also used to combine up
to  four sequential data file  (linking the files one to another,
end  to end in a chain).  Files are linked in the order and other
files  on  the  diskette  are  not changed.  Files must be closed
before they are copied or linked.

FORMAT FOR THE COPY COMMAND:

  PRINT#15,'COPYdrive#:new file=old file'

EXAMPLES:

  PRINT#15,'COPY0:BACKUP=ORIGINAL'

or abbreviated as:

  PRINT#15,'Cdrive#:new file=old file'

  PRINT#15,'C0:BACKUP=ORIGINAL'

where  'drive#'  is the drive number  'new file'  is the copy and
'old file' is the original.

FORMAT FOR THE COMBINE OPTION:

  PRINT#15,'Cdrive#:new file=file 1,file 2,file 3,file 4'

where 'drive#' is always 0,

| The  length  of  a  command string (command and filenames) is |
| limited to 41 characters.                                     |"
"In the context of the C64, What is the purpose of the CONCAT command in a CP/M system?","1581 disk with basic 7,0: CONCAT

  The  CONCAT  command  allows  you  to concatenate (combine) two
sequential files."
"In the context of the C64, What is the syntax and functionality of the CONCAT command in CP/M?","1581 disk with basic 7,0:FORMAT FOR THE CONCAT COMMAND:

  CONCAT [Ddrive#,]'add file' TO [Ddrive#,] 'master file'
         [,Udevice#]

where  the  optional  'drive#'  would be 0 in both cases. The old
'master file'  is  deleted and replaced with a new  'master file'
which  is  the concatenation of the old  'master file'  and  'add
file'.

| The  length  of  a  command string (command and filenames) is |
| limited to 41 characters.                                     |"
"In the context of the C64, What is the purpose and precautions of using the VALIDATE command on a diskette?","1581 disk:  VALIDATE

  The VALIDATE command recalculates the  Block  Availability  Map
(BAM)  of  the  current  diskette,  allocating only those sectors
still  being  used by valid,  properly-closed files and programs.
All other sectors  (blocks) are left unallocated and free for re-
use, and all improperly closed files are automatically scratched.
This  brief  description  of its workings doesn't indicate either
the power or the danger of the VALIDATE command.  Its power is in
restoring  to  good  health  many  diskettes whose directories or
block availability maps have become muddled.  Any time the blocks
used  by  the  files  on a diskette plus the blocks shown as free
don't add up to the 3160 available on a fresh diskette,  VALIDATE
is  needed,  with  one  exception  below.  Similarly,  any time a
diskette   contains   an  improperly-closed  file  (splat  file),
indicated  by  an  asterisk  (*)  next  to  its  file type in the
directory,  that diskette needs to be validated. In fact, but for
the  one  exception,  it  is  a  good  idea to VALIDATE diskettes
whenever you are the least bit concerned about their integrity.
  The  exception  is diskettes containing direct access files, as
described in Chapter 6.  Most direct access (random) files do not
allocate  their  sectors  in  a  way  the  VALIDATE  command  can
recognize.  Thus, using VALIDATE on such a diskette may result in
unallocating  all  direct  access  files,  with loss of all their
contents   when  other  files  are  added.   Unless  specifically
instructed otherwise, never use VALIDATE on a diskette containing
direct access files."
"In the context of the C64, What is the breakdown of the status byte in a 1581 disk assembly, including the meaning of each bit and the possible values for mode, drive number, sector size, and controller status?","1581 disk in assembly: STATUS BYTE BREAKDOWN

 BIT 7    6       5       4       3       2       1       0
-----------------------------------------------------------------
 MODE     DN     SECTOR SIZE         [ CONTROLLER STATUS]
-----------------------------------------------------------------
*MODE -- 1 = Alien Disk Format  (non-default physical format,  or
         default  physical  format  without   Directory  and  BAM
         information)
         0 = Resident Disk Format  (default  physical format with
         Directory and BAM information)
 DN  --  drive number

*Resident Disk Format is based on whether required information is
 present in BAM/DIRECTORY track.

SECTOR SIZE
             00 ........ 128 BYTE SECTORS (NOT SUPPORTED)
             01 ........ 256 BYTE SECTORS
             10 ........ 512 BYTE SECTORS (DEFAULT)
             11 ........ 1024 BYTE SECTORS

CONTROLLER STATUS
             000X ...... OK
             0010 ...... CAN'T FIND HEADER BLOCK
             0011 ...... NO ADDRESS MARK
             0100 ...... DATA BLOCK NOT PRESENT
             0101 ...... DATA CRC ERROR
             0110 ...... FORMAT ERROR
             0111 ...... VERIFY ERROR
             1000 ...... WRITE PROTECT ERROR
             1001 ...... HEADER BLOCK CRC ERROR
             1010 ...... WRITE PROTECTED
             1011 ...... DISK CHANGE
             1100 ...... DISK FORMAT NOT LOGICAL
             1101 ...... RESERVED
             1110 ...... SYNTAX ERROR
             1111 ...... NO DRIVE PRESENT"
"In the context of the C64, What is the purpose of the $9A command in a 1581 disk controller job?","1581 disk Controller Job commands: ERRLEDOFF_DV  
$9A     Disables error LED blinking."
"In the context of the C64, What is the purpose of the RESTORE_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: RESTORE_DV    $C0
     Restores  the  read/write  head  to track 0
                      ('bump')."
"In the context of the C64, What is the function of the SEEKHD_DV disk controller job command in a 1581 disk controller?","1581 disk Controller Job commands: SEEKHD_DV
     $B0     Logs  in a disk by reading information from
                      the  first  header  encountered on the disk
                      into RAM so that it can be used by the DOS.
                      The track cache buffer is not updated."
"In the context of the C64, What is the function of the $84 command in the MOTON_DV disk controller job commands?","1581 disk Controller Job commands: MOTON_DV
      $84     Turns on the spindle motor  (overlays a $01
                      in the Job Queue after the spin-up sequence
                      is complete)."
"In the context of the C64, What is the purpose of the DISKIN_DV command in a disk controller job?","1581 disk Controller Job commands: DISKIN_DV
     $92     Determines  if  there is a disk inserted in
                      the drive."
"In the context of the C64, What is the purpose of the SAVE command ?","1581 disk with basic 7,0: SAVE

  This  command  will save a program or file so you can reuse it.
The  diskette  must  be  formatted before you can save it to that
diskette."
"In the context of the C64, What is the purpose of the VERIFY command in Commodore computers?","1581 disk with basic 7,0: VERIFY

  This  command  makes  a  byte-by-byte comparison of the program
currently   in   memory  against  a  program  on  diskette.  This
comparison includes the BASIC line links,  which may be different
for different types of memory configurations.  What this means is
that  a  program  saved to disk on a C64 and reloaded into a C128
wouldn't   verify  properly  because  the  line  links  point  to
different  memory  locations.  If  the  disk  copy of the program
differs at all from the copy in memory,  a 'VERIFY ERROR' will be
displayed. This doesn't mean either copy is bad, but if they were
supposed to be identical, there is a problem."
"In the context of the C64, How do you handle renaming and deleting files with troublesome characters in their names, such as commas, Shifted Spaces, or non-printing characters, in a disk file system?","1581 disk: RENAMING AND SCRATCHING TROUBLESOME FILES

  Eventually,  you  may  run  across  a  file  which  has  an odd
filename,  such as a comma by itself (',') or one that includes a
Shifted Space (a Shifted Space looks same as a regular space, but
if  a  file  with a space in its name won't load properly and all
else is correct,  it's probably a Shifted Space).  Or perhaps you
will find one that includes non-printing characters. Any of these
can be troublesome.  Comma files,  for instance, are an exception
to  the  rule  that no two files can have the same name. Since it
shouldn't  be possible to make a file whose name is only a comma,
the disk never expects you to do it again.
  Files  with  a   Shifted  Space  in  their  name  can  also  be
troublesome,  because  the  disk  interprets the Shifted Space as
signaling  the end of the file name,  and prints whatever follows
after  the  quotation  mark  that  marks the end of a name in the
directory.  This  technique can be useful by allowing you to have
a  long file name,  and making the disk recognize a small part of
it  as  being  the same as the whole thing without using pattern-
matching characters.
  In any case,  if  you have a troublesome filename,  you can use
the  CHR$()  function  to  specify troublesome characters without
typing  them  directly.  This  may allow you to build them into a
RENAME  command.  If  this  fails,  you may also use the pattern-
matching characters in a SCRATCH command. This gives you a way to
specify the name without using the troublesome characters at all,
but also means loss of your file.
  For  example,  if  you  have  managed  to  create  a file named
''MOVIES',  with an extra quotation mark at the front of the file
name,  you can rename it to  'MOVIES' using the CHR$() equivalent
of a quotation mark in the RENAME command:

  PRINT#15,'R0:MOVIES='+CHR$(34)+'MOVIES'

The  CHR$(34)  forces  a  quotation  mark into the command string
without  upsetting  BASIC.  The  procedure  for  a file name that
includes a Shifted Space is similar, but uses CHR$(160).
  In cases  where even this doesn't work,  for  example,  if your
diskette contains a comma file,  (one named ',')  you can get rid
of it this way:

  PRINT#15,'S0:?'

  This example deletes all files with one-character names.

  Depending  on  the  exact  problem,  you  may  have  to be very
creative in choosing pattern-matching characters that will affect
only  the desired file,  and may have to rename other files first
to keep them from being scratched.
  In  some  cases,  it  may  be easier to copy desired files to a
different diskette and leave the troublesome files behind."
"In the context of the C64, What is the syntax and usage of the RENAME command in a diskette directory?","1581 disk:  RENAME

  The RENAME command allows you to alter the name of a program or
other file in the diskette directory. Since only the directory is
affected, RENAME works very quickly.

FORMAT FOR RENAME COMMAND:

  PRINT#15,'RENAME0:new name=old name'

or it may be abbreviated as:

  PRINT#15,'R0:new name=old name'

where  'new name' is the name you want the file to have, and 'old
name'  is  the name it has now.  'new name' may be any valid file
name,  up  to  16  characters  in length.  It is assumed you have
already opened file 15 to the command channel.
  One  caution  --  be  sure  the  file you are renaming has been
properly closed before you rename it.

EXAMPLES:

Just before saving a new copy of a 'calendar' program,  you might
type:

  PRINT#15,'R0:CALENDAR/BACKUP=CALENDAR'

Or to move a program called  'BOOT',  currently the first program
on a diskette to someplace else in the directory, you might type:

  PRINT#15,'R0:TEMP=BOOT'

followed by a COPY command (described later),  which turns 'TEMP'
into a new copy of  'BOOT',  and finishing with a SCRATCH command
to get rid of the original copy of 'BOOT'."
"In the context of the C64, What is the procedure for saving a new version of a file using the DSAVE command in BASIC 7.0?","1581 disk with basic 7,0:FORMAT FOR SAVE WITH REPLACE:

  DSAVE '@file name'[,Ddrive#][,Udevice#]

  The  actual  procedure  is  this  --  the  new version is saved
completely,  then  the old version is scratched and its directory
entry altered to point to the new version.  Because it works this
way,  there  is little danger a disaster such as having the power
going  off  midway through the process would destroy both the old
and new copies of the file. Nothing happens to the old copy until
after the new copy is saved properly."
"In the context of the C64, What is the purpose of the PRINT DS$ command and how can it be used in a program to handle disk errors?","1581 disk with basic 7,0: ERROR CHECKING

  When  the  drive  light  (red light) flashes,  you must use the
following command to find out what the error is:

  PRINT DS$

  A  message  is  displayed  whether there is an error or not. If
there  was an error,  this command clears it from disk memory and
turns off the error light on the disk drive.
  Once  the  message  is  on  the  screen,  you can look it up in
Appendix B to see what it means, and what to do about it.
  For those of you who are writing programs,  the  following is a
small error-checking subroutine you can include in your programs:

  59990 REM READ ERROR CHANNEL
  60000 IF DS>1 THEN PRINT DS$: STOP
  60010 RETURN

  The  subroutine  reads  the  error channel and puts the results
into  the  reserved  variables  DS  and  DS$.  They  are  updated
automatically by BASIC.
  Two error numbers are harmless -- 0 means everything is OK, and
1  tells  how  many  files  were  erased  by  a  SCRATCH  command
(described  later  in  this  chapter).  If  the  error  status is
anything else,  line 60000 prints the error message and halts the
program.
  Because  this  is  a  subroutine,  you access it with the BASIC
GOSUB  command,  either  in immediate mode or from a program. The
RETURN  statement  in line 60010 will jump back to immediate mode
or the next statement in your program, whichever is appropriate."
"In the context of the C64, What is the disk controller job command to turn on the activity LED?","1581 disk Controller Job commands: LEDACTON_DV   $94
     Turns on the activity LED."
"In the context of the C64, What is the function of the MOTOFF_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: MOTOFF_DV
     $86     Turns the spindle motor off after the spin-
                      down sequence is complete."
"In the context of the C64, What is the function of the SEEKPHD_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: SEEKPHD_DV
    $B8     Seeks   to   a  particular  logical  track,
                      sector. The track cache is not updated."
"In the context of the C64, What is the purpose of the $98 command in the 1581 disk controller job commands?","1581 disk Controller Job commands: ERRLEDON_DV
   $98     Enables error LED blinking."
"In the context of the C64, What is the function of the MOTOFFI_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: MOTOFFI_DV
    $8A     Turns the spindle motor off immediately."
"In the context of the C64, What is the syntax and usage of the DVERIFY command in BASIC 7.0?","1581 disk with basic 7,0:FORMAT FOR THE DVERIFY COMMAND:

  DVERIFY 'file name'[,Ddrive#][,Udevice#]

  The  following  version of the command verifies a file that was
just saved:

  DVERIFY'*'

  This  command  won't  work  properly  after  SAVE-WITH-REPLACE,
because  the  last  file used was the one deleted,  and the drive
will try to compare the deleted file to the program in memory. No
harm will result, but 'VERIFY ERROR' will always be announced. To
use  DVERIFY after @SAVE,  include at least part of the file name
that is to be verified in the pattern."
"In the context of the C64, What is the syntax and usage of the DSAVE command in BASIC 7.0?","1581 disk with basic 7,0:FORMAT FOR THE SAVE COMMAND:

  DSAVE 'file name'[,Ddrive#][,Udevice#]

  This  command  will  not  work in copying programs that are not
written  in  BASIC.  To copy these machine-language programs, you
can use the BSAVE command or the built-in Monitor S command."
"In the context of the C64, What is the syntax and usage of the BSAVE command in Commodore 128?","1581 disk with basic 7,0:FORMAT FOR THE BSAVE COMMAND:

  BSAVE 'file name'[,Ddrive#][,Udevice#][,Bbank#]
                   [,Pstarting address][TO Pending address+1]

where  the  usual options are the same and bank# is one of the 16
banks of the C128.  The address to be saved are given in decimal.
Note  that  the ending address must be 1 location beyond the last
location to be saved.
  To access a built-in monitor, type MONITOR.  To exit a monitor,
type X alone on a line."
"In the context of the C64, What is the syntax and usage of the COPY command on a Commodore 1581 disk with Basic 7.0?","1581 disk with basic 7,0: COPY

  The COPY command allows you to make a spare copy of any program
or file on a diskette. However, on a single derive like the 1581,
the  copy  must  be on the same diskette,  which means it must be
given a different name from the file copied.  The source file and
other files on the diskette are not changed. Files must be closed
before they can be copied or concatenated.

FORMAT FOR THE COPY COMMAND:

  COPY [Ddrive#,]'old file name' TO [Ddrive#,]'new file name'
       [,Udevice#]

where both drive#s would be 0 if included."
"In the context of the C64, What is the function of the $88 command in the MOTONI_DV disk controller job?","1581 disk Controller Job commands: MOTONI_DV
     $88     Turns the spindle motor on immediately."
"In the context of the C64, What is the purpose of the $96 command in a 1581 disk controller job?","1581 disk Controller Job commands: LEDACTOFF_DV
  $96     Turns off the activity LED."
"In the context of the C64, What is the purpose of the WRTVER_DV disk controller job command $A0?","1581 disk Controller Job commands: WRTVER_DV
     $A0     Verifies  the  track  cache  buffer's  data
                      against the specified logical track's data."
"In the context of the C64, What is the format and protocol of the QUERY DISK FORMAT command in a disk assembly?","1581 disk in assembly: QUERY DISK FORMAT

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       F      X      T      S      1      0      1      N
-----------------------------------------------------------------
  03               OFFSET      (OPTIONAL, F-BIT SET)
-----------------------------------------------------------------

SWITCHES: F -- force flag  (F = 1 steps the head  with the offset
          specified in byte 03)
          T -- sector table (T = 1, send sector table)
          N -- drive number
          X -- don't care
          S -- side select

PROTOCOL: Burst handshake.

CONVENTIONS: Determines  the  diskette  format  on any particular
             track.   Also   logs  non-standard  diskettes  (i.e.
             minimum sector addresses other than one).

OUTPUT:  * burst status byte (no bytes will follow if there is an
           error)
        ** burst status byte  (no bytes will follow  if there was
           an error in compiling MFM format information)
           number of sectors (on a particular track)
           logical track (track number found in the disk header)
           minimum sector (sector with the lowest value address)
           maximum sector (sector with the highest value address)
           interleave (always returns 1)
           sector table (with T bit set, sector table is sent)
 * status from track offset zero
** if F bit is set, status is from offset track"
"In the context of the C64, What precautions should be taken when using the SCRATCH command to delete files, and how to recover from accidentally deleting a file or a splat"" file?""","1581 disk: Scratch in-depth

  SCRATCH  is  a powerful command and should be used with caution
to be sure you delete only the files you really want erased. When
using  it  with  a  pattern,  we  suggest  you first use the same
pattern in a  DIRECTORY  command,  to be sure exactly which files
will  be  deleted.  That  way you'll have no unpleasant surprises
when you use the same pattern in the SCRATCH command.
  If you accidentally SCRATCH a file you shouldn't have, there is
still  a  chance of saving it by using the 'UNSCRATCH' program on
your Test/Demo diskette.

More about Splats

  Never SCRATCH a splat file.  These are files  that show up in a
directory listing with an asterisk (*)  just before the file type
for  an entry.  The asterisk (or splat) means that file was never
properly  closed,  and  thus  there  is  no valid chain of sector
links for the SCRATCH command to follow in erasing the file.
  If you  SCRATCH such a file,  odds are you will improperly free
up  sectors  that are still needed by other programs or files and
cause  permanent damage to those later when you add more files to
the  diskette.  If you find a splat file,  or if you discover too
late  that  you have scratched such a file,  immediately validate
the diskette using the  VALIDATE  command described later in this
chapter.  If  you  have  added  any  files  to the diskette since
scratching  the  splat  file,  it is best to immediately copy the
entire  diskette onto another fresh diskette,  but do this with a
copy  program  rather than with a backup program.  Otherwise, the
same problem will be recreated on the new diskette.  When the new
copy is done,  compare the number of blocks free in its directory
to  the  number  free  on  the original diskette.  If the numbers
match, no damage has been done.  If not, very likely at least one
file  on  the  diskette  has  been  corrupted,  and all should be
checked immediately."
"In the context of the C64, How do you erase a locked file on a diskette that cannot be deleted with the SCRATCH command?","1581 disk: Locked Files

  Occasionally,  a diskette will contain a locked file; one which
cannot  be  erased with the  SCRATCH  command.  Such files may be
recognized  by  the  '<'  character which immediately follows the
file type in their directory entry. If you wish to erase a locked
file, you will have to use a sector editor program to clear bit 6
of  the  file-type  byte  in the directory entry on the diskette.
Conversely, to lock a file, you would set bit 6 of the same byte."
"In the context of the C64, What is the format of the 1581 disk in assembly, including the byte layout and switches?","1581 disk in assembly:  FORMAT

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       M      X      X      X      0      1      1      N
-----------------------------------------------------------------
  03   SECTOR SIZE           *(OPTIONAL, DEF-02,512 BYTE SECTORS)
-----------------------------------------------------------------
  04   LAST TRACK NUMBER      (OPTIONAL, DEF-79)
-----------------------------------------------------------------
  05   NUMBER OF SECTORS    **(OPTIONAL, DEF DEPENDS ON BYTE 03)
-----------------------------------------------------------------
  06   STARTING TRACK         (OPTIONAL, DEF-0)
-----------------------------------------------------------------
  07   FILL BYTE              (OPTIONAL, DEF-$E5)
-----------------------------------------------------------------
  08   STARTING SECTOR        (OPTIONAL, DEF-1)
-----------------------------------------------------------------

SWITCHES: M -- mode (1 = will accept BYTES 03-08,0 = will format,
          create directory and BAM)
          N -- drive number

PROTOCOL: Conventional.

CONVENTIONS: CMD 4 must be followed with CMD 3  or  CMD 6 once to
             log the disk in.

OUTPUT: None. Status will be updated within the drive."
"In the context of the C64, What is the function of the WRTSD_DV command in a disk controller job?","1581 disk Controller Job commands: WRTSD_DV
      $90     Writes  the  job  queue's  buffer data to a
                      particular  logical track,  sector.  If the
                      same  track  is already in the track cache,
                      then  this  involves  only transferring the
                      job  queue  buffer  data to the track cache
                      buffer.  If  a different track's data is in
                      the  disk  (only  if  it was modified), the
                      desired  track  read  into  the track cache
                      buffer,  and finally the job queue buffer's
                      data transferred to the track cache."
"In the context of the C64, What is the format and protocol for the CMD 2 -- WRITE command in a disk assembly?","1581 disk in assembly : CMD 2 -- WRITE

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       L      E      X      S      0      0      1      N
-----------------------------------------------------------------
  03                       DESTINATION TRACK
-----------------------------------------------------------------
  04                       DESTINATION SECTOR
-----------------------------------------------------------------
  05                       NUMBER OF SECTORS
-----------------------------------------------------------------
  06                      NEXT TRACK (OPTIONAL)
-----------------------------------------------------------------

RANGE: All  values  are  determined by the particular disk format
       and format of translation table.

SWITCHES: L -- logical flag(1=do logical to physical translation)
          E -- ignore error (1 = ignore)
          S -- side select
          N -- drive number

PROTOCOL: Burst  data  to  the drive,  then host must perform the
          following:  fast  serial input,  pull the clock low and
          wait  for  the  burst status byte,  pull clock high, go
          output for multi-sector transfers and continue.

CONVENTIONS: Before you can READ or WRITE to a diskette,  it must
             be logged-in using either the  INQUIRE DISK or QUERY
             DISK FORMAT command (both are described later). This
             must be done once each time you change diskettes.

INPUT: Host must transfer burst data.

OUTPUT: One burst status byte following each WRITE operation."
"In the context of the C64, What is the primary interface between the host computer and the 1581 system, responsible for managing file creation, modification, and deletion, and keeping track of file names and free space on the disk?","1581 disk:  CONTROLLER JOB QUEUE

  The  software  in  the  1581's  ROM can be broken down into two
major  components  --  the DOS and the Controller.  The DOS (Disk
Operating  System)  is  the  software  interface between the host
computer  and  the  1581 system.  The DOS keeps track of the file
management details necessary to create,  modify and delete files.
It  monitors  the  amount of free space left on a disk, and keeps
track of the file names in the directory. It remembers where each
file starts, and ensures that none of them overlap. When the host
sends commands,  the DOS checks make sure that the syntax and the
parameters  are  valid.  The  DOS  is very complex,  and its code
occupies the majority of the ROM.

  The  Controller,  on  the  other hand,  knows nothing about the
concept of files. The Controller deals only in the physical world
of  the  disk  itself.  It is responsible for reading and writing
each of the individual sectors on the disk.

  The  DOS  and  Controller  communicate  to each other primarily
through  a  'mailbox',  known  as the Job Queue.  Because the DOS
deals more in the abstract, or logical, world, it does not access
the physical disk itself. If the DOS requires access to the disk,
it must ask the controller to do it.  The DOS places a Controller
Command  Code into the Job Queue and then waits for the requested
operation  to  be  completed.  The Controller polls the Job Queue
every 10 milliseconds  (the polling rate is determined by timer B
of  8520)  looking for something to do.  If there is a job in the
queue,  the Controller executes the job and returns a status byte
to the DOS.  To speed things up, the polling of the job queue can
be  bypassed  by  a  direct  jump  to JSTROBE_CONTROLLER at $FF54
(refer to the section describing the Vectored Jump Table). A call
to JSTROBE_CONTROLLER requires the command in the accumulator and
the job queue offset in the x register.

  Most  of  the tasks that the Controller can be asked to perform
require parameters. The parameters are also placed in a 'mailbox'
location  for  the  Controller  to  access  (prior to placing the
command byte into the queue, of course).  These parameters can be
either the physical or the logical parameters,  depending on what
the command expects to see. Logical parameters are placed in HDRS
as  two consecutive bytes of track,  sector.  Physical parameters
are  also  placed  in  HDRS,  but  in  addition  the side must be
specified  (in  SIDS).  Commands  that require logical parameters
must  translate  them  into  physical parameters at some point in
their  execution.  The  logical  parameters  are  translated into
physical parameters by a vectored routine called TRANSTS, and are
written into  HDRS2  and  SIDS.  The DOS will always pass logical
parameters, and uses only the Controller commands that allowed to
put  jobs  in  its  own  queue,  so  it  needs  to  pass physical
parameters as well as logical.

               Mailbox Locations of the Controller
-----------------------------------------------------------------
Name     Address  Purpose
-----------------------------------------------------------------
JOBS      $0002   JOB queue for Controller commands (JOBS 0-8).
            .     Each JOB uses 1 byte. The last 2 locations
            .     ($09,$0A) are reserved for BAM jobs only!
          $000A
HDRS      $000B   Logical or physical track, sector for each of
            .     the jobs in the JOB queue (2 bytes per job).
            .
          $001C
HDRS2     $01BC   Translated (physical) track, sector for each
            .     of the jobs in the JOB queue (2 bytes per job).
            .
          $01CD
SIDS      $01CE   Physical side for each of the jobs
            .     in the job queue (1 byte per job).
            .
          $01D6
CACHE     $008B   Pointer to BUFFCACHE below.
CACHEOFF  $009F   Offset into the track cache buffer.
            .     (1 byte per job).
            .
          $00A7
BUFFCACHE $0C00   20 pages for track cache.
            .
            .
          $1FFF

  Associated with each of the nine  Job Queue  locations  (Jobs 0
through 8) are nine 256 byte buffers (buffers 0-8),  beginning at
location  $0300.  Data passed from/to a particular Job during its
execution  is  located  in  the  buffer  which corresponds to the
position  of  the  Controller  Job  Code  in  the  Job Queue. For
example,  if the  Controller  Code  in  Job Queue  position 2 (at
location  $0004)  requests that a logical sector of data be read,
the data is put into Buffer 2 (at location $0500).

  Table 1 is a list of Controller Job Codes  that can be put into
the  Job Queue.  Table 2 is a list of the codes that are returned
by the Controller once the job has been executed. The return code
is  placed  into  the  Job Queue in the same memory location that
contained the Controller Job Code. Consequently, the procedure to
use the Controller is the following:

  1) Write  any  parameters  needed by the Job into the parameter
     variables (HDRS, HDRS2, SIDS).
  2) Write the Controller Code into the Job Queue (JOBS).
  3) Wait  for  the  job  to  be  completed by simply polling the
     location in JOBS where the Job code was put, and waiting for
     it to change (bit 7 will be reset to 0)."
"In the context of the C64, What is the function of the SEEK_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: SEEK_DV
       $8C     Seeks  to  a  particular   physical   track
                      (cylinder).   The  current  physical  track
                      position   should   be  put  in  the  track
                      parameter of HDRS."
"In the context of the C64, What is the purpose of the SAVE WITH REPLACE command in a disk drive?","1581 disk with basic 7,0: SAVE WITH REPLACE

  If a file already exists, it can't be saved again with the same
name  because  the  disk  drive allows only one copy of any given
file name per diskette. It is possible to get around this problem
using the  RENAME  and  SCRATCH  commands described later in this
chapter.  If all you wish to do is replace a program or data file
with a revised version, another command is more convenient. Known
as SAVE-WITH-REPLACE, or @SAVE.  This option tells the disk drive
to  replace  any file it finds in the diskette directory with the
same name, substituting the new file for the old version."
"In the context of the C64, What is the command and its format to erase unwanted files and free up disk space in a C64 system?","1581 disk:  SCRATCH

  The SCRATCH command allows you to erase unwanted files and free
the space they occupied for use by other files. It can be used to
erase either a single file  or several files at once via pattern-
matching.

FORMAT FOR THE SCRATCH COMMAND:

  PRINT#15,'SCRATCH0:pattern'

or abbreviate it as:

  PRINT#15,'S0:pattern'

'pattern'  can  be any file name or combination of characters and
wildcard characters.  As usual, it is assumed the command channel
has  already  been  opened  as  file 15.  Although not absolutely
necessary,  it  is  best  to  include the drive number in SCRATCH
commands.
  If  you  check  the  error channel after a SCRATCH command, the
value  for  ET  (error  track)  will tell you how many files were
scratched.  For example,  if your diskette contains program files
named  'TEST',  'TRAIN',  'TRUCK' and 'TAIL', you may SCRATCH all
four,  along  with any other files beginning with the letter 'T',
by using the command:

  PRINT#15,'S0:T*'

Then, to prove they are gone, you can type:

  GOSUB 59990

to  call  the  error  checking  subroutine  given earlier in this
chapter.  If  the  four listed were the only files beginning with
'T', you will see:

  01, FILES SCRATCHED,04,00
  READY.

The '04' tells you 4 files were scratched."
"In the context of the C64, What is the purpose and syntax of the VERIFY command ?","1581 disk:  VERIFY

  The  VERIFY  command can be used to make certain that a program
file  was  properly  saved  to disk.  It works much like the LOAD
command,  except  that  it  only  compares  each character in the
program  against  the  equivalent  character  in  the  computer's
memory, instead of actually being copied into memory.
  If  the  disk  copy of the program differs even a tiny bit from
the copy in memory, 'VERIFY ERROR' will be displayed, to tell you
that the copies differ. This doesn't mean either copy is bad, but
if they were supposed to be identical, there is a problem.
  Naturally,  there's no point in trying to VERIFY a disk copy of
a program after the original is no longer in memory. With nothing
to compare to,  an apparent error will always be announced,  even
though  the  disk copy is automatically verified as it is written
to the diskette."
"In the context of the C64, What is the format for using the SAVE command on a Commodore 1581 disk with BASIC 7.0?","1581 disk with basic 7,0:FORMAT FOR A MONITOR SAVE:

  S 'drive#:file name',device#,starting address,ending address+1

where 'drive#:' is the drive number,  0 on the 1581;  'file name'
is any valid file name up to 14 characters long  (16 if you leave
out the drive# and the colon that follows it); 'device#' is a two
digit device number,  normally  08 on the 1581  (the leading 0 is
required); and the addresses to be saved are given in Hexadecimal
(base 16), but without a leading dollar sign (for the Plus/4). On
the C128, the addresses need not be in Hexadecimal. Note that the
ending address listed must be 1 location beyond the last location
to be saved."
"In the context of the C64, What is the description of the FORMAT_DV command in a 1581 disk controller job?","1581 disk Controller Job commands: FORMAT_DV
     $8E     Formats  one  physical track (one half of a
                      cylinder).   The   head   must   be  placed
                      physically  over  the  proper cylinder, and
                      the  head  electronics must be selected for
                      the side desired."
"In the context of the C64, What happens when the READ_DV command is executed on a disk controller job?","1581 disk Controller Job commands: READ_DV
       $80     Reads  a particular logical sector into the
                      job queue buffer  (only if the disk has not
                      been  changed).  If  the  desired sector is
                      already in the track cache buffer,  then no
                      disk  activity  is  required  (the  data is
                      merely  transferred  from  the  track cache
                      memory to the job queue buffer memory).  If
                      the  desired  sector  is  not  in the track
                      cache,  then  the  current  track  cache is
                      dumped  to  disk   (only  if  it  has  been
                      modified),  the  desired track is read into
                      the track cache, and finally the particular
                      sector's data is transferred from the track
                      cache memory to the job queue buffer."
"In the context of the C64, What is the format of the output of the INQUIRE DISK command in a 1581 disk assembly?","1581 disk in assembly : INQUIRE DISK

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       X      X      X      S      0      1      0      N
-----------------------------------------------------------------

SWITCHES: N -- drive number

PROTOCOL: Burst handshake.

OUTPUT: One   burst   status  byte  following  each  INQUIRE DISK
        operation."
"In the context of the C64, What is the function of the SP_WRITE command in a 1581 disk controller job?","1581 disk Controller Job commands: SP_WRITE
      $A6     Writes  to  the  specified  physical sector
                      directly.  It does not use the track cache.
                      Data  to  be  written  starts  at buffer #0
                      ($0300)."
"In the context of the C64, What is the output of the DUMP TRACK CACHE BUFFER command in a CMD 8 disk assembly?","1581 disk in assembly:CMD 8 -- DUMP TRACK CACHE BUFFER

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       F      S      X      1      1      1      0      1
-----------------------------------------------------------------
  03                         PHYSICAL TRACK
-----------------------------------------------------------------

SWITCHES: X -- don't care
          S -- side select
          F -- (1 = write even if not 'dirty')"
"In the context of the C64, What is described in the chapter about the internal operations of the 1581 disk?","1581 disk:  1581 INTERNAL OPERATION


This  chapter  describes  some  of the internal operations of the
1581  --  how things work on the 'other side of the fence' of the
host computer.  Experienced programmers may find this information
useful.  The information learned in previous chapters (especially
Chapter 7)  combined with that presented in this chapter provides
a  wide  realm  of  possibilities for the creative and persistent
programmer. Please be reminded, however, of the NOTE presented at
the beginning of Chapter 7 regarding future compatibility."
"In the context of the C64, What is the meaning of the Error 73"" message that appears when reading the disk error channel?""","1581 disk:  One  disk  error  message  is  not  always an error. Error 73,
'COPYRIGHT CBM DOS V10 1581'  will  appear  if  you read the disk
error  channel  before sending any disk commands when you turn on
your computer.  This is a handy way to check which version of DOS
you  are  using.  However,  if  this message appears later, after
other disk commands, it means there is a mismatch between the DOS
used  to  format  your diskette and the DOS in your drive. DOS is
Disk Operating System."
"In the context of the C64, What precautions should be taken when using the SCRATCH command, and what can be done if a file is accidentally deleted?","1581 disk with basic 7,0: in depth scratch:

  SCRATCH  is  a powerful command and should be used with caution
to be sure you delete only the files you really want erased. When
using  it  with  a  pattern,  we  suggest  you first use the same
pattern in a  DIRECTORY  command,  to be sure exactly which files
will  be  deleted.  That  way you'll have no unpleasant surprises
when you use the same pattern in the SCRATCH command.
  If you accidentally SCRATCH a file you shouldn't have, there is
still  a  chance of saving it by using the 'UNSCRATCH' program on
your Test/Demo diskette."
"In the context of the C64, What should you never do to a 'splat file' on a disk, and how can you recover from accidentally doing so?","1581 disk with basic 7,0: More about Splats

  Never SCRATCH a splat file.  These are files  that show up in a
directory listing with an asterisk (*)  just before the file type
for  an entry.  The asterisk (or splat) means that file was never
properly  closed,  and  thus  there  is  no valid chain of sector
links for the  SCRATCH  command to follow in erasing the file. If
you  SCRATCH  such  a file,  odds are you will improperly free up
sectors  that  are  still  needed  by other programs or files and
cause  permanent damage to those later when you add more files to
the diskette.
  If you find a splat file,  or if you discover too late that you
have  scratched  such  a  file, immediately validate the diskette
using the COLLECT command described later in this chapter. If you
have  added  any files to the diskette since scratching the splat
file,  it  is  best  to immediately copy the entire diskette onto
another  fresh  diskette,  but do this with a copy program rather
than with a backup program.  Otherwise,  the same problem will be
recreated on the new diskette. When the new copy is done, compare
the  number of blocks free in its directory to the number free on
the  original diskette.  If the numbers match, no damage has been
done.  If not,  very likely at least one file on the diskette has
been corrupted, and all should be checked immediately."
"In the context of the C64, What is the syntax and limitations of the SAVE command in Commodore computers?","1581 disk:  To reset drive, type: OPEN 15,8,15,'UJ':CLOSE 15.


1581 disk:  SAVE

  The  SAVE  command  preserves  a program or file on a formatted
diskette for latter use.

FORMAT FOR THE SAVE COMMAND:

  SAVE 'drive#:file name',device#

where   'file  name'  is  any  string  expression  of  up  to  16
characters,  preceded  by  the  drive  number  and  a  colon, and
followed by the device number of the disk, normally 8.
  However,  the  SAVE  command  will not work in copying programs
that  are  not in the BASIC text area,  such as 'DOS 5.1' for the
C64.  To copy it and similar machine-language programs,  you will
need a machine-language monitor program, such as the one resident
in the C128."
"In the context of the C64, What are the procedures and commands used to interact with the 1581 disk drive?","1581 disk: EXPLANATION OF PROCEDURES

send-cmd-string   sends  one  byte  of  the  command to determine
                  whether the drive is fast or slow.

toggle-clock      changes the state of the clock line.

set-clock-high    changes the state of the clock to logic 1.

set-clock-low     changes the state of the clock to logic 0.

wait-byte         polls the 8520 for a byte ready.

read-error        calls toggle-clock and wait-byte,  then returns
                  to the main if there are no errors.

store-data        stores data in a particular memory location.

last-byte         depending  on  sector size,  will increment and
                  compare value to sector size.

serial-in         sets the 8520 serial port and driver circuit to
                  input mode.

read-err          calls wait-byte and evaluates the status of the
                  previous controller job.

serial-out        sets the 8520 serial port and driver circuit to
                  output mode.

send-byte         sends a byte of data to the 1581.

read-1581         sends a typical unit read to a 1581.

write-1581        sends a typical unit write to a 1581."
"In the context of the C64, What is the format and protocol of the INQUIRE STATUS command in a disk assembly?","1581 disk in assembly: INQUIRE STATUS

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       W      C      M      0      1      1      0      N
-----------------------------------------------------------------
  03                  NEW STATUS (W-BIT CLEAR)
-----------------------------------------------------------------
  04                  NEW ORA MASK (M-BIT SET)
-----------------------------------------------------------------
  05                  NEW AND MASK (M-BIT SET)
-----------------------------------------------------------------

SWITCHES: W -- write switch (0 = write)
          M -- write AND/OR mask (04 new OR mask (M-bit set),  05
          new AND mask (M-bit set))
          C -- change (C=1 and W=0 -- log in disk, C=1 and W=1 --
          return  whether  disk was logged,  i.e. $B error or old
          status)
          N -- drive number
          X -- don't care

PROTOCOL: Burst handshake (W=1), conventional (W=0).

CONVENTIONS: This  is  a  method  of  reading  or writing current
             status, and changing the status mask value.

OUTPUT: None (W=0), Burst status byte (W=1)."
"In the context of the C64, What is the function of the SP_READ command in a 1581 disk controller job?","1581 disk Controller Job commands: SP_READ
       $A4     Reads   the   specified   physical   sector
                      directly  into  RAM starting at #0 ($0300).
                      It does not use the track cache buffer. The
                      sector   is   always  read  from  the  disk
                      regardless  of  the current contents of the
                      track cache."
"In the context of the C64, What is the difference between the logical and physical disk format of the Commodore 1581 disk drive?","1581 disk:  LOGICAL VERSUS PHYSICAL FORMAT

  All  DOS  operations  of  the 1581 are done in 256 byte blocks.
These blocks appear as individually numbered sectors on the disk.
By  going  through the DOS interface via the commands outlined in
this manual, the logical disk format is as follows:

  single sided
  80 tracks (track 1 through track 80)
  40 x 256 byte sectors per track (sector 0 through sector 39)

  Internally,  however,  the 1581 has a different view of things.
The disk is actually formatted as follows:

  double sided (side 0 and side 1)
  80 tracks per side (track 0 through track 79)
  10 x 512 byte sectors per track (sector 1 through sector 10)

  That  is  the  physical  disk  format created whenever a HEADER
(NEW)  command  is  sent  to the 1581 from the host computer. The
physical  format  is different from the logical so that more data
can be squeezed onto each disk.

  All commands sent from the host computer are parsed through the
DOS  (except the BURST commands) and refer to the logical format.
Software  inside the 1581 automatically takes care of the logical
to  physical translations necessary to retrieve the data properly
from the disk."
"In the context of the C64, What is the format and functionality of the CHGUTL UTILITY commands and parameters?","1581 disk in assembly: CHGUTL UTILITY

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       X      X      X      1      1      1      1      0
-----------------------------------------------------------------
  03     UTILITY COMMANDS: 'B','S','R','T','V',#DEV,'MR','MW'
-----------------------------------------------------------------
  04     COMMAND PARAMETER
-----------------------------------------------------------------

SWITCHES: X -- don't care

UTILITY COMMANDS; 'B' -- serial bus mode
                  'S' -- DOS sector interleave
                  'R' -- DOS retries
                  'T' -- ROM signature analysis
                  'V' -- verify select
                  #DEV -- device#

Note: Byte 02 is equivalent to '>'.

EXAMPLES: 'U0>B1' = Fast Serial, 'U0>B0' = Slow Serial
          'U0>S' + CHR$(SECTOR INTERLEAVE)
          'U0>R' + CHR$(RETRIES)
          'U0>T' (If the ROM signature failed, the activity LED
                 blinks 4 times)
          'U0>V0' = Disk Verify ON, 'U0>V1' = Disk Verify OFF
          'U0>' + CHR$(#DEV), where #DEV = 4 - 30
          'U0>MR' + CHR$(>memory address) + (# of pages)*
          'U0>MW' + CHR$(>memory address) + (# of pages)*

 * Burst memory read and memory write use standard burst protocol
   (without status byte)."
"In the context of the C64, What is the purpose and syntax of the SAVE WITH REPLACE command in disk operations?","1581 disk:  SAVE WITH REPLACE

  If a file already exists, it can't be saved again with the same
name  because  the  disk  drive only allows one copy of any given
file name per diskette. It is possible to get around this problem
using the  RENAME and  SCRATCH commands described later. However,
if  all  you  wish to do is replace a program or data file with a
revised  version,  another  command  is more convenient. Known as
SAVE-WITH-REPLACE, or @SAVE.  This option tells the disk drive to
replace any file it finds in the diskette directory with the same
name, substituting the new file for the old version.

FORMAT FOR SAVE WITH REPLACE:

  SAVE '@drive#:file name',device#

where all the parameters are as usual except for adding a leading
'at' sign (@). The 'drive#:' is required here.

EXAMPLE:

  SAVE'@0:REVISED PROGRAM',8

  The  actual  procedure   is  that  the  new  version  is  saved
completely, then the old version is erased. Because it works this
way,  there  is  little  danger  a  disaster such as losing power
midway  through  the  process  would destroy both the old and new
copies  of the file.  Nothing happens to the old copy until after
the new copy is saved properly."
"In the context of the C64, What is the format for a monitor save command on a 1581 disk?","1581 disk: FORMAT FOR A MONITOR SAVE:

  S 'drive#:file name',device#,starting address,ending address+1

where 'drive#:' is the drive number,  0 on the 1581;  'file name'
is any valid file name up to 14 characters long  (leaving two for
the  drive  number  and  colon);  'device#' is a two digit device
number,  normally 08 (the leading 0 is required); and the address
to be saved are given in Hexadecimal but without a leading dollar
sign  ($).  Note  the  ending address listed must be one location
beyond the last location to be saved.

EXAMPLE:

  Here is the required syntax to SAVE a copy of 'DOS 5.1':

  S '0:DOS 5.1',08,CC00,D000"
"In the context of the C64, What is the format and protocol of the FASTLOAD UTILITY disk in assembly?","1581 disk in assembly: FASTLOAD UTILITY

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       P      X      X      1      1      1      1      1
-----------------------------------------------------------------
  03                          FILE NAME
-----------------------------------------------------------------

SWITCHES: P -- sequential file bit (P = 1,  does not have to be a
          program file)
          X -- don't care

PROTOCOL: Burst handshake.

OUTPUT: Burst status byte preceding each sector transferred.

STATUS IS AS FOLLOWS:   0000000X -- OK
                      * 00000010 -- file not found
                     ** 00011111 -- EOI

*  Values between 3 and 15 should be considered a file read error
** The  byte  following the EOI status byte is the number of data
   bytes to follow."
"In the context of the C64, What is the purpose and functionality of the Track Cache Buffer in the 1581 disk drive?","1581 disk:  TRACK CACHE BUFFER

  One  of  the  improvements  in  the  1581  design over previous
Commodore  disk  drives  which makes the device more efficient is
the Track Cache buffer. This buffer is located from $0C00 through
$1FFF.  All  disk  accesses involve an entire physical track at a
time.  If  a single sector is needed from a particular track, the
entire  track is read into RAM.  Consequently,  any more requests
for sectors from the same track require only a RAM data transfer,
rather  than  a  search  of  the  track on the disk again. Sector
writes  are also speeded up considerably,  since each consecutive
write  to  sectors  on  the same track requires only a RAM to RAM
data transfer. After data is written into the Track Cache Buffer,
it  is not written to the disk until one of the following occurs:
1) a request is made for access of a sector on a different track,
2) a  'dump  track  buffer'  command is issued,  or  3) after 250
milliseconds of no serial bus activity."
"In the context of the C64, What error message is displayed when trying to create a new file with a duplicate name on a diskette?","1581 disk: Controller commands error code 63: FILE EXISTS
    A  file  with  the  same name as has been requested for a new
    file already exists on the diskette. Duplicate file names are
    not allowed. Select another name."
"In the context of the C64, What is the error code 26 on a disk controller, and what is its typical cause?","1581 disk: Controller commands error code 26: WRITE PROTECT ON
    The controller has been requested to write a data block while
    the  write-protect  sensor  is  uncovered.  Usually caused by
    writing  to  a  diskette  whose write protect notch is pushed
    back  to  expose  the hole to prevent changing the diskette's
    contents."
"In the context of the C64, What are the jump table vectors and their corresponding descriptions for the 1581 disk controller?","1581 disk:  Indirect Vector Jump Table
Name             Location  Description
-----------------------------------------------------------------
JIDLE              $FF00   Main  idle  loop.  When  a  Controller
                           command is completed  the IDLE routine
                           is executed. It first checks to see if
                           there are any more jobs pending in the
                           Job Queue. If so, it executes them. If
                           not,  it sits in the idle loop waiting
                           for  something  to  happen,   such  as
                           another  job being put into the queue,
                           ATN  line going low,  disk inserted or
                           removed, etc.
JIRQ               $FF03   Interrupt routine. Interrupts normally
                           occur  from  the following sources  --
                           ATN  line going low,  Fast Serial Byte
                           is   shifted   in,   timer  time  out,
                           execution of a BRK instruction.
JNMI               $FF06   Does  a  'soft'  reset  (UI  command).
                           Default   vectors  and  variables  are
                           restored.  Searches for 'COPYRIGHT CBM
                           86'  USR  type  file  to  boot. No RAM
                           check or ROM checksum is done. Device#
                           switches are read.
JVERDIR            $FF09   VALIDATE command (collect).
JINTDRV            $FF0C   INITIALIZE command.
JPART              $FF0F   Routine to create or switch partitions
JMEM               $FF12   Memory  Read/Memory  Write  (M-R, M-W)
                           commands.
JBLOCK             $FF15   Performs all  BLOCK commands,  such as
                           ALLOCATE,  FREE, READ, WRITE, EXECUTE,
                           POINTER.
JUSER              $FF18   USER command.
JRECORD            $FF1B   RECORD   command   for  relative  file
                           positioning.
JUTLODR            $FF1E   Utility loader command (&).
JDSKCPY            $FF21   COPY command.
JRENAME            $FF24   RENAME command.
JSCRTCH            $FF27   SCRATCH command.
JNEW               $FF2A   NEW/Format command.
ERROR              $FF2D   Controller error handler routine.
JATNSRV            $FF30   Serial Bus attention (ATN) server.
JTALK              $FF33   Serial Bus talk routine.
JLISTEN            $FF36   Serial Bus listen routine.
JLCC               $FF39   Controller routine.
JTRANS_TS          $FF3C   Logical to physical sector translation
                           routine.
CMDERR             $FF3F   DOS error handler routine.

JSTROBE_CONTROLLER $FF54   Direct Controller call.
JCBMBOOT           $FF57   CBM autoloader routine.
JCBMBOOTRTN        $FF5A   Return   from   CBM   autoloader  with
                           autoloader disabled.
JSIGNATURE         $FF5D   Signature analysis routine.
JDEJAVU            $FF60   Switch    for   autoloader   boot   on
                           INITIALIZE   or   BURST INQUIRE/QUERY.
                           Enter   with   carry   set  to  enable
                           autoloader, carry clear to disable it.
JSPINOUT           $FF63   SPIN,  SPOUT.   Sets  up  fast  serial
                           direction  as  input or output.  Carry
                           set to do SPOUT, cleared to do SPIN.
JALLOCBUFF         $FF66   Allocates   RAM  buffers.   Call  with
                           buffer#  in  reg A  (1 = buffer 0, 2 =
                           buffer 1...)."
"In the context of the C64, What are the different ways to open a sequential file in BASIC 7.0 and BASIC 2.0, and how can you read and write to these files?","1581 disk with basic 7,0:EXAMPLES OF OPENING SEQUENTIAL FILES:

  To create a sequential file of phone numbers, you could use:

  BASIC 7.0:  DOPEN#2,'PHONES',D0,U8,W
  BASIC 2.0:  OPEN 2,8,2,'0:PHONES,SEQUENTIAL,WRITE'
              or
              OPEN 2,8,2,'0:PHONES,S,W'

  On  the  chance  you've  already  got  a  'PHONES'  file on our
diskette, you can avoid a 'FILE EXISTS' error message by doing an
@OPEN:

  BASIC 7.0:  DOPEN#2,'@PHONES',D0,U8,W
  BASIC 2.0:  OPEN 2,8,2,'@0:PHONES,S,W'

This  erases  all  your old phone numbers,  so make sure that any
information  that  may  be  deleted  is  of  no importance. After
writing  our  phone  file,  remove  the diskette and turn off the
system.  To recall the data in the file, reopen it with something
like:

  BASIC 7.0:  DOPEN#8,'PHONES',D0,U8
  BASIC 2.0:  OPEN 8,8,8,'0:PHONES,S,R'

It doesn't matter  whether the file and channel numbers match the
ones we used before,  but the file name does have to match.  It's
possible  to  use an abbreviation form of the file name, if there
are no other files that would have the same abbreviation:

  BASIC 7.0:  DOPEN#10,'PH*',D0,U8
  BASIC 2.0:  OPEN 10,8,6,'0:PH*,S,R'

  If you have too many phone numbers,  they  might not fit in one
file.  In  that  case,  use  several similar file names and let a
program choose the correct file.

  BASIC 7.0:  100 INPUT'WHICH PHONE NUMBERS FILE (1-3)';PH
              110 IF PH<>1 AND PH<>2 AND PH<>3 THEN 100
              120 DOPEN#4,'PHONE'+STR$(PH),D0,U8

  BASIC 2.0:  100 INPUT'WHICH PHONE NUMBERS FILE (1-3)';PH
              110 IF PH<>1 AND PH<>2 AND PH<>3 THEN 100
              120 OPEN 4,8,2,'PHONE'+STR$(PH)+',S,R'

You can omit the drive number on an OPEN command  to read a file.
Doing  so  allows those with dual drives to search both diskettes
for the file."
"In the context of the C64, What is the BASIC code to read a relative record from a disk file in both variable and fixed length fields formats?","1581 disk:  READING A RELATIVE RECORD

  Once  a  relative record has been written properly to diskette,
reading it back  into computer memory  is fairly simple,  but the
procedure  again  varies,  depending  on whether it uses fixed or
variable  length  fields.  Here  are  the program lines needed to
read  back  the  variable fields created above from record number
RE in file and channel 3:

BASIC 7.0:

start tok64 /128 readv128.prg
   10 :
   20 dopen#3,'myrelfile',l88
   30 input'enter record number';re
   40 :
   50 :
   60 record#3,(re),1
   70 gosub 1000
   80 input#3,na$,sa$,cs$,zp$
   90 gosub 1000
  100 record#3,(re),1
  110 gosub 1000
  120 print na$:print sa$
  130 print cs$:print zp$
  140 dclose#3:end
 1000 if ds<20 then return
 1002 :
 1010 print'error:';ds$:dclose#3:end

BASIC 2.0:

start tok64 readv64.prg
   10 open 15,8,15
   20 open 3,8,3,'myrelfile,l,'+chr$(88)
   30 input'enter record number';re
   40 rh=int(re/256)
   50 rl=re-256*rh
   60 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
   70 gosub 1000
   80 input#3,na$,sa$,cs$,zp$
   90 gosub 1000
  100 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  110 gosub 1000
  120 print na$:print sa$
  130 print cs$:print zp$
  140 close 3:close 15:end
 1000 input#15,en,em$,et,es
 1002 if en<20 then return
 1010 print'error:';em$:close 3:close 15:end


  Here are the lines  needed to read back  the version with fixed
length fields:

BASIC 7.0:

start tok64 /128 readf128.prg
   10 :
   20 dopen#3,'myrelfile',l88
   30 input'enter record number';re
   40 :
   50 :
   60 record#3,(re),1
   70 gosub 1000
   80 input#3,da$
   90 gosub 1000
  100 record#3,(re),1
  110 gosub 1000
  112 na$=left$(da$,27)
  114 sa$=mid$(da$,28,27)
  116 cs$=mid$(da$,55,23)
  118 zp$=right$(da$,10)
  120 print na$:print sa$
  130 print cs$:print zp$
  140 dclose#3:end
 1000 if ds<20 then return
 1002 :
 1010 print'error:';ds$:dclose#3:end


BASIC 2.0:

start tok64 readf64.prg
   10 open 15,8,15
   20 open 3,8,3,'myrelfile,l,'+chr$(88)
   30 input'enter record number';re
   40 rh=int(re/256)
   50 rl=re-256*rh
   60 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
   70 gosub 1000
   80 input#3,da$
   90 gosub 1000
  100 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  110 gosub 1000
  112 na$=left$(da$,27)
  114 sa$=mid$(da$,28,27)
  116 cs$=mid$(da$,55,23)
  118 zp$=right$(da$,10)
  120 print na$:print sa$
  130 print cs$:print zp$
  140 close 3:close 15:end
 1000 input#15,en,em$,et,es
 1002 if en<20 then return
 1010 print'error:';em$:close 3:close 15:end"
"In the context of the C64, What is an example of a BASIC 7.0 program that demonstrates the use of sequential files?","1581 disk with basic 7,0: DEMONSTRATION OF SEQUENTIAL FILES (BASIC 7.0)

  Use  the  following  program  for  your  first experiments with
sequential  files.  Comments  have  been added to help you better
understand it.

 150 cr$=chr$(13)                 Make a carriage return variable
 170 print chr$(147):rem clear
     screen
 190 print'** write a file **'
 210 print
 220 dopen#2,'@seq file',w        Open demo file with replace
 230 gosub 500                    Check for disk errors
 240 print'enter a word,
     then a number'
 250 print'or 'end,0' to stop'
 260 print
 270 input a$,b                   Accept a string & number
                                  from keyboard
 280 print#2,a$;cr$;b             Write them to the disk file
 290 gosub 500
 300 if a$<>'end' then 270
 310 print
 320 dclose#2                     Tidy up
 340 print'** read same file
     back **'
 360 print
 370 dopen#2,'seq file'           Reopen same file for reading
 380 gosub 500
 390 input#2,a$,b                 Read next string & number
                                  from file
 400 rs=st
 410 gosub 500
 420 print a$,b                   Display file contents
 430 if rs=0 then 390             until done,
 440 if rs<>64 then
     print'status=';rs            unless there's an error
 450 dclose#2                     Then quit
 460 end
 480 rem ** error check s/r **
 500 if ds>0 then print ds$:stop
 510 return"
"In the context of the C64, What is the purpose and syntax of the GET# statement in BASIC, and how is it used to retrieve data from a disk drive?","1581 disk with basic 7,0: READING FILE DATA: USING GET#

  The  GET#  statement  retrieves  data  from the disk drive, one
character  at a time.  Like the similar keyboard GET statement in
BASIC,  it  only  accepts  a  single  character  into a specified
variable. However, unlike the GET statement, it doesn't just fall
through  to  the next statement if there is no data to be gotten.
The  primary  use  of  GET# is to retrieve from diskette any data
that  cannot be read into an INPUT# statement,  either because it
is  too  long  to  fit in the input buffer or because it includes
troublesome characters.

FORMAT FOR THE GET# STATEMENT:

  GET#file#,variable list

where 'file#' is the same file number given in the desired file's
current OPEN statement,  and 'variable list' is one or more valid
BASIC  variable  names.  If  more  than one data element is to be
input by a particular GET# statement,  each variable name must be
separated from others by a comma.
  In practice,  you will almost never see a GET or GET# statement
containing  more  than  one  variable  name.  If  more  than  one
character  is  needed,  a  loop  is  used  rather than additional
variables.  Also  as in the INPUT# statement,  it is safer to use
string  variables  when  the file to be read might contain a non-
numeric character.
  Data in a GET# statement comes in byte-by-byte,  including such
normally  invisible  characters  as  the Carriage Return, and the
various cursor controls.  All but one will be read properly.  The
exception is CHR$(0),  the ASCII Null character.  It is different
from an empty string  (one of the form A$=''),  even though empty
strings are often referred to as null strings.  Unfortunately, in
a GET# statement,  CHR$(0) is converted into an empty string. The
cure is to test for an empty string after a GET#, and replace any
that  are  found  with  CHR$(0) instead.  The first example below
illustrates the method.

EXAMPLES:

  To  read  a file that may contain a CHR$(0),  such as a machine
language program file, you could correct any CHR$(0) bytes with

  1100 GET#3,G$:IF G$='' THEN G$=CHR$(0)

  If an overlong string has managed to be recorded in a file,  it
may be read back safely into the computer with GET#, using a loop
such as this

  3300 B$=''
  3310 GET#1,A$
  3320 IF A$<>CHR$(13) THEN B$=B$+A$: GOTO 3310

The limit for such a technique is 255 characters.  It will ignore
CHR$(0),  but that may be an advantage in building a text string.
If CHR$(0) is required in the file, then add the following line:

  3315 IF A$='' THEN A$=CHR$(0)

  GET# may be useful in recovering damaged files,  or files  with
unknown contents. The BASIC reserved variable ST (the file STatus
variable)  can  be used to indicate when all of a properly closed
file has been read.

  500 GET#2,S$
  510 SU=ST: REM REMEMBER FILE STATUS
  520 PRINT S$;
  530 IF SU=0 THEN 500: REM IF THERE'S MORE TO BE READ
  540 IF SU<>64 THEN PRINT'STATUS ERROR: ST =';SU

Copying  ST into  SU is often an unnecessary precaution, but must
be done  if any other file-handling statement appears between the
one which read from the file  and the one that loops back to read
again.  For example, it would be required if line 520 was changed
to

  520 PRINT#1,S$;

Otherwise,  the  file status checked in line 530 would be that of
the write file, not the read file.

  The  following  table applies to single errors or a combination
of two or more errors.

|       POSSIBLE VALUES OF THE FILE STATUS VARIABLE 'ST',       |
|                       AND THEIR MEANINGS                      |
|                                                               |
| IF ST=                        THEN                            |
|    0     All is OK                                            |
|    1     Receiving device was not available                   |
|          (time out on talker)                                 |
|    2     Transmitting device was not available                |
|          (time out on listener)                               |
|    4     Cassette data file block was too short               |
|    8     Cassette data file block was too long                |
|   16     Unrecoverable read error from cassette, verify error |
|   32     Cassette checksum error -- one or more faulty        |
|          characters were read                                 |
|   64     End of file reached (EOI detected)                   |
|  128     Device not present, or end of tape mark found        |
|          on cassette                                          |"
"In the context of the C64, What is the BASIC 2.0 code to write a record to a file?","BASIC 2.0:

start tok64 writef64.prg
  100 input'enter record number';re
  110 open 15,8,15
  120 open 3,8,3,'myrelfile,l,'+chr$(88)
  130 bl$='{160*27}'
  140 input'name';na$
  145 ln=len(na$)
  150 if ln>27 then 140
  155 na$=na$+left$(bl$,27-ln)
  160 input'street';sa$
  165 ln=len(sa$)
  170 if ln>27 then 160
  175 sa$=sa$+left$(bl$,27-ln)
  180 input'city & state';cs$
  185 ln=len(cs$)
  190 if ln>23 then 180
  195 cs$=cs$+left$(bl$,23-ln)
  200 input'zip code';zp$
  205 ln=len(zp$)
  210 if ln>10 then 200
  215 zp$=zp$+left$(bl$,10-ln)
  220 da$=na$+sa$+cs$+zp$
  260 rh=int(re/256)
  270 rl=re-256*rh
  280 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  290 gosub 1000:if en=50 then print#3,chr$(255):gosub 1000:\
      goto 280
  300 gosub 1000
  310 print#3,da$
  320 gosub 1000
  330 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  340 gosub 1000
  350 close 3:close 15:end
 1000 input#15,en,em$,et,es
 1002 if en<20 then return
 1010 print'error:';em$:close 3:close 15:end"
"In the context of the C64, What is the syntax for opening a sequential file in BASIC 7.0 and BASIC 2.0?","1581 disk with basic 7,0: FORMAT FOR THE DISK OPEN STATEMENT FOR SEQUENTIAL FILES:

  BASIC 7.0: DOPEN#file#,'file name'[,Ddrive#][,Udevice#][,W]
  BASIC 2.0: OPEN file#,device#,channel#,'drive#:file name,
                                          file type,direction'"
"In the context of the C64, How do you change the device number of a 1581 disk drive?","1581 disk: CHANGING THE DEVICE NUMBER

  Two  switches  on the back of the 1581 enable you to change the
device#  of  the drive.  You can use a screwdriver,  pen,  or any
other  small tool to set the switches.  The following table shows
the settings required for each device number:

            +------------+------------+-------------+
            |    Left    |    Right   |   Device#   |
            +------------+------------+-------------+
            |     UP     |     UP     |      8      |
            |    DOWN    |     UP     |      9      |
            |     UP     |    DOWN    |      10     |
            |    DOWN    |    DOWN    |      11     |
            +------------+------------+-------------+

  Another  way  to temporarily change the device number of a disk
drive is via a program.  When power is first turned on, the drive
reads  an  I/O  location  whose  value  is  controlled by the two
switches  on  its circuit board,  and writes the device number it
reads  there  into  memory  locations  119  and  120.   Any  time
thereafter, you may write over that device number with a new one,
which will be effective until it is changed again, or the 1581 is
reset."
"In the context of the C64, What is the error message and explanation for a CRC error in the header of a requested data block on a disk controller?","1581 disk: Controller commands error code 27: READ ERROR (CRC error in header)
    The  controller  detected an error in the header bytes of the
    requested  data  block.  The  block  was  not  read into disk
    memory."
"In the context of the C64, What error message is displayed when trying to access a file with a mismatched type?","1581 disk: Controller commands error code 64: FILE TYPE MISMATCH
    The  requested file access is not possible using files of the
    type named. Reread the chapter covering that file type."
"In the context of the C64, What error message is displayed when a user enters an invalid command in DOS?","1581 disk: Controller commands error code 31: SYNTAX ERROR (invalid command)
    The  DOS  does not recognize the command.  It must begin with
    the first character sent. Check your typing and try again."
"In the context of the C64, What is the disk command that allows you to read bytes from disk memory into the computer, similar to the BASIC PEEK() function?","1581 disk:  MEMORY-READ

  The 6502 has an address  space  from  $0000-$FFFF.  You can get
direct  access  to  any  location  within  this  by  using memory
commands. MEMORY-READ allows you to select which byte or bytes to
read from disk memory into the computer.  The MEMORY-READ command
is  the  equivalent  of the BASIC PEEK() function,  but reads the
disk's memory instead of the computer's memory.


|   Unlike other disk commands, those in this chapter cannot be |
| spelled out in full. Thus, M-R is correct, but MEMORY-READ is |
| not a permitted alternate wording.                            |"
"In the context of the C64, What is the error message and explanation for a DOS error code 66?","1581 disk: Controller commands error code 66: ILLEGAL TRACK AND SECTOR
    The  DOS has attempted to access a track or sector which does
    not  exist.  May  indicate  a faulty link pointer in the data
    block."
"In the context of the C64, What are the advantages and types of random access files on Commodore disk drives?","1581 disk with basic 7,0: RELATIVE DATA FILES


  Sequential files are very useful  when you're just working with
a continuous stream of data --  i.e. information that can be read
or written all at once.  However, sequential files are not useful
in some situations.  For  example,  after writing a large list of
mail labels,  you wouldn't want to have to reread the entire list
each time you need a person's record. Instead, you need some kind
of random access, a way to get to a particular label in your file
without having to read through all those preceding it.
  As  an  example,  compare  a  record  turntable with a cassette
recorder. You have to listen to a cassette from beginning to end,
but  a  turntable  needle  can  be  picked  up  at  any time, and
instantly moved to any spot on the record.  Your disk drive works
like a turntable in that respect.  In this chapter you will learn
about a type of file that reflects this flexibility.
  Actually,  two  different  types  of random access files may be
used on Commodore disk drives:  relative files  and random files.
Relative  files  are  much more convenient for most data handling
operations,  but  true  random  access  file  commands  are  also
available  to  advanced users,  and will be discussed in the next
chapter."
"In the context of the C64, What is the purpose of using index files in conjunction with sequential and relative files?","1581 disk:  THE VALUE OF INDEX FILES

  In the last two chapters you have learned how to use sequential
and relative files separately.  But they are often used together,
with the sequential file used to keep brief records of which name
in  the  relative  file is stored in each record number. That way
the  contents  of  the  sequential file can be read into a string
array and sorted alphabetically. After sorting, a technique known
as a binary search can be used to quickly find an entered name in
the  array,  and  read  in  or write the associated record in the
relative  file.  Advanced  programs can maintain two or more such
index files, sorted in differing ways simultaneously."
"In the context of the C64, What are direct access commands used for on a diskette?","1581 disk:  DIRECT ACCESS COMMANDS


  Direct  access  commands  specify  individual  sectors  on  the
diskette,  reading  and  writing  information entirely under your
direction.  This  gives them almost complete flexibility in data-
handling programs, but imposes tremendous responsibilities on the
programmer.  As a result,  they are normally used only in complex
commercial  programs  able to properly organize data without help
from the disk drive itself.
  A far more common use of direct access commands is  in  utility
programs  used  to  view and alter parts of the diskette that are
not normally seen directly.  For  instance,  such commands can be
used to change the name of a diskette  without erasing all of its
programs,  to lock a program so it can't be erased,  or hide your
name in a location where it won't be expected."
"In the context of the C64, What is the concept of organizing data in a relative file, and how does it differ from sequential files in terms of structure and access speed?","1581 disk with basic 7,0: FILES, RECORDS, AND FIELDS

  When learning about sequential files,  you  did not worry about
the organization of data within a file,  so long as the variables
used to write the file  matched up properly with those which read
it  back  into the computer.  But in order for relative access to
work,  you need a more structured and predictable environment for
our data.
  The  structure  you  will  use  is  similar to that used in the
traditional filing cabinet. In a traditional office, all customer
records might be kept in a single file cabinet. Within this file,
each  customer  has a personal record in a file folder with their
name on it,  that contains everything the office knows about that
person.  Likewise,  within  each  file folder,  there may be many
small  slips  of  paper,  each  containing one bit of information
about  that customer,  such as a home phone number or the date of
the most recent purchase.
  In  a  computerized office,  the file cabinet is gone,  but the
concept of a file containing all the information about a group or
topic  remains.  The file folders are gone too, but the notion of
subdividing the file into individual records remains. The slip of
paper  within  the  personal  records  are gone too,  replaced by
subdivisions  within  the records,  called fields.  Each field is
large enough to hold one piece of information about one record in
the  file.  Thus,  within  each  file there are many records, and
within each record there are typically many fields.
  A  relative  file takes care of organizing the records for you,
numbering them from 1 to the highest record number,  by ones, but
the fields are up to you to organize.  Each record will be of the
same size, but the 1581 won't insist that they all be divided the
same way. On the other hand, they normally will be subdivided the
same  way,  and  if it can be known in advance exactly where each
field  starts  within  each  record,  there are even fast ways to
access  a  desired  field within a record without reading through
the  other  fields.  As  all  of this implies,  access speed is a
primary reason for putting information into a relative disk file.
Some  well-written  relative  file  programs are able to find and
read  the record of one desired person out of a thousand in under
15 seconds, a feat no sequential file program could match."
"In the context of the C64, What is the memory map and functionality of the Commodore 1581 disk drive?","1581 disk:  1581 MEMORY MAP

Location                        Purpose
-----------------------------------------------------------------
0000-00FF       Zero page work area, job queue, variables
0100-01FF       Stack, variables, vectors
0200-02FF       Command buffer, tables, variables
0300-09FF       Data buffers (0-6)
0A00-0AFF       BAM for tracks 0-39
0B00-0BFF       BAM for tracks 40-79
0C00-1FFF       Track cache buffer
4000-5FFF       8520A CIA
6000-7FFF       WD177X FDC
8000-FEFF       32K byte ROM, DOS and controller routines
FF00-FFFF       Jump table, vectors
-----------------------------------------------------------------
|   The  1581,  as  well  as  other  Commodore  peripherals, is |
| designed   to   support   interfacing  via  software  command |
| structures.  The software commands provided in the 1581 allow |
| for   a   smooth   and  controllable  interface  between  the |
| peripheral  and  CPU.  Although  Commodore  has  provided the |
| mechanism  enabling  users  to  load  and  execute  their own |
| machine language programs within the 1581 system, please keep |
| in mind that Commodore reserves the right to change ROM, RAM, |
| I/O and hardware structure at any time.  Consequently, if the |
| defined software interface is bypassed,  future compatibility |
| of  the  user's machine language software within the 1581 may |
| be in question. The 1581 was not designed primarily as a user |
| programmable  device,  but Commodore recognizes that  certain |
| operations   (such  as  copy  protection)  cannot  be  easily |
| achieved without this ability.                                |


  If  you  find  it  necessary to use machine language within the
1581,  use  the jump table listed in this chapter and Chapter 10.
That  will  lessen the possibility of incompatibility if a future
version of the 1581 changes internally.  Also, let the controller
work for you on the physical level by requesting its help via the
JOB QUEUE.  That  too  will  greatly  increase  the likelihood of
future compatibility."
"In the context of the C64, What is the error code 65 on a disk controller and how should you respond to it?","1581 disk: Controller commands error code 65: NO BLOCK
    Occurs  in  conjunction  with  B-A.  The  sector you tried to
    allocate  is already allocated.  The track and sector numbers
    returned  are  the next higher track and sector available. If
    the  track  number  returned is 0,  all remaining sectors are
    full. If the diskette is not full yet,  try a lower track and
    sector."
"In the context of the C64, What is the error message and explanation for a DOS error code 30?","1581 disk: Controller commands error code 30: SYNTAX ERROR (general syntax)
    The  DOS  cannot  interpret  the  command sent to the command
    channel.  Typically,  this  is caused by an illegal number of
    file  names or an illegal pattern.  Check your typing and try
    again."
"In the context of the C64, What are the key features and considerations of the Burst Command Instruction Set (BCIS) for the 1581 disk?","1581 disk:  BURST COMMANDS


  The  Burst  Command  Instruction  Set  (BCIS)  is  a  series of
powerful,  versatile,  and complex commands that enables the user
to format,  read,  and write in numerous formats.  Burst commands
are sent via kernal calls, but the handshaking of data is done by
the user for maximum performance. There is no parameter checking,
so exercise care  when using the BCIS.  For instance,  if a burst
read  with an illegal track address is sent to a 1581,  the drive
will keep trying to find the invalid track.  Reading  and writing
in other formats is automatic if the commands are given in proper
sequence. Please become thoroughly familiar with all the commands
and follow the examples given in this chapter.  It's important to
follow the handshake conventions exactly for maximum performance.
  With the exception of  READ  and  WRITE,  burst commands do not
translate  from  logical to physical track and sector.  All track
and  sector  parameters  refer to physical locations (see Chapter
10).  Burst  sector  READ  and  WRITE  commands provide a flag to
enable logical to physical translation.  If the flag is set,  the
drive  does  the  translation  and  the default logical number of
bytes  per  sector  (256)  is transferred instead of the physical
number of bytes per sector (512)."
"In the context of the C64, What is the error message and explanation for a DOS error code 34?","1581 disk: Controller commands error code 34: SYNTAX ERROR (no file given)
    The  file  name was left out of a command or the DOS does not
    recognize  it  as  such.  Typically,  a  colon (:)  has  been
    omitted. Try again."
"In the context of the C64, What is the error code 61 in DOS and what does it indicate?","1581 disk: Controller commands error code 61: FILE NOT OPEN
    A file is being accessed that has not been opened by the DOS.
    In some such cases no error message is generated.  Rather the
    request is simply ignored."
"In the context of the C64, What is the format for the RECORD# command in BASIC 7.0 and BASIC 2.0, and how does it work?","FORMAT FOR THE RECORD# COMMAND:

  BASIC 7.0: RECORD#file#,record number[,offset]
  BASIC 2.0: PRINT#15,'P'+CHR$(channel#+96)+CHR$(<record#)+
             CHR$(>record#)+CHR$(offset)

where  'file#'  is  the  file#  specified  in  the  current DOPEN
statement for the specified file,  'record number' is the desired
record number,  'channel#' is the channel number specified in the
current OPEN statement for the specified file,  '<record#' is the
low  byte  of the desired record number,  expressed as a two-byte
integer,  '>record#'  is  the  high  byte  of  the desired record
number,  and an optional 'offset' value,  if present, is the byte
within  the  record  at  which  a  following Read or Write should
begin.
  To fully understand this command,  you must understand how most
integers  are  stored  in computers based on the 6502 and related
microprocessors.   In   the   binary   arithmetic   used  by  the
microprocessor,  it  is  possible to express any unsigned integer
from  0-255  in  a single byte.  It is also possible to store any
unsigned integer from 0-65535 in two bytes, with one byte holding
the  part  of the number that is evenly divisible by 256, and any
remainder  in the other byte.  In machine language,  such numbers
are  written backwards,  with the low-order byte  (the remainder)
first,  followed  by  the  high-order byte.  In assembly language
programs written with the Commodore Assembler,  the low part of a
two-byte  number  is  indicated  by  preceding its label with the
less-than character (<).  Similarly,  the high part of the number
is indicated by greater-than (>).

|   To avoid the remote possibility of corrupting relative file |
| data, it is necessary to give RECORD# command once before the |
| Read or Write access and once after the access.               |
|   Although  this  is  not  necessary  for  the  1581,   other |
| Commodore drives require it. To make your programs compatible |
| with those other drives, it's a good idea to use it.          |

EXAMPLES:

  In  BASIC  7.0,  to  position the record pointer for file #2 to
record number 3, type:

  RECORD#2,3

  In BASIC 2.0,  to position the record pointer for channel #2 to
record number 3, type:

  PRINT#15,'P'+CHR$(98)+CHR$(3)+CHR$(0)

The  CHR$(98)  comes from adding the constant (96) to the desired
channel  number  (2).  (96+2=98)  Although the command appears to
work  even  when  96  is  not  added  to  the channel number, the
constant is normally added to maintain compatibility with the way
RECORD# works in BASIC 7.0.
  Since  3  is  less  than  256,  the  high  byte  of  its binary
representation is 0, and the entire value fits into the low byte.
Since you want to read or write from the beginning of the record,
no offset value is needed.
  Since these calculations quickly become tedious,  most programs
are  written to do them for you.  Here is an example of a program
which  inputs  a  record number and converts it into the required
low-byte/high-byte form:

  450 INPUT'RECORD NUMBER DESIRED';RE
  460 IF RE<1 OR RE>65535 THEN 450
  470 RH=INT(RE/256)
  480 RL=RE-256*RH
  490 PRINT#15,'P'+CHR$(98)+CHR$(RL)+CHR$(RH)

Assuming  RH  and  RL  are calculated as in the previous example,
programs  may  also  use  variables  for  the channel, record and
offset required:

  570 INPUT'CHANNEL, RECORD, OFFSET DESIRED';CH,RE,OF
  630 PRINT#15,'P'+CHR$(CH+96)+CHR$(RL)+CHR$(RH)+CHR$(OF)"
"In the context of the C64, What is the BASIC 7.0 code to create a program that accepts user input for a record number, name, street, city and state, and zip code, and then writes this data to a file with fixed-length fields?","To  use  the  above  program  lines  for the version with fixed
length fields, we would alter a few lines as follows:

BASIC 7.0:

start tok64 /128 writf128.prg
  100 input'enter record number';re
  110 :
  120 dopen#3,'myrelfile',l88
  130 bl$='{160*27}'
  140 input'name';na$
  145 ln=len(na$)
  150 if ln>27 then 140
  155 na$=na$+left$(bl$,27-ln)
  160 input'street';sa$
  165 ln=len(sa$)
  170 if ln>27 then 160
  175 sa$=sa$+left$(bl$,27-ln)
  180 input'city & state';cs$
  185 ln=len(cs$)
  190 if ln>23 then 180
  195 cs$=cs$+left$(bl$,23-ln)
  200 input'zip code';zp$
  205 ln=len(zp$)
  210 if ln>10 then 200
  215 zp$=zp$+left$(bl$,10-ln)
  220 da$=na$+sa$+cs$+zp$
  260 :
  270 :
  280 record#3,(re),1
  290 if ds=50 then print#3,chr$(255):gosub 1000:goto 280
  300 gosub 1000
  310 print#3,da$
  320 gosub 1000
  330 record#3,(re),1
  340 gosub 1000
  350 dclose#3:end
 1000 if ds<20 then return
 1002 :
 1010 print'error:';ds$:dclose#3:end"
"In the context of the C64, What command should you type to properly close all open disk files in BASIC when it halts with an error?","1581 disk:  If  BASIC  halts with an error when you have files open, BASIC
aborts  them  without closing them properly on the disk. To close
them properly on the disk, you must type:

  CLOSE 15: OPEN 15,8,15,'I': CLOSE 15

This  opens  the command channel and immediately closes it, along
with all other disk files.  Failure to close a disk file properly
both  in  BASIC  and  on the disk may result in losing the entire
file."
"In the context of the C64, what is the format for the VERIFY command?","FORMAT FOR THE VERIFY COMMAND:

  VERIFY 'drive#:pattern',device#,relocate flag

where  'drive#:'  is  an optional drive number,  'pattern' is any
string expression that evaluates to a file name,  with or without
pattern-matching  characters,  and  'device#'  is the disk device
number, normally 8. If the relocate flag is present and equals 1,
the  file  will  be verified where originally saved,  rather than
relocated into the BASIC text area.

A useful alternate form of the command is:

  VERIFY '*',device#

It  verifies  the last files used without having to type its name
or drive number. However, it won't work properly after SAVE-WITH-
REPLACE,  because the last file used was the one deleted, and the
drive  will  try  to  compare  the deleted file to the program in
memory.  No  harm will result,  but 'VERIFY ERROR' will always be
announced.  To  use VERIFY after @SAVE,  include at least part of
the file name that is to be verified in the pattern.

  One  other  note  about  VERIFY  -- when you VERIFY a relocated
BASIC  file,  an  error  will  nearly always be announced, due to
changes  in  the  link  pointers  of  BASIC  programs made during
relocation.  It  is best to VERIFY files saved from the same type
of  machine,  and  identical  memory  size.  For example, a BASIC
program  saved from a Plus/4 can't be verified easily with a C64,
even  when  the  program  would  work fine on both machines. This
shouldn't  matter,  as the only time you'll be verifying files on
machines  other  than  the  one  which wrote them is when you are
comparing  two  disk  files  to see if they are the same. This is
done by loading one and verifying against the other, and can only
be  done  on the same machine and memory size as the one on which
the files were first created."
"In the context of the C64, What is an example of a BASIC program to write a record to a relative file in Commodore 64?","1581 disk: WRITING THE RECORD

  Here  is  an  example of program lines to enter variable length
fields for the above file design,  build them into a string,  and
send them to record number RE  in file number 3  (assumed to be a
relative file that uses channel number 3).

BASIC 7.0:

start tok64 /128 writv128.prg
  100 input'enter record number';re
  110 :
  120 dopen#3,'myrelfile',l88
  130 cr$=chr$(13)
  140 input'name';na$
  150 if len(na$)>30 then 140
  160 input'street';sa$
  170 if len(sa$)>30 then 160
  180 input'city & state';cs$
  190 if len(cs$)>25 then 180
  200 input'zip code';zp$
  210 if len(zp$)>10 then 200
  220 da$=na$+cr$+sa$+cr$+cs$+cr$+zp$
  230 if len(da$)<88 then 260
  240 print'record too long'
  250 goto 140
  260 :
  270 :
  280 record#3,(re),1
  290 if ds=50 then print#3,chr$(255):gosub 1000:goto 280
  300 gosub 1000
  310 print#3,da$
  320 gosub 1000
  330 record#3,(re),1
  340 gosub 1000
  350 dclose#3:end
 1000 if ds<20 then return
 1002 :
 1010 print'error:';ds$:dclose#3:end


BASIC 2.0:

start tok64 writev64.prg
  100 input'enter record number';re
  110 open 15,8,15
  120 open 3,8,3,'myrelfile,l,'+chr$(88)
  130 cr$=chr$(13)
  140 input'name';na$
  150 if len(na$)>30 then 140
  160 input'street';sa$
  170 if len(sa$)>30 then 160
  180 input'city & state';cs$
  190 if len(cs$)>25 then 180
  200 input'zip code';zp$
  210 if len(zp$)>10 then 200
  220 da$=na$+cr$+sa$+cr$+cs$+cr$+zp$
  230 if len(da$)<88 then 260
  240 print'record too long'
  250 goto 140
  260 rh=int(re/256)
  270 rl=re-256*rh
  280 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  290 gosub 1000:if en=50 then print#3,chr$(255):gosub 1000:\
      goto 280
  300 gosub 1000
  310 print#3,da$
  320 gosub 1000
  330 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  340 gosub 1000
  350 close 3:close 15:end
 1000 input#15,en,em$,et,es
 1002 if en<20 then return
 1010 print'error:';em$:close 3:close 15:end"
"In the context of the C64, What is the recommended approach when opening a relative file for the first time to ensure reliable usage and avoid potential issues?","USING RELATIVE FILES: RECORD# COMMAND

  When  a  relative file is opened for the first time,  it is not
quite ready for use. Both to save time when using the file later,
and to assure  that the file will work reliably,  it is necessary
to  create  several records before closing the file for the first
time.  At  a  minimum,  enough records to fill more than two disk
sectors (512 bytes) should be written. In practice, most programs
go ahead  and create as many records as the program is eventually
expected  to  use.  That  approach  has the additional benefit of
avoiding  such  problems  as  running out of room on the diskette
before the entire file is completed.
  If  you  simply  begin  writing  data to a just-opened relative
file,  it will act much like a sequential file,  putting the data
elements  written  by  the  first  PRINT# statement in record #1,
those  written by the second PRINT# statement in record #2 and so
on.  This  means  each  record must be written by a single PRINT#
statement,  using  embedded  carriage  returns within the data to
separate  fields  that  will  be  read  in via one or more INPUT#
statements later. However, it is far better to explicitly specify
which record number is desired via a RECORD# command to the disk.
This  allows  you to access records in any desired order, hopping
anywhere in a file with equal ease."
"In the context of the C64, What is the error message displayed when a file is not found on the specified drive?","1581 disk: Controller commands error code 62: FILE NOT FOUND
    The  requested  file  does  not exist on the indicated drive.
    Check your spelling and try again."
"In the context of the C64, What is the format and protocol of the READ command in a disk assembly, including the byte structure, switches, and conventions?","1581 disk in assembly :  CMD 1 -- READ

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       L      E      X      S      0      0      0      N
-----------------------------------------------------------------
  03                       DESTINATION TRACK
-----------------------------------------------------------------
  04                       DESTINATION SECTOR
-----------------------------------------------------------------
  05                       NUMBER OF SECTORS
-----------------------------------------------------------------
  06                      NEXT TRACK (OPTIONAL)
-----------------------------------------------------------------

RANGE: All  values  are  determined by the particular disk format
       and format of translation table.

SWITCHES: L -- logical flag(1=do logical to physical translation)
          E -- ignore error (1 = ignore)
          S -- side select
          N -- drive number

PROTOCOL: Burst handshake.

CONVENTIONS: Before you can READ or WRITE to a diskette,  it must
             be logged-in using either the  INQUIRE DISK or QUERY
             DISK FORMAT command (both are described later). This
             must be done once each time you change diskettes.

OUTPUT: One burst status byte,  followed  by burst data,  is sent
        for each sector transferred.  An error prevents data from
        being sent unless the E bit is set."
"In the context of the C64, What is the error message displayed when a syntax error occurs in a controller command?","1581 disk: Controller commands error code 39: SYNTAX ERROR (invalid command)
    The  DOS  does  not  recognize  a command sent to the command
    channel  (secondary  address  15).  Check your typing and try
    again."
"In the context of the C64, What is the error code 25 on a disk controller and what does it indicate?","1581 disk: Controller commands error code 25: WRITE ERROR (write-verify error)
    The  controller  has  detected  a  mismatch  between the data
    written  to  diskette  and  the same data in disk memory. May
    mean  the diskette is faulty.  If so,  try another.  Use only
    high-quality diskettes from reputable makers."
"In the context of the C64, What error message is displayed when a write file that has not been closed is reopened for reading?","1581 disk: Controller commands error code 60: WRITE FILE OPEN
    A  write  file that has not been closed is being reopened for
    reading.  This file must be immediately rescued, as described
    in  BASIC  Hint #2  in  Chapter 2,  or it will become a splat
    (improperly closed) file and probably be lost."
"In the context of the C64, What error message is displayed when using pattern matching characters in a file name while trying to save or open a file for writing?","1581 disk: Controller commands error code 33: SYNTAX ERROR (invalid file name)
    Pattern  matching  characters  cannot  be  used  in  the SAVE
    command  or when Opening files for the purpose of Writing new
    data. Spell out the file name."
"In the context of the C64, What are the commands used to read and write relative file data, and how do they differ from sequential file programming?","1581 disk: WRITING RELATIVE FILE DATA

  The commands used  to read and write relative file data are the
same  PRINT#,  INPUT#,  and  GET# commands  used in the preceding
chapter  on  sequential files.  Each command is used as described
there.  However,  some  aspects of relative file access do differ
from  sequential  file  programming,  and  we  will  cover  those
differences here."
"In the context of the C64, What are the limitations and benefits of using relative files in DOS?","FILE LIMITS

  With  relative  files,  you  don't  have to worry about exactly
where  on  the  diskette's surface a given record will be stored,
or  whether  it will fit properly within the current disk sector,
or need to be extended onto the next available sector.  DOS takes
care of all that for you.  All you need to do is specify how long
each  record  is,  in bytes,  and how many records you will need.
DOS  will do the rest,  and organize things in such a way that it
can  quickly find any record in the file,  as soon as it is given
the record number (ordinal position within the file).
  The  only  limit that will concern you is that each record must
be  the  same  size,  and  the  record  length you choose must be
between 2 and 254 characters.  Naturally the entire file also has
to fit on your diskette, along with any other existing file(s)."
"In the context of the C64, How can commas and colons be safely included within a data element when using INPUT or INPUT# statements in BASIC?","1581 disk with basic 7,0: COMMAS (,) AND COLONS (:)

  commas  and colons can cause trouble in a
file,  because they delimit  (end) the data element in which they
appear  and cause any remaining characters in the data element to
be read into the next INPUT# variable.  They have the same effect
in an INPUT statement,  causing the common  'EXTRA IGNORED' error
message.  However,  sometimes  you  really  need a comma or colon
within a data element,  such as a name written as  'Last, First'.
The cure  is to precede such data elements with a quotation mark.
After a quotation mark,  in either an  INPUT or INPUT# statement,
all   other  characters  except  a  carriage  return  or  another
quotation mark are accepted as part of the current data element.

EXAMPLES:

  To force a quotation mark into a data element  going to a file,
append a CHR$(34) to the start of the data element. For example:

  PRINT#2,CHR$(34)+'DOE,JOHN'

or

  PRINT#2,CHR$(34);'DOE,JOHN'

If  you  do  this  often,  some  space  and time may be saved by
previously  defining  a  variable as equal to CHR$(34) as we did
earlier with CHR$(13):

   20 QT$=CHR$(34)
  ...
  400 PRINT#5,QT$+NAME$

  In  each  case,  the added quotation mark will be stripped from
the data  by the  INPUT  or  INPUT#  statement,  but the comma or
colon will remain part of the data."
"In the context of the C64, How does the storage of numeric data on diskettes in BASIC 7.0 differ from its storage in computer memory, and what are some strategies for optimizing disk space when writing numeric data to files?","1581 disk with basic 7,0: NUMERIC DATA STORAGE ON DISKETTE


  Inside the computer,  the space  occupied by a numeric variable
depends  only  on  its  type.  Simple numeric variables use seven
bytes  (character locations) of memory.  Real array variables use
five bytes per array element,  and integer array elements use two
bytes each.  In contrast,  when a numeric variable or any type is
written to a file,  the space it occupies depends entirely on its
length, not its type.  This is because numeric data is written to
a  file  in  the form of a string,  as if the STR$() function had
been  performed on it.  The first character will be a blank space
if the number is positive,  and a minus sign (-) if the number is
negative.   Then  comes  the  number,  digit-by-digit.  The  last
character is a cursor right character.
  This  format allows the disk data to be read back into a string
or  numeric  variable  later.  It is,  however,  wasteful of disk
space,  and  it can be difficult to anticipate the space required
by  numbers  of  unknown  length.  For this reason, some programs
convert all numeric variables into strings before writing them to
diskette,  and  use  string  functions  to  remove  any  unneeded
characters in advance.  Doing so still allows those data elements
to be read back into a numeric variable by INPUT# later, although
file  data  errors  may  be  avoided  by  reading  all data in as
strings, and converting to numbers using the VAL() function after
the information is inside the computer.
  For example, 'N$=RIGHT$(STR$(N),LEN(STR$(N))-1)' will convert a
positive  number  N  into a string  N$  without the usual leading
space for its numeric sign.  Then instead of  writing  PRINT#5,N,
you would use PRINT#5,N$."
"In the context of the C64, What is the format of the OPEN statement to create or reopen a relative file in BASIC 7.0 and BASIC 2.0?","CREATING A RELATIVE FILE

  When a relative file is to be used for the first time, its OPEN
statement will create the file; after that, the OPEN statement is
used to reopen the file for both reading and writing.

FORMAT STATEMENT TO OPEN A RELATIVE FILE:

  BASIC 7.0: DOPEN#file#,'file name',Lrecord length
             [,Ddrive#][,Udevice#]
  BASIC 2.0: OPENfile#,device#,channel#,'drive#:file name,L,'+
             CHR$(record length)

where  'file#' is the file number,  normally an integer between 1
and 127; 'device#' is the device number to be used, normally 8 on
the  1581;  'channel#'  selects  a particular channel along which
communications  for this file can take place,  normally between 2
and 14;  'drive#' is the drive number,  always 0 on the 1581; and
'file name' is the name of the file,  with a maximum length of 16
characters.  Pattern  matching characters are allowed in the name
when accessing an existing file, but not when creating a new one.
The  record  length is the size of each record within the file in
bytes used, including carriage returns, quotation marks and other
special characters.


|  o Do not precede the file name  (in BASIC 7.0)  or the drive |
| number  (in BASIC 2.0)  with  the 'at' sign (@);  there is no |
| reason to replace a relative file.                            |
|  o L record length (in BASIC 7.0) or ,L,'+CHR$(record length) |
| (in BASIC 2.0) is only required when a relative file is first |
| created,  though it may be used later,  so long as the record |
| length is the same as when the file was first created.  Since |
| relative files may be read from or written to alternately and |
| with  equal  case,  there is no need to specify Read or Write |
| mode when opening a relative file.                            |
|  o 'file#',  'device#'  and  'channel#' must be valid numeric |
| constants, variables or expressions.  The rest of the command |
| must be a valid string literal,  variable  or  expression. In |
| BASIC 7.0 DOPEN, whenever a variable or expression is used as |
| a file name it must be surrounded by parentheses.             |

EXAMPLES:

  To create or reopen a relative file named  'GRADES',  of record
length 100 use:

  BASIC 7.0: DOPEN#2,'GRADES',L100,D0,U8
  BASIC 2.0: OPEN 2,8,2,'GRADES,L,'+CHR$(100)

  To  reopen  an  unknown relative file of the user's choice that
has already been created, use:

  BASIC 7.0:  200 INPUT'WHICH FILE';FI$
              210 DOPEN#5,(FI$),D0,U8
  BASIC 2.0:  200 INPUT'WHICH FILE';FI$
              210 OPEN 5,8,5,FI$"
"In the context of the C64, What are the two popular ways to organize individual fields of information within a fixed-length relative record, and what are the advantages and disadvantages of each approach?","1581 disk: DESIGNING A RELATIVE RECORD

  As  stated earlier in this chapter,  each relative record has a
fixed length, including all special characters. Within that fixed
length, there are two popular ways to organize various individual
fields of information. One is free-format, with individual fields
varying in length from record to record, and each field separated
from the next by a carriage return character  (each of which does
take  up  one character space in the record).  The other approach
is to use fixed-length fields,  that may  or may not be separated
by carriage returns. If fixed length fields are not all separated
by  carriage returns,  you will either need to be sure a carriage
return is included within each 88-character portion of the record
(88 is for BASIC 2, 160 is for BASIC 7). If this is not done, you
will  have  to  use  the  GET#  command  to read the record, at a
significant cost in speed.
  Since  each  relative record is most easily written by a single
PRINT# statement,  the recommended approach is to build a copy of
the current record in memory before writing it to disk. It can be
collected into a single string variable  with the help of BASIC's
many string-handling functions,  and then all written out at once
from that variable.
  Here  is  an  example.  If  we are writing a 4-line mail label,
consisting of 4 fields named  'NAME',  'STREET',  'CITY & STATE',
and 'ZIP CODE', and have a total record size of 87 characters, we
can organize it in either of two ways:

  WITH FIXED LENGTH  FIELDS         WITH VARIABLE LENGTH FIELDS

Field Name     Length             Field Name        Length

NAME           27 characters      NAME              31 characters
STREET         27 characters      STREET            31 characters
CITY & STATE   23 characters      CITY & STATE      26 characters
ZIP CODE       10 characters      ZIP CODE          11 characters
----------------------------      -------------------------------
Total length   87 characters      Potential length  99 characters
                                  Edited length     87 characters

  With fixed length records,  the field lengths add up to exactly
the  record  length.  Since  the  total length is just within the
input  buffer size limitation,  no carriage return characters are
needed.  With variable length records,  you can take advantage of
the  variability  of  actual  address  lengths.  While  one  name
contains  27  letters,  another  may  have only 15,  and the same
variability exists in street and city lengths.  Although variable
length records lose one character per field for carriage returns,
they  can  take advantage of the difference between maximum field
length  and  average  field length.  A program that uses variable
record  lengths must calculate the total length of each record as
it is entered,  to be sure the total of all fields doesn't exceed
the space available."
"In the context of the C64, What error message is displayed when a disk controller command exceeds 58 characters?","1581 disk: Controller commands error code 32: SYNTAX ERROR (long line)
    The   command   sent  is  longer  than  58  characters.   Use
    abbreviated disk commands."
"In the context of the C64, What error message and solution are provided when a file is too large to be created on a diskette?","1581 disk: Controller commands error code 52: FILE TOO LARGE
    There isn't room left on the diskette to create the requested
    relative record.  To avoid this error, create the last record
    number  that  will be needed as you first create the file. If
    the file is too large for the diskette,  either split it into
    two files on two diskettes,  or use abbreviations in the data
    to allow shorter records."
"In the context of the C64, What is the error message displayed when a disk controller encounters an invalid bit pattern in a data byte during a read operation?","1581 disk: Controller commands error code2 4: READ ERROR (byte sector header)
    The  data  or  header  has  been read into disk memory, but a
    hardware  error has been created by an invalid bit pattern in
    the data byte."
"In the context of the C64, What are the different addressing modes supported by instructions in a 6510 processor?","Addressing Modes
Each instruction supports one or more addressing
modes. Common instructions like LDA (load accumulator) support more addressing modes than less
common ones (BIT).
 The immediate addressing mode is indicated with
a # sign: LDA #$17 loads the immediate value of
$17 into the accumulator.
 Absolute addressing specifies a 16 bit address as an
operand: LDA $0314 loads from the memory address $0314.
 Zero page addressing is an optimized version of
absolute addressing: LDA $02 will read from address $0002 in memory, but the instruction can be
encoded more tightly, and execution is faster.
 Absolute-X-indexed addressing reads from a specified address, to which the contents of the X register
is added. LDA $0200,X reads from the address
$020A, in case X is $0A. This allows reading from
tables.
 Absolute-Y-indexed is the same thing, but with the
Y register.
 Zero-Page-X-indexed is an optimized version of
Absolute-X-indexed. LDA $F0,X reads from the
Xth location in a table stored starting at $00F0 in
memory. Note that zero page addresses will wrap
around, so $F0 + $10 = $00.
 Zero-Page-Y-indexed is the same thing, but with
the Y register.
 Zero-Page-X-indexed-indirect adds X to a specified
zero page address, reads a 16 bit pointer from the
resulting address and finally accesses memory at
that address. So LDA ($80,X) will read from an
address specified by the array of pointers at $0080
and the index X into the array. This addressing
mode is rarely used.
 Zero-Page-indirect-Y-indexed treats two consecutive bytes in zero page as an address and adds Y to
the address. LDA ($14),Y will read from $E020, if
the address stored at $14/$15 is $E000 and Y is
$20. This addressing mode is the most convenient
way to work with pointers, as no register can hold
16 bits."
"In the context of the C64, What are the instructions and characteristics of the 6502/6510 processor related to register transfer and stack operations?","Register Transfer and Stack
There are several 1 byte instructions without operands that move data between registers. TAX, TXA,
TAY and TYA move between A, X and Y. TSX and
TXS copies between X and the stack pointer.
The stack pointer always points to the next address
that is written to. This means that an empty stack has
a stack pointer of $FF, and pushing a value first
writes the value and then decrements the stack
pointer. The 6502 can move the accumulator from
and to the stack (PHA/PLA), as well as the processor
status P (PHP/PLP)."
"In the context of the C64, What are the different types of instructions that make up the instruction set of the 6510 processor?","Instruction Set
The instruction set is very streamlined, and avoid
redundancies. There are load instructions (LDA/
LDX/LDY to load A, X and Y respecively), store instructions (STA/STX/STY), read-modify-write instructions (logic: ASL/LSR/ROL/ROR, count: INC/
DEC), arithmetic (ADC/SBC; note that these always
include the carry: CLC/ADC is a regular addition, and
SEC/SBC is a regular subtraction, because of the
one's complement logic), compare (CMP/CPX/CPY;
these are subtractions without storing the result),
logic (AND/ORA/EOR, and BIT, which is AND without storing the result), as well as branch instructions,
flag manipulation, register transfer and stack manipulation."
"In the context of the C64, What are the key features and characteristics of the 6502 CPU, including its architecture, registers, and instruction set?","6502 CPU
The CPU inside the C64 is a 0.985 MHz (on PAL)
MOS 6510, which is a close derivative of the wellknown 8 bit little-endian MOS 6502. The 6502 was
introduced in 1975 by MOS Technology, a company
formed earlier the same year by former Motorola engineers, headed by Chuck Peddle. The philosophy of
the 6502 was to have a reduced instruction set and a
small register file, making it simpler and faster than
CPUs like the Z80 at the same clock speed, as well as
cheaper to manufacture.
Unlike other CPUs, the 6502 does not have a set of
general purpose registers. Instead, it has a single accumulator A (for arithmetic and logic), two index registers X and Y (for incrementing, decrementing and
indexing memory) and a stack pointer. All these registers are 8 bits. The processor status, consisting of
the negative (N), overflow (V), break (B), decimal (D),
interrupt (I), zero (Z) and carry (C) flags is exposed as
register P. The program counter (PC) is 16 bits wide.
The fact that the stack pointer is 8 bit means that the
stack is confined to the area between $0100 and
$01FF in the address space, i.e. the upper half of the
effective stack pointer is hard-coded to $01. There is
another special area in the address space: The first
256 bytes, at $0000 to $00FF are referred to as the
zero page (ZP). Many instructions support special
encodings for zero page addresses, which saves one
byte in the instruction encoding as well as at least one
cycle of execution time. This can be seen as an extension of the register file to another 256 (though external) registers.
All opcodes are one byte, and have 0, 1 or 2 byte operands. The 8x8 opcode matrix is somewhat logical
(e.g. branch instructions are encoded as $10, $30,
$50, ...), but there is no easy rule to construct the opcode table. Nevertheless, the opcode table is a minimal encoding for optimal decoding in the 6502's internal PLA ROM."
"In the context of the C64, What is the history of the Commodore 64, including its development, features, and impact on the computer market?","History of the C64
Commodore Business Machines was founded in 1962
by Jack Tramiel. The company specialized on electronic calculators, and in 1976, Commodore bought the chip manufacturer MOS Technology and decided to have Chuck Peddle from MOS evolve their KIM-1 computer kit (a design that demos their new MOS 6502 8 bit CPU) into the Commodore PET series: computers with built-in monitors for the home, school and small business market that ended up competing with devices from Atari and Apple. In 1981, Commodore introduced the VIC-20, a 5 KB stripped down monitorless computer-in-thekeyboard design based on the PET for the home computer market. This was followed by the (incompatible) higher-end Commodore 64 in 1982 that included more PET features, came with 64 KB of RAM (an immense amount compared to the rest of the market) and was very aggressively priced at US$595 beating the competition by a factor of two. This was made possible by designing and building most of the system in-house. Although some features of the C64 were taken from the PET models of the time, it had to be connected to a TV set, which only made 40 columns of text possible (as opposed to 80 columns on the PET). Also, the BASIC 4.0 codebase was stripped down to the old 2.0 feature set to make it fit into 8 KB.
In the beginning, the C64 did well in the competition. The superior but compatible C128 from 1985 did well, too, but was never more popular than the C64, which continued to be sold. The direct successor to the lowend VIC-20, the 1984 Plus/4 and its siblings, the C16 and the C116, failed, mostly because they were incompatible with the C64, which at that time already had a remarkable software library. A few years after the introduction, the C64 was still offered as a low-end alternative to the Commodore Amiga, and while it became less popular in the USA,
it gained more and more popularity in Europe. In the early 90s, when manufacturing costs of a C64 were as low as $25, it gained a second life in Eastern Europe.
Production did not end until the liquidation of Commodore in 1994. According to the 1993 Annual Report, 17 million C64 had been produced in by then, as
well as 4.5 million C128."
"In the context of the C64, What are the key features, capabilities, and technical specifications of the Commodore 64 (C64) computer?","Look and Feel
A C64 only needs to be connected to power and a TV set (or monitor) to be fully functional. When turned on, it shows a blue-on-blue theme with a startup message and drops into a BASIC interpreter derived from
Microsoft BASIC. In order to load and save BASIC programs or use third party software, the C64 requires mass storage - either a datasette cassette tape drive or a disk drive like the 5.25' Commodore 1541.
Unless the user really wanted to interact with the BASIC interpreter, he would typically only use the BASIC instructions LOAD, LIST and RUN in order to access mass storage. LOAD'$',8 followed by LIST shows the directory of the disk in the drive, and
LOAD'filename',8 followed by RUN would load and start a program. If a tape drive is connected, LOAD and RUN will launch the first program on tape - pressing SHIFT and the RUN/STOP key has the same effect.

By default, typing characters without SHIFT will result in upper case characters being shown on the screen. This can be changed by pressing the Commodore key and SHIFT at the same time, which switches to the upper/lower character set. This behavior is due to the fact that the first PET only had uppercase characters, and that BASIC required keywords unshifted - but all tutorials taught them as uppercase. This is also the reason why in Commodore's version of ASCII, called PETSCII, the codes for uppercase and lowercase characters are reversed.
The text based user interface is not a line editor, but a screen editor, i.e. the cursor can be moved freely on the screen, and pressing RETURN on a line with existing text will present the text to the application as if it were just typed in.
While a physical screen line is only 40 characters, the screen editor logic can extend it to a logical 80 characters - whenever a character is entered on the 40th column, the rest of the screen is moved down by one line, opening a line that extends the previous line to 80 characters.
The C64 screen editor supports selecting one out of 16 color for the foreground text by pressing the key combinations Ctrl+1 to Ctrl+8 and Commodore+1 to Commodore+8. Reverse text mode can be turned on and off with Ctrl+9 and Ctrl+0.


Ports and Connections
The C64 has a whole range of connection possibilities.
On the side, it has two 9 pin Atari-style joystick connectors that can also be used for a mouse, light pens or paddles. On the back, there is the expansion port, which exports the complete processor bus, allowing not only game cartridges but also cartridges with I/O chips that map themselves into the CPU's address space - or even cartridges that completely replace the CPU. For a conventional TV connection, there is an RCA connector that outputs an RF signal. For monitors, there is an extra DIN connector that carries separate chroma, luma and audio signals (S-Video).
For connecting Commodore compatible printers and disk drives, there is a DIN connector for the IEC bus.
There is also a dedicated connector for datasette drives. The User Port consists of several GPIO pins that can be used for custom hardware projects, or as a RS-232 port (with TTL levels), for which support exists in the ROM."
"In the context of the C64, What is the memory mapping of the Commodore 64's 6510 CPU, including the address ranges for RAM, ROM, I/O devices, and other components?","Address Space
The 8 bit C64 design has a 16 bit address bus, allowing the CPU to address 64 KB of memory. Since the
C64 has 64 KB of RAM, filling the complete address
space, ROM and I/O chips are mapped into regions of
the address space that are shared with RAM: The
CPU can switch these regions between RAM and a
second or third mapping. These regions are as follows:
 $0000-$9FFF: RAM
 $A000-$BFFF: RAM or BASIC ROM
 $C000-$CFFF: RAM
 $D000-$DFFF: RAM or memory mapped I/O
chips or character ROM
 $E000-$FFFF: RAM or KERNAL ROM
In contrast to CPUs like the Z80 and the 8086, and
like most modern CPUs, I/O devices are memory
mapped on the C64's 6510 CPU. The mapping is as
follows:
 $D000-$D3FF: VIC video controller
 $D400-$D7FF: SID sound controller
 $D800-$DBFF: Color RAM
 $DC00-$DCFF: CIA 1 I/O controller
 $DD00-$DDFF: CIA 2 I/O controller
 $DE00-$DFFF: for extensions on the expansion
port"
"In the context of the C64, What are the components that make up the Commodore 64 motherboard?","Board
On the C64 motherboard, there is a dedicated IC each for the main tasks. There is the MOS 6510 CPU, eight 64 KBit RAM chips (later consolidated into 2), three ROM chips with KERNAL (I/O library), BASIC and the character set (KERNAL and BASIC were later consolidated), two 6526 CIA I/O controllers (one for keyboard and joystick, one for the IEC bus and the user port), the 6581 SID sound chip, and the 6567/6569 VIC video chip, as well as the RAM chip that holds the 512 bytes of Color RAM.
All non-RAM chips are custom chips designed manufactured by MOS, Commodore's inhouse chip company."
"In the context of the C64, What are the memory layout and addressing capabilities of the VIC chip in a Commodore 64 computer?","Memory Layout
The VIC can address 16 KB at a time. All VIC data
structures can be stored anywhere in these 16 KB, but
they have to be aligned to their size.
 The screen RAM is $0400 bytes in size and can be
at $0000, $0400, ...
 The character set is $0800 bytes, and can be at
$0000, $0800, ...
 The bitmap is $2000 bytes and can be at $0000 or
$2000.
 Sprites are $40 bytes, and can be at $0000,
$0040, ...
Two GPIO pins of the second 6526 CIA are connected
to bits 6 and 7 of RAM when the VIC accesses it. By
changing the lower 2 bits of $DD02, the VIC can be
switched between banks $0000-$3FFF (11), $4000-
$7FFF (10), $8000-$BFFF (01) and $C000-$FFFF
(00).
If the VIC is set to banks $0000 or $8000, then the
two built-in character sets shadow RAM in the area of
$1000-$1FFF. This means that the built-in character
set can be used on those banks without occupying
RAM, but it also means that the area from $1000-
$1FFF cannot be used for bitmap, screen RAM or
sprite data either.
For timing reasons, color information is not taken
from main RAM, but from a dedicated Color RAM.
These $0400 half-bytes are accessible to the C64 at
$D800-$DBFF and can not be bank switched."
"In the context of the C64, What are the characteristics and capabilities of the VIC's hardware sprites (MOBs) on the Commodore 64?","Sprites
The VIC has eight hardware sprites (also called
MOBs, movable objects). Each sprite is 24x21 pixels,
which is encoded in 63 bytes. Set bits will be drawn in
the sprite's individual foreground color, and cleared
bits will be transparent. The index to the sprite's bitmap data in memory is an 8 bit value that is read
from the last 8 bytes of screen RAM - since the screen
is only 1000 characters, the last 24 characters of the
$0400=1024 bytes area would otherwise be unused.
There is also a multicolor mode for sprites, which
makes pixels twice as wide and decreases the horizontal resolution to 12 pixels. In this mode, 00 is still
transparent, and 10 encodes the sprite's individual
color. The codes 01 and 11 take the color out of the
sprite multicolor registers ($D025 and $D026),
which are shared among all sprites.
Sprites can be positioned at arbitrary pixel positions
on the screen, and overlap. In this case, sprites with
lower numbers have priority over sprites with higher
numbers. Each sprite can either be shown in front or
behind background pixels. Sprites can be X- and Yexpanded by a factor of two, and collision of two
sprites or of a sprite and background pixels is detected by hardware: Whenever two non-transparent
sprite pixels are drawn at the same position on the
screen, they have collided. Whenever a nonbackground pixel is drawn by the character generator
at the same position where a non-background pixel of
a sprite is draw, the sprite has collided with the background. An exception from this rule is the 01 code in
the character data, which also counts as background.
This way, a background picture can be constructed
that does not cause collisions in certain areas. In
practice, most newer games do not use the hardware
functionality, but instead test for overlapping sprite
bounding boxes in software."
"In the context of the C64, How does the VIC chip handle graphics modes, including hi-res and multi-color bitmap modes, in terms of resolution, pixel encoding, and color management?","Bitmap Mode
In hi-res graphics mode, the VIC supports a resolution of 320x200, which uses the same pixel frequency
as 40x25 character mode (40*8=320, 25*8=200).
The bitmap can reside at $0000 or $2000, and the
VIC reads one byte for 8 pixels. But hi-res mode does
not only support monochrome graphics: The foreground and background colors of each 8x8 tile are
taken from the high and low nibble of screen RAM,
which would otherwise be unused. Color RAM is not
used in this mode.
The encoding of the bitmap is identical to the encoding of a character set, making it a non-linear framebuffer: The first eight bytes of the bitmap represent
the pixels in the tile at character position (0,0), the
second eight bytes represent the tile at character position (1,0), which is pixel position (8,0), and so on.
This layout makes pixel addressing in software
slower.
In Multi-Color Bitmap Mode, the horizontal resolution is halved to 160x200, and pixels are twice the
width. Every set of two bits in the encodes one of four
colors per tile: 00 takes it from the global background
register ($D021), 01 and 10 take it from the upper
and lower nibble of screen RAM, respectively, and 11
takes it from Color RAM."
"In the context of the C64, How does the VIC support scrolling and what are the implications for screen mode and border size?","Scrolling
The VIC supports hardware X and Y scrolling by 0 to
7 pixels. Since the 40th column is half visible and another column left of the first column is half-visible
when the horizontal shift register is set to e.g. 4, a
41th column would be needed. Instead, it is possible
to switch the screen to 38 column mode, i.e. the
whole screen is a little narrower, and more border is
shown on the left and on the right. The screen can
also be switched from 25 to 24 lines the same way."
"In the context of the C64, What is the memory configuration of a Commodore 64 system, including how the ROMs and I/O area can be altered, and how programs typically utilize the available memory?","Memory Configuration
In a running system with BASIC and KERNAL, the
BASIC and KERNAL ROMs are turned on and visible
at $A000-$BFFF and $E000-$FFFF respectively,
and at $D000-$DFFF, the I/O area is visible. Using
the 3 lowest bits in the processor port at address 1,
this configuration can be altered. The ROMs can be
turned off, revealing RAM instead, and the I/O area
can be configured to show either RAM or the character set ROM. Note that writing to ROM will always
direct the data to the underlying RAM.
In practice, many programs run in the default configuration and use both KERNAL library routines, as
well as functions in BASIC, to keep their own code as
small as possible. More recent programs and almost
all games turn off all of ROM, to get direct control of
the interrupt vector without having to go though the
KERNAL handler first. The I/O area is typically configured to show the I/O registers and Color RAM, and
only rarely switched to a different configuration to
temporarily access the RAM underneath. A few applications read the character ROM at program start and
modify the copy.
The C64 supports another ROM bank at $8000-
$9FFF, which can only be serviced by an external cartridge connected to the expansion port. If KERNAL
detects the magic string CBM80 at $8004 on
startup, it will jump to the code of the cartridge right
away."
"In the context of the C64, What are the characteristics and modes of the Commodore 64's character display system?","Character Mode
The C64 has two built-in character sets that the VIC
can access. They can be shown on the screen by writing the numbers 0 to 255 into screen RAM (at $0400
by default). The default font has uppercase characters
and lots of line-drawing symbols in the lower 128
characters, and the second half consists of the same
characters, but inverse. The alternative font has upper- and lowercase characters and omits some of the
symbols.
The foreground color of the characters can be
changed by writing the color numbers into the Color
RAM, which is located at $D800-$DBFF. There is
one byte per character, but only the lower 4 bits are
actually preserved by Color RAM.
Each character is 8x8 pixels, and stored as eight bytes
in the character ROM, one line being one byte. A 1-bit
will take the color from the Color RAM ($D800-
$DBFF), and a 0 bit will take it from the global background color register ($D021). The pixel matrix is
determined by looking up the character index in the
screen RAM (at $0400-$07FF by default) and consequently looking up the pattern the current character
set (the VIC sees the default font at $1000, although
for the 6502 it is invisible there).
In Extended Color Mode (ECM), it is possible to
chose between one of four background colors (registers $D021 to $D024) with the upper two bits of the
character index, but then only 6 bits will be used to
look up the character pattern, decreasing the number
of possible characters to 64. The built-in (uppercase)
character set is well-suited for this: While it is similar
to the ASCII encoding, it has the uppercase characters
mapped to codes $01 to $1A, so the most important
characters are within the first $40.
Multi-Color Character Mode allows up to four colors
per character and is intended for tile-based games,
like platformers. If bit 3 of the value in Color RAM is
0, then the character gets displayed just like in nonmulticolor mode, but colors are restricted to the first
eight. If bit 3 is 1, then pairs of horizontally adjacent
bits are combined in their meaning: 00 represents the
screen background ($D021), 01 is the second background register ($D022), 10 is the third background
register ($D023), and 11 is the color specified in bits
0-2 of the Color RAM. Pixels in these characters are
twice as wide, so the resolution of a character is 4x8."
"In the context of the C64, What are the features and capabilities of the MOS 6567/6569 VIC-II video chip in the Commodore 64?","6567/6569 VIC
The video chip inside the C64 is called the MOS
6567/6569 VIC-II (Video Interface Controller) - the
video chip in the VIC-20 had been the original VIC,
and was the reason for the marketing name of the
VIC-20.
The VIC supports a 40x25 text mode, a 320x200 bitmap mode, 16 colors and 8 sprites - all of these features have lots of sub-modes and options. The
amount of memory the VIC can address is 16 KB, and
while by default, it accesses the first 16 KB of the C64
RAM, it can be configured to use any of the four
banks.
The 16 colors of the VIC are divided into two sets of
eight. The first eight are the more important colors,
as some modes only support the first eight. The colors
are, in the original order: black, white, red, cyan, purple, green, blue, yellow, orange, brown, pink, dark
gray, gray, light green, light blue and light gray."
"In the context of the C64, What are the key aspects of the VIC's timing that are essential to understand for advanced programming and achieving cycle-exact timing in assembly code?","Timing
For advanced VIC programming, it is necessary to not
just set up a certain mode and have the VIC display it,
but to reprogram the VIC while it is drawing the picture. For this, it is necessary, to understand its timing.
While the pixels within the screen area are 320 by
200, the VIC actively draws pixels in the border color
outside of this area, which (on PAL) is 403x284 pixels. Analog TV standards specify an H blank area at
the end of every line, and V blank area at the end of
every screen. So counting this timing as pixels, this
gives an absolute resolution of 504x312 pixels. The
interesting and very useful connection about the pixel
clock and the system clocks is that an 8 pixel character is drawn every system clock cycle, i.e. about 1 million times a second. The 504 horizontal pixels therefore mean that a line is drawn on the screen every 63
cycles. With this information, it is possible to do
cycle-exact timing of assembly code to switch a VIC
register at an 8 pixel granularity.
Further timing details (badlines, sprite timing), as
well as the application of this information to do tricks
like FLD, FLI and AGSP would go beyond the scope
of this article."
"In the context of the C64, What are the components and connections of the tape interface?","Tape Interface
The tape interface consists of a single line each for
data input and output, motor control and key sense.
The raw data is read from and written to the data
lines, and all encoding and decoding of the data
stream is done in software. 3 of the required lines are
connected to the processor port at zero page location
1, and one (data input) is connected to CIA 2."
"In the context of the C64, What is the IEC bus and how does it work on Commodore computers?","IEC Bus
The IEC bus is a serial version of the IEEE-488 bus
used on the PET. Devices on the IEC bus are daisychained, and are all connected to the same three
lines: ATN (attention), clock and data. IEC has a single bus master, which is the computer. It is the only
device to ever raise ATN, while every device can output to clock and data, depending on the state of the
bus.
If the computer raises ATN, every device on the bus
listens for the 4 bit device number and compares it
with its own. The protocol on who sends and who receives is determined by the computer sending TALK/
UNTALK and LISTEN/UNLISTEN requests, quick is an ATN sequence, followed by one of the four commands.
While KERNAL exports the interface at this level, it
also allows high-level open, close, read and write operations on the IEC bus, as well as load and save operations. The BASIC LOAD and SAVE commands are
directly hooked up to this interface.
The IEC bus was designed for the serial shift register
in the VIA (Versatile Interface Adapter) of the VIC-20
and its disk drive, but it turned out that the VIA had a
bug that made the shift register unusable, so the IEC
protocol had to be implemented in software. While
the C64 has CIAs, in which the bug has been fixed,
the 1541 still used VIAs. It wasn't until the C128 (in its
native mode only) that the computer could talk to the
floppy drive (Commodore 1570/1571/1581) in its intended speed."
"In the context of the C64, What was the graphical user interface-based operating system released by Berkeley Softworks in 1986 for the Commodore 64?","GEOS
While KERNAL is a minimal character-based operating system in ROM, there is also a disk-based operating system with a graphical user interface for the C64.
GEOS was released by Berkeley Softworks in 1986
and Commodore bundled it with the C64 for some
time. The GUI, which can be controlled by a joystick
or a mouse, runs in 320x200 graphics mode and resembles early versions of MacOS. GEOS is a 16 KB
library that includes an optimized disk interface
(faster, support for timstamps, icons and multi-fork
VLIR files), library code for drawing to the screen,
high level UI primitives for menus, buttons and dialog boxes (with callbacks) and a simple memory
swapping facility. Furthermore GEOS allows input
and printer driver plugins, as well as proportional
fonts in different sizes. Internally, GEOS has a jump
table to its library routines that consists of about 150
entries.
GEOS came with applications like GeoPaint and GeoWrite; Berkeley Softworks themselves offered solutions like GeoPublish and GeoCalc, and more software was available from third parties.
GEOS' only requirement is a 1541 disk drive, but a
3.5' 1581 drive, a RAM extension or one of the later
hard drives helped speed it up a lot."
"In the context of the C64, What are the features and uses of the 6526 CIA (Complex Interface Adapter) in the Commodore 64 computer?","6526 CIA
The C64 has two identical 6526 CIAs (Complex Interface Adapter) that are mostly used for I/O. One CIA
features 16 general purpose I/O pins (8 bit port A and
8 bit port B) that can be used either as an input or an
output, two programmable timers and a real-timeclock.
The timers have 16 bit counters and count down by
one either on each clock cycle, or on an external
event, or on a timer A underflow (in the case of timer
B). This allows concatenating the timers to one 32 bit
timer. On an underflow, the CIA can be programmed
to cause an IRQ or to send data through a serial shift
register. The CIA also supports receiving data
through a shift register.
The real-time-clock has a resolution of 1/10 of seconds and supports generating interrupts at a certain
time.
CIA 1 is hooked up to the keyboard and the joystick
ports. Since the keyboard consists of 64 keys (plus
SHIFT LOCK, which is parallel to the left SHIFT key,
and RESTORE, which is directly connected to the
CPU's NMI line), these can be laid out in a 8x8 matrix
of lines, key presses connecting the intersections. One
side of the matrix is connected to port A (output), and
the perpendicular side is connected to port B (input).
The keyboard driver can now write the values of $01,
$02, $04 etc. in port A and test the input of port B to
see which keys are pressed. The two joysticks are
connected in parallel to port A and port B, so they can
cause spurious keyboard events.
CIA 2 is hooked up to the IEC bus, and I/O lines control the VIC bank. The rest is exposed on the user
port, and can be used for RS-232.
KERNAL uses CIA 1 for the 50 Hz system timer, but,
apart from the ports, doesn't use any of the extra features of either CIA."
"In the context of the C64, What are the various peripherals and accessories that were developed for the Commodore 64 (C64) computer?","Other Peripherals
The 1541 is the necessary companion to a C64. It can
be replaced by a 1570 (1541 with fast bus routines for
the C128) or a 1571 (double-sided 1570), since they
include a 1541 compatibility mode. The 3.5' Commodore 1581, which supports 880 KB per disk, can
hardly be a replacement for a 1541, because most applications contain their own floppy speeders that
make lots of assumptions on the exact on-disk format. For GEOS, it can be very useful though.
Creative Micro Devices sold and continues to sell a
line of hard drives that have an IEC connection but
contain a 3.5' SCSI drive inside. Although they have a
6502 CPU built in and allow code execution on their
CPU, they are not compatible enough to replace a
1541 either.
Several memory extension cartridges exist for the
expansion port of the C64: The Commodore REU
(contains a DMA chip that transfers data between
itself and main RAM), as well as the third party
GeoRAM (maps a block to the $DE00-$DFFF area)
and RAMLink (battery backed, designed as RAM
disk).
Freezer cartridges like the Action Replay and the Final Cartridge were not only popular because they
could dump all of memory to disk and thus copy certain copy-protected games, but also because they featured floppy speeders that disabled the original routines directly at startup time, without any effort from
the user.
In the mid 90s, CPU speeders for the expansion port
became popular. The 8 MHz Flash 8 is rare today, but
many enthusiasts have a SuperCPU, which replaces
the onboard CPU with a 20 MHz 65C816, which has a
native 16 bit mode that can address up to 16 MB or
RAM. There are a few applications and games that
require a SuperCPU. The speedup of GEOS with a
SuperCPU is significant.
In the 2000s, the enthusiast scene created all kinds of
peripherals, like ethernet interfaces, IDE interfaces
and SD card readers.
And there are not only peripherals: In 2004, the
Commodore 64 DTV, a reimplemented C64 appeared
in the form of a Joystick. The device is fairly compatible and can be extended to connect to a keyboard and
a 1541."
"In the context of the C64, What is the role and functionality of the KERNAL I/O library in Commodore 8-bit systems, particularly in the Commodore 64?","KERNAL
The C64 has an 8 KB I/O library at $E000-$FFFF
which is utilized by BASIC, but is intended to be used
by other applications as well. All Commodore 8 bit
systems have a standardized library call interface in
the form of jump tables at the very top of memory
that call into machine-specific functions for I/O.
KERNAL is started form the RESET vector, initializes
the machine, sets up an interrupt service routine that
handles the keyboard, animates the cursor and does
the real time clock. The C64 has a hardware clock in
each of the CIA chips, but KERNAL has not been updated to use this feature since the VIC-20.
KERNAL provides an abstract character I/O interface
to a number of devices. All devices support open,
read, write and close. The open call takes three parameters: The logical file number (there is a maximum of 16 channels), the device number and the secondary address. There are 16 device numbers statically assigned to the devices. The 8 bit secondary address can signal something to the device, like speed or
an operation mode. Some devices (tape and IEC)
support an optional filename.
Device 0 is the keyboard. While KERNAL exports raw
key presses, the keyboard can also be accessed
through character I/O, which will go through the
screen editor and replay all characters on the screen
that are in the line of the cursor, regardless of
whether the user typed them or they had been there
before.
Device 1 is the tape drive. KERNAL reads and writes
blocks of data at a time and buffers them for character I/O.
Device 2 is RS-232. KERNAL contains a very sophisticated (but rarely used) software RS-232 implementation that supports up to 2400 baud.
Device 3 is the screen. KERNAL interprets special
codes, manages the cursor position and handles
scrolling.
Devices 4 to 15 will be directed to the IEC bus. By
convention, devices 4 to 7 are printers and plotters,
and devices 8 to 15 are floppy or hard disks.
KERNAL allows interacting with the IEC bus manually by sending TALK and LISTEN requests to the
bus."
"In the context of the C64, What is the history and features of Microsoft BASIC and its variations, including Commodore BASIC, on early home computers?","BASIC
Microsoft had a strong position in the market for
(mostly ROM) BASIC interpreters in 8080-based
home computers when the MOS 6502 was released in
1975, so they rewrote their interpreter in 6502 assembly. Microsoft BASIC was pure 6502 code with a
minimal character I/O interface to the machine's
monitor, i.e. I/O library.
Commodore decided to license the interpreter for the
1977 PET and extended it slightly to interface with
their disk and tape libraries. Commodore BASIC was
very buggy, so they went back to Microsoft for an update, which, with the Commodore changes re-applied,
shipped in newer PETs as BASIC V2. For version 4,
Commodore added several extensions, both language
constructs as well as support for graphics and sound.
Being a low-end machine, Commodore took the bugfixed BASIC V4 codebase and removed all features
after V2, making it independent of the machine's
graphics and sound features again, and fitting it back
into 8 KB, and shipped this version on the VIC-20.
The Commodore 64 got the exact same version, except that it runs at a different memory address
($A000-$BFFF).
Microsoft BASIC is a line-based editor, that is, lines
can be shown with the LIST command, and they can
be modified by re-typing them. This integrates nicely
with the KERNAL screen editor: The cursor can be
moved up to LISTed lines, the lines can be modified,
and when RETURN is pressed, the whole line is fed
into BASIC again.
4
A nice feature of this and later versions of Commodore BASIC is the fact that all important parts, like
the tokenizer, the detokenizer and the interpreter
loop jump over a jump table in RAM before they do
their work, allowing the user to extend BASIC arbitrarily. The most well-known BASIC extension is Simons' BASIC, a cartridge that maps 8 KB of extra
ROM at $8000-$9FFF."
"In the context of the C64, What are the technical specifications and features of the Commodore 1541 Disk Drive used with the Commodore 64?","1541 Disk Drive
The Commodore 1541 Disk Drive is the most common
disk drive used with the C64. It uses 5.25' SS/DD
(single side, double density) disks, but disks can be
flipped, and the other side can be used as well, if the
disks are double sided. The 1541 does not use the index hole, and uses software markers (SYNC) instead
to be able to tell the start of a sector. Due to reliability
problems of early drives, the 1541 only uses 35 out of
the 40 possible tracks on a 5.25' disk. The tracks have
a variable number of 256 byte sectors, ranging from
21 on the outside to 17 on the inside. The data is written in 4 different speeds. This makes an overall 683
sectors, or 174,848 bytes.
The file system is stored on track 18. Track 18, sector
0 contains the disk name and the BAM (block availability map), which stores one bit per sector (1 = free).
Track 18, sector 1 is the first sector containing directory entries: There are eight 32 byte entries per sector, with a maximum filename length of 16 characters. The first two bytes of a directory sector point to
the next directory entry sector.
The files on disk are also stored as a linked list. The
first two bytes of every sector are either the track and
sector number of the next block, or the first byte is 0
and the second byte is the number of valid bytes in
this sector.
The 1541 is a stripped down version of the PET drive
series, which had a parallel connection, and contained two 6502 CPUs: One for doing the filesystem
and communicating with the computer, and one for
reading data from disk and writing data to it, as well
as encoding and decoding the data. The 1541 only has
a single 6502 CPU running at 1 MHz, which (using
timer IRQs) regularly switches itself between the two
modes. The two virtual CPUs still communicate with
each other using a messaging interface in the zero
page. The 1541 has 2 KB of RAM at $0000-$07FF.
The 1541 has two VIA I/O controllers at $1800 (for
the IEC bus) and at $1C00 (for the drive). The firmware is located at $C000-$FFFF.
Since loading an application or a game takes minutes
on an unmodified C64, several floppy speeders appeared (either as software on disk or built into applications, as ROM extension cartridges, or as internal
replacement ROMs), that consisted of implementations of more optimized protocols for the IEC bus for
both the C64 and the 1541. The 1541 code was uploaded using the old bus protocol. Such a new protocol would for example not do a handshake on every
bit using the clock line, but shift a complete byte
through in 4 steps, two bits at a time, using the clock
and data line at the same time. This would of course
only work if both CPUs were not interrupted. VIC
timing on the C64 side could already affect this, so
many floppy speeders turned off the screen while
loading."
"In the context of the C64, How many cycles do different types of instructions take on a 6502 processor?","Cycle Counting
It is quite straightforward to find out how many cycles an instruction takes. As a rule of thumb, an instruction takes as many cycles as the number of
memory fetches it has to perform, but at least two.
Therefore, single-byte opcodes (one byte fetches;
NOP/TAX/INX etc.) as well as instructions with immediate operands take two cycles. Zero page instructions take three memory accesses (opcode, address,
data), so they are three cycles. Absolute instructions
take four accesses (opcode, address low, address high,
data), so they are four cycles.
Read-modify-write instructions (INC/DEC/shift/
rotate) are an exception: They require 4 memory accesses for the zero page case and 5 otherwise, but they
take 5 and 6 cycles, respectively.
Branches take 3 cycles if they are taken and two if
they are not taken. And extra cycle has to be added if
the branch crosses a page boundary. JMP is 3, push is
3, pull is 4, JSR and RTS are 6 each.
All other timings can be looked up in the 6502's reference, but they are very easy to memorize."
"In the context of the C64, What are some common tricks and optimizations used when programming the 6502 microprocessor?","Common Tricks
 The BIT instruction exists in a two-byte (immediate operand) and three-byte (absolute operand)
variant. Since BIT only changes the flags, it effectively skips one or two bytes in the instruction
stream. This can be used to replace a two-byte
branch or a three-byte JMP with a one-byte BIT if
only one or two bytes have to be skipped.
 The architecture allows safe self-modifying code so a common optimization for copy loops is to use
LDA $nn00,X and STA $mm00,X, looping X from
$00 to $FF and then incrementing the bytes that
encode nn and mm for the next page. Compared toa LDA (zp1),Y: STA (zp2),Y sequence, this gets the
inner loop down from 16 cycles (5 LDA, 6 STA, 2
INY, 3 BNE) to 14 (4 LDA, 5 STA, 2 INY, 3 BNE).
 A PHA/PLA combination is 7 cycles, while an STA/
LDA combination in the zero page is 6 cycles, so
unless there is no free zero page space, PHA/PLA
should be avoided to quickly store a value. Using
an absolute store to write the value into the operand of a future immediate load (i.e. self modification) is the same speed at the zero page solution,
but does not waste zero page space.
 An elegant way to store a flag is to have it in bit #7
of a zero page address. While a load/store combination has to be used to set the flag, it can be
cleared with a simple LSR (5 cycles) and tested
with BIT (3 cycles), without affecting register contents.
 Since the 6502 is so register starved, only 3 bytes
can be passed to a subroutine in registers. Also, the
stack is small, and accessing it is slow, so stack
frames as seen on modern architectures are very
uncommon. Many applications and libraries (e.g.
GEOS) use a dedicated area in the zero page as virtual registers.
 The 6502 has no instructions for multiplication,
division or floating point arithmetic. Most 6502-
based computers have a BASIC interpreter in ROM
though, and they typically include a math and
floating point library."
"In the context of the C64, What are the key differences between the MOS 6510 used in the Commodore 64 and the generic MOS 6502, and how does it interact with other components on the C64?","The MOS 6510
Except for the pin layout, the MOS 6510 that is used
in the C64 differs from the generic MOS 6502 in two
ways: It can make the bus tri-state when not used, so
the VIC can use it, and it has a 6 bit I/O port built in,
which can be controlled using zero page locations 0
and 1. In register 0, each bit from 0-5 set it to output
if 1, and to input if 0. Bits 0-5 in register 1 are the actual I/O pins. On the C64, bits 0-2 are outputs and
control bank switching, they turn the ROMs and the
I/O area on and off. Bits 3-5 go to the tape connector
and control the motor and the data sent to the head,
and detect whether a key on the tape deck is pressed."
"In the context of the C64, What are some of the bugs and quirks of the original 6502 microprocessor implementation?","Bugs and Quirks
The original 6502 implementation has a series of
bugs and other anomalies that have never been fixed
in MOS chips (not counting the 65CE02, which was
only used in Amiga peripherals).
 The indirect version of JMP loads the program
counter from the wrong address, if the vector's address lies on a page boundary: JMP ($23FF) will
read the address from $23FF and $2300 instead of
$23FF and $2400.
 When in decimal mode, the negative flag reflects
the original binary result, not the effective decimal
result.
 If a software interrupt (BRK) and a hardware interrupt occur at the same time, the BRK is dropped.
 Read instructions (LDA/AND etc.) with the
absolute-indexed addressing mode first read from
the absolute address without the index register
added, and then read again from the correct address. LDX #$07 LDA $D019,X will first read from
$D019, discard the result, and then read from
$D020. On the C64, this read form $D019 would
ACK all pending VIC interrupts, while it is only
supposed to read the border color ($D020).
 Read-modify-write instructions with absolute addresses first read the value, but one cycle before
they store the result, they store the original value
again. On a C64, this can be seen when incrementing the screen border color at a defined area of the
screen, as every write to the register will cause a
tiny gray dot on the screen. When this is used with
certain I/O ports, this can have other side effects.
The latter two quirks have been used heavily for
obfuscating copy protection software.
 Instruction decoding in the 6502 is done by a PLA
that compares the current cycle number within the
instruction and the current opcode against a ROM
of 130 mask lines, of which any number can fire
independently. The outputs of these lines are then
fed into components like the ALU, bus control, register control and program counter logic. The instruction set only consists of 151 defined opcodes,
and since handling the remaining 105 opcodes as
NOPs or traps would have required extra lines in
the PLA, they will match against some lines that
were meant for instructions with similar opcodes.
Some of these illegal opcodes lead to useful results and are used in some software (SAX = store A
& X), but most of the instructions make little sense
(SHX = store X & the upper 8 bits of the program
counter), and some even lock up the CPU, disabling IRQs and NMIs (CRA/KIL)."
"In the context of the C64, What are the effects of flags and branches on 8-bit load and logic instructions, and how do conditional branches and decimal mode work in a 6502/6510 processor architecture?","Flags and Branches
All load and logic instructions set N and Z accordingly, shift instructions also modify C, and arithmetic
instructions touch N V, Z and C. The D (decimal), I
(interrupt disable) and C flags can be set and cleared
programmatically (CLD/SED, CLI/SEI, CLC/SEC),
while the V flag can only be cleared (CLV). Conditional branches are possible based on the value of the
negative (BPL/BMI), overflow (BVC/BVS), zero
(BNE/BEQ) and carry (BCC/BCS) flags. Branches
encode an 8 bit relative offset and can therefore reach
code in the area of +127 and -128. Since a compare is
the same as a subtraction, BCC is a branch on (unsigned) below, and BCS is a branch on above-orequal.
NOP
NOP (no operation) does nothing. Its encoding is
$EA.
Decimal Mode
If the D flag is set, all ADC and SBC operations will be
BCD-adjusted afterwards, i.e. $09+$02 won't be $0B,
but $11, since 9+2=11. The BCD correction circuit has
been patented in US patent 3,991,307."
"In the context of the C64, What are the different types of control transfer instructions and interrupts available on C64, and how do they function?","Control Transfer
Next to the absolute JMP instruction, there is an indirect version that jumps over a vector (e.g. JMP
($FFFC)). JSR (jump to subroutine) only has an absolute version, and stores the address of the next instruction minus one on the stack. RTS (return from
subroutine) takes the address from the stack, adds
one, and moves it into the program counter. The minus one logic was chosen because it could save one
cycle in the implementation of JSR.
A hardware interrupt, unless disabled by a set interrupt (I) flag, pushes the address of the next instruction minus one (just like JSR), pushes the processor
status afterwards, disables interrupts, and jumps over
the vector at $FFFE/$FFFF. RTI return from interrupt) is the same as the combination of PLP and RTS.
BRK causes a software interrupt and behaves the
same as a hardware interrupt, except that it sets the B
flag on the stack to 1 (a hardware interrupt sets it to 0)
NMIs behave the same as IRQs, but they cannot be
masked, and they use the $FFFA/$FFFB vector. The
reset vector is at $FFFC/$FFFD."
"In the context of the C64, What is the function that returns the natural logarithm of a number X?","basic: LOG(X)  (logarithm)

  Will  return  the natural log of X.  The natural log to the base e (see
EXP(X)). To convert to log base 10, simply divide by LOG(10)."
"In the context of the C64, What is the purpose and syntax of the PRINT# statement in BASIC programming?","basic: PRINT#

  There are a few differences between this statement and PRINT. PRINT# is
followed by a number,  which refers to the device or data file previously
OPENed.  This number is followed by a comma and a list to be printed. The
comma and semicolon have the same effect as they do in PRINT. Please note
that some devices may not work with TAB and SPC.

  100 PRINT#1, 'DATA VALUES'; A%, B1, C$"
"In the context of the C64, What is the format and syntax of the DATA statement in a programming language?","basic: DATA

  This  statement  is  followed  by  a  list  of items to be used by READ
statements.  Items  may  be numeric values or text strings, and items are
separated  by commas.  String items need not be inside quote marks unless
they contain space,  colon, or comma.  If two commas have nothing between
them, the value will be READ as a zero for a number, or an empty string.

  DATA 12, 14.5, 'HELLO, MOM', 3.14, PART1"
"In the context of the C64, What should you do if you purchased peripheral equipment, such as a VIC 1541 disk drive or a VIC 1525E printer?","Audio System
  If you purchased peripheral equipment, such as a VIC 1541 disk drive or
a VIC 1525E printer,  you may wish to connect it at this time.  Refer  to
the  user's  manuals  supplied  with  any  additional  equipment  for the
procedure for connecting it to the computer."
"In the context of the C64, What are the registers and procedures involved in creating and moving sprites in a graphics program?","basic: Sprites

 you need to know what
picture making locations control the functions you need. These locations,
called registers, could be illustrated in this manner:

  Register(s)   Description

   0            X coordinate of sprite 0
   1            Y coordinate of sprite 0
   2 - 15       Paired like 0 and 1 for sprites 1-7
  16            Most Significant Bit -- X coordinate
  21            Sprite appear: 1 = appear, 0 = disappear
  29            Expand sprite in 'X' Direction
  23            Expand sprite in 'Y' Direction
  39-46         Sprite 0-7 color

  In  addition  to  this  information you need to know from which 64 byte
section sprites will get their data (1 byte is used).
  This data is handled by 8 locations directly after screen memory:

        | 2040 | 2041 | 2042 | 2043 | 2044 | 2045 | 2046 | 2047 |
     SPRITE 0      1      2      3      4      5      6      7

  Now let's outline the exact procedure to get things moving  and finally
write a program.
  There  are  only a few things necessary to actually create  and move an
object.

  1. Make the proper sprite(s) appear on the screen by POKEing into
     location 21 a 1 for the bit which turns on the sprite.
  2. Set sprite pointer (locations 2040-2047) to where sprite data should
     be read from.
  3. POKE actual data into memory.
  4. Through a loop, update X and Y coordinates to move sprite around.
  5. You can, optionally, expand the object, change colors,  or perform a
     variety  of  special  functions.  Using  location  29 to expand your
     sprite in the 'X' direction and location 23 in the 'Y' direction."
"In the context of the C64, What are the steps to start programming in BASIC on a Commodore 64?","basic: how to start ?

Clear the screen by holding down the <SHIFT> key, and then depressing the
<CLR/HOME> key.
Type NEW and press <RETURN>. (This just clears out any numbers that might
have been left in the computer from your experimenting.)
Now type the following exactly as shown  (remember to hit <RETURN>  after
each line)

  10 ? 'COMMODORE 64'
  20 GOTO 10

  Now, type RUN and hit <RETURN> -- watch what happens.  Your screen will
come alive with COMMODORE 64. After you've finished watching the display,
hit <RUN/STOP> to stop the program."
"In the context of the C64, What are the editing options and techniques available to correct mistakes in a line of text?","basic:  Editing Tips

  If you make a mistake on a line, you have a number of editing options.

1. You can retype a line anytime,  and the  computer  will  automatically
   substitute the new line for the old one.
2. An unwanted line can be erased by simply typing the  line  number  and
   <RETURN>.
3. You can also easily edit an existing line,  using the cursor keys  and
   editing keys.

   Suppose you made a typing mistake in a line of the example. To correct
it without retyping the entire line, try this:
  Type LIST, then using the <SHIFT> and <CRSR UP/DOWN> keys together move
the  cursor  up  until  it  is  positioned  on  the line that needs to be
changed.
  Now,  use  the  cursor-right  key  to  move the cursor to the character
you  want  to  change,  typing the change over the old character. Now hit
<RETURN> and the corrected line will replace the old one.
  If you need more space on the line, position the cursor where the space
is needed and hit  <SHIFT>  and  <INST/DEL>  at the same time and a space
will  open  up.  Now  just  type  in  the  additional information and hit
<RETURN>.  Likewise,  you  can  delete unwanted characters by placing the
cursor to the right of the unwanted character and hitting the  <INST/DEL>
key."
"In the context of the C64, What are the steps to set up and troubleshoot a Commodore 64 computer?","USING THE COMMODORE 64

1. Turn  on  the computer using the rocker switch on the right-side panel
   when you're looking at the computer from the front.
2. After a few moments the following will be displayed on the TV screen:

      **** COMMODORE 64 BASIC V2 ****
   64K RAM SYSTEM  38911 BASIC BYTES FREE

   READY.
   _  

Cursor signals Commodore 64 is waiting for your input

3. If your TV has a manual fine tuning knob,  adjust the TV until you get
   a clear picture.
4. You  may also want to adjust the color and tint controls on the TV for
   the best display. You can use the color adjustment procedure described
   later to get everything setup properly.  When you first get a picture,
   the  screen  should appear mostly dark blue,  with a light blue border
   and letters.

TROUBLESHOOTING CHART

| Symptom               Cause                 Remedy                    |
| Indicator Light      Computer not 'On'     Make sure power switch     |
| not 'On'                                   is in 'On' position        |
|                                                                       |
|                      Power cable not       Check power socket for     |
|                      not plugged in        loose or disconnected      |
|                                            power cable                |
|                                                                       |
|                      Power supply not      Check connection with      |
|                      plugged in            wall outlet                |
|                                                                       |
|                      Bad fuse in           Take system to authorized  |
|                      computer              dealer for replacement of  |
|                                            fuse                       |
|                                                                       |
|                      TV on wrong           Check other channel        |
|                      channel               for picture (3 or 4)       |
|                                                                       |
|                      Incorrect             Computer hooks up to       |
|                      hookup                VHF antenna terminals      |
|                                                                       |
|                      Video cable not       Check TV output cable      |
|                      plugged in            connection                 |
|                                                                       |
|                      Computer set for      Set computer for same      |
|                      wrong channel         channel as TV (3 or 4)     |
|                                                                       |
| Random patterns on   Cartridge not         Reinsert cartridge after   |
| TV with cartridge    properly inserted     turning off power          |
| in place                                                              |
|                                                                       |
| Picture without      Poorly tuned TV       Retune TV                  |
| color                                                                 |
|                                                                       |
| Picture with         Bad color             Adjust color/hue/          |
| poor color           adjustment on TV      brightness controls on TV  |
|                                                                       |
| Sound with excess    TV volume up high     Adjust volume of TV        |
| background noise                                                      |
|                                                                       |
| Picture OK,          TV volume too low     Adjust volume of TV        |
| but no sound                                                          |
|                                                                       |
|                      Aux. output not       Connect sound jack to      |
|                      properly connected    aux. input on amplifier    |
|                                            and select aux. input      |"
"In the context of the C64, What are the types of variables used in Commodore 64 BASIC and how are they specified?","basic: VARIABLES

  The Commodore 64 uses three types of variables in BASIC. These are real
numeric, integer numeric, and string (alphanumeric) variables.
  Variable  names  may consist of a single letter, a letter followed by a
number, or two letters.
  An  integer  variable  is specified by using the percent (%) sign after
the  variable name.  String variable have the dollar sign ($) after their
name.

Examples

  Real Variable Names: A, A5, BZ
  Integer Variable Names: A%, A5%, BZ%
  String Variable Names: A$, A5$, BZ$"
"In the context of the C64, What is the purpose and syntax of the DEF FN command in a programming language?","basic: DEF FN

  This  command  allows you to define a complex calculation as a function
with a short name.  In the case of a long formula that is used many times
within the program, this can save time and space.
  This  function  name  will  be  FN and any legal variable name  (1 or 2
characters long).  First you must define the function using the statement
DEF  followed  by  the  function  name.  Following  the  name is a set of
parentheses enclosing a numeric variable. Then follows the actual formula
that  you want to define,  with the variable in the proper spot.  You can
then 'call' the formula, substituting any number for the variable.

  10 DEF FN A(X) = 12 * ( 34.75 - X / .3 )
  20 PRINT FN A(7)"
"In the context of the C64, What are the basic syntax and usage of the POKE and PRINT statements in a programming language?","basic: POKE

  POKE is always followed by two numbers, or formulas. The first location
is a memory location; the second number is a decimal value from 0 to 255,
which  will  be  placed in the memory location,  replacing any previously
stored value.

  10 POKE 53281,0
  20 S = 4096 * 13
  30 POKE S + 29, 8

PRINT

  The  PRINT  statement  is  the  first one most people learn to use, but
there  are  a  number of variations to be aware of. PRINT can be followed
by:

  Text String with quotes
  Variable names
  Functions
  Punctuation marks

  Punctuation  marks  are used to help format the data on the screen. The
comma   divides  the  screen  into  four  columns,  while  the  semicolon
suppresses  all  spacing.  Either mark can be last symbol on a line. This
results  in the next thing PRINTed acting as if it were a continuation of
the same PRINT statement.

  10 PRINT 'HELLO'
  20 PRINT 'HELLO', A$
  30 PRINT A + B
  40 PRINT J;
  50 PRINT A, B, C, D

  Also see: POS, SPC and TAB functions."
"In the context of the C64, What is the function of the basic function INT(X) in a programming language?","basic: INT(X)

  Returns the truncated value of X, that is,  with all the decimal places
to the right of the decimal point removed. The result will always be less
than, or equal to, X. Thus, any negative numbers with decimal places will
become the integer less than their current value."
"In the context of the C64, What is the purpose of the ON command in BASIC programming?","basic: ON

  This command turns the GOTO and GOSUB commands into special versions of
the IF statement. ON is followed by a formula, which is evaluated. If the
result of the calculation is one, the first line on the list is executed;
if the result is 2, the second line is executed, and so on. If the result
is 0,  negative,  or  larger  than  the  list  of numbers,  the next line
executed will be the statement following the ON statement.

  10 INPUT X
  20 ON X GOTO 10,20,30,40,50"
"In the context of the C64, What is the mathematical function that returns the value of e (approximately 2.718) raised to the power of a given number?","basic: EXP(X)

  Returns the value of the mathematical constant e (2.71827183) raised to
the power of X."
"In the context of the C64, What are the rules for assigning a name to a variable in BASIC?","basic: variable names: 

  In  assigning  a  name  to a variable there are a few things to keep in
mind.  First,  a  variable name can have one or two characters. The first
character  must  be  an  alphabetic  character  from  A to Z;  the second
character  can  be either alphabetic or numeric (in the range 0 to 9).  A
third character can be included to indicate the type of variable (integer
or text string), '%' or '$'.
  You can use variable names  having more than two alphabetic characters,
but  only the first two are recognized by the computer.  So PA and PARTNO
are the same and would refer to the same variable box.
  The  last  rule  for  variable names is simple:  they can't contain any
BASIC keywords  (reserved  words)  such as GOTO, RUN, etc.  Refer back to
Appendix D for a complete list of BASIC reserved words."
"In the context of the C64, What are the different types of operators in programming, including their symbols and uses, and how do they interact with each other in an expression?","basic: OPERATORS

  The arithmetic operators include the following signs:

  +  Addition
  -  Subtraction
  *  Multiplication
  /  Division
  ^  Raising to a power (exponentiation)

  On a line  containing  more than one operator,  there is a set order in
which operations always occur. If several operations are used together on
the  same  line,  the  computer  assigns  priorities  as follows:  First,
exponentiation. Next, multiplication and division, and last, addition and
subtraction.
  You can change the order of operations  by enclosing within parentheses
the calculation to be performed first. Operations enclosed in parentheses
will take place before other operations.
  There are also operations for equalities and inequalities:

  =  Equal To
  <  Less Than
  >  Greater Than
  <= Less Than or Equal To
  >= Greater Than or Equal To
  <> Not Equal To

  Finally, there are three logical operators:

  AND
  OR
  NOT

  These are used most  often  to  join  multiple  formulas  in  IF...THEN
statements. For example:

  IF A=B AND C=D THEN 100  (Requires both parts to be true)
  IF A=B OR  C=D THEN 100  (Allows either part to be true)"
"In the context of the C64, What are the optional connections available on the Commodore 64 and how can they be utilized?","c64 Optional Connections

  Since the Commodore 64 furnishes a channel of high fidelity sound,  you
may wish to play it through a quality amplifier to realize the best sound
possible.   In addition,  the  Commodore  64  also  provides  a  standard
'composite' video signal, which can be fed into a television monitor.
  These  options  are made possible by the audio/video output jack on the
rear panel  of the Commodore 64.  The easiest way to gain access to these
signals is by using a standard 5-Pin DIN audio cable (not supplied). This
cable connects directly to the audio/video connector on the computer. Two
of  the  four pins on the opposite end of the cable contain the audio and
video signals.  Optionally,  you can construct your own cable,  using the
pinouts shown in Appendix I as a guide.
  Normally,  the  BLACK  connector  of  the  DIN cable supplies the AUDIO
signal.  This  plug  may  be  connected  to  the  AUXILIARY  input  of an
amplifier,  or the AUDIO IN connector of a monitor or other video system,
such as a video cassette recorder (VCR).
  The  WHITE  or  RED connector usually supplies the direct VIDEO signal.
This  plug is connected to the VIDEO IN connector of the monitor or video
input section of some other video system, such as a VCR.
  Depending  on  the manufacturer of your DIN cable,  the color coding of
the plugs may be different.  Use the pinouts shown in Appendix I to match
up the proper plugs  if you don't get an audio or video signal  using the
suggested connections."
"In the context of the C64, What is the concept in programming that allows for the creation of lists of variables with the same name, using extra numbers to specify the element of the list, and how are they defined and used in Commodore 64 BASIC?","basic: Arrays are lists of variables with the same name,  using extra  numbers
to specify the element of the array.  Arrays are defined  using  the  DIM
statement, and may contain floating point, integer,  or string variables.
The array variable name is followed by a set of parentheses ( ) enclosing
the number of variables in the list.

  A(7), BZ%(11), A$(50), PT(20,20)

  NOTE:  There are three variable names which are reserved for use by the
Commodore 64, and may not be defined by you.  These variables are: ST, TI
and  TI$.   ST  is  a  status  variable  which  relates  to  input/output
operations.  The value of ST will change  if there is a problem loading a
program from disk or tape.
  TI and TI$ are variables which relate to the real-time clock built into
the Commodore 64. The variable TI is updated every 1/60th of a second. It
starts at 0 when the computer is turned on, and is reset only by changing
the value of TI$.
  TI$  is a string which is constantly updated by the system.  The  first
two characters contain the number of hours , the  3rd and 4th  characters
the number of minutes,  and  the 5th and 6th characters are the number of
seconds.  This  variable  can  be  given  any numeric value,  and will be
updated from that point.

  TI$ = '101530' sets the clock to 10:15 and 30 seconds AM.

  This clock is erased when the computer is turned  off,  and  starts  at
zero when the system is turned back on."
"In the context of the C64, How does the antenna switchbox facilitate the connection between the Commodore 64 and a TV?","No additional connections are required to use the c64 with your TV. The antenna switchbox will
connect the computer to the TV when the slide switch is in the 'computer'
position.  When  the switch is in the 'TV' position your set will operate
normally."
"In the context of the C64, What is the concept in programming languages that allows you to store and label a value, such as a number or string of text characters, in a computer's memory?","basic:  Variables

  Variables  are  some  of  the  most  used  features  of any programming
language,  because  variables  can represent much more information in the
computer.  Understanding how variables operate will make computing easier
and allow us to accomplish feats that would not be possible otherwise.
  Imagine a number of boxes within the computer that can hold a number or
a string of text characters.  Each of these boxes is to be labeled with a
name  that  we choose.  That name is called a variable and represents the
information in the respective box.
  For example, if we say:

  10 X% = 15
  20 X = 23.5
  30 X$ = 'THE SUM OF X% + X ='

  The computer might represent the variables like this:

  X%  15

  X   23.5

  X$  THE SUM OF X% + X =

  A  variable  name  represents  the  box,  or memory location, where the
current  value  of  the variable is stored. As you can see, we can assign
either  an  integer  number, floating point number, or a text string to a
variable.
  The '%' symbol  following  a  variable name indicates the variable will
represent  an  integer  number.  The following are valid integer variable
names:

  A%
  X%
  A1%
  NM%

  The  '$'  following  the  variable  name  indicates  the  variable will
represent a text string. The following are examples of string variables:

  A$
  X$
  MI$

  Floating  point  variables  follow  the  same  format,  with  the  type
indicator:

  A1
  X
  Y
  MI"
"In the context of the C64, What is the purpose of the basic function FN xx(X) in a programming language?","basic: FN xx(X)

  Returns  the  value  of  the  user-defined function xx created in a DEF
FN xx(X) statement."
"In the context of the C64, What is the purpose and syntax of the OPEN statement in Commodore 64 BASIC programming?","basic: OPEN

  Then  OPEN  statement allows the Commodore 64 to access devices such as
the cassette recorder and disk for data,  a printer,  or even the screen.
OPEN  is followed by a number (0-255),  to which all following statements
will  refer.  There is usually a second number after the first,  which is
the device number.
  The device numbers are:

  0   Screen
  1   Cassette
  4   Printer
  8   Disk

  Following the device number may be a third number, separated again by a
third number, separated again by a comma, which is the secondary address.
In the case of the cassette,  this is 0 for read,  1 for write, and 2 for
write with end-of-tape marker.
  In the case of the disk,  the number refers to the buffer,  or channel,
number.  In  the  printer,  the  secondary address controls features like
expanded printing. See the Commodore 64 Programmer's Reference Manual for
more details.

  10 OPEN 1,0           OPENs the SCREEN as a device
  20 OPEN 2,1,0,'D'     OPENs the cassette for reading,
                        file to be searched for is D
  30 OPEN 3,4           OPENs the printer
  40 OPEN 4,8,15        OPENs the data channel on the disk

  Also see: CLOSE, CMD, GET#, INPUT#, and PRINT#, system variable ST, and
Appendix B."
"In the context of the C64, What is the purpose and characteristics of the REM statement in a program?","basic: REM  (Remark)

  REMark  is a note to whomever is reading a LIST of the program.  It may
explain  a section of the program,  or give additional instructions.  REM
statements  in no way affect the operation of the program,  except to add
to its length. REM may be followed by any text."
"In the context of the C64, What is the function that returns the absolute value of a number, without its sign, and always returns a positive answer?","basic: ABS(X)  (absolute value)

  ABS  returns  the absolute value of the number,  without its sign (+ or
-). The answer is always positive."
"In the context of the C64, What is the formula to generate a random number within a specific range in BASIC programming?","basic:  Random Numbers and Other Functions

The RND instruction is generating random numbers

  PRINT INT(6*RND(1))+1,

The general formula for generating a set of random numbers in a certain
range is:

  NUMBER=INT(LOWER+(UPPER-LOWER+1)*RND(1))"
"In the context of the C64, What items should you find in the Commodore 64 container besides the manual?","Before  attaching  anything to the computer,  check the contents of the
Commodore  64  container.  Besides  a  manual,  you  should  find  the
following items:

  1. Commodore 64
  2. Power supply (black box with an AC plug and supply cord)
  3. Video cable
  4. TV Switchbox (small silver box with short antenna leads).

  If any items are missing  check back with your dealer immediately for a
replacement."
"In the context of the C64, What is the memory map structure used to store character and color information on the Commodore 64's screen?","COLOR MEMORY MAP

For every spot on the Commodore 64's
screen  there are two memory locations,  one for the character code,  and
the  other  for  the color code.  The color memory map begins at location
55296 (top left-hand  corner),  and continues on for 1000 locations.  The
same color codes, from 0-15, that we used to change border and background
colors can be used here to directly change character colors."
"In the context of the C64, What are the components and their functions located on the side panel of a Commodore 64 computer?","SIDE PANEL CONNECTIONS

  1. POWER SOCKET.  The  free  end  of the cable from the power supply is
     attached here to supply power to the Commodore 64.
  2. POWER SWITCH. Turns on power to the Commodore 64.
  3. GAME PORTS.  Each  game  connector  can  accept  a  joystick or game
     controller  paddle,  while the lightpen can only be plugged into the
     game port closest to the front of your computer."
"In the context of the C64, How do sprites work on the Commodore 64 and how are they controlled?","basic:  Sprite Creation

  Sprites are controlled by a separate picture-maker in the Commodore 64.
This  picture maker handles the video display.  It does all the hard work
of  creating  and  keeping  track  of  characters and graphics,  creating
colors, and moving around.
  This display circuit has 46 different 'ON/OFF' locations which act like
internal  memory  locations.  Each  of these locations breaks down into a
series of 8 blocks. And each block can either be 'ON' or 'OFF'. We'll get
into  more  detail  about this later.  By POKEing the appropriate decimal
value  in  the  proper  memory location you can control the formation and
movement of your sprite creations.
  In  addition  to accessing many of the picture making locations we will
also be using some of the Commodore 64's main memory to store information
(data) that defines the sprites. Finally, eight memory locations directly
after  the  screen memory will be used to tell the computer exactly which
memory area each sprite will get its data from."
"In the context of the C64, What is the process to change text colors and create a rainbow effect in a basic printing system?","basic: PRINTing Colors

you  can  change  text colors by simply holding the <CTRL> key and one of
the color keys.  

You have a full range of 16 text colors to work with.  Using <CTRL> key
and a number key, the following colors are available:

     1        2        3        4        5       6        7        8
   Black    White     Red     Cyan    Purple   Green    Blue    Yellow

  If  you  hold  down the <C=> key along with the appropriate number key,
these additional eight colors can be used:

     1        2        3        4        5       6        7        8
   Orange   Brown   Lt.Red    Gray 1  Gray 2  Lt.Green  Lt.Blue  Gray 3

Type NEW,  and experiment with the following.  Hold down the <CTRL> key
and  at  the  same  time hit the <1> key.  Next,  hit the <R> key without
holding down the <CTRL> key.  Now,  while again depressing the <CTRL> key
at the same time hit the <2> key.  Release the <CTRL> key and hit the <A>
key. Move through the numbers, alternating with the letters, and type out
the word RAINBOW as follows:"
"In the context of the C64, What is the purpose and syntax of the WAIT command in a programming language?","basic: WAIT

  WAIT  is  used  to  halt  the  program  until  the contents of a memory
location changes in a specific way. WAIT is followed by a memory location
(X) and up to two variables. The format is:

  WAIT X,Y,Z

  The  contents  of the memory location are first exclusive-ORed with the
third  number,  if  present,  and  then  logically  ANDed with the second
number.  If  the  result  is  zero,  the program goes back to that memory
location  and  checks  again.  When  the  result  is nonzero, the program
continues with the next statement."
"In the context of the C64, What is the purpose of the READ statement in programming?","basic: READ

  READ  is  used to assign information from DATA statements to variables,
so the information may be put to use. Care must be taken to avoid READing
strings where READ is expecting a number, which will give a TYPE MISMATCH
ERROR."
"In the context of the C64, What is the mathematical function that returns the angle, measured in radians, whose tangent is X?","basic: ATN(X)  (arctangent)

  Returns the angle, measured in radians, whose tangent is X."
"In the context of the C64, What is the purpose of the RESTORE statement in a program?","basic: RESTORE

  When  executed  in  a  program,  the pointer to which an item in a DATA
statement will be READ next is reset to the first item in the list.  This
gives you ability to re-READ the information. RESTORE stands by itself on
a line."
"In the context of the C64, What is the formula to calculate the memory location on the Commodore 64 screen, and how would you use it to determine the memory location of a ball bouncing on the screen at column 20, row 12?","basic:   Screen  memory  in  the Commodore 64 normally begins at memory location
1024,  and ends at location 2023.  Location 1024 is the upper left corner
of the screen. Location 1025 is the position of the next character to the
right  of that,  and so on down the row.  Location 1063 is the right-most
position of the first row. The next location following the last character
on a row is the first character on the next row down.

  Now,  let's  say that you're controlling a ball bouncing on the screen.
The ball is in the middle of the screen,  column 20, row 12.  The formula
for calculation of the memory location on the screen is:

  POINT = 1024 + X + 40 * Y

where X is the column and Y is the row.
  Therefore, the memory location of the ball is:
  POKE 1524, 81
  POKE 55796, 1"
"In the context of the C64, What are the steps to connect a Commodore 64 computer to a TV?","CONNECTIONS TO TV:
Connect the computer to your TV as shown below.
1. Attach one end of the TV cable to the phono type TV signal jack at the
   rear of the Commodore 64. Just push it in. Either end of the cable can
   be used.
2. Connect the other end of the cable to the antenna switchbox. Just push
   it in.
3. If you have a VHF antenna, disconnect it from your TV set.
4. Connect your VHF antenna cable to the screw terminals labeled 'antenna
   input'  on  the  switchbox.  If your antenna cable is the round 75-ohm
   coax  type,  use  a 75-ohm to 300-ohm adapter (not supplied) to attach
   your antenna cable to the switchbox.
5. Connect the twin lead output cable of the antenna switchbox to the VHF
   antenna  terminals  of  your  TV set.  If your set is one of the newer
   types  with  a round 75-ohm VHF connector,  you will need a 300-ohm to
   75-ohm converter (not supplied) to connect the switchbox to the 75-ohm
   VHF antenna input on the set.
6. Set  the  TV's  VHF  tuner  to  the  channel  number  indicated on the
   computer's  channel selector switch (channel 3  move the switch to the
   left,  channel 4  move the switch to the right).  If a strong local TV
   signal  is present on one of these channels,  select the other channel
   to avoid possible interference.
7. Plug  the  power supply cable into the power socket on the side of the
   Commodore 64.  Just  push  it in.  It is 'keyed' to allow insertion in
   only one direction, so you can't connect the power cord the wrong way.
   The power supply converts household current into the form the computer
   uses."
"In the context of the C64, What is the purpose and functionality of the GET command in BASIC programming?","basic:  GET

  GET  allows  you  to  input  one  character at a time from the keyboard
without  hitting  <RETURN>.  This  really  speeds  entering  data in many
applications.  Whatever  key  is hit is assigned variable to the variable
you specify with GET.
  The following routine illustrates how GET works:

  NEW

   1 PRINT '{CLR/HOME}'
  10 GET A$: IF A$ = '' THEN 10
  20 PRINT A$;        
  30 GOTO 10          

If you RUN the program,  the screen will clear  and each time you hit a
key, will  print  it  on  the  display,  and  then GET another
character. It is important to note that the character entered will not be
displayed  unless you specifically PRINT it to the screen,  as we've done
here."
"In the context of the C64, What is the purpose and syntax of the NEXT statement in a FOR loop?","basic: NEXT

  NEXT  is  always  used in conjunction with the FOR statement.  When the
program  reaches a NEXT statement,  it checks the FOR statement to see if
the limit of the loop has been reached.  If the loop is not finished, the
loop  variable  is increased by the specified STEP value.  If the loop is
finished,  execution  proceeds  with  the  statement following NEXT.
  NEXT  may  be  followed by a variable name,  or list of variable names,
separated by commas.  If there are no names listed, the last loop started
is the one being completed. If variables are given, they are completed in
order from left to right.

  10 FOR X = 1 TO 100: NEXT"
"In the context of the C64, What are the explanations and examples of the INPUT# and LET statements in BASIC programming?","basic: INPUT#

  INPUT#  is  similar  to INPUT,  but takes data from a previously OPENed
file or device.

  10 INPUT#1, A

LET

  LET  is  hardly  ever  used  in programs, since it is optional, but the
statement is the heart of all BASIC programs.  The variable name which is
to  be  assigned  the  result of a calculation is on the left side of the
equal sign, and the formula in the right.

  10 LET A = 5
  20 LET D$ = 'HELLO'"
"In the context of the C64, What happens when you run a BASIC program that uses the INPUT statement to prompt the user for input, and how can you exit the program?","basic: INPUT


To get an idea of how INPUT works,  type  NEW  <RETURN>  and enter this
short program:

  10 INPUT A$
  20 PRINT 'YOU TYPED: ';A$
  30 PRINT
  40 GOTO 10
  RUN
  ? COMMODORE 64 
  YOU TYPED: COMMODORE 64 

  What  happens  when  you  run this simple program. A question mark will
appear,  indicating  that  the  computer  is  waiting  for  you  to  type
something. Enter any character, or group of characters, from the keyboard
and  hit  <RETURN>.  The  computer  will  then  respond with 'YOU TYPED:'
followed by the information you entered.
You  can  INPUT  either numeric or string variables,  and even have the
INPUT statement prompt the user with a message. The format of INPUT is:

  INPUT 'PROMPT MESSAGE';VARIABLE


Or, just:

  INPUT VARIABLE

NOTE:  To  get out of this program hold down the <RUN/STOP> and <RESTORE>
keys."
"In the context of the C64, How does the Commodore 64's screen memory map work and how can characters be displayed on the screen?","basic: SCREEN MEMORY MAP

  Since  the  computer's screen is capable of holding 1000 characters (40
columns by 25 lines)  there are 1000 memory locations set aside to handle
what  is placed on the screen.  The layout of the screen could be thought
of as a grid, with each square representing a memory location.
  And  since  each location in memory can contain a number from 0 to 255,
there  are  256  possible  values for each memory location.  These values
represent  the  different  characters  the  Commodore 64 can display (see
Appendix E).  By  POKEing  the  value  for a character in the appropriate
screen  memory  location,  that character will be displayed in the proper
position."
"In the context of the C64, What are the different connections and interfaces available on the rear of a Commodore 64 computer?","REAR CONNECTIONS

  4. CARTRIDGE SLOT.  The rectangular slot to the left accepts program or
     game cartridges.
  5. CHANNEL SELECTOR.  Use  this  switch  to select which TV channel the
     computer's picture will be displayed on.
  6. TV CONNECTOR.  This connector supplies both the picture and sound to
     your television set.
  7. AUDIO & VIDEO OUTPUT.  This  connector supplies direct audio,  which
     can  be connected to a high quality sound system,  and a 'composite'
     video signal, which can be fed into a television 'monitor'.
  8. SERIAL PORT.  You can attach a printer or single disk drive directly
     to the Commodore 64 through this connector.
  9. CASSETTE INTERFACE.  A  DATASSETTE  recorder  can be attached to the
     computer  so  you  can  save  information entered for use at a later
     time.
 10. USER PORT.  Various interface cartridges can be attached to the user
     port, such as the VICMODEM, or RS 232 communication cartridge."
"In the context of the C64, What happens when a program encounters a RETURN statement, and what error occurs if no GOSUB was previously issued?","basic: RETURN

  This  statement  is  always  used  in conjunction with GOSUB.  When the
program  encounters  a  RETURN,  it  will go to the statement immediately
following the GOSUB command.  If no GOSUB was previously issued, a RETURN
WITHOUT GOSUB ERROR will occur."
"In the context of the C64, What is the function that returns the value of the cosine of an angle measured in radians?","basic: COS(X)  (cosine)

  Returns  the  value of the cosine of X, where X is an angle measured in
radians."
"In the context of the C64, What is the operator used for division in BASIC, and how would you divide 144 by 12?","basic: DIVISION

  Division uses the familiar '/'. For example, to divide 144 by 12, type:

  PRINT 144 / 12           <----- Hit <RETURN>
  12"
"In the context of the C64, What are the steps to reset the Commodore 64 screen and text color to their default settings after running a color test?","C64 Rinitialize

<SHIFT> and <CLR/HOME>.  The screen should clear and the cursor
will  be  positioned  in  the  'home' spot (upper left-hand corner of the
screen).
  Now, simultaneously hold <C=> and the <7> key. This sets the text color
back to light blue.  There is one more step needed to get everything back
to normal. Hold <CTRL> and <0> (Zero not Oh!). This sets the display mode
back  to  normal.  If  you  remember,  we turned REVERSE type on with the
<CTRL><9> to create the color bars (the color bars were actually reversed
spaces).  If  we were in the normal text mode during the color test,  the
cursor would have moved, but just left blank spaces."
"In the context of the C64, What is the function of the Commodore key (<C=>) on a Commodore computer?","<C=> COMMODORE KEY key

  The Commodore key <C=> performs a number of functions. First, it allows
you to move between the text and graphic display modes.
  When  the computer is first turned on,  it is in the upper case/graphic
mode,  that  is,  everything  you  type is in upper case letters.  As was
mentioned, using the <SHIFT> key in this mode will display the graphic on
the right side of the keys.
  If you hold down the <C=> key and <SHIFT> key,  the display will change
to upper and lower case. Now, if you hold down the <C=> key and any other
key with a graphic symbol,  the graphic shown on the left side of the key
will be displayed.
  To get back into the upper case/graphic mode hold down the <C=> key and
<SHIFT> key again.
  The second function of the <C=> key is to  allow you access to a second
set  of  eight  text colors.  By holding down the <C=> key and any of the
number keys,  any text now typed will be in the alternate color available
from  the  key  you depressed.  Chapter 5 lists the text colors available
from each key.

`"
"In the context of the C64, What is the syntax to multiply two numbers in a programming language?","basic: MULTIPLICATION

  If  you  wanted  to  multiply  12  times  12,  use  the asterisk (*) to
represent multiplication. You would type:

  PRINT 12 * 12            <----- Hit <RETURN>
  144"
"In the context of the C64, What is the function of the BASIC command STR$(X)""?""","basic: STR$(X)

  This will return a string  which is identical to the PRINTed version of
X."
"In the context of the C64, What is the purpose and function of the key that stands for ConTRoL?","<CTRL> key

  The  <CTRL>  key,  which  stands for ConTRoL, allows you to set colors,
and  perform  other  specialized  functions. You hold the <CTRL> key down
while  depressing  another  designated key to get a control function. You
had an opportunity to try the <CTRL> key  when you changed text colors to
create different color bars during the setup procedure."
"In the context of the C64, What is the purpose of the plus sign (+) in arithmetic operations?","basic: ADDITION

  The plus sign (+) signals addition: we instructed the computer to print
the result of 12 added to 12.  Other arithmetic operations take a similar
form to addition.  Remember to always hit <RETURN> after typing PRINT and
the calculation."
"In the context of the C64, What is the syntax to subtract 9 from 12 in a programming language?","basic: SUBTRACTION

  To subtract, use the conventional minus (-) sign. Type:

  PRINT 12 - 9             
  3"
"In the context of the C64, What is the function of the <RUN/STOP> key in a BASIC program, and how can it be used in shifted mode?","<RUN/STOP> key

  Normally,  depressing the <RUN/STOP>  key  will stop the execution of a
BASIC program. It signals the computer to STOP doing something. Using the
<RUN/STOP> key in the shifted mode will allow you to automatically load a
program from tape."
"In the context of the C64, What is the function of the RIGHT$ command in BASIC?","basic: RIGHT$(X$,X)

  Returns the rightmost X characters in X$."
"In the context of the C64, What is one of the most important features of the Commodore 64?","Loading and Saving Programs

  One  of  the most important features of the Commodore 64 is the ability
to save and load programs to and from cassette tape or disk.
  This  capability allows you to save the programs you write for use at a
later time, or purchase prewritten programs to use with the Commodore 64.
  Make  sure  that  either  the  disk  drive or cassette unit is attached
properly."
"In the context of the C64, What is the procedure to save a program on tape in a computer?","SAVING PROGRAMS ON TAPE

  After entering a program, if you wish to save it on tape, type:

  SAVE 'PROGRAM NAME'

  'PROGRAM NAME' can be up to 16 characters long.  After you hit <RETURN>
the computer will respond with:

  PRESS PLAY AND RECORD ON TAPE

  Press both the record and play keys on the datassette.  The screen will
blank, turning the color of the border.
  After  the  program  is  saved on tape, the READY prompt will reappear,
indicating  that  you can start working on another program,  or just turn
off the computer for a while."
"In the context of the C64, What is the purpose of the four function keys on the right side of the keyboard?","FUNCTION KEYS key

  The  four  function  keys  on  the  right  side  of the keyboard can be
'programmed'  to  handle  a variety of functions.  They can be defined in
many ways to handle repetitive tasks."
"In the context of the C64, What does the <RESTORE> command do in a computer?","<RESTORE>  key

  <RESTORE>  operates as the name implies.  It stores the computer to the
normal  state  it was in before you changed things with a program or some
command. A lot more will be said on this in later chapters."
"In the context of the C64, What is the process and syntax for loading a program from a disk on a computer?","LOADING PROGRAMS FROM DISK

  Loading a program from disk follows the same format. Type:

  LOAD 'PROGRAM NAME',8

  The  8  is  the  code for the disk, so you're just letting the computer
know that you want the program loaded from the disk.
  After  you  hit  <RETURN>  the disk will start whirring and the display
shows:

  SEARCHING FOR PROGRAM NAME
  LOADING
  READY.
  _

NOTE:
  When   you   load  a  new  program  into  the  computer's  memory,  any
instructions  that  were  in the computer previously will be erased. Make
sure  you  save  a  program  you're  working on before loading a new one.
Once a program has been loaded, you can RUN it, LIST, or make changes and
re-save the new version."
"In the context of the C64, What are the steps to reset a Commodore 64 computer to its normal display, and how can you completely reset the machine as if it were turned off and on again?","C64 Reset
There is a simple way to
reset the machine  to the normal display.  First press the <RUN/STOP> key
and then press the <RESTORE> key.  <RUN/STOP> must always be held down in
order to use the <RESTORE> key function.
  This will clear the screen and return everything to normal. If there is
a  program  in  the computer,  it will be left untouched.  This is a good
sequence to remember, especially if you do a lot of programming.
  If  you  wish  to  reset  the machine as if it were turned off and then
switched on again, type,  SYS 64759  and press <RETURN>. Be careful using
this  command!  It  will  wipe  out  any  program  or information that is
currently in the computer."
"In the context of the C64, What is the command to save a program to disk, and what does the number 8 represent in the command?","SAVING PROGRAMS ON DISK

  Saving a program on disk is even simpler. Type:

  SAVE 'PROGRAM NAME',8

  The  8  is  the code for the disk,  so you're just letting the computer
know you want the program saved to disk.
  After you press  <RETURN>  the disk will start to turn and the computer
will respond with:

  SAVING PROGRAM NAME
  OK
  READY.
  _"
"In the context of the C64, What are the steps to load a game cartridge on a Commodore 64 computer?","CARTRIDGES: The Commodore 64 computer has a line of programs and games
on cartridge.  The programs offer a wide variety of business and personal
applications  and  the  games  are  just  like real arcade games  --  not
imitations. To load these games, first turn on your TV set. Next turn OFF
your  Commodore 64.  YOU MUST TURN OFF YOUR COMMODORE 64 BEFORE INSERTING
OR  REMOVING  CARTRIDGES  OR  YOU  MAY  DAMAGE  THE CARTRIDGE AND/OR YOUR
COMMODORE 64! Third insert the cartridge.  Now turn your Commodore 64 on.
Finally  type  the  appropriate START key as is listed on the instruction
sheet that comes with each game."
"In the context of the C64, What are the steps to load a program from a cassette tape into a computer?","CASSETTES:  Use  your  DATASSETTE  recorder  and  the  ordinary  audio
cassettes  that  came as part of your prepackaged program.  Make sure the
tape is completely rewound to the beginning of the first side.  Then just
type  LOAD.  The  computer  will  answer with PRESS PLAY ON TAPE,  so you
respond  by  pressing play on your datassette machine.  At this point the
computer  screen  will go blank until the program is found.  The computer
will say  FOUND (PROGRAM NAME)  on the screen.  Now you press down on the
<C=> key.  This will actually load the program into the computer.  If you
want to stop the loading simply press <RUN/STOP> key."
"In the context of the C64, What is the purpose of the PRINT command in BASIC programming, and how can it be used for calculations and displaying results?","PRINT and Calculations

  Now  that  you've  gotten  through  a  couple  of  the  more  difficult
operations  you need  in order to keep the programs you like,  lets start
making some programs for you to save.
  Try typing the following exactly as shown:

  PRINT 'COMMODORE 64'     <----- Type this line and hit <RETURN>
  COMMODORE 64            <------ Computer typed

  READY.
  _

  If  you  make  a  typing  mistake,  use the <INST/DEL> key to erase the
character  immediately  to the left of the cursor. You can delete as many
characters as necessary.
  Let's  see  what  went on in the example above.  First,  you instructed
(commanded) the computer to PRINT whatever was inside the quote marks. By
hitting  <RETURN>  you  told  the computer to do  what you instructed and
COMMODORE 64 was printed on the screen.
  When you use the PRINT statement in this form,  whatever is enclosed in
quotes is printed exactly as you typed it.
  If the computer responded with:

  ?SYNTAX ERROR

ask yourself if you made a mistake in typing,  or forgot the quote marks.
The  computer  is  precise  and  expects  instructions  to  be given in a
specific form.
  But don't get worried; just remember to enter things as we present them
in the examples and you'll get along great with the Commodore 64.
  Remember, you can't hurt the computer by typing on it, and the best way
to learn BASIC is to try different things and see what happens.
  PRINT  is  one  of  the  most useful and powerful commands in the BASIC
language.  With  it,  you  can  display  just  about  anything  you wish,
including graphics and results of computations.
  For example,  try the following.  Clear the screen  by holding down the
<SHIFT> key  and  <CLR/HOME> key and type (be sure to use the '1' key for
one, not a letter 'I'):

  PRINT 12 + 12            
  24                      

  READY.
  _

  What you've discovered is  that the Commodore 64 is a calculator in its
basic form.  The result of '24' was calculated and printed automatically.
In  fact,  you can also perform  subtraction,  multiplication,  division,
exponentiation, and  advanced  math  functions such as calculating square
roots, etc. And you're not limited to a single calculation on a line, but
more on that later.
  Note  that in the above form,  PRINT behaved differently from the first
example.  In  this  case,  a value or result of a calculation is printed,
rather  than  the  exact message you entered because the quote marks were
omitted."
"In the context of the C64, What does the BASIC function ASC(X$) return?","basic: ASC(X$)

  This function will return the ASCII code of the first character of X$."
"In the context of the C64, What is the function of the <INST/DEL> key in a text editor?","<INST/DEL> key

  If  you  hit  the  <INST/DEL>  key,  the cursor will move back a space,
erasing  (DELeting)  the  previous  character you typed. If you're in the
middle of a line, the character to the left is deleted and the characters
to the right automatically move together to close up the space.
  A <SHIFT>ed <INST/DEL> allows you to INSerT information on a line.  For
example,  if you noticed a typing mistake  in the beginning of a line  --
perhaps you left out part of the name  -- you could use the <CRSR> key to
move back to the error  and then hit <INST/DEL>  to insert a space.  Then
just type in the missing later."
"In the context of the C64, What is the function of the CLR/HOME key on a computer keyboard?","<CLR/HOME> key

  <CLR/HOME>  positions  the cursor at the 'HOME' position of the screen,
which is the upper left-hand corner.  A shifted <CLR/HOME> will clear the
screen and place the cursor in the home position."
"In the context of the C64, What is the purpose and functionality of the BASIC function USR(X)?","basic: USR(X)

  When  this  function  is used,  the program jumps to a machine language
program  whose  starting  point  is  contained  in memory locations.  The
parameter X is passed to the machine language program,  which will return
another  value  back  to  the  BASIC  program.  Refer to the Commodore 64
Programmer's Reference Manual  for  more  details  on  this  function and
machine language programming."
"In the context of the C64, What is the purpose of the SGN(X) function in basic programming?","basic: SGN(X)  (sign)

  This function returns the sign (positive, negative, or zero) of X.  The
result will be +1 if positive, 0 if zero, and -1 if negative."
"In the context of the C64, What is the function of TAB(X) in a print statement in BASIC program?","basic: TAB(X)

  TAB is used in a PRINT statement; the next item to be PRINTed will
be in column X."
"In the context of the C64, What are the steps to load a program from tape on a Commodore computer?","LOADING PROGRAMS FROM TAPE

  Loading  a program back from tape or disk is just as simple.  For tape,
rewind the tape back to the beginning and type:

  LOAD 'PROGRAM NAME'

  If  you  don't remember the program name,  just type LOAD and the first
program on the tape will be loaded into memory.
  After you press <RETURN> the computer will respond with:

  PRESS PLAY ON TAPE

  After  you  depress  the  play  key, the screen will blank, turning the
border color of the screen as the computer searches for the program.
  When the program is found, the screen will display:

  FOUND PROGRAM NAME

To  actually  load  the  program,  depress the <C=> key. To abandon the
loading  procedure,  hit  <RUN/STOP>.  If  you hit the Commodore key, the
screen  will  again  turn  the  border color while the program is loaded.
After  the  loading procedure is completed, the screen will return to the
normal state and the READY prompt will reappear."
"In the context of the C64, What is the function of the <CRSR> key on a keyboard?","<CRSR> key

  There are two keys marked <CRSR> (CuRSoR), one with up and down arrows,
the other with left and right arrows.  You can use these keys to move the
cursor up and down or left and right.  In the unshifted mode,  the <CRSR>
keys  will  let  you  move  the  cursor down and to the right.  Using the
<SHIFT> key and <CRSR> keys allows the cursor to be moved either up or to
the  left.  The  cursor keys have a special repeat feature that keeps the
cursor moving until you release the key."
"In the context of the C64, What features does the Commodore 64 offer to help with correcting typing mistakes and moving information on the screen?","EDITING key

  No  one  is  perfect,  and  the Commodore 64 takes that into account. A
number  of  editing  keys  let  you  correct  typing  mistakes  and  move
information around on the screen."
"In the context of the C64, What are the steps to load a preprogrammed disk and run a software program?","DISK:  Using your disk drive,  carefully insert the preprogrammed disk
so  that  the label on the disk is facing up and is closest to you.  Look
for  a  little notch on the disk (it might be covered with a little piece
of tape). If  you're inserting the disk properly the notch will be on the
left side.  Once the disk is inside  close the protective gate by pushing
down on the lever.  Now type  LOAD 'PROGRAM NAME',8  and hit the <RETURN>
key. The disk will make noise and your screen will say:

  SEARCHING FOR PROGRAM NAME
  LOADING
  READY.
  _

  When  the  READY  comes  on  and  the  _ is on, just type RUN, and your
prepackaged software is ready to use."
"In the context of the C64, What are the abbreviations and corresponding keyboard shortcuts for various BASIC commands?","ABS     A <SHIFT+B>                
 NOT     N <SHIFT+O>
 AND     A <SHIFT+N>                
 ASC     A <SHIFT+S>                
 OPEN    O <SHIFT+P>
 ATN     A <SHIFT+T>                
 CHR$    C <SHIFT+H>                
 PEEK    P <SHIFT+E>
 CLOSE   CL <SHIFT+O>               
 POKE    P <SHIFT+O>
 CLR     C <SHIFT+L>                
 CMD     C <SHIFT+M>                
 PRINT   ? 
 CONT    C <SHIFT+O>                
 PRINT#  P <SHIFT+R>
 READ    R <SHIFT+E>
 DATA    D <SHIFT+A>                
 DEF     D <SHIFT+E>                
 RESTORE RE <SHIFT+S>
 DIM     D <SHIFT+I>                
 RETURN  RE <SHIFT+T>
 END     E <SHIFT+N>                
 RIGHT$  R <SHIFT+I>
 EXP     E <SHIFT+X>                
 RND     R <SHIFT+N>
 RUN     R <SHIFT+U>
 FOR     F <SHIFT+O>                
 SAVE    S <SHIFT+A>
 FRE     F <SHIFT+R>                
 SGN     S <SHIFT+G>
 GET     G <SHIFT+E>                
 SIN     S <SHIFT+I>
 SPC     S <SHIFT+P>
 GOSUB   GO <SHIFT+S>               
 SQR     S <SHIFT+Q>
 GOTO    G <SHIFT+O>                
 STEP    ST <SHIFT+E>
 STOP    S <SHIFT+T>
 INPUT#  I <SHIFT+N>                
 STR$    ST <SHIFT+R>
 SYS     S <SHIFT+Y>
 LEFT$   LE <SHIFT+F>               
 TAB(    T <SHIFT+A>
 LET     L <SHIFT+E>                
 THEN    T <SHIFT+H>
 LIST    L <SHIFT+I>  
 LOAD    L <SHIFT+O>                
 TIME$   TI$
 USR     U <SHIFT+S>
 MID$    M <SHIFT+I>                
 VAL     V <SHIFT+A>
 VERIFY  V <SHIFT+E>
 NEXT    N <SHIFT+E>                
 WAIT    W <SHIFT+A>"
"In the context of the C64, What are the definitions and behaviors of the SIN(X), SQR(X), and TAN(X) functions?","basic: SIN(X)  (sine)

  SIN(X) is the trigonometric sine function.  The result will be the sine
of X, where X is an angle in radians.

SQR(X)  (square root)

  This  function will return the square root of X,  where X is a positive
number or 0. If X is negative, an ILLEGAL QUANTITY ERROR results.

TAN(X)  (tangent)

  The result will be the tangent of X, where X is an angle in radians."
"In the context of the C64, What is the function of the LEFT$ command in BASIC?","basic: LEFT$(X$,X)

  Returns a string containing the leftmost X characters of X$."
"In the context of the C64, What does the FRE(X) function return in terms of memory availability?","basic: FRE(X)

  This  function  returns the number of unused bytes available in memory,
regardless  of the value of X.  Note that FRE(X) will read out n negative
numbers if the number of unused bytes is over 32K."
"In the context of the C64, What is the procedure to adjust the color settings on a Commodore 64 computer using the keyboard controls?","C64 Color Adjustment

  There  is  a simple way to get a pattern of colors on the TV so you can
easily  adjust  the  set.  Even  though  you may not be familiar with the
operation  of the computer right now,  just follow along,  and you'll see
how easy it is to use the Commodore 64.
  First,  look on the left side of the keyboard and locate the key marked
<CTRL>.  This  stands for ConTRoL and is used,  in conjunction with other
keys, to instruct the computer to do a specific task.

  To  use  a  control  function,  you  hold  down  the  <CTRL>  key while
depressing a second key.
  Try this:  hold the <CTRL> key  while also depressing the <9> key. Then
release both keys. Nothing obvious should have happened, but if you touch
any  key  now,  the  screen  will show the character displayed in reverse
type, rather than normal type -- like the opening message or anything you
typed earlier.
  Hold down the <SPACE BAR>. What happens? If you did the above procedure
correctly,  you  should  see  a light blue bar move across the screen and
then move down to the next line as long as the <SPACE BAR> is depressed.

     **** COMMODORE 64 BASIC V2 ****
  64K RAM SYSTEM  38911 BASIC BYTES FREE

  READY.

  Now,  hold <CTRL>  while depressing any of the other number keys.  Each
of  them  has a color  marked on the front.  Anything displayed from this
point will be in that color. For example, hold <CTRL> and the <8> key and
release both. Now hold the <SPACE BAR>.
  Watch the display.  The bar is now in yellow!  In a like manner you can
change  the  bar  to  any  of  the colors indicated on the number keys by
holding <CTRL> and the appropriate key.
  Change the bar to a few more different colors and then adjust the color
and  tint  controls  on  your  TV  so  the display matches the colors you
selected.
  The display should appear something like this:

     **** COMMODORE 64 BASIC V2 ****
  64K RAM SYSTEM  38911 BASIC BYTES FREE

  READY.
  _________________________     <------ <3> Red bar
  _______ ____________ ____     <------ <3>,<6>,<7> Red, Green, Blue bars
  __________ ______________     <------ <7>,<8> Blue, Yellow bars
  ____________                  <------ <8> Yellow bar

  At  this  point  everything is properly adjusted and working correctly.
The following chapters will introduce you to the BASIC language. However,
you can  immediately start using some of the many prewritten applications
and  games available for the Commodore 64  without knowing anything about
computer programming.
  Each  of  these packages contains detailed information about how to use
the  program.  It is suggested,  though,  that you read through the first
few  chapters  of  this  manual  to  become  more familiar with the basic
operation of your new system."
"In the context of the C64, What is the operation represented by the '^' symbol in programming, and how does it differ from multiplication?","basic: EXPONENTIATION

  In  a  like fashion,  you can easily raise a number to a power (this is
the same as multiplying a number by itself  a specified number of times).
The '^' (up arrow) signifies exponentiation.

  PRINT 12 ^ 5
  248832

  This is the same as typing:

  PRINT 12 * 12 * 12 * 12 * 12
  248832"
"In the context of the C64, What is a shortcut way to replace the BASIC command PRINT"" in a calculation?""","BASIC  has  number  of  shortcut ways of doing things.  One such way is
abbreviating BASIC commands (or keywords).  A '?' can be used in place of
PRINT,  for example.  As we go on you'll be presented with many commands;
Appendix D shows the abbreviations for each and what will be displayed on
the screen when you type the abbreviated form.

many calculations
may be performed on the same line, and they can be of mixed types.
  You could calculate this problem:

  ? 3 + 5 - 7 + 2          (The '?' replaces the word PRINT)
  3"
"In the context of the C64, What is the first thing you should do after setting up your Commodore 64?","C64 Keyboard

  Now that you've got everything set up and adjusted,  please  take a few
moments  to  familiarize  yourself  with  the keyboard which is your most
important means of communication with the Commodore 64.
  You  will  find  the keyboard similar to a standard typewriter keyboard
found  in  most  areas.  There  are,  however, a number of new keys which
control specialized functions. What follows is a brief description of the
various  keys  and how they function.  The detailed operation of each key
will be covered in later sections."
"In the context of the C64, What is the purpose and behavior of the VAL function in Basic programming?","basic: VAL(X$)

  This function converts X$ into a number, and is essentially the inverse
operation  from STR$.  The string is examined from the leftmost character
to  the  right,  for  as  many  characters  as are in recognizable number
format.

  10 X = VAL('123.456')             X = 123.456
  10 X = VAL('12A13B')              X = 12
  10 X = VAL('RIU017')              X = 0
  10 X = VAL('-1.23.45.67')         X = -1.23"
"In the context of the C64, What is the function in Visual Basic that returns a string character whose ASCII code is a specified value?","basic: CHR$(X)

  This is the opposite of ASC, and returns a string character whose ASCII
code is X."
"In the context of the C64, What does the BASIC function POS(X) return?","basic: POS(X)

  This function returns the number of the column (0-39) at which the next
PRINT statement will begin on the screen. X may have any value and is not
used."
"In the context of the C64, What is the function in BASIC that returns the number of characters in a string, including spaces and symbols?","basic: LEN(X$)

  Returned will be the number of characters  (including  spaces and other
symbols) in the string X$."
"In the context of the C64, What is the function of the key on a keyboard that allows you to switch between uppercase and lowercase characters, as well as access graphic characters and special functions?","<SHIFT> key

  The <SHIFT> key works like that on a standard typewriter. Many keys are
capable of displaying two letters or symbols  and two graphic characters.
In  the  'upper/lower case' mode the <SHIFT> key gives you standard upper
case  characters.  In the 'upper case/graphic' mode  the <SHIFT> key will
display the graphic character on the right hand side of the front part of
the key.
  In the case of special YELLOW function keys,  the <SHIFT> key will give
you the function marked on the front of the key."
"In the context of the C64, What does the <RETURN> key do when you press it after typing information?","<RETURN> key

  The <RETURN> key signals the computer  to look at the information  that
you typed and enters that information into memory."
"In the context of the C64, What is the syntax and purpose of the MID$ function in BASIC programming?","basic: MID$(X$,S,X)

  This will return a string containing X characters starting from the Sth
character in X$."
"In the context of the C64, What is the function of the basic statement SPC(X)"" in a PRINT statement?""","basic: SPC(X)

  This is used in a PRINT statement to skip X spaces forward."
"In the context of the C64, What is the concept in Commodore 64 programming that allows you to directly manipulate specific memory locations to change various aspects of the computer's behavior, such as screen colors and object definitions?","basic:  PEEKs and POKEs

  Just  as  variables  could be thought of as a representation of 'boxes'
within the machine where you placed your information,  you can also think
of  some  specially  defined  'boxes'  within the computer that represent
specific memory locations.

  The  Commodore 64  looks  at  these  memory  locations  to see what the
screen's background and border color should be, what characters are to be
displayed on the screen -- and where -- and a host of other tasks.
  By  placing,  'POKEing',  a  different  value  into  the  proper memory
location,  we can change colors, define and move objects, and even create
music.

  Above  we  showed just four locations,  two of which control the screen
and background colors. Try typing this:

  POKE 53281,7 <RETURN>

  The  background  color  of  the screen will change to yellow because we
placed the value '7' --  for yellow --  in the location that controls the
background color of the screen."
"In the context of the C64, What are the differences and uses of the GOSUB and GOTO statements in programming?","basic: GOSUB

  This statement is similar to GOTO,  except the computer remembers which
program line it last executed before the GOSUB. When a line with a RETURN
statement  is  encountered,  the  program  jumps  back  to  the statement
immediately following the GOSUB.  This is useful if there is a routine in
your program that occurs in several parts of the program.
Instead of typing the routine over and over, execute GOSUBs each time the
routine is needed.

  20 GOSUB 800

GOTO or GO TO

  When a statement with the GOTO command is reached,  the next line to be
executed will be the one with the line number following the word GOTO."
"In the context of the C64, What is the function of the NEW command in BASIC programming?","basic: NEW

  This  command  erases  the  entire  program in memory,  and also clears
out  any  variables  that  may  have  been  used.  Unless the program was
SAVEd, it is lost. BE CAREFUL WHEN YOU USE THIS COMMAND.
  The NEW command can also be used as a BASIC program statement. When the
program reaches this line,  the program is erased.  This is useful if you
want to leave everything neat when the program is done."
"In the context of the C64, What is the purpose and syntax of the LOAD command in Commodore 64?","basic: LOAD

  This  command  is  used  to  transfer  a program from tape or disk into
memory  so  the  program  can  be  used.  If  you  just type LOAD and hit
RETURN,  the  first  program found on the cassette unit will be placed in
memory.  The  command  may  be followed by a program name enclosed within
quotes.  The  name  may  then  be  followed  by  a  comma and a number or
numeric  variable,  which  acts  as a device number to indicate where the
program is coming from.

  If  no  device  number  is  given,  the Commodore 64 assumes device #1,
which  is  the  cassette  unit.  The  other device commonly used with the
LOAD command is the disk device, which is device #8.

  LOAD              Reads in the next program on tape
  LOAD 'HELLO'      Searches tape for program called HELLO,
                    and loads program, if found
  LOAD A$           Looks for program whose name is in the variable A$
  LOAD 'HELLO',8    Looks for program called HELLO on the disk drive
  LOAD '*',8        Looks for first program on disk"
"In the context of the C64, What is the purpose of the GET# statement in BASIC programming?","basic: GET#

  The GET# statement is used with a previously OPENed device or file,  to
input one character at a time from that device or file.

  GET #1,A$

This would input one character from a data file."
"In the context of the C64, What are the keyboard shortcuts and corresponding colors for the display?","KEYBOARD    COLOR      DISPLAY         KEYBOARD    COLOR      DISPLAY
  ---------------------------------------------------------------------
  <CTRL><1>   BLACK                      <C=><1>     ORANGE
  <CTRL><2>   WHITE                      <C=><2>     BROWN
  <CTRL><3>   RED                        <C=><3>     LT. RED
  <CTRL><4>   CYAN                       <C=><4>     GRAY 1
  <CTRL><5>   PURPLE                     <C=><5>     GRAY 2
  <CTRL><6>   GREEN                      <C=><6>     LT. GREEN
  <CTRL><7>   BLUE                       <C=><7>     LT. BLUE
  <CTRL><8>   YELLOW                     <C=><8>     GRAY 3"
"In the context of the C64, What is the purpose of the SYS command in a programming language?","basic: SYS

  SYS  is  followed  by  a  decimal  number or numeric value in the range
0-65535.  The  program  will  then  begin  executing the machine language
program  starting  at  that  memory  location. This is similar to the USR
function, but does not allow parameter passing."
"In the context of the C64, What is the purpose of the RUN command in a programming language?","basic: RUN

  This  command  causes  execution  of  a  program,  once  the program is
loaded  into  memory.  If  there  is  no  line  number following RUN, the
computer  will  start  with  the  lowest line number. If a line number is
designated, the program will start executing from the specified line.

  RUN               Starts program at lowest line number
  RUN 100           Starts execution at line 100
  RUN X             UNDEFINED STATEMENT ERROR. You must always specify an
                    actual line number, not a variable representation"
"In the context of the C64, What is the purpose and syntax of the IF ... THEN statement in BASIC programming?","basic: IF ... THEN

  IF ... THEN lets the computer analyze a situation and take two possible
courses of action,  depending on the outcome.  If the expression is true,
the  statement  following  THEN  is  executed.  This  may  be  any  BASIC
statement.
  If the expression is false, the program goes directly to the next line.
  The expression being evaluated may be a variable or formula,  in  which
case it is considered true if nonzero,  and false if zero.  In most cases,
there  is an expression involving relational operators  (=, <, >, <=, >=,
<>, AND, OR, NOT).

  10 IF X > 10 THEN END"
"In the context of the C64, What is the purpose and syntax of the INPUT statement in a programming language?","basic: INPUT

  The  INPUT  statement  allows  the  program  to get data from the user,
assigning  that  data  to  a  variable.  The  program  will stop, print a
question  mark  (?)  on  the screen, and wait for the user to type in the
answer and hit RETURN.
  INPUT  is  followed  by  a  variable name, or a list of variable names,
separated by commas.  A message may be placed within quote marks,  before
the  list of variable names to be INPUT.  If more than one variable is to
be INPUT, they must be separated by commas when typed.

  10 INPUT 'PLEASE ENTER YOUR FIRST NAME';A$
  20 PRINT 'ENTER YOUR CODE NUMBER';: INPUT B"
"In the context of the C64, What is the purpose and syntax of the SAVE command in Commodore 64 BASIC?","basic: SAVE

  This  command  will  store  the program currently in memory on cassette
or  disk.  If  you  just  type SAVE and RETURN, the program will be SAVEd
on  cassette.  The  computer  has no way of knowing if there is a program
already  on  that  tape, so be careful with your tapes or you may erase a
valuable program.
  If you type SAVE followed by a name in quotes or a string variable, the
computer  will  give  the  program  that  name,  so it can be more easily
located  and retrieved in the future.  The name may also be followed by a
device number.
  After  the  device  number,  there  can be a comma and a second number,
either  0  or  1. If the second number is 1, the Commodore 64 will put an
END-OF-TAPE  marker  after  your  program.  This signals the computer not
to  look  any  further on the tape if you were to give an additional LOAD
command.  If  you  try  to  LOAD  a program and the computer finds one of
these markers, you will get a FILE NOT FOUND ERROR.

  SAVE              Stores program to tape without name
  SAVE 'HELLO'      Stores on tape with name HELLO
  SAVE A$           Stores on tape with name A$
  SAVE 'HELLO',8    Stores on disk with name HELLO
  SAVE 'HELLO',1,1  Stores on tape with name HELLO and follows
                    program with END-OF-TAPE marker"
"In the context of the C64, What is the purpose and behavior of the STOP statement in a program?","basic: STOP

  This statement will halt program execution.  The message,  BREAK IN xxx
will  be  displayed,  where  xxx is the line number containing STOP.  The
program may be restarted by using the CONT command. STOP is normally used
in debugging a program."
"In the context of the C64, What is the purpose of the BASIC command PEEK(X)?","basic: PEEK(X)

  Used  to  find  out  contents  of  memory  location  X,  in  the  range
0-65535,  giving  a  result from 0-255. PEEK is often used in conjunction
with the POKE statement."
"In the context of the C64, What is the purpose and usage of the CMD command in BASIC programming?","basic: CMD

  CMD sends the output which normally would go to the screen (i.e., PRINT
statements,  LISTs,  but  not  POKEs  onto the screen)  to another device
instead.  This could be a printer,  or a data file on tape or disk.  This
device or file must be OPENed first.  The CMD command must be followed by
a number or numeric variable referring to the file.

  OPEN 1,4          OPENs device #4, which is the printer
  CMD 1             All normal output now goes to printer
  LIST              The program listing now goes to
                    the printer, not the screen

  To send output back to the screen, CLOSE the file with CLOSE 1."
"In the context of the C64, What is the purpose and syntax of the GET statement in BASIC programming?","basic: GET

  The  GET  statement  allows  you  to  get  data from the keyboard,  one
character at a time. When GET is executed, the character that is typed is
assigned to the variable.  If no character is typed,  then a null (empty)
character is assigned.
  GET  is  followed by a variable name,  usually a string variable.  If a
numeric  variable  was  used and a nonnumeric key depressed,  the program
would halt with an error message.  The GET statement may be placed into a
loop,  checking for  any result.  This loop will continue  until a key is
hit.

  10 GET A$: IF  A$ = ''  THEN 10"
"In the context of the C64, What is the purpose of the flashing square under READY on the screen?","CURSOR

  The  flashing  square  under  READY  is called the cursor and indicates
where what you type on the keyboard  will be displayed on the screen.  As
you  type,  the cursor will move ahead one space,  as the original cursor
position  is  replaced  with  the character you typed.  Try typing on the
keyboard and watch as characters you type are displayed on the TV screen."
"In the context of the C64, What advice does Commodore offer to users who may encounter difficulties with their COMMODORE 64 computer?","TIP:  The  COMMODORE 64  was designed  to be used by everyone.  But we at
Commodore  recognize  that  computer  users may,  occasionally,  run into
difficulties.  To  help  answer  your  questions  and  give  you some fun
programming  ideas,  Commodore  has  created several publications to help
you.  You might also find that it's a good idea to join a Commodore Users
Club  to  help  you  meet some other COMMODORE 64 owners who can help you
gain knowledge and experience."
"In the context of the C64, What is the syntax and functionality of the FOR loop statement in a programming language?","basic: FOR ... TO ... STEP

  This statement works with the NEXT statement to repeat a section of the
program a set number of times. The format is:

  FOR (Var. Name)=(Start of Count) TO (End of Count) STEP (Count By)

  The  loop  variable  will  be  added  to  or subtracted from during the
program.  Without any STEP specified,  STEP is assumed to be 1. The start
count and end count are the limits to the value of the loop variable.

  10 FOR L = 1 to 10 STEP .1
  20 PRINT L
  30 NEXT L

  The end of the loop value may be followed by the word STEP  and another
number or variable.  In this case, the value following STEP is added each
time instead of 1. This allows you to count backwards, or by fractions."
"In the context of the C64, What is the effect of the CLR command in BASIC?","basic: CLR

  This command will erase any variables in memory, but leaves the program
itself intact.  This command is automatically executed when a RUN command
is given."
"In the context of the C64, What is the syntax and behavior of the RND function in a programming language, including how to generate a random number between a specific range and how to reseed the random number generator?","basic: RND(X)  (random number)

  RND(X)  returns  a  random  number  in  the range 0-1. The first random
number  should  be  generated by the formula RND(-TI) to start things off
differently  every  time.  After  this,  X  should be a 1 or any positive
number.  If  X  is zero, the result will be the same random number as the
last one.
  A  negative  value  for  X  will  reseed  the generator. The use of the
same  negative  number  for  X  will  result  in  the  same  sequence  of
'random' numbers.
  The formula for generating a number between X and Y is:

  N = RND(1) * (Y-X) + X

where,
  Y is the upper limit,
  X is the lower range of numbers desired."
"In the context of the C64, What is the purpose of the DIM statement in programming and how does it relate to arrays?","basic: DIM

  When you use more than 11 elements of an array,  you must execute a DIM
statement for the array.  Keep in mind that the whole array takes up room
in  memory,  so  don't  create  an  array  much  larger than you'll need.
To  figure  the number of variables created with DIM,  multiply the total
number of elements in each dimension of the array.

  10 DIM A$(40), B7(15), CC%(4,4,4)
             ^       ^         ^
             |       |         |
   41 elements  16 elements  125 elements

  You  can  dimension more than one array in a DIM statement. However, be
careful not to dimension an array more than once."
"In the context of the C64, What is the purpose and syntax of the VERIFY command in Commodore 64?","basic: VERIFY

  This  command  causes  the  computer  to  check  the program on disk or
tape  against  the  one  in  memory.  This  is  proof that the program is
actually SAVEd,  in case the tape or disk is bad, or something went wrong
during  the  SAVE.  VERIFY  without anything after the command causes the
Commodore  64  to  check  the  next  program on tape, regardless of name,
against the program in memory.
  VERIFY  followed by a program name,  or a string variable,  will search
for that program and then check. Device numbers can also be included with
the verify command.

  VERIFY            Checks the next program on tape
  VERIFY 'HELLO'    Searches for HELLO, checks against memory
  VERIFY 'HELLO',8  Searches for HELLO on disk, then checks"
"In the context of the C64, What is the purpose of the CONT command in a program?","basic: CONT (Continue)

  This command is used to restart the execution of a  program  which  has
been stopped by either using the <STOP> key, a STOP statement,  or an END
statement within the program. The program will restart at the exact place
from where it left off.
  CONT will not work if you have changed or added lines  to  the  program
(or even just moved the cursor),  or if the  program  halted  due  to  an
error, or if you caused an error before trying to restart the program. In
these cases you will get a CAN'T CONTINUE ERROR."
"In the context of the C64, What are the different ways to use the LIST command in BASIC programming?","basic: LIST

  The  LIST  command  allows  you  to look at lines of a BASIC program in
memory.  You  can  ask  for  the  entire program to be displayed, or only
certain line numbers.

  LIST              Shows entire program
  LIST 10-          Shows only from line 10 until end
  LIST 10           Shows only line 10
  LIST -10          Shows lines from beginning until 10
  LIST 10-20        Shows line from 10 to 20, inclusive"
"In the context of the C64, What is the purpose of the CLOSE command in a programming language?","basic: CLOSE

  This  command  completes  and closes any files used by OPEN statements.
The number following CLOSE is the file number to be closed.

  CLOSE 2           Only file #2 is closed"
"In the context of the C64, What happens when a program encounters an END statement?","basic: END

  When a program encounters an END statement, the program halts, as if it
ran out of lines. You may use CONT to restart the program."
"In the context of the C64, What is the purpose of the OPEN statement in BASIC?","OUTPUT TO OTHER DEVICES

    It is often necessary to send output to devices other than the screen,
  like a cassette deck, printer, disk drive, or modem. The OPEN statement
  in BASIC creates a 'channel' to talk to one of these devices. Once the
  channel is OPEN, the PRINT# statement will send characters to that
  device.

  EXAMPLE of OPEN and PRINT# Statements:

    100 OPEN 4,4: PRINT# 4, 'WRITING ON PRINTER'
    110 OPEN 3,8,3,'0:DISK-FILE,S,W':PRINT#3,'SEND TO DISK'
    120 OPEN 1,1,1,'TAPE-FILE': PRINT#1,'WRITE ON TAPE'
    130 OPEN 2,2,0,CHR$(10):PRINT#2,'SEND TO MODEM'
    The OPEN statement is somewhat different for each device. The pa-
  rameters in the OPEN statement are shown in the table below for each
  device."
"In the context of the C64, How can I output data to the RS-232 on the Commodore 64?","SENDING DATA TO AN RS-232 CHANNEL

    When sending data, the output buffer can hold 255 characters before a
  full buffer hold-off occurs. The system will wait in the CHROUT routine
  until transmission is allowed or the <RUN/STOP> and <RESTORE> keys are
  used to recover the system through a WARM START.


  BASIC SYNTAX:

    CMD lfn-acts same as in the BASIC specifications.
    PRINT#lfn,<variable list>


  KERNAL ENTRIES:

    CHKOUT ($FFC9)-See Memory Map for more information on entry and exit
  conditions.
    CHROUT ($FFD2)-See Memory Map for more information on entry conditions.
 
 
  | IMPORTANT NOTES: There is no carriage-return delay built into the     |
  | output channel. This means that a normal RS-232 printer cannot        |
  | correctly print, unless some form of hold-off (asking the Commodore 64|
  | to wait) or internal buffering is implemented by the printer. The     |
  | hold-off can easily be implemented in your program. If a CTS (x-line) |
  | handshake is implemented, the Commodore 64 buffer will fill, and then |
  | hold-off more output until transmission is allowed by the RS-232      |
  | device. X-line handshaking is a handshake routine that uses multi-    |
  | lines for receiving and transmitting data.                            |
  |   The routine CHKOUT handles the x-line handshake, which follows the  |
  | EIA standard (August 1979) for RS-232-C interfaces. The RTS, CTS, and |
  | DCD lines are implemented with the Commodore 64 defined as the Data   |
  | Terminal Device.                                                      |"
"In the context of the C64, What is the purpose of the RTS instruction in the 6502 assembly language?","RTS                    RTS Return from subroutine                     RTS
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   RTS                 |    60   |    1    |    6     |"
"In the context of the C64, What is the purpose of the JSR 6502 instruction ?","JSR          JSR Jump to new location saving return address           JSR


  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Absolute      |   JSR Oper            |    20   |    3    |    6     |"
"In the context of the C64, What is the primary function of the input/output port described in the given text?","THE INPUT/OUTPUT PORT

    This register appears at memory locations 0 (for the DATA DIRECTION
  REGISTER) and 1 (for the actual PORT). It is an 8-bit input/output port.
  On the Commodore 64 this register is used for memory management, to
  allow the chip to control more than 64K of RAM and ROM memory.
    The details of these registers are not given here. They are explained
  as the principles needed to explain them are explained."
"In the context of the C64, What types of filtering are available on the SID chip?","FILTERING

    The harmonic content of a waveform can be changed by using a filter.
  The SID chip is equipped with three types of filtering. They can be used
  separately or in combination with one another. Let's go back to the
  sample program you've been using to play with a simple example that uses
  a filter. There are several filter controls to set.
    You add line 15 in the program to set the cutoff frequency of the
  filter. The cutoff frequency is the reference point for the filter. You
  SET the high and low frequency cutoff points in registers 21 and 22. To
  turn ON the filter for voice 1, POKE register 23.
    Next change line 30 to show that a high-pass filter will be used (see
  the SID register map).


    The SID chip also has a low-pass filter. As its name implies, this
  filter will pass the frequencies below cutoff and attenuate those above.


    Finally, the chip is equipped with a bandpass filter, which passes a
  narrow band of frequencies around the cutoff, and attenuates all others.


    The high- and low-pass filters can be combined to form a notch reject
  filter which passes frequencies away from the cutoff while attenuating
  at the cutoff frequency.



    Register 24 determines which type filter you want to use. This is in
  addition to register 24's function as the overall volume control. Bit 6
  controls the high-pass filter (0 = off, 1 = on), bit 5 is the bandpass
  filter, and bit 4 is the low-pass filter. The low 3 bits of the cutoff
  frequency are determined by register 21 (Lcf) (Lcf = 0 through 7). While
  the 8 bits of the high cutoff frequency are determined by register 22
  (Hcf) (Hcf = 0 through 255).
    Through careful use of filtering, you can change the harmonic structure
  of any waveform to get just the sound you want. In addition, changing the
  filtering of a sound as it goes through the ADSR phases of its life can
  produce interesting effects."
"In the context of the C64, What is the purpose of the RAMTAS kernal function?","B.20. Function Name: RAMTAS

    Purpose: Perform RAM test
    Call address: $FF87 (hex) 65415 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: This routine is used to test RAM and set the top and
  bottom of memory pointers accordingly. It also clears locations $0000 to
  $0101 and $0200 to $03FF. It also allocates the cassette buffer, and sets
  the screen base to $0400. Normally, this routine is called as part of the
  initialization process of a Commodore 64 program cartridge.

  EXAMPLE:
    JSR RAMTAS"
"In the context of the C64, For sprites: What values can the X position take on, and how do you move beyond the range of 0 to 255?","X POSITION VALUES BEYOND 255:

    X positions run from 0 to 255... and then START OVER from 0 to 255. To
  put a sprite beyond X position 255 on the far right side of the screen,
  you must first POKE V+ 16 as shown, THEN POKE a new X valve from 0 to 63,
  which will place the sprite in one of the X positions at the right side
  of the screen. To get back to positions 0-255, POKE V+16,0 and POKE in an
  X value from 0 to 255.

  Y POSITION VALUES:

    Y positions run from 0 to 255, including 0 to 49 off the TOP of the
  viewing area, 50 to 229 IN the,viewing area, and 230 to 255 off the
  BOTTOM of the viewing area."
"In the context of the C64, What is the purpose of the CIOUT routine in a serial communication system?","B-6. Function Name: CIOUT

    Purpose: Transmit a byte over the serial bus
    Call address: $FFA8 (hex) 65448 (decimal)
    Communication registers: A
    Preparatory routines: LISTEN, [SECOND]
    Error returns: See READST
    Stack requirements: 5
    Registers affected: None

    Description: This routine is used to send information to devices on the
  serial bus. A call to this routine will put a data byte onto the serial
  bus using full serial handshaking. Before this routine is called, the
  LISTEN KERNAL routine must be used to command a device on the serial bus
  to get ready to receive data. (If a device needs a secondary address, it
  must also be sent by using the SECOND KERNAL routine.) The accumulator is
  loaded with a byte to handshake as data on the serial bus. A device must
  be listening or the status word will return a timeout. This routine
  always buffers one character. (The routine holds the previous character
  to be sent back.) So when a call to the KERNAL UNLSN routine is made to
  end the data transmission, the buffered character is sent with an End Or
  Identify (EOI) set. Then the UNLSN command is sent to the device.
  How to Use:

    0) Use the LISTEN KERNAL routine (and the SECOND routine if needed).
    1) Load the accumulator with a byte of data.
    2) Call this routine to send the data byte.

  EXAMPLE:


    LDA #'X       ;SEND AN X TO THE SERIAL BUS
    JSR CIOUT"
"In the context of the C64, What is the purpose of the BANK SELECT bits in the 6526 COMPLEX INTERFACE ADAPTER CHIP #2 (CIA #2) in the Commodore 64?","VIDEO BANK SELECTION
 OR VBLANK

    The VIC-II chip can access ('see') 16K of memory at a time. Since there
  is 64K of memory in the Commodore 64, you want to be able to have the
  VIC-II chip see all of it. There is a way. There are 4 possible BANKS
  (or sections) of 16K of memory. All that is needed is some means of
  controlling which 16K bank the VIC-II chip looks at. In that way, the
  chip can 'see' the entire 64K of memory. The BANK SELECT bits that allow
  you access to all the different sections of memory are located in the
  6526 COMPLEX INTERFACE ADAPTER CHIP #2 (CIA #2). The POKE and PEEK BASIC
  statements (or their machine language versions) are used to select a
  bank, by controlling bits 0 and 1 of PORT A of CIA#2 (location 56576 (or
  $DD00 HEX)). These 2 bits must be set to outputs by setting bits 0 and 1
  of location 56578 ($DD02,HEX) to change banks. The following example
  shows this:

    POKE 56578,PEEK(56578)OR 3: REM MAKE SURE BITS 0 AND 1 ARE OUTPUTS
    POKE 56576,(PEEK(56576)AND 252)OR A: REM CHANGE BANKS



  This 16K bank concept is part of everything that the VIC-II chip does.
  You should always be aware of which bank the VIC-II chip is pointing at,
  since this will affect where character data patterns come from, where the
  screen is, where sprites come from, etc. When you turn on the power of
  your Commodore 64, bits 0 and 1 of location 56576 are automatically set
  to BANK 0 ($0000-$3FFF) for all display information.

  
  NOTE: The Commodore 64 character set is not available to the VIC-II 
  chip in BANKS 1 and 3. (See character memory section.)"
"In the context of the C64, What is the purpose of the interrupt status register in the Commodore 64?","INTERRUPT STATUS REGISTER

    The interrupt status register shows the current status of any interrupt
  source. The current status of bit 2 of the interrupt register will be a 1
  when two sprites hit each other. The same is true, in a corresponding 1
  to 1 relationship, for bits 0-3 listed in the chart below. Bit 7 is also
  set with a 1, whenever an interrupt occurs.
    The interrupt status register is located at 53273 ($D019) and is as
  follows:

    LATCH  BIT#             DESCRIPTION

    IRST    0   Set when current raster count = stored raster count
    IMDC    1   Set by SPRITE-DATA collision (1st one only, until reset)
    IMMC    2   Set by SPRITE-SPRITE collision (1st one only, until reset)
     ILP    3   Set by negative transition of light pen (1 per frame)
     IRQ    7   Set by latch set and enabled
 
    Once an interrupt bit has been set, it's 'latched' in and must be
  cleared by writing a 1 to that bit in the interrupt register when you're
  ready to handle it. This allows selective interrupt handling, without
  having to store the other interrupt bits."
"In the context of the C64, What are the three registers used to move a sprite around the screen on a Commodore 64?","SPRITE POSITIONING

    Once you've made a sprite you want to be able to move it around the
  screen. To do this, your Commodore 64 uses three positioning registers:

    1) SPRITE X POSITION REGISTER
    2) SPRITE Y POSITION REGISTER
    3) MOST SIGNIFICANT BIT X POSITION REGISTER

    Each sprite has an X position register, a Y position register, and a
  bit in the X most significant bit register. This lets you position your
  sprites very accurately. You can place your sprite in 512 possible X
  positions and 256 possible Y positions.
    The X and Y position registers work together, in pairs, as a team. The
  locations of the X and Y registers appear in the memory map as follows:
  First is the X register for sprite 0, then the Y register for sprite 0.
  Next comes the X register for sprite 1, the Y register for sprite 1, and
  so on. After all 16 X and Y registers comes the most significant bit in
  the X position (X MSB) located in its own register."
"In the context of the C64, What is the correct POKE statement to move the screen to a new location?","The location of screen memory can be changed easily by a POKE to
  control register 53272 ($D018 HEX). However, this register is also used
  to control which character set is used, so be careful to avoid disturbing
  that part of the control register. The UPPER 4 bits control the location
  of screen memory. To move the screen, the following statement should be
  used:
  POKE53272,(PEEK(53272)AND15)OR A
  Where 'A' has one of the following values:
$0000
$0400
$0800
$0C00
$1000
$1400
$1800
$1C00
$2000
$2400
$2400
$2800 
$2800 
$2C00 
$2C00 
$3000 
$3000 
$3400 
$3400 
$3800 
$3800 
$3C00 
$3C00 

* Remember that the BANK ADDRESS of the VIC-II chip must be added in.
* Remember that the BANK ADDRESS of the VIC-II chip must be added in.
You must also tell the KERNAL'S screen editor where the screen is as
follows: POKE 648, page (where page = address/256, e.g., 1024/256= 4,
so POKE 648,4)."
"In the context of the C64, What is the purpose of the INTERRUPT ENABLE REGISTER in the VIC-II chip?","The INTERRUPT ENABLE REGISTER is located at 53274 ($D01A). It has the
  same format as the interrupt status register. Unless the corresponding
  bit in the interrupt enable register is set to a 1, no interrupt from
  that source will take place. The interrupt status register can still be
  polled for information, but no interrupts will be generated.
    To enable an interrupt request the corresponding interrupt enable bit
  (as shown in the chart above) must be set to a 1.
    This powerful interrupt structure lets you use split screen modes. For
  instance you can have half of the screen bit mapped, half text, more than
  8 sprites at a time, etc. The secret is to use interrupts properly. For
  example, if you want the top half of the screen to be bit mapped and the
  bottom to be text, just set the raster compare register (as explained
  previously) for halfway down the screen. When the interrupt occurs, tell
  the VIC-II chip to get characters from ROM, then set the raster compare
  register to interrupt at the top of the screen. When the interrupt occurs
  at the top of the screen, tell the VIC-II chip to get characters from RAM
  (bit map mode).
  You can also display more than 8 sprites in the same way. Unfortunately BASIC isn't fast enough to do this very well. So if you want to start using display interrupts, you should work in machine language."
"In the context of the C64, What is the purpose of the CINT routine in the Commodore 64 KERNAL?","B-7. Function Name: CINT

    Purpose: Initialize screen editor & 6567 video chip
    Call address: $FF81 (hex) 65409 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: None
    Stack requirements: 4
    Registers affected: A, X, Y


    Description: This routine sets up the 6567 video controller chip in the
  Commodore 64 for normal operation. The KERNAL screen editor is also
  initialized. This routine should be called by a Commodore 64 program
  cartridge.

  How to Use:

    1) Call this routine.

  EXAMPLE:

    JSR CINT
    JMP RUN       ;BEGIN EXECUTION"
"In the context of the C64, What is the purpose and description of the RDTIM function in  kernal?","B-21. Function Name: RDTIM

    Purpose: Read system clock
    Call address: $FFDE (hex) 65502 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: This routine is used to read the system clock. The clock's
  resolution is a 60th of a second. Three bytes are returned by the
  routine. The accumulator contains the most significant byte, the X index
  register contains the next most significant byte, and the Y index
  register contains the least significant byte.

  EXAMPLE:

    JSR RDTIM
    STY TIME
    STX TIME+1
    STA TIME+2
    ...
    TIME *=*+3"
"In the context of the C64, What is the recommended memory setting for each sprite in the computer's memory?","SPRITE COLORS:

    To make sprite 0 WHITE, type: POKE V+39,1 (use COLOR POKE SETTING shown
  in chart, and INDIVIDUAL COLOR CODES shown below):

    0-BLACK     4-PURPLE        8-ORANGE        12-MED. GREY
    1-WHITE     5-GREEN         9-BROWN         13-LT. GREEN
    2-RED       6-BLUE          10-LT. RED      14-LT. BLUE
    3-CYAN      7-YELLOW        11-DARK GREY    15-LT. GREY

  MEMORY LOCATION:

    You must 'reserve' a separate 64-BYTE BLOCK of numbers in the
  computer's memory for each sprite of which 63 BYTES will be used for
  sprite data. The memory settings shown below are recommended for the
  'sprite pointer' settings in the chart above. Each sprite will be unique
  and you'll have to define it as you wish. To make all sprites exactly the
  same, point the sprites you want to look the same to the same register
  for sprites."
"In the context of the C64, What is the purpose of the TYA instruction in the 6502 assembly language?","TYA                TYA Transfer index Y to accumulator                TYA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TYA                 |    98   |    1    |    2     |"
"In the context of the C64, What does the stack pointer register contain on C64?","THE STACK POINTER

    This register contains the location of the first empty place on the
  stack. The stack is used for temporary storage by machine language pro-
  grams, and by the computer."
"In the context of the C64, What are the details for the Jump 6502 instruction?","JMP                     JMP Jump to new location                      JMP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Absolute      |   JMP Oper            |    4C   |    3    |    3     |
  |  Indirect      |   JMP (Oper)          |    6C   |    3    |    5     |"
"In the context of the C64, What is the instruction that performs a return from interrupt in 6502?","RTI                    RTI Return from interrupt                      RTI

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   RTI                 |    4D   |    1    |    6     |"
"In the context of the C64, How can I get data from an RS-232 channel on a Commodore 64?","GETTING DATA FROM AN RS-232 CHANNEL

    When getting data from an RS-232 channel, the Commodore 64 receiver
  buffer will hold up to 255 characters before the buffer overflows. This
  is indicated in the RS-232 status word (ST in BASIC, or RSSTAT in machine
  language). If an overflow occurs, then all characters received during a
  full buffer condition, from that point on, are lost. Obviously, it pays
  to keep the buffer as clear as possible.
    If you wish to receive RS-232 data at high speeds (BASIC can only go so
  fast, especially considering garbage collects. This can cause the re-
  ceiver buffer to overflow), you will have to use machine language
  routines to handle this type of data burst.

  BASIC SYNTAX:

    Recommended: GET#lfn, <string variable>
    NOT Recommended: INPUT#lfn <variable list>

  KERNAL ENTRIES:

    CHKIN ($FFC6)-See Memory Map for more information on entry and exit
  conditions.
    GETIN ($FFE4)-See Memory Map for more information on entry and exit
  conditions.
    CHRIN ($FFCF)-See Memory Map for more information on entry and exit
  conditions.

  | NOTES:                                                                |
  |   If the word length is less than 8 bits, all unused bit(s) will be   |
  | assigned a value of zero.                                             |
  |   If a GET# does not find any data in the buffer, the character '' (a |
  | null) is returned.                                                    |
  |   If INPUT# is used, then the system will hang in a waiting condition |
  | until a non-null character and a following carriage return is         |
  | received. Therefore, if the Clear To Send (CTS) or Data Set Ready     |
  | (DSR) line(s) disappear during character INPUT#, the system will hang |
  | in a RESTORE-only state. This is why the INPUT# and CHRIN routines are|
  | NOT recommended.                                                      |
  |   The routine CHKIN handles the x-line handshake which follows the EIA|
  | standard (August 1979) for RS-232-C interfaces. (The Request To Send  |
  | (RTS), CTS, and Received line signal (DCD) lines are implemented with |
  | the Commodore 64 computer defined as the Data Terminal device.)       |"
"In the context of the C64, How does the print function works?","OUTPUT TO THE TV

    The simplest form of output in BASIC is the PRINT statement. PRINT uses
  the TV screen as the output device, and your eyes are the input device
  because they use the information on the screen.
    When PRINTing on the screen, your main objective is to format the
  information on the screen so it's easy to read. You should try to think
  like a graphic artist, using colors, placement of letters, capital and
  lower case letters, as well as graphics to best communicate the
  information. Remember, no matter how smart your program, you want to be
  able to understand what the results mean to you.
    The PRINT statement uses certain character codes as 'commands' to the
  cursor. The <CRSR> key doesn't actually display anything, it just makes
  the cursor change position. Other commands change colors, clear the
  screen, and insert or delete spaces. The <RETURN> key has a character
  code number (CHR$) of 13. A complete table of these codes is contained in
  Appendix C.
    There are two functions in the BASIC language that work with the PRINT
  statement. TAB positions the,cursor on the given position from the left
  edge of the screen, SPC moves the cursor right a given number of spaces
  from the current position.
    Punctuation marks in the PRINT statement serve to separate and format
  information. The semicolon (;) separates 2 items without any spaces in
  between. If it is the last thing on a line, the cursor remains after the
  last thing PRINTed instead of going down to the next line. It suppresses
  (replaces) the RETURN character that is normally PRINTed at the end of
  the line.
    The comma (,) separates items into columns. The Commodore 64 has 4
  columns of 10 characters each on the screen. When the computer PRINTs a
  comma, it moves the cursor right to the start of the next column. If it
  is past the last column of the line, it moves the cursor down to the next
  line. Like the semicolon, if it is the last item on a line the RETURN is
  suppressed.
    The quote marks ('') separate literal text from variables. The first
  quote mark on the line starts the literal area, and the next quote mark
  ends it. By the way, you don't have to have a final quote mark at the
  end of the line.
    The RETURN code (CHR$ code of 13) makes the cursor go to the next
  logical line on the screen. This is not always the very next line. When
  you type past the end of a line, that line is linked to the next line.
  The computer knows that both lines are really one long line. The links
  are held in the line link table (see the memory map for how this is set
  up).
    A logical line can be 1 or 2 screen lines long, depending on what was
  typed or PRINTed.  The logical line the cursor is on determines where the
  <RETURN> key sends it. The logical line at the top of the screen
  determines if the screen scrolls 1 or 2 lines at a time. There are other
  ways to use the TV as an output device. The chapter on graphics describes
  the commands to create objects that move across the screen. The VIC chip
  section tells how the screen and border colors and sizes are changed. And
  the sound chapter tells how the TV speaker creates music and special
  effects."
"In the context of the C64, What is the Commodore 64's built-in interface for connecting to devices?","RS-232 INTERFACE DESCRIPTION

  GENERAL OUTLINE

    The Commodore 64 has a built-in RS-232 interface for connection to any
  RS-232 modem, printer, or other device. To connect a device to the
  Commodore 64, all you need is a cable and a little bit of programming.
    RS-232 on the Commodore 64 is set-up in the standard RS-232 format, but
  the voltages are TTL levels (0 to 5V) rather than the normal RS-232 -12
  to 12 volt range. The cable between the Commodore 64 and the RS-232
  device should take care of the necessary voltage conversions. The
  Commodore RS-232 interface cartridge handles this properly.
    The RS-232 interface software can be accessed from BASIC or from the
  KERNAL for machine language programming.
    RS-232 on the BASIC level uses the normal BASIC commands: OPEN, CLOSE,
  CMD, INPUT#, GET#, PRINT#, and the reserved variable ST. INPUT# and GET#
  fetch data from the receiving buffer, while PRINT# and CMD place data
  into the transmitting buffer. The use of these commands (and examples)
  will be described in more detail later in this chapter.
    The RS-232 KERNAL byte and bit level handlers run under the control of
  the 6526 CIA #2 device timers and interrupts. The 6526 chip generates

  NMI (Non-Maskable Interrupt) requests for RS-232 processing. This allows
  background RS-232 processing to take place during BASIC and machine
  language programs. There are built-in hold-offs in the KERNAL, cassette,
  and serial bus routines to prevent the disruption of data storage or
  transmission by the NMIs that are generated by the RS-232 routines.
  During cassette or serial bus activities, data can NOT be received from
  RS-232 devices. But because these hold-offs are only local (assuming
  you're careful about your programming) no interference should result.
    There are two buffers in the Commodore 64 RS-232 interface to help
  prevent the loss of data when transmitting or receiving RS-232 informa-
  tion.
    The Commodore 64 RS-232 KERNAL buffers consist of two first-in/first-
  out (FIFO) buffers, each 256 bytes long, at the top of memory. The
  OPENing of an RS-232 channel automatically allocates 512 bytes of memory
  for these buffers. If there is not enough free space beyond the end of
  your BASIC program no error message will be printed, and the end of your
  program will be destroyed. SO BE CAREFUL!
    These buffers are automatically removed by using the CLOSE command."
"In the context of the C64, What is the purpose and functionality of the MACHINE LANGUAGE MONITOR (64MON) program?","MACHINE LANGUAGE MONITOR (64MON):

    This program allows you to enter a program in either HEX or SYMBOLIC
  codes, and save the portion of memory the program is in. Advantages of
  this method include easier entry of the machine language routines,
  debugging aids, and a much faster means of saving and loading. The
  drawback to this method is that it generally requires the BASIC program
  to load the machine language routine from tape or disk when it is
  started. (For more details on 64MON see the machine language section.)

  EXAMPLE:

    The following is an example of a BASIC program using a machine language
  routine prepared by 64MON. The routine is stored on tape:

    10 IF FLAG=L THEN 20
    15 FLAG=1:LOAD'MACHINE LANGUAGE ROUTINE NAME',1,1
    20
    .
    .
    REST OF BASIC PROGRAM"
"In the context of the C64, What is the purpose of the SETTMO kernal routine?","Function  Name: SETTMO

    Purpose: Set IEEE bus card timeout flag
    Call address: $FFA2 (hex) 65442 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: None

  NOTE: This routine is used ONLY with an IEEE add-on card!      
  
    Description: This routine sets the timeout flag for the IEEE bus. When
  the timeout flag is set, the Commodore 64 will wait for a device on the
  IEEE port for 64 milliseconds. If the device does not respond to the
  Commodore 64's Data Address Valid (DAV) signal within that time the
  Commodore 64 will recognize an error condition and leave the handshake
  sequence. When this routine is called when the accumulator contains a 0
  in bit 7, timeouts are enabled. A 1 in bit 7 will disable the timeouts.

NOTE: The Commodore 64 uses the timeout feature to communicate that a 
disk file is not found on an attempt to OPEN a file only with an IEEE card.                                                                 |
  
  How to Use:

  TO SET THE TIMEOUT FLAG
    1) Set bit 7 of the accumulator to 0.
    2) Call this routine.

  TO RESET THE TIMEOUT FLAG
    1) Set bit 7 of the accumulator to 1.
    2) Call this routine.

  EXAMPLE:

    ;DISABLE TIMEOUT
    LDA #0
    JSR SETTMO"
"In the context of the C64, What are the details of the 6502 LDA instruction?","LDA                  LDA Load accumulator with memory                 LDA


  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   LDA #Oper           |    A9   |    2    |    2     |
  |  Zero Page     |   LDA Oper            |    A5   |    2    |    3     |
  |  Zero Page,X   |   LDA Oper,X          |    B5   |    2    |    4     |
  |  Absolute      |   LDA Oper            |    AD   |    3    |    4     |
  |  Absolute,X    |   LDA Oper,X          |    BD   |    3    |    4*    |
  |  Absolute,Y    |   LDA Oper,Y          |    B9   |    3    |    4*    |
  |  (Indirect,X)  |   LDA (Oper,X)        |    A1   |    2    |    6     |
  |  (Indirect),Y  |   LDA (Oper),Y        |    B1   |    2    |    5*    |
  * Add 1 if page boundary is crossed."
"In the context of the C64, What is the purpose of the SBC instruction in 6502?","SBC          SBC Subtract memory from accumulator with borrow         SBC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   SBC #Oper           |    E9   |    2    |    2     |
  |  Zero Page     |   SBC Oper            |    E5   |    2    |    3     |
  |  Zero Page,X   |   SBC Oper,X          |    F5   |    2    |    4     |
  |  Absolute      |   SBC Oper            |    ED   |    3    |    4     |
  |  Absolute,X    |   SBC Oper,X          |    FD   |    3    |    4*    |
  |  Absolute,Y    |   SBC Oper,Y          |    F9   |    3    |    4*    |
  |  (Indirect,X)  |   SBC (Oper,X)        |    E1   |    2    |    6     |
  |  (Indirect),Y  |   SBC (Oper),Y        |    F1   |    2    |    5     |
  * Add 1 when page boundary is crossed."
"In the context of the C64, What is the harmonic structure of a triangular wave, and how does it relate to the fundamental frequency and the harmonic number?","UNDERSTANDING WAVEFORMS

    When a note is played, it consists of a sine wave oscillating at the
  fundamental frequency and the harmonics of that wave.
    The fundamental frequency defines the overall pitch of the note.
  Harmonics are sine waves having frequencies which are integer multiples
  of the fundamental frequency. A sound wave is the fundamental frequency
  and all of the harmonics it takes to make up that sound.

    In musical theory let's say that the fundamental frequency is harmonic
  number 1. The second harmonic has a frequency twice the fundamental
  frequency, the third harmonic is three times the fundamental frequency,
  and so on. The amounts of each harmonic present in a note give it its
  timbre.
    An acoustic instrument, like a guitar or a violin, has a very compli-
  cated harmonic structure. In fact, the harmonic structure may vary as a
   single note is played. You have already played with the waveforms
  available in your Commodore music synthesizer. Now let's talk about how
  the harmonics work with the triangular, sawtooth, and rectangular waves.
    A triangular wave contains only odd harmonics. The amount of each
  harmonic present is proportional to the reciprocal of the square of the
  harmonic number. In other words harmonic number 3 is 1/9 quieter than
  harmonic number 1, because the harmonic 3 squared is 9 (3 X 3) and the
  reciprocal of 9 is 1/9.
    As you can see, there is a similarity in shape of a triangular wave to
  a sine wave oscillating at the fundamental frequency.
    Sawtooth waves contain all the harmonics. The amount of each harmonic
  present is proportional to the reciprocal of the harmonic number. For
  example, harmonic number 2 is 1/2 as loud as harmonic number 1.
    The square wave contains odd harmonics in proportion to the reciprocal
  of the harmonic number. Other rectangular waves have varying harmonic
  content. By changing the pulse width, the timbre of the sound of a
  rectangular wave can be varied tremendously.

    By choosing carefully the waveform used, you can start with a harmonic
  structure that looks somewhat like the sound you want. To refine the
  sound, you can add another aspect of sound quality available on your
  Commodore 64 called filtering, which we'll discuss later in this section."
"In the context of the C64, What is the primary component of the CPU that consists of eight flags?","THE STATUS REGISTER

    This register consists of eight 'flags' (a flag = something that indi-
  cates whether something has, or has not occurred)."
"In the context of the C64, HWhat is the purpose of the CHROUT routine in the KERNAL?","B-5. Function Name: CHROUT

    Purpose: Output a character
    Call address: $FFD2 (hex) 65490 (decimal)
    Communication registers: A
    Preparatory routines: (CHKOUT,OPEN)
    Error returns: 0 (See READST)
    Stack requirements: 8+
    Registers affected: A

    Description: This routine outputs a character to an already opened
  channel. Use the KERNAL OPEN and CHKOUT routines to set up the output
  channel before calling this routine, If this call is omitted, data is
  sent to the default output device (number 3, the screen). The data byte
  to be output is loaded into the accumulator, and this routine is called.
  The data is then sent to the specified output device. The channel is left
  open after the call.

 
 NOTE: Care must be taken when using this routine to send data to a    
 specific serial device since data will be sent to all open output     
 channels on the bus. Unless this is desired, all open output channels 
 on the serial bus other than the intended destination channel must be 
 closed by a call to the KERNAL CLRCHN routine.                        

  How to Use:

    0) Use the CHKOUT KERNAL routine if needed, (see description above).
    1) Load the data to be output into the accumulator.
    2) Call this routine.

  EXAMPLE:

    ;DUPLICATE THE BASIC INSTRUCTION CMD 4,'A';
    LDX #4          ;LOGICAL FILE #4
    JSR CHKOUT      ;OPEN CHANNEL OUT
    LDA #'A
    JSR CHROUT      ;SEND CHARACTER"
"In the context of the C64, What is the purpose of the PLOT kernal function?","B-19. Function Name: PLOT

    Purpose: Set cursor location
    Call address: $FFF0 (hex) 65520 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: A call to this routine with the accumulator carry flag
  set loads the current position of the cursor on the screen (in X,Y
  coordinates) into the Y and X registers. Y is the column number of the
  cursor location (6-39), and X is the row number of the location of the
  cursor (0-24). A call with the carry bit clear moves the cursor to X,Y
  as determined by the Y and X registers.

  How to Use:


  READING CURSOR LOCATION

    1) Set the carry flag.
    2) Call this routine.
    3) Get the X and Y position from the Y and X registers, respectively.


  SETTING CURSOR LOCATION

    1) Clear carry flag.
    2) Set the Y and X registers to the desired cursor location.
    3) Call this routine.


  EXAMPLE:

    ;MOVE THE CURSOR TO ROW 10, COLUMN 5 (5,10)
    LDX #10
    LDY #5
    CLC
    JSR PLOT"
"In the context of the C64, explain the vertical positionning of sprites","VERTICAL POSITIONING

    Setting up positions in the horizontal direction is a little more
  difficult than vertical positioning, so we'll discuss vertical (Y)
  positioning first.
    There are 200 different dot positions that can be individually pro-
  grammed onto your TV screen in the Y direction. The sprite Y position
  registers can handle numbers up to 255. This means that you have more
  than enough register locations to handle moving a sprite up and down. You
  also want to be able to smoothly move a sprite on and off the screen.
  More than 200 values are needed for this.
    The first on-screen value from the top of the screen, and in the Y
  direction for an unexpanded sprite is 30. For a sprite expanded in the Y
  direction it would be 9. (Since each dot is twice as tall, this makes a
  certain amount of sense, as the initial position is STILL calculated from
  the top left corner of the sprite.)
    The first Y value in which a sprite (expanded or not) is fully on the
  screen (all 21 possible lines displayed) is 50.
    The last Y value in which an unexpanded sprite is fully on the screen
  is 229. The last Y value in which an expanded sprite is fully on the
  screen is 208.
    The first Y value in which a sprite is fully off the screen is 250."
"In the context of the C64, What is the starting location of the VIC-II chip in the Commodore 64's memory?","GRAPHICS LOCATIONS

    Some general information first. There are 1000 possible locations on
  the Commodore 64 screen. Normally, the screen starts at location 1024
  ($0400 in HEXadecimal notation) and goes to location 2023. Each of
  these locations is 8 bits wide. This means that it can hold any integer
  number from 0 to 255. Connected with screen memory is a group of 1000
  locations called COLOR MEMORY or COLOR RAM. These start at location 55296
  ($D800 in HEX) and go up to 56295. Each of the color RAM locations is 4
  bits wide, which means that it can hold any integer number from 0 to 15.
  Since there are 16 possible colors that the Commodore 64 can use, this
  works out well.
    In addition, there are 256 different characters that can be displayed
  at any time. For normal screen display, each of the 1000 locations in
  screen memory contains a code number which tells the VIC-II chip which
  character to display at that screen location.
    The various graphics modes are selected by the 47 CONTROL registers in
  the VIC-II chip. Many of the graphics functions can be controlled by
  POKEing the correct value into one of the registers. The VIC-II chip is
  located starting at 53248 ($D000 in HEX) through 53294 ($D02E in HEX)."
"In the context of the C64, What are the key characteristics of the ADSR envelope generator in the SID chip?","SID ENVELOPE GENERATORS

    The four-part ADSR (ATTACK, DECAY, SUSTAIN, RELEASE) envelope generator
  has been proven in electronic music to provide the optimum trade-off
  between flexibility and ease of amplitude control. Appropriate selection
  of envelope parameters allows the simulation of a wide range 2: of
  percussion and sustained instruments. The violin is a good example of a
  sustained instrument. The violinist controls the volume by bowing the
  instrument. Typically, the volume builds slowly, reaches a peak, then
  drops to an intermediate level. The violinist can maintain this level for
  as long as desired, then the volume is allowed to slowly die away.
    Note that the tone can be held at the intermediate SUSTAIN level for
  as long as desired. The tone will not begin to die away until GATE is
  cleared. With minor alterations, this basic envelope can be used for
  brass and woodwinds as well as strings.
    An entirely different form of envelope is produced by percussion in-
  struments such as drums, cymbals and gongs, as well as certain
  keyboards such as pianos and harpsichords. The percussion envelope is
  characterized by a nearly instantaneous attack, immediately followed by
  a decay to zero volume. Percussion instruments cannot be sustained at
  a constant amplitude. For example, the instant a drum is struck, the
  sound reaches full volume and decays rapidly regardless of how it was
  struck.

    Note that the tone immediately begins to decay to zero amplitude after
  the peak is reached, regardless of when GATE is cleared. The amplitude
  envelope of pianos and harpsichords is somewhat more complicated, but can
  be generated quite easily with the ADSR. These instruments reach full
  volume when a key is first struck. The amplitude immediately begins to
  die away slowly as long as the key remains depressed. If the key is
  released before the sound has fully died away, the amplitude will
  immediately drop to zero. 
    Note that the tone decays slowly until GATE is cleared, at which point
  the amplitude drops rapidly to zero.
    The most simple envelope is that of the organ, When a key is pressed,
  the tone immediately reaches full volume and remains there. When the key
  is released, the tone drops immediately to zero volume. 
    The real power of SID lies in the ability to create original sounds
  rather than simulations of acoustic instruments. The ADSR is capable of
  creating envelopes which do not correspond to any 'real' instruments. A
  good example would be the 'backwards' envelope. This envelope is
  characterized by a slow attack and rapid decay which sounds very much
  like an instrument that has been recorded on tape then played backwards.
 
    Many unique sounds can be created by applying the amplitude envelope of
  one instrument to the harmonic structure of another. This produces sounds
  similar to familiar acoustic instruments, yet notably different. In
  general, sound is quite subjective and experimentation with various
  envelope rates and harmonic contents will be necessary in order to
  achieve the desired sound."
"In the context of the C64, Can you suggest colors good for TVs?","SUGGESTED SCREEN AND CHARACTER COLOR COMBINATIONS

    Color TV sets are limited in their ability to place certain colors next
  to each other on the same line. Certain combinations of screen and char-
  acter colors produce blurred images. This chart shows which color com-
  binations to avoid, and which work especially well together.

 


  PROGRAMMING SPRITES - ANOTHER LOOK

    For those of you having trouble with graphics, this section has been
  designed as a more elementary tutorial approach to sprites."
"In the context of the C64, What are the different graphics display modes supported by the Commodore 64's 6567 Video Interface Chip (VIC-II chip)?","GRAPHICS OVERVIEW

  All of the graphics abilities of the Commodore 64 come from the 6567
  Video Interface Chip (also known as the VIC-II chip). This chip gives a
  variety of graphics modes, including a 40 column by 25 line text display,
  a 320 by 200 dot high resolution display, and SPRITES, small movable
  objects which make writing games simple. And if this weren't enough,
  many of the graphics modes can be mixed on the same screen. It is
  possible, for example, to define the top half of the screen to be in
  high resolution mode, while the bottom half is in text mode. And SPRITES
  will combine with anything! More on sprites later. First the other
  graphics modes.
   The VIC-II chip has the following graphics display modes:

  A) CHARACTER DISPLAY MODES

     1) Standard Character Mode
            a)ROM characters
            b)RAM programmable characters
     2) Multi-Color Character Mode
            a)ROM characters
            b)RAM programmable characters

     3) Extended Background Color Mode
            a)ROM characters
            b)RAM programmable characters


  B) BIT MAP MODES

     1) Standard Bit Map Mode
     2) Multi-Color Bit Map Mode


  C) SPRITES

     1) Standard Sprites
     2) Multi-Color Sprites"
"In the context of the C64, What is the starting point for calculating the position of a sprite in a 24x21 dot area?","The position of a sprite is calculated from the TOP LEFT corner of the
  24 dot by 21 dot area that your sprite can be designed in. It does NOT
  matter how many or how few dots you use to make up a sprite. Even if only
  one dot is used as a sprite, and you happen to want it in the middle of
  the screen, you must still calculate the exact positioning by starting at
  the top left corner location."
"In the context of the C64, What is the purpose of the OPEN function in the KERNAL routines?","B-18. Function Name: OPEN


    Purpose: Open a logical file
    Call address: $FFC0 (hex) 65472 (decimal)
    Communication registers: None
    Preparatory routines: SETLFS, SETNAM
    Error returns: 1,2,4,5,6,240, READST
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine is used to OPEN a logical file. Once the
  logical file is set up, it can be used for input/output operations. Most
  of the I/O KERNAL routines call on this routine to create the logical
  files to operate on. No arguments need to be set up to use this routine,
  but both the SETLFS and SETNAM KERNAL routines must be called before
  using this routine.


  How to Use:

    0) Use the SETLFS routine.
    1) Use the SETNAM routine.
    2) Call this routine."
"In the context of the C64, What is the purpose of the CHRIN  kernal function?","B-4. Function Name: CHRIN

    Purpose: Get a character from the input channel
    Call address: $FFCF (hex) 65487 (decimal)
    Communication registers: A
    Preparatory routines: (OPEN, CHKIN)
    Error returns: 0 (See READST)
    Stack requirements: 7+
    Registers affected: A, X

    Description: This routine gets a byte of data from a channel already
  set up as the input channel by the KERNAL routine CHKIN. If the CHKIN has
  NOT been used to define another input channel, then all your data is
  expected from the keyboard. The data byte is returned in the accumulator.
  The channel remains open after the call.
    Input from the keyboard is handled in a special way. First, the cursor
  is turned on, and blinks until a carriage return is typed on the
  keyboard. All characters on the line (up to 88 characters) are stored in
  the BASIC input buffer. These characters can be retrieved one at a time
  by calling this routine once for each character. When the carriage return
  is retrieved, the entire line has been processed. The next time this
  routine is called, the whole process begins again, i.e., by flashing the
  cursor.

  How to Use:

  FROM THE KEYBOARD

    1) Retrieve a byte of data by calling this routine.
    2) Store the data byte.
    3) Check if it is the last data byte (is it a CR?)
    4) If not, go to step 1.

  EXAMPLE:

       LDY $#00      ;PREPARE THE Y REGISTER TO STORE THE DATA
   RD  JSR CHRIN
       STA DATA,Y    ;STORE THE YTH DATA BYTE IN THE YTH
                     ;LOCATION IN THE DATA AREA.
       INY
       CMP #CR       ;IS IT A CARRIAGE RETURN?
       BNE RD        ;NO, GET ANOTHER DATA BYTE

  EXAMPLE:

    JSR CHRIN
    STA DATA

  FROM OTHER DEVICES

    0) Use the KERNAL OPEN and CHKIN routines.
    1) Call this routine (using a JSR instruction).
    2) Store the data.

  EXAMPLE:

    JSR CHRIN
    STA DATA"
"In the context of the C64, What is the primary function of the program counter in a C64?","THE PROGRAM COUNTER

    This contains the address of the current machine language instruction
  being executed. Since the operating system is always 'RUN'ning in the
  Commodore 64 (or, for that matter, any computer), the program counter is
  always changing. It could only be stopped by halting the microprocessor
  in some way."
"In the context of the C64, Explain the sid envelop generator?","SID: THE ENVELOPE GENERATOR

    The volume of a musical tone changes from the moment you first hear it,
  all the way through until it dies out and you can't hear it anymore. When
  a note is first struck, it rises from zero volume to its peak volume. The
  rate at which this happens is called the ATTACK. Then, it fails from the
  peak to some middle-ranged volume. The rate at which the fall of the note
  occurs is called the DECAY. The mid-ranged volume itself is called the
  SUSTAIN level. And finally, when the note stops playing, it fails from
  the SUSTAIN level to zero volume. The rate at which it fails is called
  the RELEASE. 


    Each of the items mentioned above give certain qualities and restric-
  tions to a note. The bounds are called parameters.
    The parameters ATTACK/DECAY/SUSTAIN/RELEASE and collectively called
  ADSR, can be controlled by your use of another set of locations in the
  sound generator chip. LOAD your first example program again. RUN it again
  and remember how it sounds."
"In the context of the C64, What is the purpose of the SEC instruction in the 6502 microprocessor?","SEC                        SEC Set carry flag                         SEC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   SEC                 |    38   |    1    |    2     |"
"In the context of the C64, What is the purpose of the LDX 6502 instruction ?","LDX                   LDX Load index X with memory                    LDX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   LDX #Oper           |    A2   |    2    |    2     |
  |  Zero Page     |   LDX Oper            |    A6   |    2    |    3     |
  |  Zero Page,Y   |   LDX Oper,Y          |    B6   |    2    |    4     |
  |  Absolute      |   LDX Oper            |    AE   |    3    |    4     |
  |  Absolute,Y    |   LDX Oper,Y          |    BE   |    3    |    4*    |
  * Add 1 when page boundary is crossed."
"In the context of the C64, What is the purpose of the STOP kernal function ?","Function Name: STOP

    Purpose: Check if <STOP> key is pressed
    Call address: $FFE1 (hex) 65505 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: None
    Stack requirements: None
    Registers affected: A, X

    Description: If the <STOP> key on the keyboard was pressed during a
  UDTIM call, this call returns the Z flag set. In addition, the channels
  will be reset to default values. All other flags remain unchanged. If the
  <STOP> key is not pressed then the accumulator will contain a byte
  representing the lost row of the keyboard scan. The user can also check
  for certain other keys this way.

  How to Use:
    0) UDTIM should be called before this routine.
    1) Call this routine.
    2) Test for the zero flag.

  EXAMPLE:

    JSR UDTIM   ;SCAN FOR STOP
    JSR STOP
    BNE *+5     ;KEY NOT DOWN
    JMP READY   ;=... STOP"
"In the context of the C64, How do I open an RS-232 communication?","OPENING AN RS-232 CHANNEL

    Only one RS-232 channel should be open at any time; a second OPEN
  statement will cause the buffer pointers to be reset. Any characters in
  either the transmit buffer or the receive buffer will be lost.
    Up to 4 characters can be sent in the filename field. The first two are
  the control and command register characters; the other two are reserved
  for future system options. Baud rate, parity, and other options can be
  selected through this feature.
    No error-checking is done on the control word to detect a non-
  implemented baud rate. Any illegal control word will cause the system
  output to operate at a very slow rate (below 50 baud).

  BASIC SYNTAX:

    OPEN lfn,2,0,'<control register><command register><opt baud low><opt
  baud high>'
    lfn-The logical file number (lfn) then can be any number from 1 through
  255. But be aware of the fact that if you choose a logical file number
  that is greater than 127, then a line feed will follow all carriage
  returns.
               
    <control register>- Is a single byte character (see Figure 6-1, Control
  Register Map) required to specify the baud rates. If the lower 4 bits of
  the baud rate is equal to zero (0), the <opt baud low><opt baud high>
  characters give you a rate based on the following:
    <opt baud low>=<system frequency/rate/2-100-<opt baud high>*256
    <opt baud high>=INT((system frequency/rate/2-100)/256

 
                    
  The formulas above are based on the fact that:

    system frequency = 1.02273E6 NTSC (North American TV standard)
                     = 0.98525E6 PAL (U.K. and most European TV standard)

    <command register>- Is a single byte character (see Figure 6-2, Command
  Register Map) that defines other terminal parameters. This character is
  NOT required.

  KERNAL ENTRY:

    OPEN ($FFC0) (See KERNAL specifications for more information on entry
  conditions and instructions.)


IMPORTANT NOTE: In a BASIC program, the RS-232 OPEN command should be
  | performed before creating any variables or arrays because an automatic|
  | CLR is performed when an RS-232 channel is OPENed (This is due to the |
  | allocation of 512 bytes at the top of memory.) Also remember that your|
  | program will be destroyed if 512 bytes of space are not available at  |
  | the time of the OPEN statement.                                       |"
"In the context of the C64, What are the common methods to add machine language programs to a BASIC program?","HOW TO ENTER MACHINE LANGUAGE

    There are 3 common methods to add the machine language programs to a
  BASIC program. They are:

  1-DATA STATEMENTS:

    By READing DATA statements, and POKEing the values into memory at the
  start of the program, machine language routines can be added. This is the
  easiest method. No special methods are needed to save the two parts of
  the program, and it is fairly easy to debug. The drawbacks include taking
  up more memory space, and the wait while the program is POKED in.
  Therefore, this method is better for smaller routines.

  EXAMPLE:

  10 RESTORE:FORX=1T09:READA:POKE12*4096+X,A:NEXT
  .
  BASIC PROGRAM
  .
  1000 DATA 161,1,204,204,204,204,204,204,96"
"In the context of the C64, How can I handle the paddles?","PADDLES

    A paddle is connected to both CIA #1 and the SID chip (MOS 6581 Sound
  Interface Device) through a game port. The paddle value is read via the
  SID registers 54297 ($D419) and 54298 ($D41A). PADDLES ARE NOT RELIABLE
  WHEN READ FROM BASIC ALONE!!!! The best way to use paddles, from BASIC or
  machine code, is to use the following machine language routine... (SYS to
  it from BASIC then PEEK the memory locations used by the subroutine).


                      ; four paddle read routine (can also be used for two)
                      ;
                      ; author - bill hindorff
                      ;
porta=$dc00
ciddra=$dc02
sid=$d400

*=$c100

buffer  *=*+1
pdlx    *=*+2
pdly    *=*+2
btna    *=*+1
btnb    *=*+1

* = $c000

pdlrd   ldx #1        ; for four paddles or two analog joysticks
pdlrd0                ; entry point for one pair (condition x 1st)
        sei
        lda ciddra    ; get current value of ddr
        sta buffer    ; save it away
        lda #$c0
        sta ciddra    ; set port a for input
        lda #$80
pdlrd1
        sta porta     ; address a pair of paddles
        ldy #$80      ; wait a while
pdlrd2
        nop
        dey
        bpl pdlrd2
        lda sid+25    ; get x value
        sta pdlx,x
        lda sid+26
        sta pdly,x    ; get y value
        lda porta     ; time to read paddle fire buttons
        ora #80       ; make it the same as other pair
        sta btna      ; bit 2 is pdl x, bit 3 is pdl y
        lda #$40
        dex           ; all pairs done?
        bpl pdlrd1    ; no
        lda buffer
        sta ciddra    ; restore previous value of ddr
        lda porta+1   ; for 2nd pair -
        sta btnb      ; bit 2 is pdl x, bit 3 is pdl y
        cli
        rts
.end"
"In the context of the C64, WHow can I output to a Commodore printer?","OUTPUT TO PRINTER

    The printer is an output device similar to the screen. Your main con-
  cern when sending output to the printer is to create a format that is
  easy on the eyes. Your tools here include reversed, double-width, capital
  and lower case letters, as well as dot-programmable graphics.
    The SPC function works for the printer in the same way it works for the
  screen. However, the TAB function does not work correctly on the printer,
  because it calculates the current position on the line based on the
  cursor's position on the screen, not on the paper.
    The OPEN statement for the printer creates the channel for communi-
  cation. It also specifies which character set will be used, either upper
  case with graphics or upper and lower case.

  EXAMPLES of OPEN Statement for Printer:

    OPEN 1,4: REM UPPER CASE/GRAPHICS
    OPEN 1,4,7: REM UPPER AND LOWER CASE

    When working with one character set, individual lines can be PRINTed
  in the opposite character set. When in upper case with graphics, the
  cursor down character (CHR$(17)) switches the characters to the upper
  and lower case set. When in upper and lower case, the cursor up char-
  acter (CHR$(145)) allows upper case and graphics characters to be
  PRINTed.
    Other special functions in the printer are controlled through character
  codes. All these codes are simply PRINTed just like any other character.

  TABLE of Printer Control Character Codes:

  | CHR$ CODE|                         PURPOSE                            |
  |    10    |   Line feed                                                |
  |    13    |   RETURN (automatic line feed on CBM printers)             |
  |    14    |   Begin double-width character mode                        |
  |    15    |   End double-width character mode                          |
  |    18    |   Begin reverse character mode                             |
  |   146    |   End reverse character mode                               |
  |    17    |   Switch to upper/lower case character set                 |
  |   145    |   Switch to upper case/graphics character set              |
  |    16    |   Tab to position in next 2 characters                     |
  |    27    |   Move to specified dot position                           |
  |     8    |   Begin dot-programmable graphic mode                      |
  |    26    |   Repeat graphics data                                     |
    See your Commodore printer's manual for details on using the command
  codes."
"In the context of the C64, What is the register A on 6502 and 6510?","THE REGISTERS INSIDE THE 6510 MICROPROCESSOR

  THE ACCUMULATOR

    This is THE most important register in the microprocessor. Various ma-
  chine language instructions allow you to copy the contents of a memory
  location into the accumulator, copy the contents of the accumulator into
  a memory location, modify the contents of the accumulator or some other
  register directly, without affecting any memory. And the accumulator is
  the only register that has instructions for performing math."
"In the context of the C64, What are the details for the ORA 6502 instruction?","ORA                 ORA 'OR' memory with accumulator                  ORA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   ORA #Oper           |    09   |    2    |    2     |
  |  Zero Page     |   ORA Oper            |    05   |    2    |    3     |
  |  Zero Page,X   |   ORA Oper,X          |    15   |    2    |    4     |
  |  Absolute      |   ORA Oper            |    0D   |    3    |    4     |
  |  Absolute,X    |   ORA Oper,X          |    10   |    3    |    4*    |
  |  Absolute,Y    |   ORA Oper,Y          |    19   |    3    |    4*    |
  |  (Indirect,X)  |   ORA (Oper,X)        |    01   |    2    |    6     |
  |  (Indirect),Y  |   ORA (Oper),Y        |    11   |    2    |    5     |
  * Add 1 on page crossing"
"In the context of the C64, What is the purpose of the ROR instruction in 6502?","ROR          ROR Rotate one bit right (memory or accumulator)         ROR

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Accumulator   |   ROR A               |    6A   |    1    |    2     |
  |  Zero Page     |   ROR Oper            |    66   |    2    |    5     |
  |  Zero Page,X   |   ROR Oper,X          |    76   |    2    |    6     |
  |  Absolute      |   ROR Oper            |    6E   |    3    |    6     |
  |  Absolute,X    |   ROR Oper,X          |    7E   |    3    |    7     |
    Note: ROR instruction is available on MCS650X microprocessors after
          June, 1976."
"In the context of the C64, What are the acceptable ranges for the X and Y coordinates for unexpanded sprites in the 40 column, 25 row mode?","SPRITE POSITIONING SUMMARY

    Unexpanded sprites are at least partially visible in the 40 column, by
  25 row mode within the following parameters:

1 < X < 343
30 < Y < 249

  In the 38 column mode, the X parameters change to she following:

 8 <= X <= 334

  In the 24 row mode, the Y parameters change to the following:

 34 <= Y <= 245

Expanded sprites are at least partially visible in the 40 column, by 25
  row mode within the following parameters:
  489 >= X <= 343
  9 >= Y <= 249

In the 38 column mode, the X parameters change to the following:
496 >= X <= 334

In the 24 row mode, the Y parameters change to the following:
13 <= Y <= 245"
"In the context of the C64, What are the three program modules that make up the Operating System?","THE OPERATING SYSTEM (OS)
    The Operating System is contained in the Read Only Memory (ROM) chips
  and is a combination of three separate, but interrelated, program
  modules.

    1) The BASIC Interpreter
    2) The KERNAL
    3) The Screen Editor

    1) The BASIC Interpreter is responsible for analysing BASIC statement
       syntax and for performing the required calculations and/or data
       manipulation. The BASIC Interpreter has a vocabulary of 65
       'keywords' which have special meanings. The upper and lower case
       alphabet and the digits 0-9 are used to make both keywords and
       variable names. Certain punctuation characters and special symbols
       also have meanings for the Interpreter. Table 1-1 lists the special
       characters and their uses.
    2) The KERNAL handles most of the interrupt level processing in the
       system (for details on interrupt level processing, see Chapter 5).
       The KERNAL also does the actual input and output of data.
    3) The Screen Editor controls the output to the video screen (tele-
       vision set) and the editing of BASIC program text. In addition, the
       Screen Editor intercepts keyboard input so that it can decide
       whether the characters put in should be acted upon immediately, or
       passed on to the BASIC Interpreter."
"In the context of the C64, how do I control the screen blanking?","SCREEN BLANKING

    Bit 4 of the VIC-II control register controls the screen blanking func-
  tion. It is found in the control register at location 53265 ($D011). When
  it is turned ON (in other words, set to a 1) the screen is normal. When
  bit 4 is set to 0 (turned OFF), the entire screen changes to border
  color.
    The following POKE blanks the screen. No data is lost, it just isn't
  displayed.

    POKE 53265,PEEK(53265)AND 239

  To bring back the screen. use the POKE shown below:

    POKE 53265,PEEK(53265)OR 16

  NOTE: Turning off the screen will speed up the processor slightly.
  This means that program RUNning is also sped up."
"In the context of the C64, What is the purpose of the CLALL function?","B-8. Function Name: CLALL

    Purpose: Close all files
    Call address: $FFE7 (hex) 65511 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: None
    Stack requirements: 11
    Registers affected: A, X

    Description: This routine closes all open files. When this routine is
  called, the pointers into the open file table are reset, closing all
  files. Also, the CLRCHN routine is automatically called to reset the I/O
  channels.

  How to Use:

    1) Call this routine.

  EXAMPLE:

    JSR CLALL   ;CLOSE ALL FILES AND SELECT DEFAULT I/O CHANNELS
    JMP RUN     ;BEGIN EXECUTION"
"In the context of the C64, What is the purpose of the LISTEN function in a serial bus communication system?","B-14. Function Name: LISTEN

    Purpose: Command a device on the serial bus to listen
    Call Address: $FFB1 (hex) 65457 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: None
    Registers affected: A

    Description: This routine will command a device on the serial bus to
  receive data. The accumulator must be loaded with a device number between
  0 and 31 before calling the routine. LISTEN will OR the number bit by bit
  to convert to a listen address, then transmits this data as a command on
  the serial bus. The specified device will then go into listen mode, and
  be ready to accept information.

  How to Use:
    1) Load the accumulator with the number of the device to command
       to LISTEN.
    2) Call this routine using the JSR instruction.

  EXAMPLE:
    ;COMMAND DEVICE #8 TO LISTEN
    LDA #8
    JSR LISTEN"
"In the context of the C64, What is the purpose of the LOAD routine in the Commodore 64 KERNAL?","B-15. Function Name: LOAD

    Purpose: Load RAM from device
    Call address: $FFD5 (hex) 65493 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: SETLFS, SETNAM
    Error returns: 0,4,5,8,9, READST
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine LOADs data bytes from any input device di-
  rectly into the memory of the Commodore 64. It can also be used for a
  verify operation, comparing data from a device with the data already in
  memory, while leaving the data stored in RAM unchanged.
    The accumulator (.A) must be set to 0 for a LOAD operation, or 1 for a
  verify, If the input device is OPENed with a secondary address (SA) of 0
  the header information from the device is ignored. In this case, the X
  and Y registers must contain the starting address for the load. If the
  device is addressed with a secondary address of 1, then the data is
  loaded into memory starting at the location specified by the header. This
  routine returns the address of the highest RAM location loaded.
    Before this routine can be called, the KERNAL SETLFS, and SETNAM
  routines must be called.


NOTE: You can NOT LOAD from the keyboard (0), RS-232 (2), or the screen (3).

  How to Use:

    0) Call the SETLFS, and SETNAM routines. If a relocated load is de-
       sired, use the SETLFS routine to send a secondary address of 0.
    1) Set the A register to 0 for load, 1 for verify.
    2) If a relocated load is desired, the X and Y registers must be set
       to the start address for the load.
    3) Call the routine using the JSR instruction."
"In the context of the C64, What is the purpose of the CLOSE kernal function?","B-9. Function Name: CLOSE

    Purpose: Close a logical file
    Call address: $FFC3 (hex) 65475 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: 0,240 (See READST)
    Stack requirements: 2+
    Registers affected: A, X, Y

    Description: This routine is used to close a logical file after all I/O
  operations have been completed on that file. This routine is called after
  the accumulator is loaded with the logical file number to be closed (the
  same number used when the file was opened using the OPEN routine).

 How to Use:

    1) Load the accumulator with the number of the logical file to be
       closed.
    2) Call this routine.

  EXAMPLE:

    ;CLOSE 15
    LDA #15
    JSR CLOSE"
"In the context of the C64, What is the purpose of the raster register in the VIC-II chip?","RASTER REGISTER

    The raster register is found in the VIC-II chip at location 53266
  ($D012). The raster register is a dual purpose register. When you read
  this register it returns the lower 8 bits of the current raster position.
  The raster position of the most significant bit is in register location
  53265 ($D011). You use the raster register to set up timing changes in
  your display so that you can get rid of screen flicker. The changes on
  your screen should be mode when the raster is not in the visible display
  area, which is when your dot positions fall between 51 and 251.
    When the raster register is written to (including the MSB) the number
  written to is saved for use with the raster compare function. When the
  actual raster value becomes the same as the number written to the raster
  register, a bit in the VIC-II chip interrupt register 53273 ($D019) is
  turned ON by setting it to 1.

   NOTE: If the proper interrupt bit is enabled (turned on), an interrupt
   (IRQ) will occur."
"In the context of the C64, What determines the order in which sprites appear in a scene?","SPRITE DISPLAY PRIORITIES

    Sprites have the ability to cross each other's paths, as well as cross
  in front of, or behind other objects on the screen. This can give you a
  truly three dimensional effect for games.
    Sprite to sprite priority is fixed. That means that sprite 0 has the
  highest priority, sprite 1 has the next priority, and so on, until we get
  to sprite 7, which has the lowest priority. In other words, if sprite 1
  and sprite 6 are positioned so that they cross each other, sprite 1 will
  be in front of sprite 6.
    So when you're planning which sprites will appear to be in the fore-
  ground of the picture, they must be assigned lower sprite numbers than
  those sprites you want to put towards the back of the scene. Those
  sprites will be given higher sprite numbers,

NOTE: A 'window' effect is possible. If a sprite with higher priority 
has 'holes' in it (areas where the dots are not set to 1 and thus     
turned ON), the sprite with the lower priority will show through. This
also happens with sprite and background data."
"In the context of the C64, What is the purpose of the ROL instruction in 6502 assembly language?","ROL          ROL Rotate one bit left (memory or accumulator)          ROL

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Accumulator   |   ROL A               |    2A   |    1    |    2     |
  |  Zero Page     |   ROL Oper            |    26   |    2    |    5     |
  |  Zero Page,X   |   ROL Oper,X          |    36   |    2    |    6     |
  |  Absolute      |   ROL Oper            |    2E   |    3    |    6     |
  |  Absolute,X    |   ROL Oper,X          |    3E   |    3    |    7     |"
"In the context of the C64, What is the instruction that performs no operation and has an opcode?","NOP                         NOP No operation                          NOP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   NOP                 |    EA   |    1    |    2     |"
"In the context of the C64, Give a rapide overview of the memory map of the Commodore 64?","SIMPLE MEMORY MAP OF THE COMMODORE 64


  ADDRESS                       DESCRIPTION                       
                                                                   
   0 & 1   -6510 Registers.                                                                                                    
    2      -Start of memory.                                       
    2-1023 -Memory used by the operating system.                   
 1024-2039 -Screen memory.                                         
 2040-2047 -SPRITE pointers.                                       
 2048-40959-This is YOUR memory. This is where your BASIC or machine language programs, or both, are stored.        
40960-49151-8K CBM BASIC Interpreter.                              
49152-53247-Special programs RAM area.                             
53248-53294-VIC-II.                                                
54272-55295-SID Registers.                                         
55296-56296-Color RAM.                                             
56320-57343-I/O Registers. (6526's)                                                                                                   
57344-65535-8K CBM KERNAL Operating System."
"In the context of the C64, What information about the SID chip's parameters can be changed dynamically during a note or sound to create many interesting and fun effects?","SOUND  ADVANCED TECHNIQUES

    The SID chip's parameters can be changed dynamically during a note or
  sound to create many interesting and fun effects. In order to make this
  easy to do, digitized outputs from oscillator three and envelope
  generator three are available for you in registers 27 and 28, respec-
  tively.
    The output of oscillator 3 (register 27) is directly related to the
  waveform selected. If you choose the sawtooth waveform of oscillator 3,
  this register will present a series of numbers incremented (increased
  step by step) from 0 to 255 at a rate determined by the frequency of
  oscillator 3. If you choose the triangle waveform, the output will incre-
  ment from 0 up to 255, then decrement (decrease step by step) back down
  to 0. If you choose the pulse wave, the output will jump back-and-forth
  between 0 and 255. Finally, choosing the noise waveform will give you a
  series of random numbers. When oscillator 3 is used for modulation, you
  usually do NOT want to hear its output. Setting bit 7 of register 24
  turns the audio output of voice 3 off. Register 27 always reflects the
  changing output of the oscillator and is not affected in any way by the
  envelope (ADSR) generator.
    Register 25 gives you access to the output of the envelope generator
  of oscillator 3. It functions in much the same fashion that the output of
  oscillator 3 does. The oscillator must be turned on to produce any output
  from this register.
    Vibrato (a rapid variation in frequency) can be achieved by adding the
  output of oscillator 3 to the frequency of another oscillator. Example
  Program 6 illustrates this idea."
"In the context of the C64, What is the format of the OPEN statement parameters?","TABLE of OPEN Statement Parameters:

    FORMAT: OPEN file#, device#, number, string


  | DEVICE | DEVICE# |       NUMBER        |            STRING            |
  |CASSETTE|    1    | 0 = Input           | File Name                    |
  |        |         | 1 = Output          |                              |
  |        |         | 2 = Output with EOT |                              |
  | MODEM  |    2    | 0                   | Control Registers            |
  | SCREEN |    3    | 0,1                 |                              |
  | PRINTER|  4 or 5 | 0 = Upper/Graphics  | Text Is PRINTed              |
  |        |         | 7 = Upper/Lower Case|                              |
  | DISK   | 8 to 11 | 2-14 = Data Channel | Drive #, File Name           |
  |        |         |                     | File Type, Read/Write        |
  |        |         | 15 = Command        | Command                      |
  |        |         |      Channel        |                              |"
"In the context of the C64, How can I read the value of the joystick?","A small machine code routine to read the joystick:


                      ; joystick - button read routine
                      ;
                      ; author - bill hindorff
                      ;
dx = $c110
dy = $c111

* = $c200

djrr    lda $dc00     ; get input from port a only
djrrb   ldy #0        ; this routine reads and decodes the
        ldx #0        ; joystick/firebutton input data in
        lsr a         ; the accumulator. this least significant
        bcs djr0      ; 5 bits contain the switch closure
        dey           ; information. if a switch is closed then it
djr0    lsr a         ; produces a zero bit. if a switch is open then
        bcs djr1      ; it produces a one bit. The joystick dir-
        iny           ; ections are right, left, forward, backward
djr1    lsr a         ; bit3=right, bit2=left, bit1=backward,
        bcs djr2      ; bit0=forward and bit4=fire button.
        dex           ; at rts time dx and dy contain 2's compliment
djr2    lsr a         ; direction numbers i.e. $ff=-1, $00=0, $01=1.
        bcs djr3      ; dx=1 (move right), dx=-1 (move left),
        inx           ; dx=0 (no x change). dy=-1 (move up screen),
djr3    lsr a         ; dy=0 (move down screen), dy=0 (no y change).
        stx dx        ; the forward joystick position corresponds
        sty dy        ; to move up the screen and the backward
        rts           ; position to move down screen.
                      ;
                      ; at rts time the carry flag contains the fire
                      ; button state. if c=1 then button not pressed.
                      ; if c=0 then pressed.
.end"
"In the context of the C64, What is the recommended location for machine language routines on the Commodore 64?","WHERE TO PUT MACHINE LANGUAGE ROUTINES

    The best place for machine language routines on the Commodore 64 is
  from $C000-$CFFF, assuming the routines are smaller than 4K bytes long.
  This section of memory is not disturbed by BASIC.
    If for some reason it's not possible or desirable to put the machine
  language routine at $C000, for instance if the routine is larger than 4K
  bytes, it then becomes necessary to reserve an area at the top of memory
  from BASIC for the routine. The top of memory is normally $9FFF. The top
  of memory can be changed through the KERNAL routine MEMTOP, or by the
  following BASIC statements:

    10 POKE51,L:POKE52,H:POKE55,1:POKE56,H:CLR

  Where H and L are the high and low portions, respectively, of the new
  top of memory. For example, to reserve the area from $9000 to $9FFF for
  machine language, use the following:

    10 POKE5110:POKE52,144:POKE5510:POKE56,144:CLR"
"In the context of the C64, how can I send data to a modem?","OUTPUT TO MODEM

    The modem is a simple device that can translate character codes into
  audio pulses and vice-versa, so that computers can communicate over
  telephone lines. The OPEN statement for the modem sets up the parameters
  to match the speed and format of the other computer you are communicating
  with. Two characters can be sent in the string at the end
  of the OPEN statement.
    The bit positions of the first character code determine the baud rate,
  number of data bits, and number of stop bits. The second code is op-
  tional, and its bits specify the parity and duplex of the transmission.
  See the RS-232 section or your VICMODEM manual for specific details on
  this device.

  EXAMPLE of OPEN Statement for Modem:

    OPEN 1,2,0,CHR$(6): REM 300 BAUD
    100 OPEN 2,2,0,CHR$(163) CHR$(112): REM 110 BAUD, ETC.

    Most computers use the American Standard Code for Information In-
  terchange, known as ASCII (pronounced ASK-KEY). This standard set of
  character codes is somewhat different from the codes used in the Com-
  modore 64. When communicating with other computers, the Commodore
  character codes must be translated into their ASCII counterparts. A table
  of standard ASCII codes is included in this book in Appendix C.
    Output to the modem is a fairly uncomplicated task, aside from the need
  for character translation. However, you must know the receiving device
  fairly well, especially when writing programs where your computer 'talks'
  to another computer without human intervention. An example of this would
  be a terminal program that automatically types in your account number and
  secret password. To do this successfully, you must carefully count the
  number of characters and RETURN characters. Otherwise, the computer
  receiving the characters won't know what to do with them."
"In the context of the C64, What is the primary purpose of the X index register in a C64?","THE X INDEX REGISTER

    This is a very important register. There are instructions for nearly
  all of the transformations you can make to the accumulator. But there are
  other instructions for things that only the X register can do. Various
  machine language instructions allow you to copy the contents of a memory
  location into the X register, copy the contents of the X register into a
  memory location, and modify the contents of the X, or some other register
  directly."
"In the context of the C64, What is the purpose of the CHKIN routine in the KERNAL?","B-2. Function Name: CHKIN

    Purpose: Open a channel for input
    Call address: $FFC6 (hex) 65478 (decimal)
    Communication registers: X
    Preparatory routines: (OPEN)
    Error returns:
    Stack requirements: None
    Registers affected: A, X


    Description: Any logical file that has already been opened by the
  KERNAL OPEN routine can be defined as an input channel by this routine.
  Naturally, the device on the channel must be an input device. Otherwise
  an error will occur, and the routine will abort.
    If you are getting data from anywhere other than the keyboard, this
  routine must be called before using either the CHRIN or the GETIN KERNAL
  routines for data input. If you want to use the input from the keyboard,
  and no other input channels are opened, then the calls to this routine,
  and to the OPEN routine are not needed.
    When this routine is used with a device on the serial bus, it auto-
  matically sends the talk address (and the secondary address if one was
  specified by the OPEN routine) over the bus.

  How to Use:

    0) OPEN the logical file (if necessary; see description above).
    1) Load the X register with number of the logical file to be used.
    2) Call this routine (using a JSR command).


  Possible errors are:

    #3: File not open
    #5: Device not present
    #6: File not an input file

  EXAMPLE:

    ;PREPARE FOR INPUT FROM LOGICAL FILE 2
    LDX #2
    JSR CHKIN"
"In the context of the C64, What is the native language of the Commodore 64?","WHAT IS MACHINE LANGUAGE?

    At the heart of every microcomputer, is a central microprocessor. It's
  a very special microchip which is the 'brain' of the computer. The
  Commodore 64 is no exception. Every microprocessor understands its own
  language of instructions. These instructions are called machine language
  instructions. To put it more precisely, machine language is the ONLY
  programming language that your Commodore 64 understands. It is the NATIVE
  language of the machine.
    If machine language is the only language that the Commodore 64
  understands, then how does it understand the CBM BASIC programming
  language? CBM BASIC is NOT the machine language of the Commodore 64.
  What, then, makes the Commodore 64 understand CBM BASIC instructions like
  PRINT and GOTO?
    To answer this question, you must first see what happens inside your
  Commodore 64. Apart from the microprocessor which is the brain of the
  Commodore 64, there is a machine language program which is stored in a
  special type of memory so that it can't be changed. And, more impor-
  tantly, it does not disappear when the Commodore 64 is turned off, unlike
  a program that you may have written. This machine language program is
  called the OPERATING SYSTEM of the Commodore 64. Your Commodore 64 knows
  what to do when it's turned on because its OPERATING SYSTEM (program) is
  automatically 'RUN.'"
"In the context of the C64, What is the instruction that pulls the accumulator from the stack in 6502?","PLA                 PLA Pull accumulator from stack                   PLA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PLA                 |    68   |    1    |    4     |"
"In the context of the C64, What are the details fot the LDY instruction in the 6502 assembly language?","LDY                   LDY Load index Y with memory                    LDY
                                                        N Z C I D V
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   LDY #Oper           |    A0   |    2    |    2     |
  |  Zero Page     |   LDY Oper            |    A4   |    2    |    3     |
  |  Zero Page,X   |   LDY Oper,X          |    B4   |    2    |    4     |
  |  Absolute      |   LDY Oper            |    AC   |    3    |    4     |
  |  Absolute,X    |   LDY Oper,X          |    BC   |    3    |    4*    |
  * Add 1 when page boundary is crossed."
"In the context of the C64, What is stored in the VIC-II chip control register at location $D01F in HEX that indicates sprite to data collisions?","SPRITE TO DATA COLLISIONS

    Sprite to data collisions are detected in the sprite to data collision
  register at location 53279 ($D01F in HEX) of the VIC-II chip control
  register.
    Each sprite has a bit in this register. If that bit is a 1 , then that
  sprite is involved in a collision. The bits in this register remain set
  until read (PEEKed). Once read, the register is automatically cleared, so
  it is a good idea to save the value in a variable until you are finished
  with it.

   NOTE: MULTI-COLOR data 01 is considered transparent for collisions,   
   even though it shows up on the screen. When setting up a background   
   screen, it is a good idea to make everything that should not cause a  
   collision 01 in multi-color mode."
"In the context of the C64, What are the two character sets available on the Commodore 64, and how can you switch between them?","The Commodore 64 has two complete character sets that you can use
  either from the keyboard or in your programs.
    In SET 1, the upper case alphabet and the numbers 0-9 are available
  without pressing the <SHIFT> key. If you hold down the <SHIFT> key
  while typing, the graphics characters on the RIGHT side of the front of
  the keys are used. If you hold down the <C=> key while typing, the
  graphics characters on the LEFT side of the front of the key are used.
  Holding down the <SHIFT> key while typing any character that doesn't
  have graphic symbols on the front of the key gives you the symbol on the
  top most part of the key.
    In SET 2, the lower case alphabet and the numbers 0-9 are available
  without pressing the <SHIFT> key. The upper case alphabet is available
  when you hold down the <SHIFT> key while typing. Again, the graphic
  symbols on the LEFT side of the front of the keys are displayed by press-
  ing the <C=> key, while the symbols on the top most part of any key
  without graphics characters are selected when you hold down the <SHIFT>
  key while typing.
    To switch from one character set to the other press the <C=> and
  the <SHIFT> keys together."
"In the context of the C64, What is the purpose and functionality of the MEMTOP routine in kernal?","B-17. Function Name: MEMTOP

    Purpose: Set the top of RAM
    Call address: $FF99 (hex) 65433 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: X, Y

    Description: This routine is used to set the top of RAM. When this
  routine is called with the carry bit of the accumulator set, the pointer
  to the top of RAM will be loaded into the X and Y registers. When this
  routine is called with the accumulator carry bit clear, the contents of
  the X and Y registers are loaded in the top of memory pointer, changing
  the top of memory.

  EXAMPLE:
    ;DEALLOCATE THE RS-232 BUFFER
    SEC
    JSR MEMTOP   ;READ TOP OF MEMORY
    DEX
    CLC
    JSR MEMTOP   ;SET NEW TOP OF MEMORY"
"In the context of the C64, what is the purpose of the GETIN subroutine in kernal?","B-11. Function Name: GETIN


    Purpose: Get a character
    Call address: $FFE4 (hex) 65508 (decimal)
    Communication registers: A
    Preparatory routines: CHKIN, OPEN
    Error returns: See READST
    Stack requirements: 7+
    Registers affected: A (X, Y)

    Description: If the channel is the keyboard, this subroutine removes
  one character from the keyboard queue and returns it as an ASCII value in
  the accumulator. If the queue is empty, the value returned in the
  accumulator will be zero. Characters are put into the queue automatically
  by an interrupt driven keyboard scan routine which calls the SCNKEY
  routine. The keyboard buffer can hold up to ten characters. After the
  buffer is filled, additional characters are ignored until at least one
  character has been removed from the queue. If the channel is RS-232, then
  only the A register is used and a single character is returned. See
  READST to check validity. If the channel is serial, cassette, or screen,
  call BASIN routine.


  How to Use:

    1) Call this routine using a JSR instruction.
    2) Check for a zero in the accumulator (empty buffer).
    3) Process the data.


  EXAMPLE:

         ;WAIT FOR A CHARACTER
    WAIT JSR GETIN
         CMP #0
         BEQ WAIT"
"In the context of the C64, What is the purpose of the CLRCHN kernal routine?","B-10. Function Name: CLRCHN

    Purpose: Clear I/O channels
    Call address: $FFCC (hex) 65484 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns:
    Stack requirements: 9
    Registers affected: A, X

    Description: This routine is called to clear all open channels and re-
  store the I/O channels to their original default values. It is usually
  called after opening other I/O channels (like a tape or disk drive) and
  using them for input/output operations. The default input device is 0
  (keyboard). The default output device is 3 (the Commodore 64 screen).
    If one of the channels to be closed is to the serial port, an UNTALK
  signal is sent first to clear the input channel or an UNLISTEN is sent to
  clear the output channel. By not calling this routine (and leaving lis-
  tener(s) active on the serial bus) several devices can receive the same
  data from the Commodore 64 at the same time. One way to take advantage
  of this would be to command the printer to TALK and the disk to LISTEN.
  This would allow direct printing of a disk file.
    This routine is automatically called when the KERNAL CLALL routine is
  executed.

  How to Use:
    1) Call this routine using the JSR instruction.

  EXAMPLE:
    JSR CLRCHN"
"In the context of the C64, What is the purpose of the MEMBOT routine?","B-16. Function Name: MEMBOT

    Purpose: Set bottom of memory
    Call address: $FF9C (hex) 65436 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: None
    Registers affected: X, Y

    Description: This routine is used to set the bottom of the memory. If
  the accumulator carry bit is set when this routine is called, a pointer
  to the lowest byte of RAM is returned in the X and Y registers. On the
  unexpanded Commodore 64 the initial value of this pointer is $0800
  (2048 in decimal). If the accumulator carry bit is clear (-O) when this
  routine is called, the values of the X and Y registers are transferred to
  the low and high bytes, respectively, of the pointer to the beginning of
  RAM.

  How to Use:
  TO READ THE BOTTOM OF RAM
    1) Set the carry.
    2) Call this routine.

  TO SET THE BOTTOM OF MEMORY
    1) Clear the carry.
    2) Call this routine.

  EXAMPLE:

    ;MOVE BOTTOM OF MEMORY UP 1 PAGE
    SEC         ;READ MEMORY BOTTOM
    JSR MEMBOT
    INY
    CLC         ;SET MEMORY BOTTOM TO NEW VALUE
    JSR MEMBOT"
"In the context of the C64, What are the key considerations and limitations when positioning sprites horizontally in a graphics system?","HORIZONTAL POSITIONING

    Positioning in the horizontal direction is more complicated because
  there are more than, 256 positions. This means that an extra bit, or 9th
  bit is used to control the X position. By adding the extra bit when
  necessary a sprite now has 512 possible positions in the left/right, X,
  direction. This makes more possible combinations than can be seen on the
  visible part of the screen. Each sprite can have a position from 0 to
  511. However, only those values between 24 and 343 are visible on the
  screen. If the X position of a sprite is greater than 255 (on the right
  side of the screen), the bit in the X MOST SIGNIFICANT BIT POSITION

  register must be set to a 1 (turned ON). If the X position of a sprite is
  less than 256 (on the left side of the screen), then the X MSB of that
  sprite must be 0 (turned OFF). Bits 0 to 7 of the X MSB register
  correspond to sprites 0 to 7, respectively."
"In the context of the C64, how sprite to sprite collision works?","SPRITE TO SPRITE COLLISIONS

    Sprite to sprite collisions are recognized by the computer, or flagged,
  in the sprite to sprite collision register at location 53278 ($D01E in
  HEX) in the VIC-II chip control register. Each sprite has a bit in this
  register. If that bit is a 1, then that sprite is involved in a
  collision. The bits in this register will remain set until read (PEEKed).
  Once read, the register is automatically cleared, so it is a good idea to
  save the value in a variable until you are finished with it.
  
   NOTE: Collisions can take place even when the sprites are off screen."
"In the context of the C64, What are the two modes of BASIC operation provided by the Operating System?","The Operating System gives you two modes of BASIC operation:
    1) DIRECT Mode
    2) PROGRAM Mode

    1) When you're using the DIRECT mode, BASIC statements don't have
       line numbers in front of the statement. They are executed whenever
       the <RETURN> key is pressed.
    2) The PROGRAM mode is the one you use for running programs.
       When using the PROGRAM mode, all of your BASIC statements must have
       line numbers in front of them. You can have more than one BASIC
       statement in a line of your program, but the number of statements is
       limited by the fact that you can only put 80 characters on a logical
       screen line. This means that if you are going to go over the 80
       character limit you have to put the entire BASIC statement that
       doesn't fit on a new line with a new line number.
         Always type NEW and hit <RETURN> before starting a new program."
"In the context of the C64, What is the purpose of the LSR instruction in 6502?","LSR          LSR Shift right one bit (memory or accumulator)          LSR

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Accumulator   |   LSR A               |    4A   |    1    |    2     |
  |  Zero Page     |   LSR Oper            |    46   |    2    |    5     |
  |  Zero Page,X   |   LSR Oper,X          |    56   |    2    |    6     |
  |  Absolute      |   LSR Oper            |    4E   |    3    |    6     |
  |  Absolute,X    |   LSR Oper,X          |    5E   |    3    |    7     |"
"In the context of the C64, What is the purpose of the instruction PLP"" in 6502?""","PLP               PLP Pull processor status from stack                PLA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PLP                 |    28   |    1    |    4     |"
"In the context of the C64, What is the purpose of the CHKOUT  kernal routine?","B-3. Function Name: CHKOUT

    Purpose: Open a channel for output
    Call address: $FFC9 (hex) 65481 (decimal)
    Communication registers: X
    Preparatory routines: (OPEN)
    Error returns: 0,3,5,7 (See READST)
    Stack requirements: 4+
    Registers affected: A, X

    Description: Any logical file number that has been created by the
  KERNAL routine OPEN can be defined as an output channel. Of course, the
  device you intend opening a channel to must be an output device.
  Otherwise an error will occur, and the routine will be aborted.
    This routine must be called before any data is sent to any output
  device unless you want to use the Commodore 64 screen as your output
  device. If screen output is desired, and there are no other output chan-
  nels already defined, then calls to this routine, and to the OPEN routine
  are not needed.
    When used to open a channel to a device on the serial bus, this routine
  will automatically send the LISTEN address specified by the OPEN routine
  (and a secondary address if there was one).

  How to Use:

REMEMBER: this routine is NOT NEEDED to send data to the screen.
    0) Use the KERNAL OPEN routine to specify a logical file number, a
       LISTEN address, and a secondary address (if needed).
    1) Load the X register with the logical file number used in the open
       statement.
    2) Call this routine (by using the JSR instruction).

  EXAMPLE:

    LDX #3        ;DEFINE LOGICAL FILE 3 AS AN OUTPUT CHANNEL
    JSR CHKOUT

    Possible errors are:
    #3: File not open
    #5: Device not present
    #7: Not an output file"
"In the context of the C64, What is the primary function of the OPERATING SYSTEM in a Commodore 64 computer?","The C64 OPERATING SYSTEM is in charge of 'organizing' all the memory in
  your machine for various tasks. It also looks at what characters you type
  on the keyboard and puts them onto the screen, plus a whole number of
  other functions. The OPERATING SYSTEM can be thought of as the
  'intelligence and personality' of the Commodore 64 (or any computer for
  that matter). So when you turn on your Commodore 64, the OPERATING SYSTEM
  takes control of your machine, and after it has done its housework, it
  then says:

    READY."
"In the context of the C64, What is the primary purpose of the Y index register in a C64?","THE Y INDEX REGISTER

    This is a very important register. There are instructions for nearly
  all of the transformations you can make to the accumulator, and the X
  register. But there are other instructions for things that only the Y
  register can do. Various machine language instructions allow you to copy
  the contents of a memory location into the Y register, copy the contents
  of the Y register into a memory location, and modify the contents of the
  Y, or some other register directly."
"In the context of the C64, describe how the ligth pen works","LIGHT PEN

    The light pen input latches the current screen position into a pair of
  registers (LPX, LPY) on a low-going edge. The X position register 19
  ($13) will contain the 8 MSB of the X position at the time of transition.
  Since the X position is defined by a 512-state counter (9 bits),
  resolution to 2 horizontal dots is provided. Similarly, the Y position is
  latched in its register 20 ($14), but here 8 bits provide single raster
  resolution within the visible display. The light pen latch may be
  triggered only once per frame, and subsequent triggers within the same
  frame will have no effect. Therefore, you must take several samples
  before turning the pen to the screen (3 or more samples average),
  depending upon the characteristics of your light pen."
"In the context of the C64, What are some key considerations when working with cassette tapes for data storage?","WORKING WITH CASSETTE TAPE

    Cassette tapes have an almost unlimited capacity for data. The longer
  the tape, the more information it can store. However, tapes are limited
  in time. The more data on the tape, the longer the time it takes to find
  the information.
    The programmer must try to minimize the time factor when working with
  tape storage. One common practice is to read the entire cassette data
  file into RAM, then process it, and then re-write all the data on the
  tape. This allows you to sort, edit, and examine your data. However, this
  limits the size of your files to the amount of available RAM.
    If your data file is larger than the available RAM, it is probably time
  to switch to using the floppy disk. The disk can read data at any
  position on the disk, without needing to read through all the other data.
  You can write data over old data without disturbing the rest of the file.
  That's why the disk is used for all business applications like ledgers
  and mailing lists.
    The PRINT# statement formats data just like the PRINT statement does.
  All punctuation works the same. But remember, you're not working with the
  screen now. The formatting must be done with the INPUT# statement
  constantly in mind.

    Consider the statement PRINT# 1, A$, B$, C$. When used with the screen,
  the commas between the variables provide enough blank space between items
  to format them into columns ten characters wide. On cassette, anywhere
  from 1 to 10 spaces will be added, depending on th length of the strings.
  This wastes space on your tape.
    Even worse is what happens when the INPUT# statement tries to read
  these strings. The statement INPUT# 1, A$, B$, C$ will discover no data
  for B$ and C$. A$ will contain all three variables, plus the spaces be-
  tween them. What happens? Here's a look at the tape file:

    A$='DOG' B$='CAT' C$='TREE'
    PRINT# 1, A$, B$, C$

    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
    D O G                 C  A  T                       T  R  E  E  RETURN

    The INPUT# statement works like the regular INPUT statement. When
  typing data into the INPUT statement, the data items are separated,
  either by hitting the <RETURN> key or using commas to separate them. The
  PRINT# statement puts a RETURN at the end of a line just like the PRINT
  statement. A$ fills up with all three values because there's no separator
  on the tape between them, only after all three.
    A proper separator would be a comma (,) or a RETURN on the tape. The
  RETURN code is automatically put at the end of a PRINT or PRINT#
  statement. One way to put the RETURN code between each item is to us only
  one item per PRINT# statement. A better way is to set a variable to the
  RETURN CHR$ code, which is CHR$(13), or use a comma. The statement for
  this is R$=',':PRINT#1, A$ R$ B$ R$ C$. Don't use commas or any other
  punctuation between the variable names, since the Commodore 64 can tell
  them apart and they'll only use up space in your program.
    A proper tape file looks like this:

    1 2 3 4 5 6 7 8 9 10 11 12 13

    D O G , C A T , T  R  E  E  RETURN

    The GET# statement will pick data from the tape one character at a
  time. It will receive each character, including the RETURN code and other
  punctuation. The CHR$(0) code is received as an empty string, not as a
  one character string with a code of 0. If you try to use the ASC function
  on an empty string, you get the error message ILLEGAL QUANTITY ERROR.

    The line GET# 1, A$: A= ASC(A$) is commonly used in programs to examine
  tape data. To avoid error messages, the line should be modified to
  GET#1, A$: A=ASC(A$+CHR$(0)). The CHR$(0) at the end acts as insurance
  against empty strings, but doesn't affect the ASC function when there are
  other characters in A$."
"In the context of the C64, What are the zero-page memory locations used for in the RS-232 system interface?","ZERO-PAGE MEMORY LOCATIONS AND USAGE FOR
  RS-232 SYSTEM INTERFACE

    $00A7-INBIT-Receiver input bit temp storage.
    $00A8-BITCI-Receiver bit count in.
    $00A9-RINONE-Receiver flag Start bit check.
    $00AA-RIDATA-Receiver byte buffer/assembly location.
    $00AB-RIPRTY-Receiver parity bit storage.
    $00B4-BITTS-Transmitter bit count out.
    $00B5-NXTBIT-Transmitter next bit to be sent.
    $00B6-RODATA-Transmitter byte buffer/disassembly location.


    All the above zero-page locations are used locally and are only given
  as a guide to understand the associated routines. These cannot be used
  directly by the BASIC or KERNAL level programmer to do RS-232 type
  things. The system RS-232 routines must be used."
"In the context of the C64, What are the values that can be POKE'd into a color memory location to change a character's color?","The actual values to POKE into a color memory location to change a
  character's color are:

             0  BLACK   4  PURPLE     8  ORANGE     12  GRAY 2
             1  WHITE   5  GREEN      9  BROWN      13  Light GREEN
             2  RED     6  BLUE      10  Light RED  14  Light BLUE
             3  CYAN    7  YELLOW    11  GRAY 1     15  GRAY 3

    For example, to change the color of a character located at the upper
  left-hand corner of the screen to red, type: POKE 55296,2."
"In the context of the C64, Describe the multi-color character mode?","MULTI-COLOR CHARACTER MODE (MCM = 1, BMM = ECM = 0 )

    Multi-color mode provides additional color flexibility allowing up to
  four colors within each character but with reduced resolution. The multi-
  color mode is selected by setting the MCM bit in register 22 ($16) to
  '1,' which causes the dot data stored in the character base to be
  interpreted in a different manner. If the MSB of the color nybble is a
  '0,' the character will be displayed as described in standard character
  mode, allowing the two modes to be inter-mixed (however, only the lower
  order 8 colors are available). When the MSB of the color nybble is a '1'
  (if MCM:MSB(CM) = 1) the character bits are interpreted in the multi-
  color mode:

                | CHARACTER  |
     FUNCTION   |  BIT PAIR  |               COLOR DISPLAYED
  --------------+------------+---------------------------------------------
    Background  |     00     |  Background #0 Color
                |            |  (register 33 ($21))
    Background  |     01     |  Background #1 Color
                |            |  (register 34 ($22)
    Foreground  |     10     |  Background #2 Color
                |            |  (register 35 ($23)
    Foreground  |     11     |  Color specified by 3 LSB
                |            |  of color nybble

  Since two bits are required to specify one dot color, the character is
  now displayed as a 4*8 matrix with each dot twice the horizontal size as
  in standard mode. Note, however, that each character region can now
  contain 4 different colors, two as foreground and two as background (see
  sprite priority)."
"In the context of the C64, can to blank the screen?","SCREEN BLANKING

    The display screen may be blanked by setting the DEN bit in register
  17 ($11) to a '0'. When the screen is blanked, the entire screen will be
  filled with the exterior color as set in register 32 ($20). When blanking
  is active, only transparent (Phase 1) memory accesses are required, per-
  mitting full processor utilization of the system bus. sprite data, however,
  will be accessed if the sprites are not also disabled. The DEN bit must be
  set to '1' for normal video display."
"In the context of the C64, Describe the EOR 6502 intstruction","EOR            EOR 'Exclusive-Or' memory with accumulator             EOR

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   EOR #Oper           |    49   |    2    |    2     |
  |  Zero Page     |   EOR Oper            |    45   |    2    |    3     |
  |  Zero Page,X   |   EOR Oper,X          |    55   |    2    |    4     |
  |  Absolute      |   EOR Oper            |    40   |    3    |    4     |
  |  Absolute,X    |   EOR Oper,X          |    50   |    3    |    4*    |
  |  Absolute,Y    |   EOR Oper,Y          |    59   |    3    |    4*    |
  |  (Indirect,X)  |   EOR (Oper,X)        |    41   |    2    |    6     |
  |  (Indirect),Y  |   EOR (Oper),Y        |    51   |    2    |    5*    |
  * Add 1 if page boundary is crossed."
"In the context of the C64, WDetail the BPL 6502 instruction","BPL                     BPL Branch on result plus                     BPL


 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
   Relative      |   BPL Oper            |    10   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
"In the context of the C64, What is the primary difference between multi-color bit map mode and standard (HI-RES) bit mapped mode?","MULTI-COLOR BET MAP MODE

    Like multi-color mode characters, multi-color bit map mode allows you
  to display up to four different colors in each 8 by 8 section of bit map.
  And as in multi-character mode, there is a sacrifice of horizontal
  resolution (from 320 dots to 160 dots).
    Multi-color bit map mode uses an 8K section of memory for the bit map.
  You select your colors for multi-color bit map mode from (1) the
  background color register 0, (the screen background color), (2) the video
  matrix (the upper 4 bits give one possible color, the lower 4 bits an-
  other), and (3) color memory.
    Multi-color bit mapped mode is turned ON by setting bit 5 of 53265
  ($D011) and bit 4 at location 53270 ($D016) to a 1. The following POKE
  does this:

    POKE 53265,PEEK(53625)OR 32: POKE 53270,PEEK(53270)OR 16
  
	Multi-color bit mapped mode is turned OFF by setting bit 5 of 53265
  ($D011) and bit 4 at location 53270 ($D016) to a 0. The following POKE
  does this:

    POKE 53265,PEEK(53265)AND 223: POKE 53270,PEEK(53270)AND 239

    As in standard (HI-RES) bit mapped mode, there is a one to one cor-
  respondence between the 8K section of memory being used for the display,
  and what is shown on the screen. However, the horizontal dots are two
  bits wide. Each 2 bits in the display memory area form a dot, which can
  have one of 4 colors."
"In the context of the C64, What should be done to minimize noise in the SID Vcc line?","VCC (Pin 25)

    As with the GND line, a separate +5 VDC line should be run between SID
  Vcc and the power supply in order to minimize noise. A bypass capacitor
  should be located close to the pin."
"In the context of the C64, Can you describe the filter register of the SID?","FILTER

  FC LO/FC HI (Registers $15,$16)

    Together these registers form an 11-bit number (bits 3-7 of FC LO are
  not used) which linearly controls the Cutoff (or Center) Frequency of the
  programmable Filter. The approximate Cutoff Frequency ranges from 30
  Hz to 12 KHz.

  RES/FILT (Register $17)

    Bits 4-7 of this register (RES0-RES3) control the resonance of the
  filter. Resonance is a peaking effect which emphasizes frequency com-
  ponents at the Cutoff Frequency of the Filter, causing a sharper sound.
  There are 16 resonance settings ranging linearly from no resonance (0) to
  maximum resonance (15 or $F). Bits 0-3 determine which signals will be
  routed through the Filter:
    FILT 1 (Bit 0): When set to a zero, Voice 1 appears directly at the
  audio output and the Filter has no effect on it. When set to a one, Voice
  1 will be processed through the Filter and the harmonic content of Voice
  1 will be altered according to the selected Filter parameters.
    FILT 2 (Bit 1): Same as bit 0 for Voice 2.
    FILT 3 (Bit 2): Same as bit 0 for Voice 3.
    FILTEX (Bit 3): Same as bit 0 for External audio input (pin 26)."
"In the context of the C64, What is the MODE/VOL (Register $18) register?","MODE/VOL (Register $18)

    Bits 4-7 of this register select various Filter mode and output
  options:
    LP (Bit 4): When set to a one, the Low-Pass output of the Filter is
  selected and sent to the audio output. For a given Filter input signal,
  all frequency components below the Filter Cutoff Frequency are passed
  unaltered, while all frequency components above the Cutoff are attenuated
  at a rate of 12 dB/Octave. The Low-Pass mode produces fullbodied sounds.
    BP (Bit 5): Same as bit 4 for the Bandpass output. All frequency
  components above and below the Cutoff are attenuated at a rate of 6
  dB/Octave. The Bandpass mode produces thin, open sounds.
    HP (Bit 6): Same as bit 4 for the High-Pass output. All frequency
  components above the Cutoff are passed unaltered, while all frequency
  components below the Cutoff are attenuated at a rate of 12 dB/Octave.
  The High-Pass mode produces tinny, buzzy sounds.
    3 OFF (Bit 7): When set to a one, the output of Voice 3 is disconnected
  from the direct audio path. Setting Voice 3 to bypass the Filter
  (FILT 3 = 0) and setting 3 OFF to a one prevents Voice 3 from reaching
  the audio output. This allows Voice 3 to be used for modulation purposes
  without any undesirable output.

  | NOTE: The Filter output modes ARE additive and multiple Filter modes  |
  | may be selected simultaneously. For example, both LP and HP modes can |
  | be selected to produce a Notch (or Band Reject) Filter response. In   |
  | order for the Filter to have any audible effect, at least one Filter  |
  | output must be selected and at least one Voice must be routed through |
  | the Filter. The Filter is, perhaps, the most important element in SID |
  | as it allows the generation of complex tone colors via subtractive    |
  | synthesis (the Filter is used to eliminate specific frequency         |
  | components from a harmonically rich input signal). The best results   |
  | are achieved by varying the Cutoff Frequency in real-time.            |


    Bits 0-3 (VOL0-VOL3) select 1 of 16 overall Volume levels for the final
  composite audio output. The output volume levels range from no output (0)
  to maximum volume (15 or $F) in 16 linear steps. This control can be used
  as a static volume control for balancing levels in multi-chip systems or
  for creating dynamic volume effects, such as Tremolo. Some Volume level
  other than zero must be selected in order for SID to produce any sound."
"In the context of the C64, What is the purpose of the EXT IN pin on the SID chip?","EXT IN (Pin 26)

    This analog input allows external audio signals to be mixed with the
  audio output of SID or processed through the Filter. Typical sources in-
  clude voice, guitar, and organ. The input impedance of this pin is on the
  order of 100 kohms. Any signal applied directly to the pin should ride at
  a DC level of 6 volts and should not exceed 3 volts p-p. In order to pre-

  vent any interference caused by DC level differences, external signals
  should be AC-coupled to EXT IN by an electrolytic capacitor in the 1-10
  uF range. As the direct audio path (FILTEX=0) has unity gain, EXT IN can
  be used to mix outputs of many SID chips by daisy-chaining. The number of
  chips that can be chained in this manner is determined by the amount of
  noise and distortion allowable at the final output. Note that the output
  Volume control will affect not only the three SID voices, but also any
  external inputs."
"In the context of the C64, How is the bit map mode works on C64?","There are two types of bit mapping available on the Commodore 64.
  They are:

    1) Standard (high-resolution) bit mapped mode (320-dot by 200-dot
       resolution)

    2) Multi-color bit mapped mode (160-dot by 200-dot resolution)

    Each is very similar to the character type it is named for: standard
  has greater resolution, but fewer color selections. On the other hand,
  multi-color bit mapping trades horizontal resolution for a greater number
  of colors in an 8-dot by 8-dot square.

  STANDARD HIGH-RESOLUTION BIT MAP MODE

    Standard bit map mode gives you a 320 horizontal dot by 200 vertical
  dot resolution, with a choice of 2 colors in each 8-dot by 8-dot section.
  Bit map mode is selected (turned ON) by setting bit 5 of the VIC-II
  control register to a 1 at location 53265 ($D011 in HEX). The following
  POKE will do this:

    POKE 53265,PEEK(53265)OR 32

    Bit map mode is turned OFF by setting bit 5 of the VIC-II control
  register to 0 at location 53265 ($D011), like this:

    POKE 53265,PEEK(53265)AND 223

    Before we get into the details of the bit map mode, there is one more
  issue to tackle, and that is where to locate the bit map area.

  HOW IT WORKS

    If you remember the PROGRAMMABLE CHARACTERS section you will recall
  that you were able to set the bit pattern of a character stored in RAM to
  almost anything you wanted. If at the same time you change the character
  that is displayed on the screen, you would be able to change a single
  dot, and watch it happen. This is the basis of bit-mapping. The entire
  screen is filled with programmable characters, and you make your changes
  directly into the memory that the programmable characters get their
  patterns from.
    Each of the locations in screen memory that were used to control what
  character was displayed, are now used for color information. For example,
  instead of POKEing a I in location 1024 to make an 'A' appear in the top
  left hand corner of the screen, location 1024 now controls the colors of
  the bits in that top left space.
    Colors of squares in bit map mode do not come from color memory, as
  they do in the character modes. Instead, colors are taken from screen
  memory. The upper 4 bits of screen memory become the color of any bit
  that is set to 1 in the 8 by 8 area controlled by that screen memory
  location. The lower 4 bits become the color of any bit that is set to
  a 0.

  EXAMPLE: Type the following:

  5 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
  10 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE

  Now RUN the program.
    Garbage appears on the screen, right? Just like the normal screen mode,
  you have to clear the HIGH-RESOLUTION (HI-RES) screen before you use it.
  Unfortunately, printing a CLR won't work in this case. Instead you have
  to clear out the section of memory that you're using for your
  programmable characters. Hit the <RUN/STOP> and <RESTORE> keys, then add
  the following lines to your program to clear the HI-RES screen:

  20 FORI=BASETOBASE+7999:POKEI,0:NEXT:REM CLEAR BIT
  30 FORI=1024TO2023:POKEI,3:NEXT:REM SET COLOR TO CYAN AND BLACK

    Now RUN the program again. You should see the screen clearing, then the
  greenish blue color, cyan, should cover the whole screen. What we want to
  do now is to turn the dots on and off on the HI-RES screen.

    To SET a dot (turn a dot ON) or UNSET a dot (turn a dot OFF) you must
  know how to find the correct bit in the character memory that you have to
  set to a 1. In other words, you have to find the character you need to
  change, the row of the character, and which bit of the row that you
  have to change. You need a formula to calculate this.
    We will use X and Y to stand for the horizontal and vertical positions
  of a dot, The dot where X=0 and Y=0 is at the upper-left of the display.
  Dots to the right have higher X values, and the dots toward the bottom
  have higher Y values."
"In the context of the C64, What feature of the VIC-II chip allows sprites to be expanded in size?","EXPANDED SPRITES

    The VIC-II chip has the ability to expand a sprite in the vertical
  direction, the horizontal direction, or both at once. When expanded, each
  dot in the sprite is twice as wide or twice as tall. Resolution doesn't
  actually increase... the sprite just gets bigger."
"In the context of the C64, What is the purpose of the BRK instruction in the context of 66502?","BRK                          BRK Force Break                          BRK

Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   BRK                 |    00   |    1    |    7     |
  1. A BRK command cannot be masked by setting I."
"In the context of the C64, What is the assembly language form of the INC instruction?","INC                    INC Increment memory by one                    INC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   INC Oper            |    E6   |    2    |    5     |
  |  Zero Page,X   |   INC Oper,X          |    F6   |    2    |    6     |
  |  Absolute      |   INC Oper            |    EE   |    3    |    6     |
  |  Absolute,X    |   INC Oper,X          |    FE   |    3    |    7     |"
"In the context of the C64, How are sprites in memory?","sprite MEMORY ACCESS

    The data for each sprite is Stored in 63 consecutive bytes of memory. Each
  block of sprite data is defined by a sprite pointer, located at the end of the
  VIDEO MATRIX. Only 1000 bytes of the video matrix are used in the normal
  display modes, allowing the video matrix locations 1016-1023 (VM base+
  $3F8 to VM base+$3FF) to be used for sprite pointers 0-7, respectively. The
  eight-bit sprite pointer from the video matrix together with the six bits
  from the sprite byte counter (to address 63 bytes) define the entire 14-bit
  address field:


     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
     MP7| MP6| MP5| MP4| MP3| MP2| MP1| MP0| MC5| MC4| MC3| MC2| MC1| MC0

  Where MPx are the sprite pointer bits from the video matrix and MCx are the
  internally generated sprite counter bits. The sprite pointers are read from the
  video matrix at the end of every raster line. When the Y position
  register of a sprite matches the current raster line count, the actual
  fetches of sprite data begin. Internal counters automatically step through
  the 63 bytes of sprite data, displaying three bytes on each raster line."
"In the context of the C64, What is the purpose of the 6566/6567 in the character display mode?","CHARACTER DISPLAY MODE

    In the character display mode, the 6566/6567 fetches CHARACTER POINTERs
  from the VIDEO MATRIX area of memory and translates the pointers to
  character dot location addresses in the 2048 byte CHARACTER BASE area of
  memory. The video matrix is comprised of 1000 consecutive locations in
  memory which each contain an eight-bit character pointer. The location of
  the video matrix within memory is defined by VM13-VM10 in register 24
  ($18) which are used as the 4 MSB of the video matrix address. The lower
  order 10 bits are provided by an internal counter (VC9-VC0) which steps
  through the 1000 character locations. Note that the 6566/6567 provides 14
  address outputs; therefore, additional system hardware may be required
  for complete system memory decodes.

                          CHARACTER POINTER ADDRESS

     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
  ------+----+----+----+----+----+----+----+----+----+----+----+----+------
    VM13|VM12|VM11|VM10| VC9| VC8| VC7| VC6| VC5| VC4| VC3| VC2| VC1| VC0


    The eight-bit character pointer permits up to 256 different character
  definitions to be available simultaneously. Each character is an 8*8 dot
  matrix stored in the character base as eight consecutive bytes. The loca-
  tion of the character base is defined by CB13-CB11 also in register 24
  ($18) which are used for the 3 most significant bits (MSB) of the char-
  acter base address. The 11 lower order addresses are formed by the 8-bit
  character pointer from the video matrix (D7-D0) which selects a
  particular character, and a 3-bit raster counter (RC2-RC0) which selects
  one of the eight character bytes. The resulting characters are formatted
  as 25 rows of 40 characters each. In addition to the 8-bit character
  pointer, a 4-bit COLOR NYBBLE is associated with each video matrix
  location (the video matrix memory must be 12 bits wide) which defines one
  of sixteen colors for each character.


                           CHARACTER DATA ADDRESS

     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
  ------+----+----+----+----+----+----+----+----+----+----+----+----+------
    CB13|CB12|CB11| D7 | D6 | D5 | D4 | D3 | D2 | D1 | D0 | RC2| RC1| RC0


  STANDARD CHARACTER MODE (MCM = BMM = ECM = 0)

    In the standard character mode, the 8 sequential bytes from the
  character base are displayed directly on the 8 lines in each character
  region. A '0' bit causes the background #0 color (from register 33 ($21))
  to be displayed while the color selected by the color nybble (foreground)
  is displayed for a '1' bit (see Color Code Table).

                | CHARACTER |
     FUNCTION   |    BIT    |               COLOR DISPLAYED
  --------------+-----------+----------------------------------------------
    Background  |     0     |  Background #0 color
                |           |  (register 33 ($21)
    Foreground  |     1     |  Color selected by 4-bit color nybble


    Therefore, each character has a unique color determined by the 4-bit
  color nybble (1 of 16) and all characters share the common background
  color."
"In the context of the C64, What are the non-zero page memory locations and their usage for the RS-232 system interface?","NONZERO-PAGE MEMORY LOCATIONS AND USAGE FOR
  RS-232 SYSTEM INTERFACE


    General RS-232 storage:

    $0293-M51CTR-Pseudo 6551 control register (see Figure 6-1).
    $0294-M51COR-Pseudo 6551 command register (see Figure 6-2) .
    $0295-M51AJB-Two bytes following the control and command registers in
          the file name field. These locations contain the baud rate for
          the start of the bit test during the interface activity, which,
          in turn, is used to calculate baud rate.
    $0297-RSSTAT-The RS-232 status register (see Figure 6-3).
    $0298-BITNUM-The number of bits to be sent/received.
    $0299-BAUDOF-Two bytes that are equal to the time of one bit cell.
          (Based on system clock/baud rate.)
    $029B-RIDBE-The byte index to the end of the receiver FIFO buffer.
    $029C-RIDBS-The byte index to the start of the receiver FIFO buffer.
    $029D-RODBS-The byte index to the start of the transmitter FIFO buffer.
    $029E-RODBE-The byte index to the end of the transmitter FIFO buffer.
    $02A1-ENABL-Holds current active interrupts in the CIA #2 ICR.
          When bit 4 is turned on means that the system is waiting for the
          Receiver Edge. When bit 1 is turned on then the system is
          receiving data. When bit 0 is turned on then the system is
          transmitting data."
"In the context of the C64, What is the primary function of the serial bus in the Commodore 64?","THE SERIAL BUS

    The serial bus is a daisy chain arrangement designed to let the Com-
  modore 64 communicate with devices such as the VIC-1541 DISK DRIVE and
  the VIC-1525 GRAPHICS PRINTER. The advantage of the serial bus is that
  more than one device can be connected to the port. Up to 5 devices can be
  connected to the serial bus at one time.
    There are three types of operation over a serial bus-CONTROL, TALK, and
  LISTEN. A CONTROLLER device is one which controls operation of the serial
  bus. A TALKER transmits data onto the bus. A LISTENER receives data from
  the bus.
    The Commodore 64 is the controller of the bus. It also acts as a TALKER
  (when sending data to the printer, for example) and as a LISTENER (when
  loading a program from the disk drive, for example). Other devices may be
  either LISTENERS (the printer), TALKERS, or both (the disk drive). Only
  the Commodore 64 can act as the controller.
    All devices connected on the serial bus will receive all the data
  transmitted over the bus. To allow the Commodore 64 to route data to its
  intended destination, each device has a bus ADDRESS. By using this device
  address, the Commodore 64 can control access to the bus. Addresses on the
  serial bus range from 4 to 31.
    The Commodore 64 can COMMAND a particular device to TALK or LISTEN.
  When the Commodore 64 commands a device to TALK, the device will begin
  putting data onto the serial bus. When the Commodore 64 commands a device
  to LISTEN, the device addressed will get ready to receive data (from the
  Commodore 64 or from another device on the bus). Only one device can TALK
  on the bus at a time; otherwise, the data will collide and the system
  will crash in confusion. However, any number of devices can LISTEN at the
  same time to one TALKER.

                         COMMON SERIAL BUS ADDRESSES
                    +--------+--------------------------+
                    | NUMBER |        DEVICE            |
                    +--------+--------------------------+
                    | 4 or 5 | VIC-1525 GRAPHIC PRINTER |
                    | 8      | VIC-1541 DISK DRIVE      |
                    +--------+--------------------------+

    Other device addresses are possible. Each device has its own address.
  Certain devices (like the Commodore 64 printer) provide a choice between
  two addresses for the convenience of the user.
    The SECONDARY ADDRESS is to let the Commodore 64 transmit setup
  information to a device. For example, to OPEN a connection on the bus to
  the printer, and have it print in UPPER/LOWER case, use the following

    OPEN 1,4,7

  where,
    1 is the logical file number (the number you PRINT# to),
    4 is the ADDRESS of the printer, and
    7 is the SECONDARY ADDRESS that tells the printer to go into UPPER/
      LOWER case mode.

    There are 6 lines used in serial bus operations - input and 3 output.
  The 3 input lines bring data, control, and timing signals into the Com-
  modore 64. The 3 output lines send data, control, and timing signals from
  the Commodore 64 to external devices on the serial bus.

  Serial I/O
                                                       ++ ++
  +-------+----------------------+                    / +-+ \
  |  Pin  |         Type         |                   /5     1\
  +-------+----------------------+                  +  O   O  +
  |   1   |  /SERIAL SRQ IN      |                  |    6    |
  |   2   |  GND                 |                  |    O    |
  |   3   |  SERIAL ATN OUT      |                  |         |
  |   4   |  SERIAL CLK IN/OUT   |                  +  O   O  +
  |   5   |  SERIAL DATA IN/OUT  |                   \4  O  2/
  |   6   |  /RESET              |                    \  3  /
  +-------+----------------------+                     +---+"
"In the context of the C64, Describe how sprite priority works","PRIORITY

    The priority of each sprite may be individually controlled with respect to
  the other displayed information from character or bit map modes. The
  priority of each sprite is set by the corresponding bit (MnDP) of register
  27 ($1B) as follows:

     REG BIT  |          PRIORITY TO CHARACTER OR BIT MAP DATA
        0     |  Non-transparent sprite data will be displayed (sprite in front)
        1     |  Non-transparent sprite data will be displayed only instead of
              |  Bkgd #0 or multi-color bit pair 01 (sprite behind)


                          sprite-DISPLAY DATA PRIORITY
                       |   MnDP = 1   |   MnDP = 0   |
                       |  spriten     |  Foreground  |
                       |  Foreground  |  spriten     |
                       |  Background  |  Background  |


  sprite data bits of '0' ('00' in multi-color mode) are transparent, always
  permitting any other information to be displayed.
    The sprites have a fixed priority with respect to each other, with sprite 0
  having the highest priority and sprite 7 the lowest. When sprite data (except
  transparent data) of two sprites are coincident, the data from the lower
  number sprite will be displayed. sprite vs. sprite data is prioritized before
  priority resolution with character or bit map data."
"In the context of the C64, What is the purpose of the instruction BNE"" in the given 6502 ASM language code?""","BNE                   BNE Branch on result not zero                   BNE


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles
 Relative      |   BMI Oper            |    D0   |    2    |    2*    
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
"In the context of the C64, What is the assembly language instruction that decrements the index register Y by one?","DEY                   DEY Decrement index Y by one                    DEY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   DEY                 |    88   |    1    |    2     |"
"In the context of the C64, What is the command that turns off extended color mode in the VIC-II register?","Extended color mode is turned OFF by setting bit 6 of the VIC-II regis-ter to a 0 at location 53265 ($D011). The following statement will do this:
    POKE 53265,PEEK(53265)AND 191"
"In the context of the C64, Give the caracteristics of the sprite multi color mode","SPRITE  MULTI-COLOR MODE

    Multi-color mode allows you to have up to 4 different colors in each
  sprite. However, just like other multi-color modes, horizontal resolution
  is cut in half. In other words, when you're working with sprite multi-
  color mode (like in multi-color character mode), instead of 24 dots
  across the sprite, there are 12 pairs of dots. Each pair of dots is
  called a BIT PAIR. Think of each bit pair (pair of dots) as a single dot
  in your overall sprite when it comes to choosing colors for the dots in
  your sprites. The table below gives you the bit pair values needed to
  turn ON each of the four colors you've chosen for your sprite:

    BIT PAIR                           DESCRIPTION
      00        TRANSPARENT, SCREEN COLOR
      01        SPRITE MULTI-COLOR REGISTER #0 (53285) ($D025)
      10        SPRITE COLOR REGISTER
      11        SPRITE MULTI-COLOR REGISTER #I (53286) ($D026)
 
  NOTE: The sprite foreground color is a 10. The character foreground   
   is a 11."
"In the context of the C64, What is the purpose of the POTY sid register?","POTY (Register $1A)

    Same as POTX for the pot tied to POTY (pin 23)."
"In the context of the C64, What is the recommended resistance for the source resistor from the AUDIO OUT to ground for proper operation?","AUDIO OUT (Pin 27)

    This open-source buffer is the final audio output of SID, comprised of
  the three SID voices, the Filter and any external input. The output level
  is set by the output Volume control and reaches a maximum of 2 volts p-p
  at a DC level of 6 volts. A source resistor from AUDIO OUT to ground is
  required for proper operation. The recommended resistance is 1 kohm for
  a standard output impedance.
    As the output of SID rides at a 6-volt DC level, it should be AC-
  coupled to any audio amplifier with an electrolytic capacitor in the 1-10
  uF range.

  VDD (Pin 28)

    As with Vcc, a separate +12 VDC line should be run to SID VDD and a
  bypass capacitor should be used.


  6581 SID CHARACTERISTICS


  ABSOLUTE MAXIMUM RATINGS

  |          RATING          |   SYMBOL   |      VALUE      |    UNITS    |
  |  Supply Voltage          |    VDD     |   -0.3 to +17   |     VDC     |
  |  Supply Voltage          |    VCC     |   -0.3 to +7    |     VDC     |
  |  Input Voltage (analog)  |    Vina    |   -0.3 to +17   |     VDC     |
  |  Input Voltage (digital) |    Vind    |   -0.3 to +7    |     VDC     |
  |  Operating Temperature   |    Ta      |      0 to +70   |   Celsius   |
  |  Storage Temperature     |    Tstg    |   -55 to +150   |   Celsius   |
  +--------------------------+------------+-----------------+-------------+"
"In the context of the C64, What is the purpose of the POTX register in the SID?","POTX (Register $19)

    This register allows the microprocessor to read the position of the
  potentiometer tied to POTX (pin 24), with values ranging from 0 at
  minimum resistance, to 255 ($FF) at maximum resistance. The value is
  always valid and is updated every 512 (02 clock cycles. See the Pin
  Description section for information on pot and capacitor values."
"In the context of the C64, how do I set multi color mode on a sprite?","SETTING A SPRITE TO MULTI-COLOR MODE

    To switch a sprite into multi-color mode you must turn ON the VIC-II
  control register at location 53276 ($D01C). The following POKE does this:

    POKE 53276,PEEK(53276)OR(2^SN)

  where SN is the sprite number (0 to 7).
    To switch a sprite out of multi-color mode you must turn OFF the VIC-II
  control register at location 53276 ($D01C). The following POKE does this:

    POKE 53276,PEEK(53276)AND(255-2^SN)

  where SN is the sprite number (0 to 7)."
"In the context of the C64, What is the primary method used to achieve high-resolution displays on the Commodore 64?","BIT MAPPED GRAPHICS

When writing games, plotting charts for business applications, or other types of programs, sooner or later you get to the point where you want
high-resolution displays.

The Commodore 64 has been designed to do just that: high resolution is available through bit mapping of the screen. Bit mapping is the method in which each possible dot (pixel) of resolution on the screen is assigned its own bit (location) in memory. If that memory bit is a one, the dot it is assigned to is on. If the bit is set to zero, the dot is off.
  
High-resolution graphic design has a couple of drawbacks, which is why it is not used all the time. First of all, it takes lots of memory to bit map the entire screen. This is because every pixel must have a memory bit to control it. You are going to need one bit of memory for each pixel (or one byte for 8 pixels). Since each character is 8 by 8, and there are 40 lines with 25 characters in each line, the resolution is 320 pixels (dots) by 200 pixels for the whole screen. That gives you 64000 separate dots, each of which requires a bit in memory. In other words, 8000 bytes of memory are needed to map the whole screen.

Generally, high-resolution operations are made of many short, simple, repetitive routines. Unfortunately, this kind of thing is usually rather slow if you are trying to write high-resolution routines in BASIC. How-ever, short, simple, repetitive routines are exactly what machine language does best. The solution is to either write your programs entirely in machine language, or call machine language, high-resolution sub-xroutines from your BASIC program using the SYS command from BASIC. That way you get both the ease of writing in BASIC, and the speed of machine language for graphics. The VSP cartridge is also available to add high-resolution commands to COMMODORE 64 BASIC.
  
All of the examples given in this section will be in BASIC to make themclear. Now to the technical details."
"In the context of the C64, What is the purpose of the JSR instruction in the C64 machine language program?","SUBROUTINES

    In machine language (in the same way as using BASIC), you can call
  subroutines. The instruction to call a subroutine is JSR (Jump to Sub-
  Routine), followed by the specified absolute address.
    Incorporated in the operating system, there is a machine language
  subroutine that will PRINT a character to the screen. The CBM ASCII code
  of the character should be in the accumulator before calling the
  subroutine. The address of this subroutine is $FFD2.
    Therefore, to print 'Hi' to the screen, the following program should be
  entered:

    .A 1400 LDA #$48     - load the CBM ASCII code of 'H'
    .A 1402 JSR $FFD2    -  print it
    .A 1405 LDA #$49     - load the CBM ASCII code of 'I'
    .A 1407 JSR $FFD2    -  print that too
    .A 140A LDA #$0D     - print a carriage return as well
    .A 140C JSR $FFD2
    .A 140F BRK          - return to 64MON
    .G 1400              - will print 'HI' and return to 64MON"
"In the context of the C64, What is the assembly language instruction that decrements the value stored in X?","DEX                   DEX Decrement index X by one                    DEX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   DEX                 |    CA   |    1    |    2     |"
"In the context of the C64, WDescribe the caracteristics of BMI 6502 instruction?","BMI                    BMI Branch on result minus                     BMI


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles
 Relative      |   BMI Oper            |    30   |    2    |    2*    
  * Add 1 if branch occurs to same page.
  * Add 1 if branch occurs to different page."
"In the context of the C64, What are the primary functions and capabilities of the 6566/6567 devices?","The 6566/6567 are multi-purpose color video controller devices for use
  in both computer video terminals and video game applications. Both
  devices contain 47 control registers which are accessed via a standard
  8-bit microprocessor bus (65XX) and will access up to 16K of memory for
  display information. The various operating modes and options within each
  mode are described."
"In the context of the C64, What is the purpose of the COLLISION DETECTION system in a sprite-based graphics system?","COLLISION DETECTION


    Two types of sprite collision (coincidence) are detected, sprite to sprite
  collision and sprite to display data collision:


    1) A collision between two sprites occurs when non-transparent output data
       of two sprites are coincident. Coincidence of sprite transparent areas
       will not generate a collision. When a collision occurs, the sprite bits
       (MnM) in the sprite-sprite COLLISION register 30 ($1E) will be set to '1'
       for both colliding spriteS. As a collision between two (or more) sprites
       occurs, the sprite-sprite collision bit for each collided sprite will be set.
       The collision bits remain set until a read of the collision
       register, when all bits are automatically cleared. sprites collisions
       are detected even if positioned off-screen.
    2) The second type of collision is a sprite-DATA collision between a sprite
       and foreground display data from the character or bit map modes. The
       sprite-DATA COLLISION register 31 ($1F) has a 'bit (MnD) for each sprite
       which is set to '1' when both the sprite and non-background display
       data are coincident. Again, the coincidence of only transparent data
       does not generate a collision. For special applications, the display
       data from the 0-1 multicolor bit pair also does not cause a
       collision. This feature permits their use as background display data
       without interfering with true sprite collisions. A sprite-DATA collision
       can occur off-screen in the horizontal direction if actual display
       data has been scrolled to an off-screen position (see scrolling).
       The sprite-DATA COLLISION register also automatically clears when read.
    The collision interrupt latches are set whenever the first bit of
   either register is set to '1'. Once any collision bit within a register
   is set high, subsequent collisions will not set the interrupt latch
   until that collision register has been cleared to all '0s' by a read."
"In the context of the C64, What are the ASCII and CHR$ codes?","ASCII AND CHR$ CODES

    This appendix shows you what characters will appear if you PRINT
  CHR$(X), for all possible values of X. It will also show the values ob-
  tained by typing PRINT ASC('x'), where x is any character you can type.
  This is useful in evaluating the character received in a GET statement,
  converting upper/lower case, and printing character based commands (like
  switch to upper/lower case) that could not be enclosed in quotes.


  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |
  |             0   |  {down}    17   |    '       34   |    3       51   |
  |             1   | {rvs on}   18   |    #       35   |    4       52   |
  |             2   |  {home}    19   |    $       36   |    5       53   |
  |             3   |  {del}     20   |    %       37   |    6       54   |
  |             4   |            21   |    &       38   |    7       55   |
  | {white}     5   |            22   |    '       39   |    8       56   |
  |             6   |            23   |    (       40   |    9       57   |
  |             7   |            24   |    )       41   |    :       58   |
  | disSHIFT+C= 8   |            25   |    *       42   |    ;       59   |
  | enaSHIFT+C= 9   |            26   |    +       43   |    <       60   |
  |            10   |            27   |    ,       44   |    =       61   |
  |            11   |  {red}     28   |    -       45   |    >       62   |
  |            12   | {right}    29   |    .       46   |    ?       63   |
  | return     13   | {green}    30   |    /       47   |    @       64   |
  | lower case 14   |  {blue}    31   |    0       48   |    A       65   |
  |            15   |  SPACE     32   |    1       49   |    B       66   |
  |            16   |    !       33   |    2       50   |    C       67   |
  |    D       68   |            97   |           126   | {grey 3}  155   |
  |    E       69   |            98   |           127   | {purple}  156   |
  |    F       70   |            99   |           128   | {left}    157   |
  |    G       71   |           100   | {orange}  129   | {yellow}  158   |
  |    H       72   |           101   |           130   |  {cyan}   159   |
  |    I       73   |           102   |           131   |  SPACE    160   |
  |    J       74   |           103   |           132   |           161   |
  |    K       75   |           104   |    f1     133   |           162   |
  |    L       76   |           105   |    f3     134   |           163   |
  |    M       77   |           106   |    f5     135   |           164   |
  |    N       78   |           107   |    f7     136   |           165   |
  |    O       79   |           108   |    f2     137   |           166   |
  |    P       80   |           109   |    f4     138   |           167   |
  |    Q       81   |           110   |    f6     139   |           168   |
  |    R       82   |           111   |    f8     140   |           169   |
  |    S       83   |           112   |shift+ret. 141   |           170   |
  |    T       84   |           113   |upper case 142   |           171   |
  |    U       85   |           114   |           143   |           172   |
  |    V       86   |           115   | {black}   144   |           173   |
  |    W       87   |           116   |   {up}    145   |           174   |
  |    X       88   |           117   | {rvs off} 146   |           175   |
  |    Y       89   |           118   | {clear}   147   |           176   |
  |    Z       90   |           119   |  {inst}   148   |           177   |
  |    [       91   |           120   | {brown}   149   |           178   |
  |  pound     92   |           121   | {lt. red} 150   |           179   |
  |    ]       93   |           122   | {grey 1}  151   |           180   |
  |    ^       94   |           123   | {grey 2}  152   |           181   |
  |{arrow left}95   |           124   | {lt.green}153   |           182   |
  |            96   |           125   | {lt.blue} 154   |           183   |
  |           184   |           186   |           188   |           190   |
  |           185   |           187   |           189   |           191   |


  CODES 192-223 SAME AS  96-127
  CODES 224-254 SAME AS 160-190
  CODE 255 SAME AS 126"
"In the context of the C64, Describe how to position a sprite","SPRITE POSlTlON

    Each sprite is positioned via its X and Y position register (see register
  map) with a resolution of 512 horizontal and 256 vertical positions. The
 position of a sprite is determined by the upper-left corner of the array. X
  locations 23 to 347 ($17-$157) and Y locations 50 to 249 ($32-$F9) are
  visible. Since not all available sprite positions are entirely visible on
  the screen, sprites may be moved smoothly on and off the display screen."
"In the context of the C64, What are the key characteristics of the bit map mode in the 6566/6567?","BIT MAP MODE

    In bit map mode, the 6566/6567 fetches data from memory in a different
  fashion, so that a one-to-one correspondence exists between each
  displayed dot and a memory bit. The bit map mode provides a screen
  resolution of 320H * 200V individually controlled display dots. Bit map
  mode is selected by setting the BMM bit in register 17 ($11) to a '1'.
  The VIDEO MATRIX is still accessed as in character mode, but the video
  matrix data is no longer interpreted as character pointers, but rather as
  color data. The VIDEO MATRIX COUNTER is then also used as an address to
  fetch the dot data for display from the 8000-byte DISPLAY BASE. The
  display base address is formed as follows:


     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
    CB13| VC9| VC8| VC7| VC6| VC5| VC4| VC3| VC2| VC1| VC0| RC2| RC1| RC0"
"In the context of the C64, What is the purpose of the BEQ"" instruction in the C64 assembly language code?""","BEQ                    BEQ Branch on result zero                      BEQ

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles
  Relative      |   BEQ Oper            |    F0   |    2    |    2*    
  * Add 1 if branch occurs to same  page.
  * Add 2 if branch occurs to next  page."
"In the context of the C64, What is the purpose of the Add 1"" and ""Add 2"" notes in the table?""","BVC                   BVC Branch on overflow clear                    BVC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Relative      |   BVC Oper            |    50   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
"In the context of the C64, What are the CMP 6502 instruction details?","CMP                CMP Compare memory and accumulator                 CMP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   CMP #Oper           |    C9   |    2    |    2     |
  |  Zero Page     |   CMP Oper            |    C5   |    2    |    3     |
  |  Zero Page,X   |   CMP Oper,X          |    D5   |    2    |    4     |
  |  Absolute      |   CMP Oper            |    CD   |    3    |    4     |
  |  Absolute,X    |   CMP Oper,X          |    DD   |    3    |    4*    |
  |  Absolute,Y    |   CMP Oper,Y          |    D9   |    3    |    4*    |
  |  (Indirect,X)  |   CMP (Oper,X)        |    C1   |    2    |    6     |
  |  (Indirect),Y  |   CMP (Oper),Y        |    D1   |    2    |    5*    |
  * Add 1 if page boundary is crossed."
"In the context of the C64, how do I turn a sprite On ?","TURNING SPRITES ON

    The VIC-II control register at location 53269 ($D015 in HEX) is known
  as the SPRITE ENABLE register. Each of the sprites has a bit in this
  register which controls whether that sprite is ON or OFF. The register
  looks like this:

                     $D015  7 6 5 4 3 2 1 0

    To turn on sprite 1, for example, it is necessary to turn that bit to
  a 1. The following POKE does this:

    POKE 53269.PEEK(53269)OR 2

  A more general statement would be the following:

    POKE 53269,PEEK(53269)OR (2^SN)

  where SN is the sprite number, from 0 to 7.

   NOTE: A sprite must be turned ON before it can be seen."
"In the context of the C64, What is the command that turns on the Extended color mode in the VIC-II register?","Extended color mode is turned ON by setting bit 6 of the VIC-II regis-ter to a 1 at location 53265 ($D011 in HEX). The following POKE does it:

    POKE 53265,PEEK(53265)OR 64"
"In the context of the C64, What are the primary functions of the D0-D7 pins in the SID and microprocessor?","D0-D7 (Pins 15-22)

    These bidirectional lines are used to transfer data between SID and the
  microprocessor. They are TTL compatible in the input mode and capable of
  driving 2 TTL loads in the output mode. The data buffers are usually in
  the high-impedance off state. During a Write operation, the data buffers
  remain in the off (input) state and the microprocessor supplies data to
  SID over these lines. During a Read operation, the data buffers turn on
  and SID supplies data to the microprocessor over these lines. The pins
  are normally connected to the corresponding data lines of the micro-
  processor.

  POTX,POTY (Pins 24,23)

    These pins are inputs to the A/D converters used to digitize the posi-
  tion of potentiometers. The conversion process is based on the time con-
  stant of a capacitor tied from the POT pin to ground, charged by a
  potentiometer tied from the POT pin to +5 volts. The component values are
  determined by:

                                RC = 4.7E-4

  Where R is the maximum resistance of the pot and C is the capacitor.
    The larger the capacitor, the smaller the POT value jitter. The recom-
  mended values for R and C are 470 komhs and 1000 pF. Note that a separate
  pot and cap are required for each POT pin."
"In the context of the C64, What is the primary limitation of using extended background color mode in terms of character display?","EXTENDED BACKGROUND COLOR MODE

Extended background color mode gives you control over the background color of each individual character, as well as over the foreground color.
For example, in this mode you could display a blue character with ayellow background on a white screen.
There are 4 registers available for extended background color mode.
Each of the registers can be set to any of the 16 colors.
Color memory is used to hold the foreground color in extended back-ground mode. It is used the same as in standard character mode.
Extended character mode places a limit on the number of different characters you can display, however. When extended color mode is on, only the first 64 characters in the character ROM (or the first 64 characters in your programmable character set) can be used. This is because two of the bits of the character code are used to select the background color.
It might work something like this:

The character code (the number you would POKE to the screen) of the letter 'A' is a 1. When extended color mode is on, if you POKED a 1 to the screen, an 'A' would appear. If you POKED a 65 to the screen normally, you would expect the character with character code (CHR$) 129 to appear, which is a reversed 'A.' This does NOT happen in extended color mode. Instead you get the same unreversed 'A' as before, but on a different background color."
"In the context of the C64, What is the formula for calculating the start of the 64 bytes of the sprite definition block?","If sprite pointer #0, at location 2040, contains the number 14, for
  example, this means that sprite 0 will be displayed using the 64 bytes
  beginning at location 14*64 = 896 which is in the cassette buffer. The
  following formula makes this clear:

    LOCATION = (BANK * 16384) + (SPRITE POINTER VALUE * 64)

  Where BANK is the 16K segment of memory that the VIC-II chip is looking
  at and is from 0 to 3.
    The above formula gives the start of the 64 bytes of the sprite
  definition block.
    When the VIC-II chip is looking at BANK 0 or BANK 2, there is a ROM
  IMAGE of the character set present in certain locations, as mentioned
  before. Sprite definitions can NOT be placed there. If for some reason
  you need more than 128 different sprite definitions, you should use one
  of the banks without the ROM IMAGE, 1 or 3."
"In the context of the C64, how can I create a smooth scrolling with the VIC-II chip on C64?","SMOOTH SCROLLING

    The VIC-II chip supports smooth scrolling in both the horizontal and
  vertical directions. Smooth scrolling is a one pixel movement of the
  entire screen in one direction. It can move either UP, or down, or left,
  or right. It is used to move new information smoothly onto the screen,
  while smoothly removing characters from the other side.
    While the VIC-II chip does much of the task for you, the actual scroll-
  ing must be done by a machine language program. The VIC-II chip features
  the ability to place the video screen in any of 8 horizontal positions,
  and 8 vertical positions. Positioning is controlled by the VIC-II
  scrolling registers. The VIC-II chip also has a 38 column mode, and a 24
  row mode. the smaller screen sizes are used to give you a place for your
  new data to scroll on from.

  The following are the steps for SMOOTH SCROLLING:
  1) Shrink the screen (the border will expand).
  2) Set the scrolling register to maximum (or minimum value depending upon
     the direction of your scroll).
  3) Place the new data on the proper (covered) portion of the screen.
  4) Increment (or decrement) the scrolling register until it reaches the
     maximum (or minimum) value.
  5) At this point, use your machine language routine to shift the entire
     screen one entire character in the direction of the scroll.
  6) Go back to step 2.

    To go into 38 column mode, bit 3 of location 53270 ($D016) must be set
  to a 0. The following POKE does this:

    POKE 53270,PEEK(53270)AND 247

    To return to 40 column mode, set bit 3 of location 53270 ($D016) to a
  1.The following POKE does this:

    POKE 53270,PEEK(53270)OR 8

    To go into 24 row mode, bit 3 of location 53265 ($D011) must be set to
  a 0. The following POKE will do this:

    POKE 53265,PEEK(53265)AND 247

    To return to 25 row mode, set bit 3 of location 53265 ($D011) to a 1.
  The following POKE does this:

    POKE 53265,PEEK(53265)OR 8

    When scrolling in the X direction, it is necessary to place the VIC-II
  chip into 38 column mode. This gives new data a place to scroll from.
  When scrolling LEFT, the new data should be placed on the right. When
  scrolling RIGHT the new data should be placed on the left. Please note
  that there are still 40 columns to screen memory, but only 38 are
  visible.
    When scrolling in the Y direction, it is necessary to place the VIC-II
  chip into 24 row mode. When scrolling UP, place the new data in the LAST
  row. When scrolling DOWN, place the new data on the FIRST row. Unlike X
  scrolling, where there are covered areas on each side of the screen,
  there is only one covered area in Y scrolling. When the Y scrolling
  register is set to 0, the first line is covered, ready for new data. When
  the Y scrolling register is set to 7 the last row is covered.
    For scrolling in the X direction, the scroll register is located in
  bits 2 to 0 of the VIC-II control register at location 53270 ($D016 in
  HEX). As always, it is important to affect only those bits. The following
  POKE does this:

    POKE 53270,(PEEK(53270)AND 248)+X

  where X is the X position of the screen from 0 to 7.
    For scrolling in the Y direction, the scroll register is located in
  bits 2 to 0 of the VIC-II control register at location 53265 ($D011 in
  HEX). As always, it is important to affect only those bits. The following
  POKE does this:

    POKE 53265,(PEEK(53265)AND 248)+Y

  where Y is the Y position of the screen from 0 to 7.
    To scroll text onto the screen from the bottom, you would step the low-
  order 3 bits of location 53265 from 0-7, put more data on the covered
  line at the bottom of the screen, and then repeat the process. To scroll
  characters onto the screen from left to right, you would step the low-
  order 3 bits of location 53270 from 0 to 7, print or POKE another column
  of new data into column 0 of the screen, then repeat the process.
    If you step the scroll bits by -1, your text will move in the opposite
  direction."
"In the context of the C64, What are the details of the CPX 6502 instruction ?","CPX                  CPX Compare Memory and Index X                   CPX
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   CPX *Oper           |    E0   |    2    |    2     |
  |  Zero Page     |   CPX Oper            |    E4   |    2    |    3     |
  |  Absolute      |   CPX Oper            |    EC   |    3    |    4     |"
"In the context of the C64, What is the purpose of the BVS instruction in the 6502 assembly language?","BVS                    BVS Branch on overflow set                     BVS


 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Relative      |   BVS Oper            |    70   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
"In the context of the C64, What is the purpose of the BIT instruction in the 6510 assembly language code?","BIT             BIT Test bits in memory with accumulator              BIT

  Bit 6 and 7 are transferred to the status register.   N Z C I D V
  If the result of A /\ M is zero then Z = 1, otherwise M7/ _ _ _ M6
  Z = 0

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Zero Page     |   BIT Oper            |    24   |    2    |    3     |
  Absolute      |   BIT Oper            |    2C   |    3    |    4     |"
"In the context of the C64, What is the extended color mode?","EXTENDED COLOR MODE (ECM = 1, Bmm = MCM = 0)

    The extended color mode allows the selection of individual, background
  colors for each character region with the normal 8*8 character
  resolution. This mode is selected by setting the ECM bit of register 17
  ($11) to '1'. The character dot data is displayed as in the standard mode
  (foreground color determined by the color nybble is displayed for a '1'

  data bit), but the 2 MSB of the character pointer are used to select the
  background color for each character region as follows:


       CHAR. POINTER  |
        MS BIT PAIR   |       BACKGROUND COLOR DISPLAYED FOR 0 BIT
  --------------------+----------------------------------------------------
           00         |  Background #0 color (register 33 ($21))
           01         |  Background #l color (register 34 ($22))
           10         |  Background #2 color (register 35 ($23))
           11         |  Background #3 color (register 36 ($24))

  Since the two MSB of the character pointers are used for color informa-
  tion, only 64 different character definitions are available. The 6566/
  6567 will force CB10 and CB9 to '0' regardless of the original pointer
  values, so that only the first 64 character definitions will be accessed.
  With extended color mode each character has one of sixteen individually
  defined foreground colors and one of the four available background
  colors.

  +-----------------------------------------------------------------------+
  | NOTE: Extended color mode and multi-color mode should not be enabled  |
  | simultaneously.                                                       |
  +-----------------------------------------------------------------------+"
"In the context of the C64, Describe how to enable sprite?","SPRITE  ENABLE

    Each sprite can be selectively enabled for display by setting its corre-
  sponding enable bit (MnE) to '1' in register 21 ($15). If the MnE bit is
  '0,' no sprite operations will occur involving the disabled sprite."
"In the context of the C64, What is the purpose of the Commodore CP/M cartridge?","Z-80 MICROPROCESSOR CARTRIDGE

  Peripherals are things like Datassette(TM) recorders, disk
  drives, printers, and modems. All these items can be added to your
  Commodore 64 through the various ports and sockets on the back of your
  machine. The thing that makes Commodore peripherals so good is the fact
  that our peripherals are 'intelligent.' That means that they don't take
  up valuable Random Access Memory space when they're in use. You're free
  to use all 64K of memory in your Commodore 64.
    Another advantage of your Commodore 64 is the fact most programs you
  write on your Commodore 64 today will be upwardly compatible with any new
  Commodore computer you buy in the future. This is partially because of
  the qualities of the computer's Operating System (OS).
    However, there is one thing that the Commodore OS can't do: make your
  programs compatible with a computer made by another company.
    Most of the time you won't even have to think about using another com-
  pany's computer, because your Commodore 64 is so easy to use. But for the
  occasional user who wants to take advantage of software that may not be
  available in Commodore 64 format we have created a Commodore CP/M(R)
  cartridge.
    CP/M(R) is not a 'computer dependent' operating system. Instead it uses
  some of the memory space normally available for programming to run its
  own operating system. There are advantages and disadvantages to this. The
  disadvantages are that the programs you write will have to be shorter
  than the programs you can write using the Commodore 64's built-in
  operating system. In addition, you can NOT use the Commodore 64's
  powerful screen editing capabilities. The advantages are that you can now
  use a large amount of software that has been specifically designed for
  CP/M(R) and the Z-80 microprocessor, and the programs that you write
  using the CP/M(R) operating system can be transported and run on any
  other computer that has CP/M(R) and a Z-80 card.
    By the way, most computers that have a Z-80 microprocessor require that
  you go inside the computer to actually install a Z-80 card. With this
  method you have to be very careful not to disturb the delicate circuitry
  that runs the rest of the computer. The Commodore CP/M& cartridge
  eliminates this hassle because our Z-80 cartridge plugs into the back of
  your Commodore 64 quickly and easily, without any messy wires that can
  cause problems later."
"In the context of the C64, What is the function of the START bit in the 6256 CRA control register?","6256 CONTROL REGISTERS

    There are two control registers in the 6526, CRA and CRB. CRA is
  associated with TIMER A and CRB is associated with TIMER B. The register
  format is as follows:

  CRA:
  Bit  Name    Function
   0  START    1=START TIMER A, 0=STOP TIMER A. This bit is automatically
               reset when underflow occurs during one-shot mode.
   1  PBON     1=TIMER A output appears on PB6, 0=PB6 normal operation.

   2  OUTMODE  1=TOGGLE, 0=PULSE
   3  RUNMODE  1=ONE-SHOT, 0=CONTINUOUS
   4  LOAD     1=FORCE LOAD (this is a STROBE input, there is no data
               storage, bit 4 will always read back a zero and writing a
               zero has no effect).
   5  INMODE   1=TIMER A counts positive CNT transitions, 0=TIMER A counts
               02 pulses.
   6  SPMODE   1=SERIAL PORT output (CNT sources shift clock),
               0=SERIAL PORT input (external shift clock required).
   7  TODIN    1=50 Hz clock required on TOD pin for accurate time,
               0=60 Hz clock required on TOD pin for accurate time.
  CRB:
  Bit  Name    Function
               (Bits CRB0-CRB4 are identical to CRA0-CRA4 for TIMER B with
               the exception that bit 1 controls the output of TIMER B on
               PB7).
  5,6 INMODE   Bits CRB5 and CRB6 select one of four input modes for
               TIMER B as:
               CRB6   CRB5
                0      0       TIMER B counts 02 pulses.
                0      1       TIMER B counts positive CNT transistions.
                1      0       TIMER B counts TIMER A underflow pulses.
                1      1       TIMER B counts TIMER A underflow pulses
                               while CNT is high.
  7   ALARM     1=writing to TOD registers sets ALARM, 0=writing to TOD
                registers sets TOD clock.

  

  All unused register bits are unaffected by a write and are forced to zero
  on a read.
  +-----------------------------------------------------------------------+
  | COMMODORE SEMICONDUCTOR GROUP reserves the right to make changes to   |
  | any products herein to improve reliability, function or design.       |
  | COMMODORE SEMICONDUCTOR GROUP does not assume any liability arising   |
  | out of the application or use of any product or circuit described     |
  | herein; neither does it convey any license under its patent rights nor|
  | the rights of others.                                                 |
  +-----------------------------------------------------------------------+"
"In the context of the C64, What is the purpose of the SERIAL ATN OUT signal in the Commodore 64?","SERIAL ATN OUT: (SERIAL ATTENTION OUT)

    The Commodore 64 uses this signal to start a command sequence for a
  device on the serial bus. When the Commodore 64 brings this signal LOW,
  all other devices on the bus start listening for the Commodore 64 to
  transmit an address. The device addressed must respond in a preset period
  of time; otherwise, the Commodore 64 will assume that the device
  addressed is not on the bus, and will return an error in the STATUS WORD."
"In the context of the C64, What are the screen display codes?","SCREEN DISPLAY CODES

    The following chart lists all of the characters built into the
  Commodore 64 character sets. It shows which numbers should be POKED into
  screen memory (locations 1024-2023) to get a desired character. Also
  shown is which character corresponds to a number PEEKed from the screen.
    Two character sets are available, but only one set at a time. This
  means that you cannot have characters from one set on the screen at the
  same time you have characters from the other set displayed. The sets are
  switched by holding down the <SHIFT> and <C=> keys simultaneously.
    From BASIC, POKE 53272,21 will switch to upper case mode and
  POKE 53272,23 switches to lower case.
    Any number on the chart may also be displayed in REVERSE. The reverse
  character code may be obtained by adding 128 to the values shown.
    If you want to display a solid circle at location 1504, POKE the code
  for the circle (81) into location 1504: POKE 1504,81.
    There is a corresponding memory location to control the color of each
  character displayed on the screen (locations 55296-56295). To change the
  color of the circle to yellow (color code 7) you would POKE the corre-
  sponding memory location (55776) with the character color: POKE 55776,7.
    Refer to Appendix D for the complete screen and color memory maps,
  along with color codes.

  | NOTE: The following POKEs display the same symbol in set 1 and 2: 1,  |
  | 27-64, 91-93, 96-104, 106-121, 123-127.                               |"
"In the context of the C64, What is the purpose of the video matrix counter?","VCx denotes the video matrix counter outputs, RCx denotes the 3-bit
  raster line counter and CB13 is from register 24 ($18). The video matrix
  counter steps through the same 40 locations for eight raster lines, con-
  tinuing to the next 40 locations every eighth line, while the raster
  counter increments once for each horizontal video line (raster line).
  This addressing results in each eight sequential memory locations being
  formatted as an 8*8 dot block on the video display."
"In the context of the C64, Describe how color works for sprites","COLOR

    Each sprite has a separate 4-bit register to determine the sprite color. The
  two sprite color modes are:

  STANDARD sprite (MnMC = 0)

    In the standard mode, a '0' bit of sprite data allows any background data
  to show through (transparent) and a '1' bit is displayed as the sprite color
  determined by the corresponding sprite Color register.

  MULTI-COLOR sprite (MnMC = 1)

    Each sprite can be individually selected as a multi-color sprite via MnMC
  bits in the sprite Multi-color register 28 ($1C). When the MnMC bit is '1',
  the corresponding sprite is displayed in the multi-color mode. In the multi-
  color mode, the sprite data is interpreted in pairs (similar to the other
  multi-color modes) as follows:

        BIT PAIR      |                   COLOR DISPLAYED
           00         |  Transparent
           01         |  sprite Multi-color #0 (register 37 ($25))
           10         |  sprite Color (registers 39-46 ($27-$2E))
           11         |  sprite Multi-color #1 (register 38 ($26))


  Since two bits of data are required for each color, the resolution of the
  sprite is reduced to 12X21, with each horizontal dot expanded to twice
  standard size so that the overall sprite size does not change. Note that up
  to 3 colors can be displayed in each sprite (in addition to transparent) but
  that two of the colors are shared among all the sprites in the multi-color
  mode."
"In the context of the C64, What are the details for the 6502 DEC instruction?","DEC                   DEC Decrement memory by one                     DEC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   DEC Oper            |    C6   |    2    |    5     |
  |  Zero Page,X   |   DEC Oper,X          |    D6   |    2    |    6     |
  |  Absolute      |   DEC Oper            |    CE   |    3    |    6     |
  |  Absolute,X    |   DEC Oper,X          |    DE   |    3    |    7     |"
"In the context of the C64, What is the purpose of the instruction CLD"" in the 6502 assembly language code?""","CLD                      CLD Clear decimal mode                       CLD


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLD                 |    D8   |    1    |    2     |"
"In the context of the C64, WHow do I set a sprite off?","TURNING SPRITES OFF

A sprite is turned off by setting its bit in the VIC-II control register at 53269 ($D015 in HEX) to a 0. The following POKE will do this:

    POKE 53269,PEEK(53269)AND(255-2^SN)

where SN is the sprite number from 0 to 7."
"In the context of the C64, What are the key features of sprites in the VIC-II chip?","SPRITES

    A SPRITE is a special type of user definable character which can be
  displayed anywhere on the screen. Sprites are maintained directly by the
  VIC-II chip. And all you have to do is tell a sprite 'what to look like,'
  'what color to be,' and 'where to appear.' The VIC-II chip will do the
  rest! Sprites can be any of the 16 colors available.
    Sprites can be used with ANY of the other graphics modes, bit mapped,
  character, multi-color, etc., and they'll keep their shape in all of
  them. The sprite carries its own color definition, its own mode (HI-RES
  or multi-colored), and its own shape.
    Up to 8 sprites at a time can be maintained by the VIC-II chip auto-
  matically. More sprites can be displayed using RASTER INTERRUPT
  techniques.

    The features of SPRITES include:

    1) 24 horizontal dot by 21 vertical dot size.
    2) Individual color control for each sprite.
    3) Sprite multi-color mode.
    4) Magnification (2x) in horizontal, vertical, or both directions.
    5) Selectable sprite to background priority.
    6) Fixed sprite to sprite priorities.
    7) Sprite to sprite collision detection.
    8) Sprite to background collision detection."
"In the context of the C64, What is the primary function of the OSC 3 register ?","OSC 3/RANDOM (Register $1B)

    This register allows the microprocessor to read the upper 8 output bits
  of Oscillator 3. The character of the numbers generated is directly re-
  lated to the waveform selected. If the Sawtooth waveform of Oscillator 3
  is selected, this register will present a series of numbers incrementing
  from 0 to 255 ($FF) at a rate determined by the frequency of Oscillator
  3. If the Triangle waveform is selected, the output will increment from 0
  up to 255, then decrement down to 0. If the Pulse waveform is selected,
  the output will jump between 0 and 255. Selecting the Noise waveform
  will produce a series of random numbers, therefore, this register can be
  used as a random number generator for games. There are numerous timing
  and sequencing applications for the OSC 3 register, however, the chief
  function is probably that of a modulation generator. The numbers
  generated by this register can be added, via software, to the Oscillator
  or Filter Frequency registers or the Pulse Width registers in real-time.
  Many dynamic effects can be generated in this manner. Siren-like sounds
  can be created by adding the OSC 3 Sawtooth output to the frequency
  control of another oscillator. Synthesizer 'Sample and Hold' effects can
  be produced by adding the OSC 3 Noise output to the Filter Frequency
  control registers. Vibrato can be produced by setting Oscillator 3 to a
  frequency around 7 Hz and adding the OSC 3 Triangle output (with proper
  scaling) to the Frequency control of another oscillator. An unlimited
  range of effects are available by altering the frequency of Oscillator 3
  and scaling the OSC 3 output. Normally, when Oscillator 3 is used for
  modulation, the audio output of Voice 3 should be eliminated (3 OFF = 1)."
"In the context of the C64, What is the SID CONTROL REGISTER (Register 04)?","CONTROL REGISTER (Register 04)

    This register contains eight control bits which select various options
  on Oscillator 1.
    GATE (Bit 0): The GATE bit controls the Envelope Generator for Voice 1.
  When this bit is set to a one, the Envelope Generator is Gated
  (triggered) and the ATTACK/DECAY/SUSTAIN cycle is initiated. When the bit
  is reset to a zero, the RELEASE cycle begins. The Envelope Generator
  controls the amplitude of Oscillator I appearing at the audio output,
  therefore, the GATE bit must be set (along with suitable envelope pa-
  rameters) for the selected output of Oscillator 1 to be audible. A de-
  tailed discussion of the Envelope Generator can be found at the end of
  this Appendix.
    SYNC (Bit 1): The SYNC bit, when set to a one, synchronizes the
  fundamental frequency of Oscillator 1 with the fundamental frequency of
  Oscillator 3, producing 'Hard Sync' effects.
    Varying the frequency of Oscillator 1 with respect to Oscillator 3 pro-
  duces a wide range of complex harmonic structures from Voice I at the
  frequency of Oscillator 3. In order for sync to occur, Oscillator 3 must
  be set to some frequency other than zero but preferably lower than the
  frequency of Oscillator 1. No other parameters of Voice 3 have any effect
  on sync.
    RING MOD (Bit 2): The RING MOD bit, when set to a one, replaces the
  Triangle waveform output of Oscillator 1 with a 'Ring Modulated'
  combination of Oscillators 1 and 3. Varying the frequency of Oscillator 1
  with respect to Oscillator 3 produces a wide range of non-harmonic
  overtone structures for creating bell or gong sounds and for special ef-
  fects. In order for ring modulation to be audible, the Triangle waveform
  of Oscillator 1 must be selected and Oscillator 3 must be set to some
  frequency other than zero. No other parameters of Voice 3 have any effect
  on ring modulation.
    TEST (Bit 3): The TEST bit, when set to a one, resets and locks Oscil-
  lator 1 at zero until the TEST bit is cleared. The Noise waveform output
  of Oscillator 1 is also reset and the Pulse waveform output is held at a
  DC level. Normally this bit is used for testing purposes, however, it can
  be used to synchronize Oscillator 1 to external events, allowing the
  generation of highly complex waveforms under real-time software control.
  (Bit 4): When set to a one, the Triangle waveform output of Oscillator
  1 is selected. The Triangle waveform is low in harmonics and has a
  mellow, flute-like quality.
    (Bit 5): When set to a one, the Sawtooth waveform output of Oscillator
  1 is selected. The Sawtooth waveform is rich in even and odd harmonics
  and has a bright, brassy quality.
    (Bit 6): When set to a one, the Pulse waveform output of Oscillator 1
  is selected. The harmonic content of this waveform can be adjusted by the
  Pulse Width registers, producing tone qualities ranging from a bright,
  hollow square wave to a nasal, reedy pulse. Sweeping the pulse width in
  real-time produces a dynamic 'phasing' effect which adds a sense of
  motion to the sound. Rapidly jumping between different pulse widths can
  produce interesting harmonic sequences.
    NOISE (Bit 7): When set to a one, the Noise output waveform of
  Oscillator 1 is selected. This output is a random signal which changes at
  the frequency of Oscillator 1. The sound quality can be varied from a low
  rumbling to hissing white noise via the Oscillator 1 Frequency registers.
  Noise is useful in creating explosions, gunshots, jet engines, wind, surf
  and other unpitched sounds, as well as snore drums and cymbals. Sweeping
  the oscillator frequency with Noise selected produces a dramatic rushing
  effect.
    One of the output waveforms must be selected for Oscillator 1 to be
  audible, however, it is NOT necessary to de-select waveforms to silence
  the output of Voice 1. The amplitude of Voice 1 at the final output is a
  function of the Envelope Generator only.


  +-----------------------------------------------------------------------+
  | NOTE: The oscillator output waveforms are NOT additive. If more than  |
  | one output waveform is selected simultaneously, the result will be a  |
  | logical ANDing of the waveforms. Although this technique can be used  |
  | to generate additional waveforms beyond the four listed above, it must|
  | be used with care. If any other waveform is selected while Noise is   |
  | on, the Noise output can 'lock up ' If this occurs, the Noise output  |
  | will remain silent until reset by the TEST bit or by bringing RES     |
  | (pin 5) low.                                                          |
  +-----------------------------------------------------------------------+"
"In the context of the C64, What features does the VIC-II chip support in terms of sprite capabilities?","These special sprite abilities make it simple to program many arcade
  style games. Because the sprites are maintained by hardware, it is even
  possible to write a good quality game in BASIC!
    There are 8 sprites supported directly by the VIC-II chip. They are
  numbered from 0 to 7. Each of the sprites has it own definition location,
  position registers and color register, and has its own bits for enable
  and collision detection."
"In the context of the C64, What are the memory locations of the color registers on C64?","SPRITE COLORS

    A sprite can be any of the 16 colors generated by the VIC-II chip. Each
  of the sprites has its own sprite color register. These are the memory
  locations of the color registers:


        53287   ($D027)     description:    SPRITE 0 COLOR REGISTER
        53288   ($D028)     description:    SPRITE 1 COLOR REGISTER
        53289   ($D029)     description:    SPRITE 2 COLOR REGISTER
        53290   ($D02A)     description:    SPRITE 3 COLOR REGISTER
        53291   ($D02B)     description:    SPRITE 4 COLOR REGISTER
        53292   ($D02C)     description:    SPRITE 5 COLOR REGISTER
        53293   ($D02D)     description:    SPRITE 6 COLOR REGISTER
        53294   ($D02E)     description:    SPRITE 7 COLOR REGISTER

    All dots in the sprite will be displayed in the color contained in the
  sprite color register. The rest of the sprite will be transparent, and
  will show whatever is behind the sprite."
"In the context of the C64, What is the purpose of the CLC instruction in the assembly language?","CLC                       CLC Clear carry flag                        CLC

Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLC                 |    18   |    1    |    2     |"
"In the context of the C64, What is the assembly language form of the CPY instruction in the Zero Page addressing mode?","CPY                  CPY Compare memory and index Y                   CPY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   CPY *Oper           |    C0   |    2    |    2     |
  |  Zero Page     |   CPY Oper            |    C4   |    2    |    3     |
  |  Absolute      |   CPY Oper            |    CC   |    3    |    4     |"
"In the context of the C64, How to control the sprite magnification?","MAGNIFICATION

    Each sprite can be selectively expanded (2X) in both the horizontal and
  vertical directions. Two registers contain the control bits (MnXE,MnYE)
  for the magnification control.


    REGISTER  |                        FUNCTION
     23 ($17) | Horizontal expand MnXE-'1'=expand; '0'=normal
     29 ($1D) | Vertical expand MnYE-'1'=expand; '0'=normal

  When sprites are expanded, no increase in resolution is realized. The same
  24*21 array (12X21 if multi-colored) is displayed, but the overall sprite
  dimension is doubled in the desired direction (the smallest sprite dot may
  be up to 4X standard dot dimension if a sprite is both multi-colored and
  expanded)."
"In the context of the C64, What is the purpose of the color nybble in standard bit map mode?","STANDARD BIT MAP MODE (BMM =1, MCM = 0)

    When standard bit map mode is in use, the color information is derived
  only from the data stored in the video matrix (the color nybble is
  disregarded). The 8 bits are divided into two 4-bit nybbles which allow
  two colors to be independently selected in each 8*8 dot block. When a bit
  in the display memory is a '0' the color of the output dot is set by the
  least significant (lower) nybble (LSN). Similarly, a display memory bit
  of '1' selects the output color determined by the MSN (upper nybble).

      BIT    |            DISPLAY COLOR
       0     |   Lower nybble of video matrix pointer
       1     |   Upper nybble of video matrix pointer"
"In the context of the C64, What is the purpose of the SRQ?","SERIAL SRQ IN: (SERIAL SERVICE REQUEST IN)

    Any device on the serial bus can bring this signal LOW when it requires
  attention from the Commodore 64. The Commodore 64 will then take care of
  the device. (See Figure 6-4)."
"In the context of the C64, describe the 6526 Interrupt Control Register?","Interrupt Control (ICR)

    There are five sources of interrupts on the 6526: underflow from TIMER
  A, underflow from TIMER B, TOD ALARM, Serial Port full/empty and /FLAG.
  A single register provides masking and interrupt information. The
  interrupt Control Register consists of a write-only MASK register and a
  read-only DATA register. Any interrupt will set the corresponding bit in
  the DATA register. Any interrupt which is enabled by the MASK register
  will set the IR bit (MSB) of the DATA register and bring the /IRQ pin
  low. In a multi-chip system, the IR bit can be polled to detect which
  chip has generated an interrupt request. The interrupt DATA register is
  cleared and the /IRQ line returns high following a read of the DATA
  register. Since each interrupt sets an interrupt bit regardless of the
  MASK, and each interrupt bit can be selectively masked to prevent the
  generation of a processor interrupt, it is possible to intermix polled
  interrupts with true interrupts. However, polling the IR bit will cause
  the DATA register to clear, therefore, it is up to the user to preserve
  the information contained in the DATA register if any polled interrupts
  were present.
    The MASK register provides convenient control of individual mask bits.
  When writing to the MASK register, if bit 7 (SET/CLEAR) of the data
written is a ZERO, any mask bit written with a one will be cleared, while
  those mask bits written with a zero will be unaffected. If bit 7 of the
  data written is a ONE, any mask bit written with a one will be set, while
  those mask bits written with a zero will be unaffected. In order for an
  interrupt flag to set IR and generate an Interrupt Request, the corre-
  sponding MASK bit must be set."
"In the context of the C64, What are the details 6510 microprocessor chip?","6510 MICROPROCESSOR CHIP
  SPECIFICATIONS

  DESCRIPTION

    The 6510 is a low-cost microcomputer system capable of solving a broad
  range of small-systems and peripheral-control problems at minimum cost to
  the user.
    An 8-bit Bi-Directional I/O Port is located on-chip with the Output
  Register at Address 0000 and the Data-Direction Register at Address 0001.
  The I/O Port is bit-by-bit programmable.
    The Three-State sixteen-bit Address Bus allows Direct Memory Accessing
  (DMA) and multiprocessor systems sharing a common memory.
    The internal processor architecture is identical to the MOS Technology
  6502 to provide software compatibility.


  FEATURES OF THE 6510...

  o Eight-Bit Bi-Directional I/O Port
  o Single +5-volt supply
  o N-channel, silicon gate, depletion load technology
  o Eight-bit parallel processing
  o 56 Instructions
  o Decimal and binary arithmetic
  o Thirteen addressing modes
  o True indexing capability
  o Programmable stack pointer
  o Variable length stack
  o Interrupt capability
  o Eight-Bit Bi-Directional Data Bus
  o Addressable memory range of up to 64K bytes
  o Direct memory access capability
  o Bus compatible with M6800
  o Pipeline architecture
  o 1-MHz and 2-MHz operation
  o Use with any type or speed memory"
"In the context of the C64, What is the 6526 handshaking?","6256 Handshaking

    Handshaking on data transfers can be accomplished using the /PC output
  pin and the FLAG input pin. PC will go low for one cycle following a read
  or write of PORT B. This signal can be used to indicate 'data ready' at
  PORT B or 'data accepted' from PORT B. Handshaking on 16-bit data
  transfers (using both PORT A and PORT B) is possible by always reading or
  writing PORT A first. /FLAG is a negative edge sensitive input which can
  be used for receiving the /PC output from another 6526, or as a general
  purpose interrupt input. Any negative transition of /FLAG will set the
  /FLAG interrupt bit.


  Interval Timers (Timer A, Timer B)

    Each interval timer consists of a 16-bit read-only Timer Counter and a
  16-bit write-only Timer Latch. Data written to the timer are latched in
  the Timer Latch, while data read from the timer are the present contents
  of the Time Counter. The timers can be used independently or linked for
  extended operations. The various timer modes allow generation of long
  time delays, variable width pulses, pulse trains and variable frequency
  waveforms. Utilizing the CNT input, the timers can count external pulses
  or measure frequency, pulse width and delay times of external signals.
  Each timer has an associated control register, providing independent
  control of the following functions:

  Start/Stop

    A control bit allows the timer to be started or stopped by the micro-
  processor at any time.

  PB On/Off:

    A control bit allows the timer output to appear on a PORT B output line
  (PB6 for TIMER A and PB7 for TIMER B). This function overrides the DDRB
  control bit and forces the appropriate PB line to an output.

  Toggle/Pulse

    A control bit selects the output applied to PORT B. On every timer
  underflow the output can either toggle or generate a single positive
  pulse of one cycle duration. The Toggle output is set high whenever the
  timer is started and is set low by /RES.

  One-Shot/Continuous

    A control bit selects either timer mode. In one-shot mode, the timer
  will count down from the latched value to zero, generate an interrupt,
  reload the latched value, then stop. In continuous mode, the timer will
  count from the latched value to zero, generate' an interrupt, reload the
  latched value and repeat the procedure continuously.

  Force Load

    A strobe bit allows the timer latch to be loaded into the timer counter
  at any time, whether the timer is running or not.

  Input Mode:

    Control bits allow selection of the clock used to decrement the timer.
  TIMER A can count 02 clock pulses or external pulses applied to the CNT
  pin. TIMER B can count (02 pulses, external CNT pulses, TIMER A underflow
  pulses or TIMER A underflow pulses while the CNT pin is held high.

    The timer latch is loaded into the timer on any timer underflow, on a
  force load or following a write to the high byte of the prescaler while
  the timer is stopped. If the timer is running, a write to the high byte
  will load the timer latch, but not reload the counter."
"In the context of the C64, describe the BCS (Branch on Carry Set) operation?","BCS                      BCS Branch on carry set                      BCS

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Relative      |   BCS Oper            |    B0   |    2    |    2*    |
  * Add 1 if branch occurs to same  page.
  * Add 2 if branch occurs to next  page."
"In the context of the C64, What is the purpose of the stack in the 6510 microprocessor?","THE STACK

    The 6510 microprocessor has what is known as a stack. This is used by
  both the programmer and the microprocessor to temporarily remember
  things, and to remember, for example, an order of events. The GOSUB
  statement in BASIC, which allows the programmer to call a subroutine,
  must remember where it is being called from, so that when the RETURN
  statement is executed in the subroutine, the BASIC interpreter 'knows'
  where to go back to continue executing. When a GOSUB statement is
  encountered in a program by the BASIC interpreter, the BASIC interpreter
  'pushes' its current position onto the stack before going to do the
  subroutine, and when a RETURN is executed, the interpreter 'pulls' off
  the stack the information that tells it where it was before the
  subroutine call was made. The interpreter uses instructions like PHA,
  which pushes the contents of the accumulator onto the stack, and PLA (the
  reverse) which pulls a value off the stack and into the accumulator. The
  status register can also be pushed and pulled with the PHP and PLP,
  respectively.

    The stack is 256 bytes long, and is located in page one of memory. It
  is therefore from $01 00 to $01 FF. It is organized backwards in memory.
  In other words, the first position in the stack is at $01 FF, and the
  last is at $0100. Another register in the 651 0 microprocessor is called
  the stack pointer, and it always points to the next available location in
  the stack. When something is pushed onto the stack, it is placed where
  the stack pointer points to, and the stack pointer is moved down to the
  next position (decremented). When something is pulled off the stack, the
  stack pointer is incremented, and the byte pointed to by the stack
  pointer is placed into the specified register.

  The implied mode means that information isimplied by an instruction itself. In other words, what registers, flags,
  and memory the instruction is referring to. The examples we have seen are
  PHA, PLA, PHP, and PLP, which refer to stack processing and the
  accumulator and status registers, respectively.


NOTE: The X register will be referred to as X from now on, and similarly A (accumulator), Y (Y index register), S (stack pointer), and P (processor status).           |"
"In the context of the C64, how do i set the multi color mode?","MULTI-COLOR MODE BIT

    To turn on multi-color character mode, set bit 4 of the VIC-II control
  register at 53270 ($D016) to a 1 by using the following POKE:

    POKE 53270,PEEK(53270)OR 16

    To turn off multi-color character mode, set bit 4 of location 53270 to
  a 0 by the following POKE:

    POKE 53270,PEEK(53270)AND 239

    Multi-color mode is set on or off for each space on the screen, so that
  multi-color graphics can be mixed with high-resolution (hi-res) graphics.
  This is controlled by bit 3 in color memory. Color memory begins at
  location 55296 ($D800 in HEX). If the number in color memory is less than
  8 (0-7) the corresponding space on the video screen will be standard
  hi-res, in the color (0-7) you've chosen. If the number located in color
  memory is greater or equal
 to 8 (from 8 to 15), then that space will be displayed in multi-color mode.

    By POKEing a number into color memory, you can change the color of the
  character in that position on the screen. POKEing a number from 0 to 7
  gives the normal character colors. POKEing a number between 8 and 15 puts
  the space into multi-color mode. In other words, turning BIT 3 ON in
  color memory, sets MULTI-COLOR MODE. Turning BIT 3 OFF in color memory,
  sets the normal, HIGH-RESOLUTION mode.
    Once multi-color mode is set in a space, the bits in the character
  determine which colors are displayed for the dots. 

    In normal or high-resolution mode, the screen color is displayed
  everywhere there is a 0 bit, and the character color is displayed where
  the bit is a 1. Multi-color mode uses the bits in pairs

  The bit pairs determine
  this, according to the following chart:


  BIT PAIR - COLOR REGISTER - LOCATION
  00 - Background #0 color (screen color) - 53281 ($D021) 
  01 - Background #l color - 53282 ($D022) 
  10 - Background #2 color - 53283 ($D023) 
  11 - Color specified by the lower 3 bits in color memory - color RAM"
"In the context of the C64, What is the purpose of the raster register in a display system?","RASTER REGISTER

    The raster register is a dual-function register. A read of the raster
  register 18 ($12) returns the lower 8 bits of the current raster position
  (the MSB-RC8 is located in register 17 ($11)). The raster register can be
  interrogated to implement display changes outside the visible area to
  prevent display flicker. The visible display window is from raster 51
  through raster 251 ($033-$0FB). A write to the raster bits (including
  RC8) is latched for use in an internal raster compare. When the current
  raster matches the written value, the raster interrupt latch is set."
"In the context of the C64, What are the key components of the 6581 synthesizer chip?","DESCRIPTION

    The 6581 consists of three synthesizer 'voices' which can be used
  independently or in conjunction with each other (or external audio
  sources) to create complex sounds. Each voice consists of a Tone
  Oscillator/Waveform Generator, an Envelope Generator and an Amplitude
  Modulator. The Tone Oscillator controls the pitch of the voice over a
  wide range. The Oscillator produces four waveforms at the selected
  frequency, with the unique harmonic content of each waveform providing
  simple control of tone color. The volume dynamics of the oscillator are
  controlled by the Amplitude Modulator under the direction of the Envelope
  Generator. When triggered, the Envelope Generator creates an amplitude
  envelope with programmable rates of increasing and decreasing volume. In
  addition to the three voices, a programmable Filter is provided for
  generating complex, dynamic tone colors via subtractive synthesis.
    SID allows the microprocessor to read the changing output of the third
  Oscillator and third Envelope Generator. These outputs can be used as a
  source of modulation information for creating vibrato, frequency/filter
  sweeps and similar effects. The third oscillator can also act as a random
  number generator for games. Two A/D converters are provided for inter-
  facing SID with potentiometers. These can be used for 'paddles' in a
  game environment or as front panel controls in a music synthesizer. SID
  can process external audio signals, allowing multiple SID chips to be
  daisy-chained or mixed in complex polyphonic systems."
"In the context of the C64, What is the purpose of the command `POKE 53270, PEEK(53270) OR 16` in the context of changing character colors?","By using the <C=> key and the COLOR keys the characters can be changed to any color, including multi-color characters. For example, type this command:

 POKE 53270,PEEK(53270)OR 16:PRINT'<CTRL+3>';: rem lt.red/ multi-color red

 The word READY and anything else you type will be displayed in multi-color mode. Another color control can set you back to regular text."
"In the context of the C64, Can you talk about the zero page addressing mode?","ADDRESSING MODES

  ZERO PAGE

  Absolute addresses are expressed in terms of a high
  and a low order byte. The high order byte is often referred to as the
  page of memory. For example, the address $1637 is in page $16 (22), and
  $0277 is in page $02 (2). There is, however, a special mode of addressing
  known as zero page addressing and is, as the name implies, associated
  with the addressing of memory locations in page zero. These addresses,
  therefore, ALWAYS have a high order byte of zero. The zero page mode of
  addressing only expects one byte to describe the address, rather than two
  when using an absolute address. The zero page addressing mode tells the
  microprocessor to assume that the high order address is zero. Therefore
  zero page addressing can reference memory locations whose addresses are
  between $0000 and $00FF. This may not seem too important at the moment,
  but you'll need the principles of zero page addressing soon."
"In the context of the C64, Describe the BCC (Branch if Carry Clear) instruction?","BCC                     BCC Branch on Carry Clear                     BCC


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Relative      |   BCC Oper            |    90   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
"In the context of the C64, What is the CP/M?","USING COMMODORE CP/M(R)

    The Commodore Z-80 cartridge let's you run programs designed for a Z-80
  microprocessor on your Commodore 64. The cartridge is provided with a
  diskette containing the Commodore CP/M(R) operating system.

  RUNNING COMMODORE CP/M(R)

    To run CP/M(R):

      1) LOAD the CP/M(R) program from your disk drive.
      2) Type RUN.
      3) Hit the <RETURN> key.
    At this point the 64K bytes of RAM in the Commodore 64 are accessible
  by the built-in 6510 central processor, OR 48K bytes of RAM are available
  for the Z-80 central processor. You can shift back and forth between
  these two processors, but you can NOT use them at the same time in a
  single program. This is possible because of your Commodore 64's
  sophisticated timing mechanism.
    Below is the memory address translation that is performed on the Z-80
  cartridge. You should notice that by adding 4096 bytes to the memory
  locations used in CP/M(R) $1000 (hex) you equal the memory addresses of
  the normal Commodore 64 operating system. The correspondence between Z-80
  and 6510 memory addresses is as follows:"
"In the context of the C64, What are the error messages generated by the Commodore-64?","ERROR MESSAGES

    This appendix contains a complete list of the error messages generated
  by the Commodore-64, with a description of causes.


  BAD DATA            String data was received from an open file, but the
                      program was expecting numeric data.
  BAD SUBSCRIPT       The program was trying to reference an element of an
                      array whose number is outside of the range specified
                      in the DIM statement.
  BREAK               Program execution was stopped because you hit the
                      <STOP> key.
  CAN'T CONTINUE      The CONT command will not work, either because the
                      program was never RUN, there has been an error, or
                      a line has been edited.
  DEVICE NOT PRESENT  The required I/O device was not available for an
                      OPEN, CLOSE, CMD, PRINT#, INPUT#, or GET#.
  DIVISION BY ZERO    Division by zero is a mathematical oddity and not
                      allowed.
  EXTRA IGNORED       Too many items of data were typed in response to an
                      INPUT statement. Only the first few items were
                      accepted.
  FILE NOT FOUND      If you were looking for a file on tape, and END-OF-
                      TAPE marker was found. If you were looking on disk,
                      no file with that name exists.
  FILE NOT OPEN       The file specified in a CLOSE, CMD, PRINT#, INPUT#,
                      or GET#, must first be OPENed.
  FILE OPEN           An attempt was made to open a file using the number
                      of an already open file.
  FORMULA TOO COMPLEX The string expression being evaluated should be split
                      into at least two parts for the system to work with,
                      or a formula has too many parentheses.
  ILLEGAL DIRECT      The INPUT statement can only be used within a pro-
                      gram, and not in direct mode.
  ILLEGAL QUANTITY    A number used as the argument of a function or
                      statement is out of the allowable range.
  LOAD                There is a problem with the program on tape.
  NEXT WITHOUT FOR    This is caused by either incorrectly nesting loops or
                      having a variable name in a NEXT statement that
                      doesn't correspond with one in a FOR statement.
  NOT INPUT FILE      An attempt was made to INPUT or GET data from a file
                      which was specified to be for output only.
  NOT OUTPUT FILE     An attempt was mode to PRINT data to a file which was
                      specified as input only.
  OUT OF DATA         A READ statement was executed but there is no data
                      left unREAD in a DATA statement.
  OUT OF MEMORY       There is no more RAM available for program or
                      variables. This may also occur when too many FOR
                      loops have been nested, or when there are too many
                      GOSUBs in effect.
  OVERFLOW            The result of a computation is larger than the
                      largest number allowed, which is 1.70141884E+38.
  REDIM'D ARRAY       An array may only be DiMensioned once. If an array
                      variable is used before that array is DIM'D, an
                      automatic DIM operation is performed on that array
                      setting the number of elements to ten, and any
                      subsequent DIMs will cause this error.
  REDO FROM START     Character data was typed in during an INPUT statement
                      when numeric data was expected. Just re-type the
                      entry so that it is correct, and the program will
                      continue by itself.
  RETURN WITHOUT GOSUB  A RETURN statement was encountered, and no GOSUB
                      command has been issued.
  STRING TOO LONG     A string can contain up to 255 characters.
  ?SYNTAX ERROR       A statement is unrecognizable by the Commodore 64. A
                      missing or extra parenthesis, misspelled keywords,
                      etc.
  TYPE MISMATCH       This error occurs when a number is used in place of a
                      string, or vice-versa.
  UNDEF'D FUNCTION    A user defined function was referenced, but it has
                      never been defined using the DEF FN statement.
  UNDEF'D STATEMENT   An attempt was made to GOTO or GOSUB or RUN a line
                      number that doesn't exist.
  VERIFY              The program on tape or disk does not match the
                      program currently in memory."
"In the context of the C64, What is the primary function of the Time of Day (TOD) clock?","Time of Day Clock (TOD)

    The TOD clock is a special purpose timer for real-time applications.
  TOD consists of a 24-hour (AM/PM) clock with 1/10th second resolution. It
  is organized into 4 registers: 10ths of seconds, Seconds, Minutes and
  Hours. The AM/PM flag is in the MSB of the Hours register for easy bit
  testing. Each register reads out in BCD format to simplify conversion for
  driving displays, etc. The clock requires an external 60 Hz or 50 Hz
  (programmable) TTL level input on the TOD pin for accurate time-keeping.
  In addition to time-keeping, a programmable ALARM is provided for
  generating an interrupt at a desired time. The ALARM registers or located
  at the same addresses as the corresponding TOD registers. Access to the
  ALARM is governed by a Control Register bit. The ALARM is write-only; any
  read of a TOD address will read time regardless of the state of the ALARM
  access bit.
    A specific sequence of events must be followed for proper setting and
  reading of TOD. TOD is automatically stopped whenever a write to the
  Hours register occurs. The clock will not start again until after a write
  to the 10ths of seconds register. This assures TOD will always start at
  the desired time. Since a carry from one stage to the next can occur at
  any time with respect to a read operation, a latching function is
  included to keep all Time Of Day information constant during a read
  sequence. All four TOD registers latch on a read of Hours and remain
  latched until after a read of 10ths of seconds. The TOD clock continues
  to count when the output registers are latched. If only one register is
  to be read, there is no carry problem and the register can be read 'on
  the fly,' provided that any read of Hours is followed by a read of 10ths
  of seconds to disable the latching."
"In the context of the C64, What is the maximum number of unique sprites that can be displayed simultaneously?","SPRITES

    The movable object block (sprite) is a special type of character which can
  be displayed at any one position on the screen without the block
  constraints inherent in character and bit map mode. Up to 8 unique sprites
  can be displayed simultaneously, each defined by 63 bytes in memory which
  are displayed as a 24*21 dot array (shown below). A number of special
  features make sprites especially suited for video graphics and game
  applications.


                              sprite DISPLAY BLOCK
                        |  BYTE  |  BYTE  |  BYTE  |
                        |   00   |   01   |   02   |
                        |   03   |   04   |   05   |
                        |    .   |    .   |    .   |
                        |    .   |    .   |    .   |
                        |    .   |    .   |    .   |
                        |   57   |   58   |   59   |
                        |   60   |   61   |   62   |"
"In the context of the C64, Can you describe the LDA?","LDA - LOAD THE ACCUMULATOR

    In 6510 assembly language, mnemonics are always three characters. LDA
  represents 'load accumulator with...', and what the accumulator should be
  loaded with is decided by the parameter(s) associated with that
  instruction. The assembler knows which token is represented by each
  mnemonic, and when it 'assembles' an instruction, it simply puts into
  memory (at whatever address has been specified), the token, and what
  parameters, are given. Some assemblers give error messages, or warnings
  when you try to assemble something that either the assembler, or the 6510
  microprocessor, cannot do.
    If you put a '#' symbol in front of the parameter associated with the
  instruction, this means that you want the register specified in the
  instruction to be loaded with the 'value' after the '#'. For example:

    LDA #$05  <----[ $=HEX ]

  This instruction will put $05 (decimal 5) into the accumulator register.
  The assembler will put into the specified address for this instruction,
  $A9 (which is the token for this particular instruction, in this mode),
  and it will put $05 into the next location after the location containing
  the instruction ($A9).
    If the parameter to be used by an instruction has '#' before it; i.e.,
  the parameter is a 'value,' rather than the contents of a memory loca-
  tion, or another register, the instruction is said to be in the
  'immediate' mode. To put this into perspective, let's compare this with
  another mode:
    If you want to put the contents of memory location $102E into the
  accumulator, you're using the 'absolute' mode of instruction:

    LDA $102E

  The assembler can distinguish between the two different modes because the
  latter does not have a '#' before the parameter. The 6510 microprocessor
  can distinguish between the immediate mode, and the absolute mode of the
  LDA instruction, because they have slightly different tokens. LDA
  (immediate) has $A9 as its token, and LDA (absolute), has $AD as its
  token."
"In the context of the C64, What is the  instruction that clears the interrupt disable bit?","CLI                  CLI Clear interrupt disable bit                  CLI


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLI                 |    58   |    1    |    2     |"
"In the context of the C64, What is the maximum addressable memory location that a sprite pointer can point to?","SPRITE POINTERS

    Even though each sprite takes only 63 bytes to define, one more byte
  is needed as a place holder at the end of each sprite. Each sprite, then,
  takes up 64 bytes. This makes it easy to calculate where in memory your
  sprite definition is, since 64 bytes is an even number and in binary it's
  an even power.
    Each of the 8 sprites has a byte associated with it called the SPRITE
  POINTER. The sprite pointers control where each sprite definition is lo-
  cated in memory. These 8 bytes are always located as the lost 8 bytes
  of the 1K chunk of screen memory. Normally, on the Commodore 64, this
  means they begin at location 2040 ($07F8 in HEX). However, if you move
  the screen, the location of your sprite pointers will also move.
    Each sprite pointer can hold a number from 0 to 255. This number points
  to the definition for that sprite. Since each sprite definition takes
  64 bytes, that means that the pointer can 'see' anywhere in the 16K
  block of memory that the VIC-II chip can access (since 256*64=16K)."
"In the context of the C64, What is the primary advantage of using multi-color mode graphics over standard high-resolution graphics?","MULTI-COLOR MODE GRAPHICS

    Standard high-resolution graphics give you control of very small dots
  on the screen. Each dot in character memory can have 2 possible values,
  1 for on and 0 for off. When a dot is off, the color of the screen is
  used in the space reserved for that dot. If the dot is on, the dot is
  colored with the character color you have chosen for that screen posi-
  tion. When you're using standard high-resolution graphics, all the dots
  within each 8X8 character can either have background color or foreground
  color. In some ways this limits the color resolution within that space.
  For example, problems may occur when two different colored lines cross.
    Multi-color mode gives you a solution to this problem. Each dot in
  multi-color mode can be one of 4 colors: screen color (background color
  register #0), the color in background register #1, the color in back-
  ground color register #2, or character color. The only sacrifice is in
  the horizontal resolution, because each multi-color mode dot is twice as
  wide as a high-resolution dot. This minimal loss of resolution is more
  than compensated for by the extra abilities of multi-color mode."
"In the context of the C64, What is the purpose of the interrupt register?","INTERRUPT REGISTER

    The interrupt register shows the status of the four sources of
  interrupt. An interrupt latch in register 25 ($19) is set to '1' when an
  interrupt source has generated an interrupt request. The four sources of
  interrupt are:

   LATCH |ENABLE|
    BIT  | BIT  |                       WHEN SET
    IRST | ERST | Set when (raster count) = (stored raster count)
    IMDC | EMDC | Set by sprite-DATA collision register (first collision only)
    IMMC | EMMC | Set by sprite-sprite collision register (first collision only)
    ILP  | ELP  | Set by negative transition of LP input (once per frame)
    IRQ  |      | Set high by latch set and enabled (invert of /IRQ output)

    To enable an interrupt request to set the /IRQ output to '0', the
  corresponding interrupt enable bit in register 26 ($1A) must be set to
  '1'. Once an interrupt latch has been set, the latch may be cleared only
  by writing a '1' to the desired latch in the interrupt register. This
  feature allows selective handling of video interrupts without software
  required to 'remember' active interrupts."
"In the context of the C64, given the SID register description","SID REGISTER DESCRIPTION

  VOICE 1

  FREQ LO/FREQ HI (Registers 00,01)

    Together these registers form a 16-bit number which linearly controls
  the frequency of Oscillator 1 . The frequency is determined by the
  following equation:

                       Fout = (Fn*Fclk/16777216) Hz

    Where Fn is the 16-bit number in the Frequency registers and Fclk is
  the system clock applied to the 02 input (pin 6). For a standard 1.0-MHz
  clock, the frequency is given by:

                       Fout = (Fn*0.059604645) Hz

    A complete table of values for generating 8 octaves of the equally
  tempered musical scale with concert A (440 Hz) tuning is provided in
  Appendix E. It should be noted that the frequency resolution of SID is
  sufficient for any tuning scale and allows sweeping from note to note
  (portamento) with no discernable frequency steps."
"In the context of the C64, What is the primary function of the built-in dynamic RAM refresh controller in the 6566/6567 devices?","DYNAMIC RAM REFRESH

    A dynamic ram refresh controller is built in to the 6566/6567 devices.
  Five 8-bit row addresses are refreshed every raster line. This rate
  guarantees a maximum delay of 2.02 ms between the refresh of any single
  row address in a 128 refresh scheme. (The maximum delay is 3.66 ms in a
  256 address refresh scheme.) This refresh is totally transparent to the
  system, since the refresh occurs during Phase 1 of the system clock. The
  6567 generates both /RAS and /CAS which are normally connected directly
  to the dynamic rams. /RAS and /CAS are generated for every Phase 2 and
  every video data access (including refresh) so that external clock
  generation is not required.


  RESET"
"In the context of the C64, What is the size of a standard (HI-RES) sprite in terms of dots?","DEFINING A SPRITE

    Sprites are defined like programmable characters are defined. However,
  since the size of the sprite is larger, more bytes are needed. A sprite
  is 24 by 21 dots, or 504 dots. This works out to 63 bytes (504/8 bits)

    A way to view how a sprite is created is to take a look at the
  sprite definition block on the bit level. 

  In a standard (HI-RES) sprite, each bit set to I is displayed in that
  sprite's foreground color. Each bit set to 0 is transparent and will
  display whatever data is behind it. This is similar to a standard
  character.
    Multi-color sprites are similar to multi-color characters. Horizontal
  resolution is traded for extra color resolution. The resolution of the
  sprite becomes 12 horizontal dots by 21 vertical dots. Each dot in the
  sprite becomes twice as wide, but the number of colors displayable in the
  sprite is increased to 4."
"In the context of the C64, What is the assembly language instruction that sets the carry flag to 0 and clears the overflow flag?","CLV                      CLV Clear overflow flag                      CLV


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLV                 |    B8   |    1    |    2     |"
"In the context of the C64, What is the instruction that performs a bitwise left shift of the value in the specified memory location or accumulator by one bit?","ASL          ASL Shift Left One Bit (Memory or Accumulator)           ASL

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Accumulator   |   ASL A               |    0A   |    1    |    2     |
  Zero Page     |   ASL Oper            |    06   |    2    |    5     |
  Zero Page,X   |   ASL Oper,X          |    16   |    2    |    6     |
  Absolute      |   ASL Oper            |    0E   |    3    |    6     |
  Absolute, X   |   ASL Oper,X          |    1E   |    3    |    7     |"
"In the context of the C64, What is the list of user-callable kernel routines in the KERNAL?","USER CALLABLE KERNAL ROUTINES
  
  
  NOM - ADDRESS - FUNCTION
  | ACPTR  |  $FFA5  |  65445  |  Input byte from serial port             |
  | CHKIN  |  $FFC6  |  65478  |  Open channel for input                  |
  | CHKOUT |  $FFC9  |  65481  |  Open channel for output                 |
  | CHRIN  |  $FFCF  |  65487  |  Input character from channel            |
  | CHROUT |  $FFD2  |  65490  |  Output character to channel             |
  | CIOUT  |  $FFA8  |  65448  |  Output byte to serial port              |
  | CINT   |  $FF81  |  65409  |  Initialize screen editor                |
  | CLALL  |  $FFE7  |  65511  |  Close all channels and files            |
  | CLOSE  |  $FFC3  |  65475  |  Close a specified logical file          |
  | CLRCHN |  $FFCC  |  65484  |  Close input and output channels         |
  | GETIN  |  $FFE4  |  65508  |  Get character from keyboard queue       |
  |        |         |         |  (keyboard buffer)                       |
  | IOBASE |  $FFF3  |  65523  |  Returns base address of I/O devices     |
  | IOINIT |  $FF84  |  65412  |  Initialize input/output                 |
  | LISTEN |  $FFB1  |  65457  |  Command devices on the serial bus to    |
  |        |         |         |  LISTEN                                  |
  | IOBASE |  $FFF3  |  65523  |  Returns base address of I/O devices     |
  | IOINIT |  $FF84  |  65412  |  Initialize input/output                 |
  | LISTEN |  $FFB1  |  65457  |  Command devices on the serial bus to    |
  |        |         |         |  LISTEN                                  |
  | LOAD   |  $FFD5  |  65493  |  Load RAM from a device                  |
  | MEMBOT |  $FF9C  |  65436  |  Read/set the bottom of memory           |
  | MEMTOP |  $FF99  |  65433  |  Read/set the top of memory              |
  | OPEN   |  $FFC0  |  65472  |  Open a logical file                     |
  | PLOT   |  $FFF0  |  65520  |  Read/set X,Y cursor position            |
  | RAMTAS |  $FF87  |  65415  |  Initialize RAM, allocate tape buffer,   |
  |        |         |         |  set screen $0400                        |
  | RDTIM  |  $FFDE  |  65502  |  Read real time clock                    |
  | READST |  $FFB7  |  65463  |  Read I/O status word                    |
  | RESTOR |  $FF8A  |  65418  |  Restore default I/O vectors             |
  | SAVE   |  $FFD8  |  65496  |  Save RAM to device                      |
  | SCNKEY |  $FF9F  |  65439  |  Scan keyboard                           |
  | SCREEN |  $FFED  |  65517  |  Return X,Y organization of screen       |
  | SECOND |  $FF93  |  65427  |  Send secondary address after LISTEN     |
  | SETLFS |  $FFBA  |  65466  |  Set logical, first, and second addresses|
  | SETMSG |  $FF90  |  65424  |  Control KERNAL messages                 |
  | SETNAM |  $FFBD  |  65469  |  Set file name                           |
  | SETTIM |  $FFDB  |  65499  |  Set real time clock                     |
  | SETTMO |  $FFA2  |  65442  |  Set timeout on serial bus               |
  | STOP   |  $FFE1  |  65505  |  Scan stop key                           |
  | TALK   |  $FFB4  |  65460  |  Command serial bus device to TALK       |
  | TKSA   |  $FF96  |  65430  |  Send secondary address after TALK       |
  | UDTIM  |  $FFEA  |  65514  |  Increment real time clock               |
  | UNLSN  |  $FFAE  |  65454  |  Command serial bus to UNLISTEN          |
  | UNTLK  |  $FFAB  |  65451  |  Command serial bus to UNTALK            |
  | VECTOR |  $FF8D  |  65421  |  Read/set vectored I/O                   |"
"In the context of the C64, Describe the multicolor Bitmap mode","MULTI-COLOR BIT MAP MODE (BMM = MCM = 1)

    Multi-colored bit map mode is selected by setting the MCM bit in
  register 22 ($16) to a '1' in conjunction with the BMM bit. Multi-color
  mode uses the same memory access sequences as standard bit map mode, but
  interprets the dot data as follows:

        BIT PAIR      |                   DISPLAY COLOR
           00         |  Background #0 color (register 33 ($21))
           01         |  Upper nybble of video matrix pointer
           10         |  Lower nybble of video matrix pointer
           11         |  Video matrix color nybble

  Note that the color nybble (DB11-DB8) IS used for the multi-color bit map
  mode. Again, as two bits are used to select one dot color, the horizontal
  dot size is doubled, resulting in a screen resolution of 160H*200V.
  Utilizing multi-color bit map mode, three independently selected colors
  can be displayed in each 8*8 block in addition to the background color."
"In the context of the C64, What is the primary function of the Serial Port (SDR)?","Serial Port (SDR)

    The serial port is a buffered, 8-bit synchronous shift register system.
  A control bit selects input or output mode. In input mode, data on the SP
  pin is shifted into the shift register on the rising edge of the signal
  applied to the CNT pin. After 8 CNT pulses, the data in the shift
  register is dumped into the Serial Data Register and an interrupt is
  generated. In the output mode, TIMER A is used for the baud rate
  generator. Data is shifted out on the SP pin at 1/2 the underflow rate of
  TIMER A. The maximum baud rate possible is 02 divided by 4, but the
  maximum useable baud rate will be determined by line loading and the
  speed at which the receiver responds to input data. Transmission will
  start following a write to the Serial Data Register (provided TIMER A is
  running and in continuous mode). The clock signal derived from TIMER A
  appears as an output on the CNT pin. The data in the Serial Data Register
  will be loaded into the shift register then shift out to the SP pin when
  a CNT pulse occurs. Data shifted out becomes valid on the falling edge of
  CNT and remains valid until the next falling edge. After 8 CNT pulses, an
  interrupt is generated to indicate more data can be sent. If the Serial
  Data Register was loaded with new information prior to this interrupt,
  the new data will automatically be loaded into the shift register and
  transmission will continue. If the microprocessor stays one byte ahead of
  the shift register, transmission will be continuous. If no further data
  is to be transmitted, after the 8th CNT pulse, CNT will return high and
  SP will remain at the level of the last data bit transmitted. SDR data is
  shifted out MSB first and serial input data should also appear in this
  format.
    The bidirectional capability of the Serial Port and CNT clock allows
  many 6526 devices to be connected to a common serial communication bus on
  which one 6526 acts as a master, sourcing data and shift clock, while all
  other 6526 chips act as slaves. Both CNT and SP outputs are open drain to
  allow such a common bus. Protocol for master/slave selection can be
  transmitted over the serial bus, or via dedicated handshaking lines."
"In the context of the C64, What is the meaning of each bit in the PROCESSOR STATUS REG 'P' register?","Status Register
                        +-+-+-+-+-+-+-+-+
                        |N|V| |B|D|I|Z|C|  PROCESSOR STATUS REG 'P'
                        +-+-+-+-+-+-+-+-+
                         | |   | | | | |
                         | |   | | | | +>  CARRY         1=TRUE
                         | |   | | | +-->  ZERO          1=RESULT ZERO
                         | |   | | +---->  IRQ DISABLE   1=DISABLE
                         | |   | +------>  DECIMAL MODE  1=TRUE
                         | |   +-------->  BRK COMMAND
                         | |
                         | +------------>  OVERFLOW      1=TRUE
                         +-------------->  NEGATIVE      1=NEG"
"In the context of the C64, What is the number of rows and columns displayed on the screen when the RSEL bit is set to 1 and the CSEL bit is set to 1?","ROW/COLUMN SELECT

    The normal display consists of 25 rows of 40 characters (or character
  regions) per row. For special display purposes, the display window may be
  reduced to 24 rows and 38 characters. There is no change in the format of
  the displayed information, except that characters (bits) adjacent to the
  exterior border area will now be covered by the border. The select bits
  operate as follows:


    RSEL |      NUMBER OF ROWS        |  CSEL |     NUMBER OF COLUMNS
     0   |          24 rows           |   0   |         38 columns
     1   |          25 rows           |   1   |         40 columns

  The RSEL bit is in register 17 ($11) and the CSEL bit is in register 22
  ($16). For standard display the larger display window is normally used,
  while the smaller display window is normally used in conjunction with
  scrolling."
"In the context of the C64, What is the assembly language instruction that increments the index Y by one?","INY                    INY Increment Index Y by one                   INY


  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   INY                 |    C8   |    1    |    2     |"
"In the context of the C64, What is the indirect indexed addressing mode?","INDIRECT INDEXED

    This only allows usage of the Y register as the index. The actual ad-
  dress can only be in zero page, and the mode of instruction is called
  indirect because the zero page address specified in the instruction con-
  tains the low byte of the actual address, and the next byte to it
  contains the high order byte.

 EXAMPLE:

    Let us suppose that location $02 contains $45, and location $03 con-
  tains $1E. If the instruction to load the accumulator in the indirect
  indexed mode is executed and the specified zero page address is $02, then
  the actual address will be:

    Low order = contents of $02
    High order = contents of $03
    Y register = $00

  Thus the actual address = $1E45 + Y = $1E45.
    The title of this mode does in fact imply an indirect principle,
  although this may be difficult to grasp at first sight. Let's look at it
  another way:
    'I am going to deliver this letter to the post office at address $02,
  MEMORY ST., and the address on the letter is $05 houses past $1600,
  MEMORY street.' This is equivalent to the code:

    LDA #$00      - load low order actual base address
    STA $02       - set the low byte of the indirect address
    LDA #$16      - load high order indirect address
    STA $03       - set the high byte of the indirect address
    LDY #$05      - set the indirect index (Y)
    LDA ($02),Y   - load indirectly indexed by Y"
"In the context of the C64, What is the primary strategy for approaching a large task in machine language programming?","APPROACHING A LARGE TASK

    When approaching a large task in machine language, a certain amount of
  subconscious thought has usually taken place. You think about how certain
  processes are carried out in machine language. When the task is started,
  it is usually a good idea to write it out on paper. Use block diagrams of
  memory usage, functional modules of code required, and a program flow.
  Let's say that you wanted to write a roulette game in machine language.
  You could outline it something like this:

    o Display title
    o Ask if player requires instructions
    o YES - display them-Go to START
    o NO - Go to START
    o START Initialize everything
    o MAIN display roulette table
    o Take in bets
    o Spin wheel
    o Slow wheel to stop
    o Check bets with result
    o Inform player
    o Player any money left?
    o YES - Go to MAIN
    o NO - Inform user!, and go to START


    This is the main outline. As each module is approached, you can break
  it down further. If you look at a large indigestable problem as something
  that can be broken down into small enough pieces to be eaten, then you'll
  be able to approach something that seems impossible, and have it all fall
  into place.
    This process only improves with practice, so KEEP TRYING."
"In the context of the C64, How do I unexpand a sprite in horizontal direction ?","To unexpand a sprite in the horizontal direction, the corresponding bit
  in the VIC-II control register at location 53277 ($D01D in HEX) must be
  turned OFF (set to a 0). The following POKE 'unexpands' a sprite in the
  X direction:

    POKE 53277,PEEK(53277)AND (255-2^SN)

  where SN is the sprite number from 0 to 7.
    To expand a sprite in the vertical direction, the corresponding bit in
  the VIC-II control register at location 53271 ($D017 in HEX) must be
  turned ON (set to a 1). The following POKE expands a sprite in the Y
  direction:

    POKE 53271,PEEK(53271)OR(2^SN)

  where SN is the sprite number from 0 to 7.

     
   To expand a sprite in the horizontal direction, the corresponding bit
  in the VIC-II control register at location 53277 ($D01D in HEX) must be
  turned ON (set to a 1). The following POKE expands a sprite in the X
  direction:

    POKE 53277,PEEK(53277)OR(2^SN)

  where SN is the sprite number from 0 to 7."
"In the context of the C64, What is the condition required for accessing the device registers?","DATA BUS (DB7-DB0)

    The eight data bus pins are the bidirectional data port, controlled by
  /CS, RW, and Phase 0. The data bus can only be accessed while AEC and
  Phase 0 are high and /CS is low.

  CHIP SELECT (/CS)

    The chip select pin, /CS, is brought low to enable access to the device
  registers in conjunction with the address and RW pins. /CS low is recog-
  nized only while AEC and Phase 0 are high."
"In the context of the C64, What is the primary function of the 6581 Sound Interface Device (SID)?","6581 SOUND INTERFACE DEVICE (SID)
  CHIP SPECIFICATIONS
  CONCEPT

    The 6581 Sound Interface Device (SID) is a single-chip, 3-voice elec-
  tronic music synthesizer/sound effects generator compatible with the 65XX
  and similar microprocessor families. SID provides wide-range, high-
  resolution control of pitch (frequency), tone color (harmonic content),
  and dynamics (volume). Specialized control circuitry minimizes software
  overhead, facilitating use in arcade/home video games and low-cost
  musical instruments.


  FEATURES

  o 3 TONE OSCILLATORS
        Range: 0-4 kHz
  o 4 WAVEFORMS PER OSCILLATOR
        Triangle, Sawtooth,
        Variable Pulse, Noise
  o 3 AMPLITUDE MODULATORS
        Range: 48 dB
  o 3 ENVELOPE GENERATORS
        Exponential response
        Attack Rate: 2 ms-8 s
        Decay Rate: 6 ms-24 s
        Sustain Level: 0-peak volume
        Release Rate: 6 ms-24 s
  o OSCILLATOR SYNCHRONIZATION
  o RING MODULATION
  o PROGRAMMABLE FILTER
        Cutoff range: 30 Hz-12 kHz
        12 dB/octave Rolloff
        Low pass, Bandpass,
        High pass, Notch outputs
        Variable Resonance
  o MASTER VOLUME CONTROL
  o 2 A/D POT INTERFACES
  o RANDOM NUMBER/MODULATION GENERATOR
  o EXTERNAL AUDIO INPUT"
"In the context of the C64, How do you unexpand a sprite in the vertical direction?","To unexpand a sprite in the vertical direction, the corresponding bit
  in the VIC-II control register at location 53271 ($D017 in HEX) must be
  turned OFF (set to a 0). The following POKE 'unexpands' a sprite in the
  Y direction:

    POKE 53271,PEEK(53271)AND (255-2^SN)

  where SN is the sprite number from 0 to 7."
"In the context of the C64, What is the standard character mode ?","STANDARD CHARACTER MODE

    Standard character mode is the mode the Commodore 64 is in when you
  first turn it on. It is the mode you will generally program in.
    Characters can be taken from ROM or from RAM, but normally they are
  taken from ROM. When you want special graphics characters for a program,
  all you have to do is define the new character shapes in RAM, and tell
  the VIC-II chip to get its character information from there instead of
  the character ROM. This is covered in more detail in the next section.
    In order to display characters on the screen in color, the VIC-II chip
  accesses the screen memory to determine the character code for that
  location on the screen. At the same time, it accesses the color memory to
  determine what color you want for the character displayed. The character
  code is translated by the VIC-II into the starting address of the 8-byte
  block holding your character pattern. The 8-byte block is located in
  character memory.
    The translation isn't too complicated, but a number of items are com-
  bined to generate the desired address. First the character code you use
  to POKE screen memory is multiplied by 8. Next add the start of char-
  acter memory (see CHARACTER MEMORY section). Then the Bank Select Bits
  are taken into account by adding in the base address (see VIDEO BANK
  SELECTION section). Below is a simple formula to illustrate what happens:
  CHARACTER ADDRESS = SCREEN CODE*8+(CHARACTER SET*2048)+(BANK*16384)"
"In the context of the C64, What are some essential tips and strategies for a beginner to learn and master machine language programming?","USEFUL TIPS FOR THE BEGINNER

    One of the best ways to learn machine language is to look at other
  peoples' machine language programs. These are published all the time in
  magazines and newsletters. Look at them even if the article is for a
  different computer, which also uses the 6510 (or 6502) microprocessor.
  You should make sure that you thoroughly understand the code that you
  look at. This will require perseveres I ce, especially when you see a new
  technique that you have never come across before. This can be infuriat-
  ing, but if patience prevails, you will be the victor.
    Having looked at other machine language programs, you MUST write your
  own. These may be utilities for your BASIC programs, or they may be an
  all machine language program.
    You should also use the utilities that are available, either IN your
  computer, or in a program, that aid you in writing, editing, or tracking
  down errors in a machine language program. An example would be the
  KERNAL, which allows you to check the keyboard, print text, control
  peripheral devices like disk drives, printers, modems, etc., manage
  memory and the screen. It is extremely powerful and it is advised
  strongly that it is used (refer to KERNAL section, Page 268).
    Advantages of writing programs in machine language:

    1. Speed - Machine language is hundreds, and in some cases thousands of
       times faster than a high level language such as BASIC.

    2. Tightness - A machine language program can be made totally
       'watertight,' i.e., the user can be made to do ONLY what the program
        allows, and no more. With a high level language, you are relying on
        the user not 'crashing' the BASIC interpreter by entering, for
        example, a zero which later causes a:


  ?DIVISION BY ZERO ERROR IN LINE 830

  READY.


  In essence, the computer can only be maximized by the machine language
  programmer."
"In the context of the C64, What is indexing in the context of the 6510 microprocessor?","INDEXING

    Indexing plays an extremely important part in the running of the 6510
  microprocessor. It can be defined as 'creating an actual address from a
  base address plus the contents of either the X or Y index registers.'
    For example, if X contains $05, and the microprocessor executes an LDA
  instruction in the 'absolute X indexed mode' with base address (e.g.,
  $9000), then the actual location that is loaded into the A register is
  $9000 + $05 = $9005. The mnemonic format of an absolute indexed
  instruction is the same as an absolute instruction except a ',X' or ',Y'
  denoting the index is added to the address.

  EXAMPLE:

    LDA $9000,X

    There are absolute indexed, zero page indexed, indirect indexed, and
  indexed indirect modes of addressing available on the 6510
  microprocessor."
"In the context of the C64, What is the assembly language instruction that increments the index register by one?","INX                    INX Increment Index X by one                   INX
                                                        N Z C I D V
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   INX                 |    E8   |    1    |    2     |"
"In the context of the C64, How can I scroll the screen?","SCROLLING

    The display data may be scrolled up to one entire character space in
  both the horizontal and vertical direction. When used in conjunction with
  the smaller display window (above), scrolling can be used to create a
  smooth panning motion of display data while updating the system memory
  only when a new character row (or column) is required. Scrolling is also
  used to center a fixed display within the display window.

           BITS         |      REGISTER      |          FUNCTION
         X2,X1,X0       |      22 ($16)      |     Horizontal Position
         Y2,Y1,Y0       |      17 ($11)      |     Vertical Position"
"In the context of the C64, What is the list of instructions in the 6502 microprocessor?","INSTRUCTION SET - ALPHABETIC SEQUENCE

          ADC   Add Memory to Accumulator with Carry
          AND   'AND' Memory with Accumulator
          ASL   Shift left One Bit (Memory or Accumulator)
          BCC   Branch on Carry Clear
          BCS   Branch on Carry Set
          BEQ   Branch on Result Zero
          BIT   Test Bits in Memory with Accumulator
          BMI   Branch on Result Minus
          BNE   Branch on Result not Zero
          BPL   Branch on Result Plus
          BRK   Force Break
          BVC   Branch on Overflow Clear
          BVS   Branch on Overflow Set
          CLC   Clear Carry Flag
          CLD   Clear Decimal Mode
          CLI   Clear Interrupt Disable Bit
          CLV   Clear Overflow Flag
          CMP   Compare Memory and Accumulator
          CPX   Compare Memory and Index X
          CPY   Compare Memory and Index Y
          DEC   Decrement Memory by One
          DEX   Decrement Index X by One
          DEY   Decrement Index Y by One
          EOR   'Exclusive-OR' Memory with Accumulator
          INC   Increment Memory by One
          INX   Increment Index X by one
          INY   Increment Index Y by one
          JMP   Jump to New location
          JSR   Jump to New Location Saving Return Address
          LDA   Load Accumulator with Memory
          LDX   Load Index X with Memory
          LDY   Load Index Y with Memory
          LSR   Shift One Bit Right (Memory or Accumulator)
          NOP   No Operation
          ORA   'OR' Memory with Accumulator
          PHA   Push Accumulator on Stack
          PHP   Push Processor Status on Stack
          PLA   Pull Accumulator from Stack
          PLP   Pull Processor Status from Stack
          ROL   Rotate One Bit Left (Memory or Accumulator)
          ROR   Rotate One Bit Right (Memory or Accumulator)
          RTI   Return from Interrupt
          RTS   Return from Subroutine
          SBC   Subtract Memory from Accumulator with Borrow
          SEC   Set Carry Flag
          SED   Set Decimal Mode
          SEI   Set Interrupt Disable Status
          STA   Store Accumulator in Memory
          STX   Store Index X in Memory
          STY   Store Index Y in Merrory
          TAX   Transfer Accumulator to Index X
          TAY   Transfer Accumulator to Index Y
          TSX   Transfer Stack Pointer to Index X
          TXA   Transfer Index X to Accumulator
          TXS   Transfer Index X to Stack Register
          TYA   Transfer Index Y to Accumulator"
"In the context of the C64, What is the purpose of the Reset signal in the 6510 microprocessor?","SIGNAL DESCRIPTION

  Clocks (01, 02)

    The 6510 requires a two-phase non-overlapping clock that runs at the
  Vcc voltage level.

  Address Bus (A0-A15)

    These outputs are TTL compatible, capable of driving one standard TTL
  load and 130 pf.

  Data Bus (D0-D7)

    Eight pins are used for the data bus. This is a Bi-Directional bus,
  transferring data to and from the device and peripherals. The outputs are
  tri-state buffers capable of driving one standard TTL load and 130 pf.

  Reset

    This input is used to reset or start the microprocessor from a power
  down condition. During the time that this line is held low, writing to or
  from the microprocessor is inhibited. When a positive edge is detected on
  the input, the microprocessor will immediately begin the reset sequence.
    After a system initialization time of six clock cycles, the mask
  interrupt flag will be set and the microprocessor will load the program
  counter from the memory vector locations FFFC and FFFD. This is the start
  location for program control.
    After Vcc reaches 4.75 volts in a power-up routine, reset must be held
  low for at least two clock cycles. At this time the R/W signal will
  become valid.
    When the reset signal goes high following these two clock cycles, the
  microprocessor will proceed with the normal reset procedure detailed
  above.

  Interrupt Request (/IRQ)

    This TTL level input requests that an interrupt sequence begin within
  the microprocessor. The microprocessor will complete the current in-
  struction being executed before recognizing the request. At that time,
  the interrupt mask bit in the Status Code Register will be examined. If
  the interrupt mask flag is not set, the microprocessor will begin an

   interrupt sequence. The Program Counter and Processor Status Register are
  stored in the stack. The microprocessor will then set the interrupt mask
  flag high so that no further interrupts may occur. At the end of this
  cycle, the program counter low will be loaded from address FFFE, and
  program counter high from location FFFF, therefore transferring program
  control to the memory vector located at these addresses.

  Address Enable Control (AEC)

    The Address Bus is valid only when the Address Enable Control line is
  high. When low, the Address Bus is in a high-impedance state. This
  feature allows easy DMA and multiprocessor systems.

  I/O Port (P0-P7)

    Six pins are used for the peripheral port, which can transfer data to
  or from peripheral devices. The Output Register is located in RAM at
  address 0001, and the Data Direction Register is at Address 0000. The
  outputs are capable at driving one standard TTL load and 130 pf.

  Read/Write (R/W)

    This signal is generated by the microprocessor to control the direction
  of data transfers on the Data Bus. This line is high except when the
  microprocessor is writing to memory or a peripheral device."
"In the context of the C64, What are the key features of the 6526 Complex Interface Adapter (CIA) chip?","6526 COMPLEX INTERFACE ADAPTER
  (CIA) CHIP SPECIFICATIONS

  DESCRIPTION

    The 6526 Complex Interface Adapter (CIA) is a 65XX bus compatible
  peripheral interface device with extremely flexible timing and I/O
  capabilities.


  FEATURES

  o 16 Individually programmable 110 lines
  o 8 or 16-Bit handshaking on read or write
  o 2 independent, linkable 16-Bit interval timers
  o 24-hour (AM/PM) time of day clock with programmable alarm
  o 8-Bit shift register for serial I/O
  o 2 TTL load capability
  o CMOS compatible I/O lines
  o 1 or 2 MHz operation available"
"In the context of the C64, What is the purpose of the Indexed Indirect addressing mode in 6502 assembly language?","INDEXED INDIRECT

    Indexed indirect only allows usage of the X register as the index. This
  is the some as indirect indexed, except it is the zero page address of
  the pointer that is indexed, rather than the actual base address.
  Therefore, the actual base address IS the actual address because the
  index has already been used for the indirect. Index indirect would also
  be used if a table of indirect pointers were located in zero page memory,
  and the X register could then specify which indirect pointer to use.

 EXAMPLE:

    Let us suppose that location $02 contains $45, and location $03 con-
  tains $10. If the instruction to load the accumulator in the indexed
  indirect mode is executed and the specified zero page address is $02,
  then the actual address will be:

    Low order = contents of ($02+X)
    High order = contents of ($03+X)
    X register = $00

  Thus the actual pointer is in = $02 + X = $02.
    Therefore, the actual address is the indirect address contained in $02
  which is again $1045.
    The title of this mode does in fact imply the principle, although it
  may be difficult to grasp at first sight. Look at it this way:
    'I am going to deliver this letter to the fourth post office at address
  $01,MEMORY ST., and the address on the letter will then be delivered to
  $1600, MEMORY street.' This is equivalent to the code:


    LDA #$00    - load low order actual base address
    STA $06     - set the low byte of the indirect address
    LDA #$16    - load high order indirect address
    STA $07     - set the high byte of the indirect address
    LDX #$05    - set the indirect index (X)
    LDA ($02,X) - load indirectly indexed by X"
"In the context of the C64, How can you create your own character sets on the Commodore 64?","PROGRAMMABLE CHARACTERS

    Since the characters are stored in ROM, it would seem that there is no
  way to change them for customizing characters. However, the memory
  location that tells the VIC-II chip where to find the characters is a
  programmable register which can be changed to point to many sections of
  memory. By changing the character memory pointer to point to RAM, the
  character set may be programmed for any need.
    If you want your character set to be located in RAM, there are a few
  VERY IMPORTANT things to take into account when you decide to actually
  program your own character sets. In addition, there are two other
  important points you must know to create your own special characters:

    1) It is an all or nothing process. Generally, if you use your own
       character set by telling the VIC-II chip to get the character
       information from the area you have prepared in RAM, the standard
     Commodore 64 characters are unavailable to you. To solve this, you
     must copy any letters, numbers, or standard Commodore 64 graphics you
     intend to use into your own character memory in RAM. You can pick and
     choose, take only the ones you want, and don't even have to keep them
     in order!

    2) Your character set takes memory space away from your BASIC program.
       Of course, with 38K available for a BASIC program, most applications
       won't have problems.
   WARNING: You must be careful to protect the character set from being  
   overwritten by your BASIC program, which also uses the RAM.           

    There are two locations in the Commodore 64 to start your character set
  that should NOT be used with BASIC: location 0 and location 2048. The
  first should not be used because the system stores important data on
  page 0. The second can't be used because that is where your BASIC program
  starts! However, there are 6 other starting positions for your custom
  character set.
    The best place to put your character set for use with BASIC while
  experimenting is beginning at 12288 ($3000 in HEX). This is done by
  POKEing the low 4 bits of location 53272 with 12."
"In the context of the C64, What is the purpose of the AEC signal in the 6566/6567 video controller devices?","THEORY OF OPERATION

  SYSTEM INTERFACE

    The 6566/6567 video controller devices interact with the system data
  bus in a special way. A 65XX system requires the system buses only during
  the Phase 2 (clock high) portion of the cycle. The 6566/6567 devices take
  advantage of this feature by normally accessing system memory during the
  Phase 1 (clock low) portion of the clock cycle. Therefore, operations
  such as character data fetches and memory refresh are totally transparent
  to the processor and do not reduce the processor throughput. The video
  chips provide the interface control signals required to maintain this bus
  sharing.
    The video devices provide the signal AEC (address enable control) which
  is used to disable the processor address bus drivers allowing the video
  device to access the address bus. AEC is active low which, permits direct
  connection to the AEC input of the 65XX family. The AEC signal is
normally activated during Phase 1 so that processor operation is not
  affected. Because of this bus 'sharing', all memory accesses must be
  completed in 1/2 cycle. Since the video chips provide a 1-MHz clock
  (which must be used as system Phase 2), a memory cycle is 500 ns
  including address setup, data access and, data setup to the reading
  device.
    Certain operations of the 6566/6567 require data at a faster rate than
  available by reading only during the Phase 1 time; specifically, the ac-
  cess of character pointers from the video matrix and the fetch of sprite
  data. Therefore, the processor must be disabled and the data accessed
  during the Phase 2 clock. This is accomplished via the BA (bus available)
  signal. The BA line is normally high but is brought low during Phase 1 to
  indicate that the video chip will require a Phase 2 data access. Three
  Phase-2 times are allowed after BA low for the processor to complete any
  current memory accesses. On the fourth Phase 2 after BA low, the AEC
  signal will remain low during Phase 2 as the video chip fetches data. The
  BA line is normally connected to the RDY input of a 65XX processor. The
  character pointer fetches occur every eighth raster line during the
  display window and require 40 consecutive Phase 2 accesses to fetch the
  video matrix pointers. The sprite data fetches require 4 memory accesses as
  follows:


     PHASE 1   | sprite Pointer |   CONDITION: Every raster
     PHASE  2   | sprite Byte 1  | CONDITION : Each raster while sprite is displayed
     PHASE  1   | sprite Byte 2  | CONDITION :  Each raster while sprite is displayed
     PHASE  2   | sprite Byte 3  | CONDITION : Each raster while sprite is displayed


  The sprite pointers are fetched every other Phase 1 at the end of each
  raster line. As required, the additional cycles are used for sprite data
  fetches. Again, all necessary bus control is provided by the 6566/6567
  devices."
"In the context of the C64, What are the key differences in address output configurations between the 6566 and 6567 video interface chips?","MEMORY INTERFACE

    The two versions of the video interface chip, 6566 and 6567, differ in
  address output configurations. The 6566 has thirteen fully decoded
  addresses for direct connection to the system address bus. The 6567 has
  multiplexed addresses for direct connection to 64K dynamic RAMS. The
  least significant address bits, A06-A00, are present on A06-A00 while
  /RAS is brought low, while the most significant bits, A13-A08, are pres-
  ent on A05-A00 while /CAS is brought low. The pins A11-A07 on the 6567
  are static address outputs to allow direct connection of these bits to a
  conventional 16K (2K*8) ROM. (The lower order addresses require external
  latching.)"
"In the context of the C64, How are characters defined on the Commodore 64?","CHARACTER DEFINITIONS

    Each character is formed in an 8 by 8 grid of dots, where each dot may
  be either on or off. The Commodore 64 character images are stored in the
  Character Generator ROM chip. The characters are stored as a set of 8
  bytes for each character, with each byte representing the dot pattern of
  a row in the character, and each bit representing a dot. A zero bit means
  that dot is off, and a one bit means the dot is on.
    The character memory in ROM begins at location 53248 (when the I/O
  is switched off). The first 8 bytes from location 53248 ($D000) to 53255
  ($D007) contain the pattern for the @ sign, which has a character code
  value of zero in the screen memory. The next 8 bytes, from location
  53256 ($D008) to 53263 ($D00F), contain the information for forming the
  letter A.

    Each complete character set takes up 2K (2048 bits) of memory, 8 bytes
  per character and 256 characters. Since there are two character sets, one
  for upper case and graphics and the other with upper and lower case, the
  character generator ROM takes up a total of 4K locations."
"In the context of the C64, Wcan you talk about branches and testing in 6502 and 6510?","BRANCHES AND TESTING

    Another very important principle in machine language is the ability to
  test, and detect certain conditions, in a similar fashion to the 'IF...
  THEN, IF... GOTO' structure in CBM BASIC.
    The various flags in the status register are affected by different in-
  structions in different ways. For example, there is a flag that is set
  when an instruction has caused a zero result, and is reset when a result
  is not zero. The instruction:

    LDA #$00

  will cause the zero result flag to be set, because the instruction has
  resulted in the accumulator containing a zero.
    There are a set of instructions that will, given a particular
  condition, branch to another part of the program. An example of a branch
  instruction is BEQ, which means Branch if result EQual to zero. The
  branch instructions branch if the condition is true, and if not, the
  program continues onto the next instruction, as if nothing had occurred.
  The branch instructions branch not by the result of the previous
  instructions), but by internally examining the status register. As was
  just mentioned, there is a zero result flag in the status register. The
  BEQ instruction branches if the zero result flag (known as Z) is set.
  Every branch instruction has an opposite branch instruction. The BEQ
  instruction has an opposite instruction BNE, which means Branch on result
  Not Equal to zero (i.e., Z not set).
  
    The index registers have a number of associated instructions which
  modify their contents. For example, the INX instruction INcrements the X
  index register. If the X register contained $FF before it was incremented
  (the maximum number the X register can contain), it will 'wrap around'
  back to zero. If you wanted a program to continue to do something until
  you had performed the increment of the X index that pushed it around to
  zero, you could use the BNE instruction to continue 'looping' around,
  until X became zero.
  
    The reverse of INX, is DEX, which is DEcrement the X index register. If
  the X index register is zero, DEX wraps around to $FF. Similarly, there
  are INY and DEY for the Y index register.
 But what if a program didn't want to wait until X or Y had reached (or
  not reached) zero? Well there are comparison instructions, CPX and CPY,
  which allow the machine language programmer to test the index registers
  with specific values, or even the contents of memory locations. If you
  wanted to see if the X register contained $40, you would use the
  instruction:

    CPX #$40         - compare X with the 'value' $40.
    BEQ              - branch to somewhere else in the
    (some other        program, if this condition is 'true.'
     part of the
     program)


  The compare, and branch instructions play a major part in any machine
  language program.
    The operand specified in a branch instruction when using 64MON is the
  address of the part of the program that the branch goes to when the
  proper conditions are met. However, the operand is only an offset, which
  gets you from where the program currently is to the address specified.
  This offset is just one byte, and therefore the range that a branch
  instruction can branch to is limited. It can branch from 128 bytes back-
  ward, to 127 bytes forward.

 
  NOTE: This is a total range of 255 bytes which is, of course, the
  maximum range of values one byte can contain.
  
    64MON will tell you if you 'branch out of range' by refusing to 'as-
  semble' that particular instruction. But don't worry about that now be-
  cause it's unlikely that you will have such branches for quite a while.
  The branch is a 'quick' instruction by machine language standards because
  of the 'offset' principle as opposed to an absolute address. 64MON allows
  you to type in an absolute address, and it calculates the correct offset.
  This is just one of the 'comforts' of using an assembler."
"In the context of the C64, What is the purpose of the ADC instruction in the given table?","ADC               Add memory to accumulator with carry                ADC


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Immediate     |   ADC #Oper           |    69   |    2    |    2     |
 Zero Page     |   ADC Oper            |    65   |    2    |    3     |
 Zero Page,X   |   ADC Oper,X          |    75   |    2    |    4     |
 Absolute      |   ADC Oper            |    60   |    3    |    4     |
 Absolute,X    |   ADC Oper,X          |    70   |    3    |    4*    |
 Absolute,Y    |   ADC Oper,Y          |    79   |    3    |    4*    |
 (Indirect,X)  |   ADC (Oper,X)        |    61   |    2    |    6     |
 (Indirect),Y  |   ADC (Oper),Y        |    71   |    2    |    5*    |
   * Add 1 if page boundary is crossed."
"In the context of the C64, What are the 6526 interface signals?","6526 INTERFACE SIGNALS

  02-Clock Input

    The 02 clock is a TTL compatible input used for internal device opera-
  tion and as a timing reference for communicating with the system data
  bus.

  /CS-Chip Select Input

    The /CS input controls the activity of the 6526. A low level on /CS
  while 02 is high causes the device to respond to signals on the R/W and
  address (RS) lines. A high on /CS prevents these lines from controlling
  the 6526. The /CS line is normally activated (low) at 02 by the
  appropriate address combination.

  R/W-Read/Write Input

    The R/W signal is normally supplied by the microprocessor and controls
  the direction of data transfers of the 6526. A high on R/W indicates
  a read (data transfer out of the 6526), while a low indicates a write
  (data transfer into the 6526).

  RS3-RS0-Address Inputs

    The address inputs select the internal registers as described by the
  Register Map.

  DB7-DB0-Data Bus Inputs/Outputs

    The eight data bus pins transfer information between the 6526 and the
  system data bus. These pins are high impedance inputs unless CS is low
  and R/W and 02 are high to read the device. During this read, the data
  bus output buffers are enabled, driving the data from the selected
  register onto the system data bus.

  IRQ-Interrupt Request Output

    IRQ is an open drain output normally connected to the processor inter-
  rupt input. An external pullup resistor holds the signal high, allowing
  multiple IRQ outputs to be connected together. The IRQ output is normally
  off (high impedance) and is activated low as indicated in the functional
  description.

  /RES-Reset Input

    A low on the RES pin resets all internal registers. The port pins are
  set as inputs and port registers to zero (although a read of the ports
  will return all highs because of passive pullups). The timer control
  registers are set to zero and the timer latches to all ones. All other
  registers are reset to zero."
"In the context of the C64, What are the 9 addressing modes supported by the 6502/ 6510 CPU?","ADDRESSING MODES

  ACCUMULATOR ADDRESSING - This form of addressing is represented with a
  one byte instruction, implying an operation on the accumulator.

  IMMEDIATE ADDRESSING - In immediate addressing, the operand is contained
  in the second byte of the instruction, with no further memory addressing
  required.

  ABSOLUTE ADDRESSING - In absolute addressing, the second byte of the
  instruction specifies the eight low order bits of the effective address
  while the third byte specifies the eight high order bits. Thus, the
  absolute addressing mode allows access to the entire 64K bytes of
  addressable memory.

  ZERO PAGE ADDRESSING - The zero page instructions allow for shorter code
  and execution times by only fetching the second byte of the instruction
  and assuming a zero high address byte. Careful use of the zero page can
  result in significant increase in code efficiency.

  INDEXED ZERO PAGE ADDRESSING - (X, Y indexing)-This form of addressing is
  used in conjunction with the index register and is referred to as 'Zero
  Page, X' or 'Zero Page, Y.' The effective address is calculated by adding
  the second byte to the contents of the index register. Since this is a
  form of 'Zero Page' addressing, the content of the second byte references
  a location in page zero. Additionally, due to the 'Zero Page' addressing
  nature of this mode, no carry is added to the high order 8 bits of memory
  and crossing of page boundaries does not occur.

  INDEXED ABSOLUTE ADDRESSING - (X, Y indexing)-This form of addressing is
  used in conjunction with X and Y index register and is referred to as
  'Absolute, X,' and 'Absolute, Y.' The effective address is formed by
  adding the contents of X and Y to the address contained in the second and
  third bytes of the instruction. This mode allows the index register to
  contain the index or count value and the instruction to contain the base
  address. This type of indexing allows any location referencing and the
  index to modify multiple fields resulting in reduced coding and execution
  time.

  IMPLIED ADDRESSING - In the implied addressing mode, the address
  containing the operand is implicitly stated in the operation code of the
  instruction.

  RELATIVE ADDRESSING - Relative addressing is used only with branch
  instructions and establishes a destination for the conditional branch.
  The second byte of the instruction becomes the operand which is an
  'Offset' added to the contents of the lower eight bits of the program
  counter when the counter is set at the next instruction. The range of the
  offset is -128 to +127 bytes from the next instruction.

  INDEXED INDIRECT ADDRESSING - In indexed indirect addressing (referred to
  as [Indirect, X]), the second byte of the instruction is added to the
  contents of the X index register, discarding the carry. The result of
  this addition points to a memory location on page zero whose contents is
  the low order eight bits of the effective address. The next memory loca-
  tion in page zero contains the high order eight bits of the effective ad-
  dress. Both memory locations specifying the high and low order bytes of

  the effective address must be in page zero.

  INDIRECT INDEXED ADDRESSING - In indirect indexed addressing (referred to
  as [Indirect], Y), the second byte of the instruction points to a memory
  location in page zero. The contents of this memory location is added to
  the contents of the Y index register, the result being the low order
  eight bits of the effective address. The carry from this addition is
  added to the contents of the next page zero memory location, the result
  being the high order eight bits of the effective address.

  ABSOLUTE INDIRECT - The second byte of the instruction contains the low
  order eight bits of a memory location. The high order eight bits of that
  memory location is contained in the third byte of the instruction. The
  contents of the fully specified memory location is the low order byte of
  the effective address. The next memory location contains the high order
  byte of the effective address which is loaded into the sixteen bits of
  the program counter."
"In the context of the C64, What is the purpose of the SCREEN kernal function in Commodore 64 programming?","B-26. Function Name: SCREEN

    Purpose: Return screen format
    Call address: $FFED (hex) 65517 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Stack requirements: 2
    Registers affected: X, Y

    Description: This routine returns the format of the screen, e.g., 40
  columns in X and 25 lines in Y. The routine can be used to determine what
  machine a program is running on. This function has been implemented on
  the Commodore 64 to help upward compatibility of your programs.
  How to Use:

    1) Call this routine.

  EXAMPLE:

    JSR SCREEN
    STX MAXCOL
    STY MAXROW"
"In the context of the C64, Give the list of kernal error codes?","KERNAL ERROR CODES

    The following is a list of error messages which can occur when using
  the KERNAL routines. If an error occurs during a KERNAL routine , the
  carry bit of the accumulator is set, and the number of the error message
  is returned in the accumulator.

  | NOTE: Some KERNAL I/O routines do not use these codes for error       |
  | messages. Instead, errors are identified using the KERNAL READST      |
  | routine.                                                              |


ERROR VALUES
  | NUMBER|                          MEANING                              |
  |   0   |  Routine terminated by the <STOP> key                         |
  |   1   |  Too many open files                                          |
  |   2   |  File already open                                            |
  |   3   |  File not open                                                |
  |   4   |  File not found                                               |
  |   5   |  Device not present                                           |
  |   6   |  File is not an input file                                    |
  |   7   |  File is not an output file                                   |
  |   8   |  File name is missing                                         |
  |   9   |  Illegal device number                                        |
  |  240  |  Top-of-memory change RS-232 buffer allocation/deallocation   |"
"In the context of the C64, What are the five main activities performed by the KERNAL during its power-up sequence?","KERNAL POWER-UP ACTIVITIES

  1) On power-up, the KERNAL first resets the stack pointer, and clears
     decimal mode.
  2) The KERNAL then checks for the presence of an autostart ROM cartridge
     at location $8000 HEX (32768 decimal). If this is present, normal
     initialization is suspended, and control is transferred to the car-
     tridge code. If an autostart ROM is not present, normal system ini-
     tialization continues.
  3) Next, the KERNAL initializes all INPUT/OUTPUT devices. The serial bus
     is initialized. Both 6526 CIA chips are set to the proper values for
     keyboard scanning, and the 60-Hz timer is activated. The SID chip is
     cleared. The BASIC memory map is selected and the cassette motor is
     switched off.
  4) Next, the KERNAL performs a RAM test, setting the top and bottom of
     memory pointers. Also, page zero is initialized, and the tape buffer
     is set up.
       The RAM TEST routine is a nondestructive test starting at location
     $0300 and working upward. Once the test has found the first non-RAM
     location, the top of RAM has its pointer set. The bottom of memory is
     always set to $0800, and the screen setup is always set at $0400.
  5) Finally, the KERNAL performs these other activities. I/O vectors are
     set to default values. The indirect jump table in low memory is estab-
     lished. The screen is then cleared, and all screen editor variables
     reset. Then the indirect at $A000 is used to start BASIC."
"In the context of the C64, What is the detail for the instruction STA?","STA                  STA Store accumulator in memory                  STA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   STA Oper            |    85   |    2    |    3     |
  |  Zero Page,X   |   STA Oper,X          |    95   |    2    |    4     |
  |  Absolute      |   STA Oper            |    80   |    3    |    4     |
  |  Absolute,X    |   STA Oper,X          |    90   |    3    |    5     |
  |  Absolute,Y    |   STA Oper, Y         |    99   |    3    |    5     |
  |  (Indirect,X)  |   STA (Oper,X)        |    81   |    2    |    6     |
  |  (Indirect),Y  |   STA (Oper),Y        |    91   |    2    |    6     |"
"In the context of the C64, What is the purpose of the instruction PHA in 6502?","PHA                   PHA Push accumulator on stack                   PHA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PHA                 |    48   |    1    |    3     |"
"In the context of the C64, What feature of the VIC-II chip allows for the detection of collisions between sprites and background data?","COLLISION DETECTS

    One of the more interesting aspects of the VIC-II chip is its collision
  detection abilities. Collisions can be detected between sprites, or be-
  tween sprites and background data. A collision occurs when a non-zero
  part of a sprite overlaps a non-zero portion of another sprite or char-
  acters on the screen."
"In the context of the C64, What is the primary way to access and modify the memory locations used for music synthesis in the Commodore 64?","Your Commodore computer is equipped with one of the most sophisticated
  electronic music synthesizers available on any computer. It comes
  complete with three voices, totally addressable, ATTACK/DECAY/SUSTAIN/
  RELEASE (ADSR), filtering, modulation, and 'white noise.' All of these
  capabilities are directly available for you through a few easy to use
  BASIC and/or assembly language statements and functions. This means that
  you can make very complex sounds and songs using programs that are
  relatively simple to design.
    This section of your Programmer's Reference Guide has been created to
  help you explore all the capabilities of the 6581 'SID' chip, the sound
  and music synthesizer inside your Commodore computer. We'll explain both
  the theory behind musical ideas and the practical aspects of turning
  those ideas into real finished songs on your Commodore computer.
    You need not be an experienced programmer nor a music expert to achieve
  exciting results from the music synthesizer. This section is full of
  programming examples with complete explanations to get you started.
    You get to the sound generator by POKEing into specified memory
  locations. A full list of the locations used is provided in Appendix O.
  We will go through each concept, step by step. By the end you should be
  able to create an almost infinite variety of sounds, and be ready to
  perform experiments with sound on your own.
    Each section of this chapter begins by giving you an example and a full
  line-by-line description of each program, which will show you how to use
  the characteristic being discussed. The technical explanation is for you
  to read whenever you are curious about what is actually going on. The
  workhorse of your sound programs is the POKE statement. POKE sets the
  indicated memory location (MEM) equal to a specified value (NUM).
    POKE MEM,NUM
    The memory locations (MEM) used for music synthesis start at 54272
  ($D400) in the Commodore 64. The memory locations 54272 to 54296
  inclusive are the POKE locations you need to remember when you're using
  the 6581 (SID) chip register map. Another way to use the locations above
  is to remember only location 54272 and then add a number from 0 through
  24 to it. By doing this you can POKE all the locations from 54272 to
  54296 that you need from the SID chip. The numbers (NUM) that you use in
  your POKE statement must be between 0 and 255, inclusive.
    When you've had a little more practice with making music, then you can
  get a little more involved, by using the PEEK function. PEEK is a
  function that is equal to the value currently in the indicated memory
  location.
    X=PEEK(MEM)

    The value of the variable X is set equal to the current contents of
  memory location MEM.
    Of course, your programs include other BASIC commands, but for a full
  explanation of them, refer to the BASIC Statements section of this
  manual."
"In the context of the C64, HWhat is the process for positioning a sprite beyond the 255th pixel across the screen in a Commodore 64 game?","POKEING AN X POSITION: The possible values of X are 0 to 255, counting
  from left to right. Values 0 to 23 place all or part of the sprite OUT OF
  THE VIEWING AREA off the left side of the screen... values 24 to 255
  place the sprite IN THE VIEWING AREA up to the 255th position (see next
  paragraph for settings beyond the 255th X position). To place the sprite
  at one of these positions, just type the X-POSITION POKE for the sprite
  you're using. For example, to POKE sprite I at the farthest left X
  position IN THE VIEWING AREA, type: POKE V+2,24.

    X VALUES BEYOND THE 255TH POSITION: To get beyond the 255th position
  across the screen, you need to make a SECOND POKE using the numbers in
  the 'RIGHT X' row of the chart (Figure 3-5). Normally, the horizontal (X)
  numbering would continue past the 255th position to 256, 257, etc., but
  because registers only contain 8 bits we must use a 'second register' to
  access the RIGHT SIDE of the screen and start our X numbering over again
  at 0. So to get beyond X position 255, you must POKE V+16 and a number
  (depending on the sprite). This gives you 65 additional X positions
  (renumbered from 0 to 65) in the viewing area on the RIGHT side of the
  viewing screen. (You can actually POKE the right side X value as high as
  255, which takes you off the right edge of the viewing screen.)

    POKEING A Y POSITION: The possible values of Y are 0 to 255, counting
  from top to bottom. Values 0 to 49 place all or part of the sprite OUT
  OF THE VIEWING AREA off the TOP of the screen. Values 50 to 229 place the
  sprite IN THE VIEWING AREA. Values 230 to 255 place all or part of the
  sprite OUT OF THE VIEWING AREA off the BOTTOM of the screen.

    Let's see how this X-Y positioning works, using sprite 1. Type this
  program:
start tok64 page159.prg
  10 print'{clear}':v=53248:pokev+21,2:poke2041,13
  20 fors=832to895:pokes,255:next:pokev+40,7
  30 pokev+2,24
  40 pokev+3,50
stop tok64

  This simple program establishes sprite 1 as a solid box and positions it
  at the upper left corner of the screen. Now change line 40 to read:

    40 POKE V+3,229

  This moves the sprite to the bottom left corner of the screen. Now let's
  test the RIGHT X LIMIT of the sprite. Change line 30 as shown:

    30 POKE V+2,255

  This moves the sprite to the RIGHT but reaches the RIGHT X LIMIT, which
  is 255. At this point, the 'most significant bit' in register 16 must be
  SET. In other words, you must type POKE V+ 16 and the number shown in the
  'RIGHT X' column in the X-Y POKE CHART above to RESTART the X position
  counter at the 256th pixel/position on the screen. Change line 30 as
  follows:

    30 POKE V+16,PEEK(V+16)OR 2:POKE V+2,0

  POKE V+16,2 sets the most significant bit of the X position for sprite 1
  and restarts it at the 256th pixel/position on the screen. POKE V+2,0
  displays the sprite at the NEW POSITION ZERO, which is now reset to the
  256th pixel.
    To get back to the left side of the screen, you must reset the most
  significant bit of the X position counter to 0 by typing (for sprite 1):

    POKE V+16, PEEK(V+16)AND 253

    TO SUMMARIZE how the X positioning works... POKE the X POSITION for any
  sprite with a number from 0 to 255. To access a position beyond the 255th
  position/pixel across the screen, you must use an additional POKE (V+16)
  which sets the most significant bit of the X position and start counting
  from 0 again at the 256th pixel across the screen.

  This POKE starts the X numbering over again from 0 at the 256th position
  (Example: POKE V+16,PEEK(V+16)OR 1 and POKE V,1 must be included to place
  sprite 0 at the 257th pixel across the screen.) To get back to the left
  side X positions you have to TURN OFF the control setting by typing
  POKE V+16,PEEK(V+16)AND 254."
"In the context of the C64, How do you control sprite to background priority?","Sprite to background priority is controllable by the SPRITE-BACK-GROUND priority register located at 53275 ($D01B).
  Each sprite has a bit in this register. If that bit is 0, that sprite has a higher priority
  than the background on the screen. In other words, the sprite appears in
  front of background data. If that bit is a 1, that sprite has a lower
  priority than the background. Then the sprite appears behind the back-
  ground data."
"In the context of the C64, What is the PHP instruction in 6502?","PHP                 PHP Push processor status on stack                PHP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PHP                 |    08   |    1    |    3     |"
"In the context of the C64, What is the instruction for storing the value in the X register in memory?","STX                    STX Store index X in memory                    STX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   STX Oper            |    86   |    2    |    3     |
  |  Zero Page,Y   |   STX Oper,Y          |    96   |    2    |    4     |
  |  Absolute      |   STX Oper            |    8E   |    3    |    4     |"
"In the context of the C64, What are the three simple steps to follow when using the KERNAL?","HOW TO USE THE KERNAL


    When writing machine language programs it is often convenient to use
  the routines which are already part of the operating system for input/
  output, access to the system clock, memory management, and other similar
  operations. It is an unnecessary duplication of effort to write these
  routines over and over again, so easy access to the operating system
  helps speed machine language programming.
    As mentioned before, the KERNAL is a jump table. This is just a col-
  lection of JMP instructions to many operating system routines.
    To use a KERNAL routine you must first make all of the preparations
  that the routine demands. If one routine says that you must call another
  KERNAL routine first, then that routine must be called. If the routine
  expects you to put a number in the accumulator, then that number must be
  there. Otherwise your routines have little chance of working the way you
  expect them to work.
    After all preparations are made, you must call the routine by means of
  the JSR instruction. All KERNAL routines you can access are structured as
  SUBROUTINES, and must end with an RTS instruction. When the KERNAL
  routine has finished its task, control is returned to your program at the
  instruction after the JSR.
    Many of the KERNAL routines return error codes in the status word or
  the accumulator if you have problems in the routine. Good programming
  practice and the success of your machine language programs demand that
  you handle this properly. If you ignore an error return, the rest of your
  program might 'bomb.'
    That's all there is to do when you're using the KERNAL. Just these
  three simple steps:

    1) Set up
    2) Call the routine
    3) Error handling

    The following conventions are used in describing the KERNAL routines:

  - FUNCTION NAME: Name of the KERNAL routine.

  - CALL ADDRESS: This is the call address of the KERNAL routine, given in
    hexadecimal.

  - COMMUNICATION REGISTERS: Registers listed under this heading are used
    to pass parameters to and from the KERNAL routines.

  - PREPARATORY ROUTINES: Certain KERNAL routines require that data be set
    up before they can operate. The routines needed are listed here.

  - ERROR RETURNS: A return from a KERNAL routine with the CARRY set
    indicates that an error was encountered in processing. The accumulator
    will contain the number of the error.

  - STACK REQUIREMENTS: This is the actual number of stack bytes used by
    the KERNAL routine.

  - REGISTERS AFFECTED: All registers used by the KERNAL routine are listed
    here.

  - DESCRIPTION: A short tutorial on the function of the KERNAL routine is
    given here.

                       USER CALLABLE KERNAL ROUTINES
  +--------+-------------------+------------------------------------------+
  |        |      ADDRESS      |                                          |
  |  NAME  +---------+---------+                 FUNCTION                 |
  |        |   HEX   | DECIMAL |                                          |
  +--------+---------+---------+------------------------------------------+"
"In the context of the C64, On can I mix 6502 assembler and Basic on the Commodore 64?","There are several methods of using BASIC and machine language on the
  Commodore 64, including special statements as part of CBM BASIC as well
  as key locations in the machine. There are five main ways to use machine
  language routines from BASIC on the Commodore 64. They are:


                1) The BASIC SYS statement
                2) The BASIC USR function
                3) Changing one of the RAM I/O vectors
                4) Changing one of the RAM interrupt vectors
                5) Changing the CHRGET routine


    1) The BASIC statement SYS X causes a JUMP to a machine language
       subroutine located at address X. The routine must end with an RTS
       (ReTurn from Subroutine) instruction. This will transfer control
       back to BASIC.
         Parameters are generally passed between the machine language
       routine and the BASIC program using the BASIC PEEK and POKE
       statements, and their machine language equivalents.
         The SYS command is the most useful method of combining BASIC with
       machine language. PEEKs and POKEs make multiple parameter passing
       easy. There can be many SYS statements in a program, each to a
       different (or even the same) machine language routine.

    2) The BASIC function USR(X) transfers control to the machine language
       subroutine located at the address stored in locations 785 and 786.
       (The address is stored in standard low-byte/high-byte format.) The
       value X is evaluated and passed to the machine language subroutine
       through floating point accumulator #1, located beginning at address
       $61 (see memory map for more details). A value may be returned back
       to the BASIC program by placing it in the floating point
       accumulator. The machine language routine must end with an RTS
       instruction to return to BASIC.
         This statement is different from the SYS, because you have to set
       up an indirect vector. Also different is the format through which
       the variable is passed (floating point format). The indirect vector
       must be changed if more than one machine language routine is used.


    3) Any of the inpUt/OUtPUT or BASIC internal routines accessed through
       the vector table located on page 3 (see ADDRESSING MODES, ZERO PAGE)
       can be replaced, or amended by user code. Each 2-byte vector
       consists of a low byte and a high byte address which is used by the
       operating system.
         The KERNAL VECTOR routine is the most reliable way to change any
       of the vectors, but a single vector can be changed by POKES. A new
       vector will point to a user prepared routine which is meant to
       replace or augment the standard system routine. When the appropriate
       BASIC command is executed, the user routine will be executed. If
       after executing the user routine, it is necessary to execute the
       normal system routine, the user program must JMP (JUMP) to the
       address formerly contained in the vector. If not, the routine must
       end with a RTS to transfer control back to BASIC.

    4) The HARDWARE INTERRUPT (IRQ) VECTOR can be changed. Every 1/60th of
       a second, the operating system transfers control to the routine
       specified by this vector. The KERNAL normally uses this for timing,
       keyboard scanning, etc. If this technique is used, you should always
       transfer control to the normal IRQ handling routine, unless the
       replacement routine is prepared to handle the CIA chip. (REMEMBER to
       end the routine with an RTI (ReTurn from Interrupt) if the CIA is
       handled by the routine).
         This method is useful for tasks which must happen concurrently
       with a BASIC program, but has the drawback of being more difficult.


NOTE: ALWAYS DISABLE INTERRUPTS BEFORE CHANGING THIS VECTOR!

    5) The CHRGET routine is used by BASIC to get each character/token.
       This makes it simple to add new BASIC commands. Naturally, each new
       command must be executed by a user written machine language
       subroutine. A common way to use this method is to specify a
       character (@ for example) which will occur before any of the new
       commands. The new CHRGET routine will search for the special
       character. If none is present, control is passed to the normal BASIC
       CHRGET routine. If the special character is present, the new command
       is interpreted and executed by your machine language program. This
       minimizes the extra execution time added by the need to search for
       additional commands. This technique is often called a wedge."
"In the context of the C64, What is the purpose of the kernal SECOND routine ?","B-27. Function Name: SECOND

    Purpose: Send secondary address for LISTEN
    Call address: $FF93 (hex) 65427 (decimal)
    Communication registers: A
    Preparatory routines: LISTEN
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine is used to send a secondary address to an
  I/O device after a call to the LISTEN routine is made, and the device is
  commanded to LISTEN. The routine canNOT be used to send a secondary
  address after a call to the TALK routine.
    A secondary address is usually used to give setup information to a
  device before I/O operations begin.
    When a secondary address is to be sent to a device on the serial bus,
  the address must first be ORed with $60.

  How to Use:

    1) load the accumulator with the secondary address to be sent.
    2) Call this routine.

  EXAMPLE:

    ;ADDRESS DEVICE #8 WITH COMMAND (SECONDARY ADDRESS) #15
    LDA #8
    JSR LISTEN
    LDA #15
    JSR SECOND"
"In the context of the C64, What is the purpose of the VECTOR kernal function?","Function Name: VECTOR

    Purpose: Manage RAM vectors
    Call address: $FF8D (hex) 65421 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y


    Description: This routine manages all system vector jump addresses
  stored in RAM. Calling this routine with the the accumulator carry bit
  set stores the current contents of the RAM vectors in a list pointed to
  by the X and Y registers. When this routine is called with the carry
  clear, the user list pointed to by the X and Y registers is transferred
  to the system RAM vectors. The RAM vectors are listed in the memory map.


 NOTE: This routine requires caution in its use. The best way to use it
 is to first read the entire vector contents into the user area, alter 
 the desired vectors, and then copy the contents back to the system    
 vectors.                                                              

  How to Use:

  READ THE SYSTEM RAM VECTORS

    1) Set the carry.
    2) Set the X and y registers to the address to put the vectors.
    3) Call this routine.

  LOAD THE SYSTEM RAM VECTORS

    1) Clear the carry bit.
    2) Set the X and Y registers to the address of the vector list in RAM
       that must be loaded.
    3) Call this routine.


  EXAMPLE:
    ;CHANGE THE INPUT ROUTINES TO NEW SYSTEM
    LDX #<USER
    LDY #>USER
    SEC
    JSR VECTOR      ;READ OLD VECTORS
    LDA #<MYINP     ;CHANGE INPUT
    STA USER+10
    LDA #>MYINP
    STA USER+11
    LDX #<USER
    LDY #>USER
    CLC
    JSR VECTOR      ;ALTER SYSTEM
    ...
    USER *=*+26"
"In the context of the C64, What is the purpose of the SCNKEY kernal function in the Commodore 64?","B-25. Function Name: SCNKEY

    Purpose: Scan the keyboard
    Call address: $FF9F (hex) 65439 (decimal)
    Communication registers: None
    Preparatory routines: IOINIT
    Error returns: None
    Stack requirements: 5
    Registers affected: A, X, Y

    Description: This routine scans the Commodore 64 keyboard and checks
  for pressed keys. It is the same routine called by the interrupt handler.
  If a key is down, its ASCII value is placed in the keyboard queue. This
  routine is called only if the normal IRQ interrupt is bypassed.

  How to Use:

  1) Call this routine.

  EXAMPLE:

    GET  JSR SCNKEY      ;SCAN KEYBOARD
         JSR GETIN       ;GET CHARACTER
         CMP #0          ;IS IT NULL?
         BEQ GET         ;YES... SCAN AGAIN
         JSR CHROUT      ;PRINT IT"
"In the context of the C64, What is the purpose of the two 9-pin Game Ports on the Commodore 64?","THE GAME PORTS

    The Commodore 64 has two 9-pin Game Ports which allow the use of
  joysticks, paddies, or a light pen. Each port will accept either one joy-
  stick or one paddle pair. A light pen can be plugged into Port A (only)
  for special graphic control, etc. This section gives you examples of how
  to use the joysticks and paddies from both BASIC and machine language.
    The digital joystick is connected to CIA #1 (MOS 6526 Complex Interface
  Adapter). This input/output device also handles the paddle fire buttons
  and keyboard scanning. The 6526 CIA chip has 16 registers which are in
  memory locations 56320 through 56335 inclusive ($DC00 to $DC0F). Port A
  data appears at location 56320 (DC00) and Port B data is found at
  location 56321 ($DC01).
    A digital joystick has five distinct switches, four of the switches are
  used for direction and one of the switches is used for the fire button.



    These switches correspond to the lower 5 bits of the data in location
  56320 or 56321. Normally the bit is set to a one if a direction is NOT
  chosen or the fire button is NOT pressed. When the fire button is
  pressed, the bit (bit 4 in this case) changes to a 0. 
  
  
  
  
  To read the
  joystick from BASIC, the following subroutine should be used:


start tok64 page344.prg
  10 fork=0to10:rem set up direction string
  20 readdr$(k):next
  30 data'','n','s','','w','nw'
  40 data'sw','','e','ne','se'
  50 print'going...';
  60 gosub100:rem read the joystick
  65 ifdr$(jv)=''then80:rem check if a direction was chosen
  70 printdr$(jv);' ';:rem output which direction
  80 iffr=16then60:rem check if fire button was pushed
  90 print'-----f-----i-----r-----e-----!!!':goto60
  100 jv=peek(56320):rem get joystick value
  110 fr=jvand16:rem form fire button status
  120 jv=15-(jvand15):rem form direction value
  130 return
stop tok64

  +-----------------------------------------------------------------------+
  | NOTE: For the second joystick, set JV = PEEK (56321).                 |
  +-----------------------------------------------------------------------+

    The values for JV correspond to these directions:

                       +-------------+---------------+
                       | JV EQUAL TO |   DIRECTION   |
                       +-------------+---------------+
                       |      0      |          NONE |
                       |      1      |            UP |
                       |      2      |          DOWN |
                       |      3      |             - |
                       |      4      |          LEFT |
                       |      5      |     UP & LEFT |
                       |      6      |   DOWN & LEFT |
                       |      7      |             - |
                       |      8      |         RIGHT |
                       |      9      |    UP & RIGHT |
                       |     10      |  DOWN & RIGHT |
                       +-------------+---------------+"
"In the context of the C64, What is the purpose of the instruction TAX in the 6502 assembly language?","TAX                TAX Transfer accumulator to index X                TAX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TAX                 |    AA   |    1    |    2     |"
"In the context of the C64, WHAT DOES MACHINE CODE LOOK LIKE?","WHAT DOES MACHINE CODE LOOK LIKE?

    You should be familiar with the PEEK and POKE commands in the CBM BASIC
  language for changing memory locations. You've probably used them for
  graphics on the screen, and for sound effects. Each memory location has
  its own number which identifies it. This number is known as the 'address'
  of a memory location. If you imagine the memory in the Commodore 64 as a
  street of buildings, then the number on each door is, of course, the
  address. Now let's look at which parts of the street are used for what
  purposes."
"In the context of the C64, What is the purpose of the ACPTR  kernal routine in a Commodore 64 system?","Description: This is the routine to use when you want to get informa-
  tion from a device on the serial bus, like a disk. This routine gets a
  byte of data off the serial bus using full handshaking. The data is
  returned in the accumulator. To prepare for this routine the TALK routine
  must be called first to command the device on the serial bus to send data
  through the bus. If the input device needs a secondary command, it must
  be sent by using the TKSA KERNAL routine before calling this routine.
  Errors are returned in the status word. The READST routine is used to
  read the status word.


  How to Use:

    0) Command a device on the serial bus to prepare to send data to
       the Commodore 64. (Use the TALK and TKSA KERNAL routines.)
    1) Call this routine (using JSR).
    2) Store or otherwise use the data.


  EXAMPLE:

    ;GET A BYTE FROM THE BUS
    JSR ACPTR
    STA DATA"
"In the context of the C64, how do I display a sprite beyond the 255TH X-POSITION?","DISPLAYING A SPRITE BEYOND THE 255TH X-POSITION

    Displaying a sprite beyond the 255th X position requires a special POKE
  which SETS the most significant bit of the X position and starts over at
  the 256th pixel position across the screen. Here's how it works...
    First, you POKE V+16 with the number for the sprite you're using (check
  the 'RIGHT X' row in the X-Y chart... we'll use sprite 0). Now we assign
  an X position, keeping in mind that the X counter starts over from 0 at
  the 256th position on the screen. Change line 50 to read as follows:
    50 POKE V+16,1:POKE V,24:POKE V+1,75

  This line POKEs V+ 16 with the number required to 'open up' the right
  side of the screen... the new X position 24 for sprite 0 now begins 24
  pixels to the RIGHT of position 255. To check the right edge of the
  screen, change line 60 to:

    60 POKE V+16,1:POKE V,65:POKE V+1,75

    Some experimentation with the settings in the sprite chart will give
  you the settings you need to position and move sprites on the left and
  right sides of the screen. The section on 'moving sprites' will also
  increase your understanding of how sprite positioning works."
"In the context of the C64, What is the range of values that the volume control can be set to?","VOLUME CONTROL

    Chip register 24 contains the overall volume control. The volume can be
  set anywhere between 0 and 15. The other four bits are used for purposes
  we'll get into later. For now it is enough to know volume is 0 to 15.
  Look at line 30 to see how it's set in Example Program 1."
"In the context of the C64, What is the purpose of the IOBASE routine in the Commodore 64 KERNAL?","B-12. Function Name: IOBASE

    Purpose: Define I/O memory page
    Call address: $FFF3 (hex) 65523 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns:
    Stack requirements: 2
    Registers affected: X, Y


    Description: This routine sets the X and Y registers to the address of
  the memory section where the memory mapped 110 devices are located. This
  address can then be used with an offset to access the memory mapped I/O
  devices in the Commodore 64. The offset is the number of locations from
  the beginning of the page on which the I/O register you want is located.
  The X register contains the low order address byte, while the Y register
  contains the high order address byte.
    This routine exists to provide compatibility between the Commodore 64,
  VIC-20, and future models of the Commodore 64. If the J/0 locations for
  a machine language program are set by a call to this routine, they should
  still remain compatible with future versions of the Commodore 64, the
  KERNAL and BASIC.


  How to Use:

    1) Call this routine by using the JSR instruction.
    2) Store the X and the Y registers in consecutive locations.
    3) Load the Y register with the offset.
    4) Access that I/O location.

  EXAMPLE:

    ;SET THE DATA DIRECTION REGISTER OF THE USER PORT TO 0 (INPUT)
    JSR IOBASE
    STX POINT       ;SET BASE REGISTERS
    STY POINT+1
    LDY #2
    LDA #0          ;OFFSET FOR DDR OF THE USER PORT
    STA (POINT),Y   ;SET DDR TO 0"
"In the context of the C64, What is the purpose of the IOINIT function?","B-13. Function Name: IOINIT

    Purpose: Initialize I/O devices
    Call Address: $FF84 (hex) 65412 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns:
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine initializes all input/output devices and
  routines. It is normally called as part of the initialization procedure
  of a Commodore 64 program cartridge.

  EXAMPLE:
    JSR IOINIT"
"In the context of the C64, What determines the order in which sprites appear on the screen when they overlap?","SPRITE PRIORITIES

    You can actually make different sprites seem to move IN FRONT OF or
  BEHIND each other on the screen. This incredible three dimensional illu-
  sion is achieved by the built-in SPRITE PRIORITIES which determine which
  sprites have priority over the others when 2 or more sprites OVERLAP on
  the screen.
    The rule is 'first come, first served' which means lower-numbered
  sprites AUTOMATICALLY have priority over higher-numbered sprites. For
  example, if you display sprite 0 and sprite 1 so they overlap on the
  screen, sprite 0 will appear to be IN FRONT OF sprite 1. Actually, sprite
  0 always supersedes all the other sprites because it's the lowest num-
  bered sprite. In comparison, sprite 1 has priority over sprites 2-7;
  sprite 2 has priority over sprites 3-7, etc. Sprite 7 (the last sprite)
  has LESS PRIORITY than any of the other sprites, and will always appear
  to be displayed 'BEHIND' any other sprites which overlap its position.
    To illustrate how priorities work, change lines 50, 60, and 70 in the
  program above to the following:


  50 POKEV,24:POKEV+1,50:POKEV+16,0
  60 POKEV+2,34:POKEV+3,60
  70 POKEV+4,44:POKEV+5,70


  You should see a white sprite on top of a yellow sprite on top of an
  orange sprite. Of course, now that you see how priorities work, you can
  also MOVE SPRITES and take advantage of these priorities in your ani-
  mation."
"In the context of the C64, What is the primary function of the built-in program that interprets and executes CBM BASIC commands on the Commodore 64?","The C64 OPERATING SYSTEM of the Commodore 64 then allows you to type on the
  keyboard, and use the built-in SCREEN EDITOR on the Commodore 64. The
  SCREEN EDITOR allows you to move the cursor, DELete, INSert, etc., and
  is, in fact, only one part of the operating system that is built in for
  your convenience.
    All of the commands that are available in CBM BASIC are simply
  recognized by another huge machine language program built into your
  Commodore 64. This huge program 'RUNS' the appropriate piece of machine
  language depending on which CBM BASIC command is being executed. This
  program is called the BASIC INTERPRETER, because it interprets each
  command, one by one, unless it encounters a command it does not
  understand, and then the familiar message appears:

    ?SYNTAX ERROR

    READY."
"In the context of the C64, What is the purpose of the ACPTR kernal function?","Function Name: ACPTR

    Purpose: Get data from the serial bus
    Call address: $FFA5 (hex) 65445 (decimal)
    Communication registers: A
    Preparatory routines: TALK, TKSA
    Error returns: See READST
    Stack requirements: 13
    Registers affected: A, X"
"In the context of the C64, What is the assembly language instruction that stores the value in the accumulator into memory at the specified address?","STY                    STY Store index Y in memory                    STY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   STY Oper            |    84   |    2    |    3     |
  |  Zero Page,X   |   STY Oper,X          |    94   |    2    |    4     |
  |  Absolute      |   STY Oper            |    8C   |    3    |    4     |"
"In the context of the C64, What forms of data storage do floppy diskettes allow?","DATA STORAGE ON FLOPPY DISKETTES

    Diskettes allow 3 different forms of data storage. Sequential files are
  similar to those on tape, but several can can be used at the same time.
  Relative files let you organize the data into records, and then read and
  replace individual records within the file. Random files let you work
  with data anywhere on the disk. They are organized into 256 byte sections
  called blocks.
    The PRINT# statement's limitations are discussed in the section on
  cassette tape. The same limitations to format apply on the disk. RETURNs
  or commas are needed to separate your data. The CHR$(0) is still read by
  the GET# statement as an empty string.
    Relative and random files both make use of separate data and command
  'channels.' Data written to the disk goes through the data channel, where
  it is stored in a temporary buffer in the disk's RAM. When the record or
  block is complete, a command is sent through the command channel that
  tells the drive where to put the data, and the entire buffer is written.
    Applications that require large amounts of data to be processed are
  best stored in relative disk files. These will use the least amount of
  time and provide the best flexibility for the programmer. Your disk drive
  manual gives a complete programming guide to use of disk files."
"In the context of the C64, HWhat is the purpose of the SAVE routine in the  kernal?","B-24. Function Name: SAVE

    Purpose: Save memory to a device
    Call address: $FFD8 (hex) 65496 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: SETLFS, SETNAM
    Error returns: 5,8,9, READST
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine saves a section of memory. Memory is saved
  from an indirect address on page 0 specified by the accumulator to the
  address stored in the X and Y registers. It is then sent to a logical
  file on an input/output device. The SETLFS and SETNAM routines must be
  used before calling this routine. However, a file name is not required to
  SAVE to device 1 (the Datassette(TM) recorder). Any attempt to save to
  other devices without using a file name results in an error.

  
  NOTE: Device 0 (the keyboard), device 2 (RS-232), and device 3 (the 
  screen) cannot be SAVEd to. If the attempt is made, an error occurs,
  and the SAVE is stopped.                                            

  How to Use:

    0) Use the SETLFS routine and the SETNAM routine (unless a SAVE with no
       file name is desired on 'a save to the tape recorder'),
    1) Load two consecutive locations on page 0 with a pointer to the start
       of your save (in standard 6502 low byte first, high byte next
       format).
    2) Load the accumulator with the single byte page zero offset to the
       pointer.
    3) Load the X and Y registers with the low byte and high byte re-
       spectively of the location of the end of the save.
    4) Call this routine.

  EXAMPLE:

    LDA #1              ;DEVICE = 1:CASSETTE
    JSR SETLFS
    LDA #0              ;NO FILE NAME
    JSR SETNAM
    LDA PROG            ;LOAD START ADDRESS OF SAVE
    STA TXTTAB          ;(LOW BYTE)
    LDA PROG+1
    STA TXTTA B+1       ;(HIGH BYTE)
    LDX VARTAB          ;LOAD X WITH LOW BYTE OF END OF SAVE
    LDY VARTAB+1        ;LOAD Y WITH HIGH BYTE
    LDA #<TXTTAB        ;LOAD ACCUMULATOR WITH PAGE 0 OFFSET
    JSR SAVE"
"In the context of the C64, What is the purpose of the UNTLK kernal function?","Function Name: UNTLK

    Purpose: Send an UNTALK command
    Call address: $FFAB (hex) 65451 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine transmits an UNTALK command on the serial
  bus. All devices previously set to TALK will stop sending data when this
  command is received.

  How to Use:
    1) Call this routine.

  EXAMPLE:
    JSR UNTALK"
"In the context of the C64, What happens when you close an RS-232 data channel?","CLOSING AN RS-232 DATA CHANNEL

    Closing an RS-232 file discards all data in the buffers at the time of
  execution (whether or not it had been transmitted or printed out), stops
  all RS-232 transmitting and receiving, sets the RTS and transmitted data
  (Sout) lines high, and removes both RS-232 buffers.


  BASIC SYNTAX:

    CLOSE lfn


  KERNAL ENTRY:

    CLOSE ($FFC3)-See Memory Map for more information on entry and exit
  conditions.

  | NOTE: Care should be taken to ensure all data is transmitted before   |
  | closing the channel. A way to check this from BASIC is:               |
  |                                                                       |
  | 100 SS=ST: IF(SS=0 OR SS=8) THEN 100                                  |
  | 110 CLOSE lfn                                                         |"
"In the context of the C64, What is the purpose of the TALK kernal function?","Function Name: TALK

    Purpose: Command a device on the serial bus to TALK
    Call address: $FFB4 (hex) 65460 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: To use this routine the accumulator must first be loaded
  with a device number between 0 and 31. When called, this routine then
  ORs bit by bit to convert this device number to a talk address. Then this
  data is transmitted as a command on the serial bus.

  How to Use:

    1) Load the accumulator with the device number.
    2) Call this routine.

  EXAMPLE:

    ;COMMAND DEVICE #4 TO TALK
    LDA #4
    JSR TALK"
"In the context of the C64, What is the purpose of the SETLFS kernal routine?","B-28. Function Name: SETLFS

    Purpose: Set up a logical file
    Call address: $FFBA (hex) 65466 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: None


    Description: This routine sets the logical file number, device address,
  and secondary address (command number) for other KERNAL routines.
    The logical file number is used by the system as a key to the file
  table created by the OPEN file routine. Device addresses can range from 0
  to 31. The following codes are used by the Commodore 64 to stand for the
  CBM devices listed below:


                  ADDRESS          DEVICE

                     0            Keyboard
                     1            Datassette(TM)
                     2            RS-232C device
                     3            CRT display
                     4            Serial bus printer
                     8            CBM serial bus disk drive


    Device numbers 4 or greater automatically refer to devices on the
  serial bus.
    A command to the device is sent as a secondary address on the serial
  bus after the device number is sent during the serial attention
  handshaking sequence. If no secondary address is to be sent, the Y index
  register should be set to 255.

  How to Use:

    1) Load the accumulator with the logical file number.
    2) Load the X index register with the device number.
    3) Load the Y index register with the command.


  EXAMPLE:

    FOR LOGICAL FILE 32, DEVICE #4, AND NO COMMAND:
    LDA #32
    LDX #4
    LDY #255
    JSR SETLFS"
"In the context of the C64, What is a common method used to write machine language programs?","HOW DO YOU WRITE MACHINE LANGUAGE PROGRAMS?

    Since machine language programs reside in memory, and there is no
  facility in your Commodore 64 for writing and editing machine language
  programs, you must use either a program to do this, or write for yourself
  a BASIC program that 'allows' you to write machine language.
    The most common methods used to write machine language programs are
  assembler programs. These packages allow you to write machine language
  instructions in a standardized mnemonic format, which makes the machine
  language program a lot more readable than a stream of numbers! Let's
  review: A program that allows you to write machine language programs in
  mnemonic format is called an assembler. Incidentally, a program that
  displays a machine language program in mnemonic format is called a
  disassembler. Available for your Commodore 64 is a machine language
  monitor cartridge (with assembler/disassembler, etc.) made by Commodore."
"In the context of the C64, What is the assembly language instruction that transfers the value of the index register X to the accumulator in 6502?","TXA                TXA Transfer index X to accumulator                TXA
  
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TXA                 |    8A   |    1    |    2     |"
"In the context of the C64, What is the breakdown of the Commodore 64's memory map?","I/O BREAKDOWN

    D000-D3FF   VIC (Video Controller)                     1 K Bytes
    D400-D7FF   SID (Sound Synthesizer)                    1 K Bytes
    D800-DBFF   Color RAM                                  1 K Nybbles
    DC00-DCFF   CIA1 (Keyboard)                            256 Bytes
    DD00-DDFF   CIA2 (Serial Bus, User Port/RS-232)        256 Bytes
    DE00-DEFF   Open I/O slot #l (CP/M Enable)             256 Bytes
    DF00-DFFF   Open I/O slot #2 (Disk)                    256 Bytes

    The two open I/O slots are for general purpose user I/O, special pur-
  pose I/O cartridges (such as IEEE), and have been tentatively designated
  for enabling the Z-80 cartridge (CP/M option) and for interfacing to a
  low-cost high-speed disk system.
    The system provides for 'auto-start' of the program in a Commodore 64
  Expansion Cartridge. The cartridge program is started if the first nine
  bytes of the cartridge ROM starting at location 32768 ($8000) contain
  specific data. The first two bytes must hold the Cold Start vector to be
  used by the cartridge program. The next two bytes at 32770 ($8002) must
  be the Warm Start vector used by the cartridge program. The next three
  bytes must be the letters, CBM, with bit 7 set in each letter. The last
  two bytes must be the digits '80' in PET ASCII."
"In the context of the C64, What is the method for turning on and off individual sprites without affecting others?","SPRITEMAKING NOTES

            Alternative Sprite Memory Pointers and Memory Locations
                            Using Cassette Buffer
  
  TURNING ON SPRITES:

    You can turn on any individual sprite by using POKE V+21 and the number
  from the chart... BUT... turning on just ONE sprite will turn OFF any
  others. To turn on TWO OR MORE sprites, ADD TOGETHER the numbers of the
  sprites you want to turn on (Example: POKE V+21, 6 turns on sprites 1 and
  2). Here is a method you can use to turn one sprite off and on without
  affecting any of the others (useful for animation).

  EXAMPLE:

    To turn off just sprite 0 type: POKE V+21,PEEK V+21AND(255-1). Change
  the number 1 in (255-1) to 1,2,4,8,16,32,64, or 128 (for sprites 0-7). To
  re-enable the sprite and not affect the other sprites currently turned
  on, POKE V+21, PEEK(V+21)OR 1 and change the OR 1 to OR 2 (sprite 2), OR
  4 (sprite 3), etc."
"In the context of the C64, What is the purpose of the RESTOR kernal function?","B-23. Function Name: RESTOR

    Purpose: Restore default system and interrupt vectors
    Call address: $FF8A (hex) 65418 (decimal)
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: This routine restores the default values of all system
  vectors used in KERNAL and BASIC routines and interrupts. (See the Memory
  Map for the default vector contents). The KERNAL VECTOR routine is used
  to read and alter individual system vectors.

  How to Use:
    1) Call this routine.

  EXAMPLE:
    JSR RESTOR"
"In the context of the C64, How you detect when a sprite collides with another?","SPRITE COLLISION:

    You can detect whether a sprite has collided with another sprite by
  using this line: IF PEEK(V+30)ANDX=XTHEN [insert action here]. This line
  checks to see if a particular sprite has collided with ANY OTHER SPRITE,
  where X equals 1 for sprite 0, 2 for sprite 1, 4 for sprite 2, 8 for
  sprite 3, 16 for sprite 4, 32 for sprite 5, 64 for sprite 6, and 128 for
  sprite 7. To check to see if the sprite has collided with a 'BACKGROUND
  CHARACTER' use this line: IF PEEK(V+31)ANDX=XTHEN [insert action here]."
"In the context of the C64, What is the range of memory locations where color memory is always located?","COLOR MEMORY

    Color memory can NOT move. It is always located at locations 55296
  ($D800) through 56295 ($DBE7). Screen memory (the 1000 locations starting
  at 1024) and color memory are used differently in the different graphics
  modes. A picture created in one mode will often look completely different
  when displayed in another graphics mode."
"In the context of the C64, What is the primary requirement for creating multi-colored sprites in a specific mode?","USING MULTI-COLOR:

    You can create multi-colored sprites although using multi-color mode
  requires that you use PAIRS of pixels instead of individual pixels in
  your sprite picture (in other words each colored 'dot' or 'block' in the
  sprite will consist of two pixels side by side). You have 4 colors to
  choose from: Sprite Color (chart,above), Multi-Color 1, Multi-Color 2 and
  'Background Color' (background is achieved by using zero settings which
  let the background color 'show through'). Consider one horizontal 8-pixel
  block in a sprite picture. The color of each PAIR of pixels is determined
  according to whether the left, right, or both pixels are solid."
"In the context of the C64, What is the Kernal?","THE KERNAL


    One of the problems facing programmers in the microcomputer field is
  the question of what to do when changes are made to the operating system
  of the computer by the company. Machine language programs which took much
  time to develop might no longer work, forcing major revisions in the
  program. To alleviate this problem, Commodore has developed a method of
  protecting software writers called the KERNAL.
    Essentially, the KERNAL is a standardized JUMP TABLE to the input,
  output, and memory management routines in the operating system. The
  locations of each routine in ROM may change as the system is upgraded.
  But the KERNAL jump table will always be changed to match. If your
  machine language routines only use the system ROM routines through the
  KERNAL, it will take much less work to modify them, should that need ever
  arise.
    The KERNAL is the operating system of the Commodore 64 computer. All
  input, output, and memory management is controlled by the KERNAL.
    To simplify the machine language programs you write, and to make sure
  that future versions of the Commodore 64 operating system don't make your
  machine language programs obsolete, the KERNAL contains a jump table for
  you to use. By taking advantage of the 39 input/output routines and other
  utilities available to you from the table, not only do you save time, you
  also make it easier to translate your programs from one Commodore
  computer to another.
    The jump table is located on the last page of memory, in read-only
  memory (ROM).
    To use the KERNAL jump table, first you set up the parameters that the
  KERNAL routine needs to work. Then JSR (Jump to SubRoutine) to the proper
  place in the KERNAL jump table. After performing its function, the KERNAL
  transfers control back to your machine language program. Depending on
  which KERNAL routine you are using, certain registers may pass parameters
  back to your program. The particular registers for each KERNAL routine
  may be found in the individual descriptions of the KERNAL subroutines.

    A good question at this point is why use the jump table at all? Why not
  just JSR directly to the KERNAL subroutine involved? The jump table is
  used so that if the KERNAL or BASIC is changed, your machine language
  programs will still work. In future operating systems the routines may
  have their memory locations moved around to a different position in the
  memory map... but the jump table will still work correctly!"
"In the context of the C64, What is 64Mon?","64MON

    The 64MON cartridge available from your local dealer, is a program that
  allows you to escape from the world of CBM BASIC, into the land of
  machine language. It can display the contents of the internal registers
  in the 6510 microprocessor, and it allows you to display portions of mem-
  ory, and change them on the screen, using the screen editor. It also has
  a built-in assembler and disassembler, as well as many other features
  that allow you to write and edit machine language programs easily. You
  don't HAVE to use an assembler to write machine language, but the task is
  considerably easier with it. If you wish to write machine language
  programs, it is strongly suggested that you purchase an assembler of some
  sort. Without an assembler you will probably have to 'POKE' the machine
  language program into memory, which is totally unadvisable. This manual
  will give its examples in the format that 64MON uses, from now on. Nearly
  all assembler formats are the same, therefore the machine language
  examples shown will almost certainly be compatible with any assembler.
  But before explaining any of the other features of 64MON, the hexadecimal
  numbering system must be explained."
"In the context of the C64, What is the purpose of the 6502 instruction TXS?","TXS              TXS Transfer index X to stack pointer                TXS
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TXS                 |    9A   |    1    |    2     |"
"In the context of the C64, What is the purpose of the SETMSG kernal routine?","B-29. Function Name: SETMSG

    Purpose: Control system message output
    Call address: $FF90 (hex) 65424 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A

    Description: This routine controls the printing of error and control
  messages by the KERNAL. Either print error messages or print control mes-
  sages can be selected by setting the accumulator when the routine is
  called. FILE NOT FOUND is an example of an error message. PRESS PLAY ON
  CASSETTE is an example of a control message.
    Bits 6 and 7 of this value determine where the message will come from.
  If bit 7 is 1, one of the error messages from the KERNAL is printed. If
  bit 6 is set, control messages are printed.

  How to Use:

    1) Set accumulator to desired value.
    2) Call this routine.

  EXAMPLE:

    LDA #$40
    JSR SETMSG          ;TURN ON CONTROL MESSAGES
    LDA #$80
    JSR SETMSG          ;TURN ON ERROR MESSAGES
    LDA #0
    JSR SETMSG          ;TURN OFF ALL KERNAL MESSAGES"
"In the context of the C64, What is the purpose of the TKSA kernal function in a serial communication protocol?","Function Name: TKSA

    Purpose: Send a secondary address to a device commanded to TALK
    Call address: $FF96 (hex) 65430 (decimal)
    Communication registers: A
    Preparatory routines: TALK
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine transmits a secondary address on the serial
  bus for a TALK device. This routine must be called with a number between
  0 and 31 in the accumulator. The routine sends this number as a secondary
  address command over the serial bus. This routine can only be called
  after a call to the TALK routine. It will not work after a LISTEN.

  How to Use:

    0) Use the TALK routine.
    1) Load the accumulator with the secondary address.
    2) Call this routine.

  EXAMPLE:

    ;TELL DEVICE #4 TO TALK WITH COMMAND #7
    LDA #4
    JSR TALK
    LDA #7
    JSR TALKSA"
"In the context of the C64, What is the purpose of the two-byte pointers $00F7 and $00F9 in the system?","RECEIVER/TRANSMITTER BUFFER BASE LOCATION POINTERS


    $00F7-REBUF-A two-byte pointer to the Receiver Buffer base location.
    $00F9-ROBUF-A two-byte pointer to the Transmitter Buffer base location.

    The two locations above are set up by the OPEN KERNAL routine, each
  pointing to a different 256-byte buffer. They are de-allocated by writing
  a zero into the high order bytes ($00F8 and $00FA), which is done by the
  CLOSE KERNAL entry. They may also be allocated/de-allocated by the
  machine language programmer for his/her own purposes, removing/creating
  only the buffer(s) required. When using a machine language program that
  allocates these buffers, care must be taken to make sure that the top of
  memory pointers stay correct, especially if BASIC programs are expected
  to run at the same time."
"In the context of the C64, What is the purpose of the SETTIM kernal function?","B-31. Function Name: SETTIM

    Purpose: Set the system clock
    Call address: $FFDB (hex) 65499 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: None

    Description: A system clock is maintained by an interrupt routine that
  updates the clock every 1/60th of a second (one 'jiffy'). The clock is
  three bytes long, which gives it the capability to count up to 5,184,000
  jiffies (24 hours). At that point the clock resets to zero. Before
  calling this routine to set the clock, the accumulator must contain the
  most significant byte, the X index register the next most significant
  byte, and the Y index register the least significant byte of the initial
  time setting (in jiffies).

  How to Use:
    1) Load the accumulator with the MSB of the 3-byte number to set the
       clock.
    2) Load the X register with the next byte.
    3) Load the Y register with the LSB.
    4) Call this routine.

  EXAMPLE:
   ;SET THE CLOCK TO 10 MINUTES = 3600 JIFFIES
   LDA #0               ;MOST SIGNIFICANT
   LDX #>3600
   LDY #<3600           ;LEAST SIGNIFICANT
   JSR SETTIM"
"In the context of the C64, What is the purpose of the UNLSN kernal function?","Function Name: UNLSN

    Purpose: Send an UNLISTEN command
    Call address: $FFAE (hex) 65454 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine commands all devices on the serial bus to
  stop receiving data from the Commodore 64 (i.e., UNLISTEN). Calling this
  routine results in an UNLISTEN command being transmitted on the serial
  bus. Only devices previously commanded to listen are affected. This
  routine is normally used after the Commodore 64 is finished sending data
  to external devices. Sending the UNLISTEN commands the listening devices
  to get off the serial bus so it can be used for other purposes.

  How to Use:
    1) Call this routine.

  EXAMPLE:
    JSR UNLSN"
"In the context of the C64, What is the instruction for disabling the interrupt in the 6502 microprocessor?","SEI                 SEI Set interrupt disable status                  SED

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   SEI                 |    78   |    1    |    2     |"
"In the context of the C64, What is the purpose of the TSX instruction in the 6502 assembly ?","TSX              TSX Transfer stack pointer to index X                TSX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TSX                 |    BA   |    1    |    2     |"
"In the context of the C64, What are some important considerations when setting sprite pointer settings in RAM memory?","DIFFERENT SPRITE POINTER SETTINGS:

    These sprite pointer settings are RECOMMENDATIONS ONLY.
    Caution: you can set your sprite pointers anywhere in RAM memory but if
  you set them too 'low' in memory a long BASIC program may overwrite your
  sprite data, or vice versa. To protect an especially LONG BASIC PROGRAM
  from overwriting sprite data, you may want to set the sprites at a higher
  area of memory (for example, 2040,192 for sprite 0 at locations 12288 to
  12350... 2041,193 at locations 12352 to 12414 for sprite 1 and so on...
  by adjusting the memory locations from which sprites get their 'data,'
  you can define as many as 64 different sprites plus a sizable BASIC
  program. To do this, define several sprite 'shapes' in your DATA
  statements and then redefine a particular sprite by changing the
  'pointer' so the sprite you are using is 'pointed' at different areas of
  memory containing different sprite picture data. See the 'Dancing Mouse'
  to see how this works. If you want two or more sprites to have THE SAME
  SHAPE (you can still change position and color of each sprite), use the
  same sprite pointer and memory location for the sprites you want to match
  (for example, you can point sprites 0 and 1 to the same location by using
  POKE 2040,192 and POKE 2041, 192)."
"In the context of the C64, What is the purpose of crunching"" a program in the context of sprite programming?""","CRUNCHING YOUR SPRITE PROGRAMS                                        

                                                                         
   Here's a helpful 'crunching' tip: The program described above is      
   already short, but it can be made even shorter by 'crunching' it      
   smaller. In our example we list the key sprite settings on separate   
   program lines so you can see what's happening in the program. In      
   actual practice, a good programmer would probably write this program  
   as a TWO LINE PROGRAM... by 'crunching' it as follows:                
                                                                         
   10 PRINTCHR$(147):V=53248:POKEV+21,1:POKE2040.13:POKEV+39,1           
   20 FORS=832TO894:POKES,255:NEXT:POKEV,24:POKEV+1,100                  
                                                                         
   For more tips on how to crunch your programs so they fit in less      
  memory and run more efficiently, see the 'crunching guide' on Page 24."
"In the context of the C64, Ho do you position a sprite on the screen?","POSITIONING SPRITES ON THE SCREEN

    The entire display screen is divided into a grid of X and Y coordi-
  nates, like a graph. The X COORDINATE is the HORIZONTAL position across
  the screen and the Y COORDINATE is the VERTICAL position up and down (see
  Figure 3-4).
    To position any sprite on the screen, you must POKE TWO SETTINGS...
  the X position and the Y position... these tell the computer where to
  display the UPPER LEFT HAND CORNER of the sprite. Remember that a sprite
  consists of 504 individual pixels, 24 across by 21 down... so if you POKE
  a sprite onto the upper left corner of your screen, the sprite will be
  displayed as a graphic image 24 pixels ACROSS and 21 pixels DOWN starting
  at the X-Y position you defined. The sprite will be displayed based on
  the upper left corner of the entire sprite, even if you define the sprite
  using only a small part of the 24X21-pixel sprite area.
    To understand how X-Y positioning works, study the following diagram
  (Figure 3-5), which shows the X and Y numbers in relation to your display
  screen. Note that the GREY AREA in the diagram shows your television
  viewing area... the white area represents positions which are OFF your
  viewing screen...

    To display a sprite in a given location, You must POKE the X and Y
  settings for each SPRITE... remembering that every sprite has its own
  unique X POKE and Y POKE."
"In the context of the C64, What is the step-by-step guide for creating a sprite?","CREATING A SPRITE... STEP BY STEP

    To make this as easy as possible for you, we've put together this
  simple step by step guide to help you draw your own sprites.

  STEP 1:

  Write the spritemaking program shown here ON A PIECE OF PAPER... note
  that line 100 starts a special DATA section of your program which will
  contain the 63 numbers you need to create your sprite.

  STEP 2:

  Color in the pixels on the spritemaking grid on Page 162 (or use a piece
  of graph paper... remember, a sprite has 24 squares across and 21 squares
  down). We suggest you use a pencil and draw lightly so you can reuse this
  grid. You can create any image you like, but for our example we'll draw
  a simple box.

  STEP 3:

  Look at the first EIGHT pixels. Each column of pixels has a number (128,
  64, 32, 16, 8, 4, 2, 1). The special type of addition we are going to
  show you is a type of BINARY ARITHMETIC which is used by most computers
  as a special way of counting. 
  STEP 4:

  Add up the numbers of the SOLID pixels. This first group of eight pixels
  is completely solid, so the total number is 255.

  STEP 5:

  Enter that number as the FIRST DATA STATEMENT in line 100 of the
  Spritemaking Program below. Enter 255 for the second and third groups
  of eight.

  STEP 6:

  Look at the FIRST EIGHT PIXELS IN THE SECOND ROW of the sprite. Add up
  the values of the solid pixels. Since only one of these pixels is solid,
  the total value is 128. Enter this as the first DATA number in line 101.


  STEP 7:

  Add up the values of the next group of eight pixels (which is 0 because
  they're all BLANK) and enter in line 101. Now move to the next group of
  pixels and repeat the process for each GROUP OF EIGHT PIXELS (there are
  3 groups across each row, and 21 rows). This will give you a total of 63
  numbers. Each number represents ONE group of 8 pixels, and 63 groups of
  eight equals 504 total individual pixels. Perhaps a better way of looking
  at the program is like this... each line in the program represents ONE
  ROW in the sprite. Each of the 3 numbers in each row represents ONE GROUP
  OF EIGHT PIXELS. And each number tells the computer which pixels to make
  SOLID and which pixels to leave blank.

  STEP 8:

  CRUNCH YOUR PROGRAM INTO A SMALLER SPACE BY RUNNING TOGETHER ALL THE DATA
  STATEMENTS, AS SHOWN IN THE SAMPLE PROGRAM BELOW. Note that we asked you
  to write your sprite program on a piece of paper. We did this for a good
  reason. The DATA STATEMENT LINES 100-120 in the program in STEP 1 are
  only there to help you see which numbers relate to which groups of pixels
  in your sprite. Your final program should be 'crunched' like this:

start tok64 page165.prg
  10 print'{clear}':poke53280,5:poke53281,6
  20 v=53248:pokev+34,3
  30 poke 53269,4:poke2042,13
  40 forn=0to62:readq:poke832+n,q:next
  100 data255,255,255,128,0,1,128,0,1,128,0,1,144,0,1,144,0,1,144,0,1,144,0
  101 data1,144,0,1,144,0,1,144,0,1,144,0,1,144,0,1,144,0,1,128,0,1,128,0,1
  102 data128,0,1,128,0,1,128,0,1,128,0,1,255,255,255
  200 x=200:y=100:poke53252,x:poke53253,y
stop tok64"
"In the context of the C64, What is the priority of a sprite that will always appear in front of or on top of all other sprites?","SPRITE PRIORITY:

    Priority means one sprite will appear to move 'in front of' or 'behind'
  another sprite on the display screen. Sprites with more priority always
  appear to move 'in front of' or 'on top of' sprites with less priority.
  The rule is that lower numbered sprites have priority over higher
  numbered sprites. Sprite 0 has priority over all other sprites. Sprite 7
  has no priority in relation to the other sprites. Sprite 1 has priority
  over sprites 2-7, etc. If you put two sprites in the some position, the
  sprite with the higher priority will appear IN FRONT OF the sprite with
  the lower priority. The sprite with lower priority will either be
  obscured, or will 'show through' (from 'behind') the sprite with higher
  priority."
"In the context of the C64, What is the instruction that transfers the accumulator to index Y in 6502?","TAY                TAY Transfer accumulator to index Y                TAY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TAY                 |    A8   |    1    |    2     |"
"In the context of the C64, Can you talk about the C64 memory management?","MEMORY MANAGEMENT ON THE
  COMMODORE 64

    The Commodore 64 has 64K bytes of RAM. It also has 20K bytes of ROM,
  containing BASIC, the operating system, and the standard character set.
  It also accesses input/output devices as a 4K chunk of memory. How is
  this all possible on a computer with a 16-bit address bus, that is
  normally only capable of addressing 64K?
    The secret is in the 6510 processor chip itself. On the chip is an
  input/output port. This port is used to control whether RAM or ROM or I/O
  will appear in certain portions of the system's memory. The port is also
  used to control the Datassette(TM), so it is important to affect only the
  proper bits.
    The 6510 input/output port appears at location 1. The data direction
  register for this port appears at location 0. The port is controlled like
  any of the other input/output ports in the system... the data direction
  controls whether a given bit will be an input or an output, and the
  actual data transfer occurs through the port itself. The lines in the
  6510 control port are defined as follows:


  |  NAME   |BIT| DIRECTION  |                 DESCRIPTION                |
  |  LORAM  | 0 |   OUTPUT   | Control for RAM/ROM at $A000-$BFFF         |
  |  HIRAM  | 1 |   OUTPUT   | Control for RAM/ROM at $E000-$FFFF         |
  |  CHAREN | 2 |   OUTPUT   | Control for I/O/ROM at $D000-$DFFF         |
  |         | 3 |   OUTPUT   | Cassette write line                        |
  |         | 4 |   INPUT    | Cassette switch sense (0=play button down) |
  |         | 5 |   OUTPUT   | Cassette motor control (0=motor spins)     |


    The proper value for the data direction register is as follows:

                              BITS 5 4 3 2 1 0
                              ----------------
                                   1 0 1 1 1 1

  (where 1 is an output, and 0 is an input).

    This gives a value of 47 decimal. The Commodore 64 automatically sets
  the data direction register to this value.
    The control lines, in general, perform the function given in their de-
  scriptions. However, a combination of control lines are occasionally used
  to get a particular memory configuration.
    LORAM (bit 0) can generally be thought of as a control line which banks
  the 8K byte BASIC ROM in and out of the microprocessor address space.
  Normally, this line is HIGH for BASIC operation. If this line is
  programmed LOW, the BASIC ROM will disappear from the memory map and be
  replaced by 8K bytes of RAM from $A000-$BFFF.
    HIRAM (bit 1) can generally be thought of as a control line which banks
  the 8K byte KERNAL ROM in and out of the microprocessor address space.
  Normally, this line is HIGH for BASIC operation. If this line is
  programmed LOW, the KERNAL ROM will disappear from the memory map and be
  replaced by 8K bytes of RAM from $E000-$FFFF.
    CHAREN (bit 2) is used only to bank the 4K byte character generator ROM
  in or out of the microprocessor address space. From the processor point
  of view, the character ROM occupies the same address space as the I/O
  devices ($D000-$DFFF). When the CHAREN line is set to 1 (as is normal),
  the I/O devices appear in the microprocessor address space, and the
  character ROM is not accessable. When the CHAREN bit is cleared to 0, the
  character ROM appears in the processor address space, and the I/O devices
  are not accessable. (The microprocessor only needs to access the
  character ROM when downloading the character set from ROM to RAM. Special
  care is needed for this... see the section on PROGRAMMABLE CHARACTERS in
  the GRAPHICS chapter). CHAREN can be overridden by other control lines in
  certain memory configurations. CHAREN will have no effect on any memory
  configuration without I/O devices. RAM will appear from $D000-$DFFF
  instead.


  | NOTE: In any memory map containing ROM, a WRITE (a POKE) to a ROM     |
  | location will store data in the RAM 'under' the ROM. Writing to a ROM |
  | location stores data in the 'hidden' RAM. For example, this allows a  |
  | hi-resolution screen to be kept underneath a ROM, and be changed      |
  | without having to bank the screen back into the processor address     |
  | space. Of course a READ of a ROM location will return the contents of |
  | the ROM, not the 'hidden' RAM.                                        |"
"In the context of the C64, What is the OP CODE for the instruction SED in 6502?","SED                       SED Set decimal mode                        SED
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   SED                 |    F8   |    1    |    2     |"
"In the context of the C64, What is the purpose of the UDTIM kernal function?","Function Name: UDTIM

    Purpose: Update the system clock
    Call address: $FFEA (hex) 65514 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X

    Description: This routine updates the system clock. Normally this
  routine is called by the normal KERNAL interrupt routine every 1/60th of
  a second. If the user program processes its own interrupts this routine
  must be called to update the time. In addition, the <STOP> key routine
  must be called, if the <STOP> key is to remain functional.

  How to Use:
    1) Call this routine.

  EXAMPLE:

    JSR UDTIM"
"In the context of the C64, What is the purpose of the SETNAM kernal routine?","B-30. Function Name: SETNAM

    Purpose: Set file name
    Call address: $FFBD (hex) 65469 (decimal)
    Communication registers: A, X, Y
    Preparatory routines:
    Stack requirements: 2
    Registers affected:

    Description: This routine is used to set up the file name for the OPEN,
  SAVE, or LOAD routines. The accumulator must be loaded with the length of
  the file name. The X and Y registers must be loaded with the address of
  the file name, in standard 6502 low-byte/high-byte format. The address
  can be any valid memory address in the system where a string of
  characters for the file name is stored. If no file name is desired, the
  accumulator must be set to 0, representing a zero file length. The X and
  Y registers can be set to any memory address in that case.

  How to Use:

    1) Load the accumulator with the length of the file name.
    2) Load the X index register with the low order address of the file
       name.
    3) Load the Y index register with the high order address.
    4) Call this routine.

  EXAMPLE:

    LDA #NAME2-NAME     ;LOAD LENGTH OF FILE NAME
    LDX #<NAME          ;LOAD ADDRESS OF FILE NAME
    LDY #>NAME
    JSR SETNAM"
"In the context of the C64, What is the purpose of the memory location at address $E6A8?","address              $E6A8
Return from Outputting a Character to the Screen

This is the common exit point for the screen portion of the CHROUT
routine."
"In the context of the C64, What is the purpose of the memory location at address $A437-$A468?","address   $A437-$A468    ERROR
General Error Handler

The error number is passed to this routine in the .X register, and it
displays the appropriate error message.  Since this routine is
vectored through RAM at 768 ($300), you can divert this vector to the
address of your own routine, which would allow error trapping, or the
addition of new commands."
"In the context of the C64, What is the purpose of the memory location at address $A7AE?","address         $A7AE          NEWSTT
Set Up Next Statement for Execution

This routine tests for the STOP key, updates the pointer to the
current line number, and positions the text pointer to read the
beginning of the statement."
"In the context of the C64, What is the purpose of the memory location at address $E8A1?","address              $E8A1
If at the Beginning of a Screen Line, Move Cursor to Previous Line"
"In the context of the C64, What is the purpose of the memory location at address $ED0C?","address              $ED0C          LISTEN

This is a documented Kernal routine whose entry in the jump table is
65457 ($FFB1).  When called, it ORs the device number in the
Accumulator with the LISTEN code (32, $20) and sends it on the serial
bus.  This commands the device to LISTEN."
"In the context of the C64, What is the purpose of the memory location at address $EDEF?","address              $EDEF          UNTLK
Send UNTALK to a Device on the Serial Bus

This is a documented Kernal routine whose entry in the jump table is
65451 ($FFAB).  When called, it sends the UNTALK code (95, $5F) on the
serial bus.  This commands any TALKer on the bus to stop sending data."
"In the context of the C64, What is the purpose of the memory location at address $EEA9?","address              $EEA9
Get Serial Bus Data Input Bit and Clock Pulse Input Bit

This subroutine reads the serial bus data input bit and clock pulse
input bit (Bits 7 and 6 of CIA #2 Data Port A at 56576 ($DD00)), and
returns the data bit in the Carry flag and the clock bit in the
Negative flag."
"In the context of the C64, What is the purpose of the memory location at address $295-$296?","address       $295-$296      M51AJB
RS-232: Nonstandard Bit Timing

These locations are provided for storing a nonstandard user-defined
baud rate, to be used when the low nybble of the control register at
659 ($293) is set to 0.  They were presumable provided to conform to
the nodel of the 6551 UART device, which allows a nonstandard baud
rate to be generated from an external reference crystal.  However, the
software emulation of that feature is not provided in the current
version of the Kernal, and thus these locations are currently
nonfunctional.

Nonetheless, Commodore has specified that if the nonstandard baud rate
feature is implemented, the value placed here should equal the system
clock frequency divided by the baud rate divided by 2 minus 100,
stored in low byte, high byte order.  The system clock frequency for
American television monitors (NTSC standard) is 1.02273 MHz, and for
European monitors (PAL standard) .98525 MHz."
"In the context of the C64, What is the purpose of the memory location at address $F7EA?","address              $F7EA
Search Tape for a Filename"
"In the context of the C64, What is the purpose of the memory location at address $F6ED?","address              $F6ED          STOP
Test STOP Key

STOP is a documented Kernal routine which can be entered from the jump
table at location 65505 ($FFE1).

It is vectored through RAM at 808 ($328).  The routine checks to see
if the STOP key was pressed during the last UDTIM call.  If it was,
the Zero flag is set to 1, the CLRCHN routine is called to set the
input and output devices back to the keyboard and screen, and the
keyboard queue is emptied."
"In the context of the C64, What is the purpose of the memory location at address $0286?","address           $286           COLOR
Current Foreground Color for Text

The process of PRINTing a character to the screen consists of both
placing the screen code value for the character in screen memory and
placing a foreground color value in the corresponding location in
color RAM.  Whenever a character is PRINTed, the Operating System
fetches the value to be put in color RAM from this location.

The foreground color may be changed in a number of ways.  Pressing the
CTRL or Commodore logo key and numbers 1-8 at the same time will
change the value stored here, and thus the color being printed.
PRINTing the PETASCII equivalent character with the CHR$ command will
have the same effect.  But probably the easiest method is to POKE the
color value directly to this location.  The table below lists the
possible colors that may be produced, and shows how to produce them
using all three methods.

POKE
COLOR #   COLOR     CHR$   KEYS TO PRESS
 0        Black     144    CTRL-1
 1        White       5    CTRL-2
 2        Red        28    CTRL-3
 3        Cyan      159    CTRL-4
 4        Purple    156    CTRL-5
 5        Green      30    CTRL-6
 6        Blue       31    CTRL-7
 7        Yellow    158    CTRL-8
 8        Orange    129    Logo-1
 9        Brown     149    Logo-2
10        Lt Red    150    Logo-3
11        Dark Gray 151    Logo-4
12        Med Gray  152    Logo-5
13        Lt Green  153    Logo-6
14        Lt Blue   154    Logo-7
15        Lt Gray   155    Logo-8"
"In the context of the C64, What is the purpose of the memory location at address $2A6?","address          $2A6
PAL/NTSC Flag

At power-on, a test is performed to see if the monitor uses the NTSC
(North American) or PAL (European) television standard.

This test is accomplished by setting a raster interrupt for scan line
311, and testing if the interrupt occurs.  Since NTSC monitors have
only 262 raster scan lines per screen, the interrupt will occur only
if a PAL monitor is used.  The results of that test are stored here,
with a 0 indicating an NTSC system in use, and one signifying a PAL
system.

This information is used by the routines which set the prescaler
values for the system IRQ timer, so that the IRQ occurs every 1/60
second.  Since the PAL system 02 clock runs a bit slower than the NTSC
version, this prescaler value must be adjusted accordingly."
"In the context of the C64, What is the purpose of the memory location at address $BB-$BC?","address       $BB-$BC        FNADR
Pointer: Current Filename

This location holds a pointer to the address of the current filename.
If an operation which OPENs a tape file does not specify a filename,
this pointer is not used.

When a disk filename contains a shifted space character, the remainder
of the name will appear outside the quotes in the directory, and may
be used for comments.  For example, if you SAVE 'ML[shifted
space]SYS828', the directory entry will read 'ML'SYS 828.  You may
reference the program either by the portion of the name that appears
within quotes, or by the full name, including the shifted space.  A
program appearing later in the directory as 'ML'SYS 900 would not be
found just by reference to 'ML', however.

A filename of up to four characters may be used when opening the
RS-232 device.  These four characters will be copied to 659-662
($293-$296), where they are used to control such parameters as baud
rate, parity, and word length."
"In the context of the C64, What is the purpose of the memory location at address $A8?","address           $A8            BITCI
RS-232 Input Bit Count/Cassete Temporary Storage

This location is used to count the number of bits of serial data that
has been received.  This is necessary so that the serial routines will
know when a full word has been received.  It is also used as an error
flag during tape loads."
"In the context of the C64, What is the purpose of the memory location at address $32A-$32B ?","address       $32A-$32B      IGETIN
Vector to Kernal GETIN Routine (Currently at 61758 ($F13E))"
"In the context of the C64, What is the purpose of the memory location at address $96?","address           $96            SYNO
Cassette Block Synchronization Number"
"In the context of the C64, What is the purpose of the memory location at address $311-$312?","address      $311-$312      USRADD
Address of USR Routine (Low Byte First)

These locations contain the target address of the USR command.  They
are initialized by the Operating System to point to the BASIC error
message handler routine, so that if you try to execute a USR call
without changing these values, you wil receive an ILLEGAL QUANTITY
error message.

In order to successfully execute a USR call, you must first POKE in
the target address in low-byte, high-byte order.  You can calculate
these two values for any address with the formula:

HI=INT(AD/256):LO=AD-(HI*256)

For example, if the USR routine started at 49152 ($C000), you would
POKE 786, INT(49152/256):POKE 785,49152-(PEEK(786)*256 before
executing the USR command.

What makes the USR command different from SYS is that you can pass a
parameter into the machine language routine by placing it in
parenthesis after the USR keyword, and you can pass a parameter back
to a variable by assigning its value to the USR function.

In other words, the statement X=USR(50) will first put the number 50
in floating point format into the Floating Point Accumulator (FAC1) at
97-102 ($61-$66).  Then, the machine language program designated by
the address at this vector will be executed.  Finally, the variable X
will be assigned the floating point value which ends up in FAC1 after
the user-written routine is finished.

Since floating point representation is difficult to work with, it is
handy to change these floating point parameters into integers before
working with them.  Fortunately, there are vectored routines which
will do the conversions for you.  The routine vectored at locations
3-4 converts the number in FAC1 to a two-byte signed integer, with the
low byte in the .Y register (and location 101 ($65)) and the high byte
in the Accumulator (.A).  Remember, that number is converted to a
signed integer in the range between 32767 and -32768, with Bit 7 of
the high byte used to indicate the sign.

To pass a value back through the USR function, you need to place the
number into FAC1.  To conert a signed integer to floating point
format, place the high byte into the Accumulator (.A), the low byte
into the .Y register, and jump through the vector at locations 5-6
with a JMP ($0005) instruction.  The floating point result will be
left in FAC1."
"In the context of the C64, What is the purpose of the memory location at address $7?","address            $7             CHARAC
Search Character for Scanning BASIC Text Input

This location and the next are used heavily by the BASIC routines that
scan the text that comes into the buffer at 512 ($200), in order to
detect significant characters such as quotes, comma, the colon which
separates BASIC statements, and end-of-line.  The ASCII values of such
special characters are usually stored here.

This location is also used as a work area by other BASIC routines that
do not involve scanning text."
"In the context of the C64, What is the purpose of the memory location at address $69?","address           $69            ARGEXP
Floating Point Accumulator #2: Exponent"
"In the context of the C64, What is the purpose of the memory location at address $4B-$4C?","address         $4B-$4C        OPPTR
Math Operator Table Displacement

This location is used during the evaluation of mathematical
expressions to hold the displacement of the current math operator in
an operator table.  It is also used as a save area for the pointer to
the address of program text which is currently being read."
"In the context of the C64, What is the purpose of the memory location at address $D408?","address              $D408          FREHI2
Voice 2 Frequency Control (high byte)"
"In the context of the C64, What is the purpose of the memory location at address $BC9B?","address         $BC9B          QINT
Convert FAC1 into Integer Within FAC1

This routine converts the value in FAC1 into a four-byte signed
integer in 98- 101 ($62-$65), with the most significant byte first."
"In the context of the C64, What is the purpose of the memory location at address $BAF9?","address         $BAF9          TENC
The Constant 10 in Five-Byte Floating Format"
"In the context of the C64, What is the purpose of the memory location at address $D402?","address              $D402          PWLO1
Voice 1 Pulse Waveform Width (low byte)"
"In the context of the C64, What is the purpose of the memory location at address $D01C?","address              $D01C          SP5COL
Sprite 5 Color Register (the default color value is 6, blue)"
"In the context of the C64, What is the purpose of the memory location at address $D010?","address              $D010          MSIGX
Most Significant Bits of Sprites 0-7 Horizontal Position

Bit 0:  Most significant bit of Sprite 0 horizontal position
Bit 1:  Most significant bit of Sprite 1 horizontal position
Bit 2:  Most significant bit of Sprite 2 horizontal position
Bit 3:  Most significant bit of Sprite 3 horizontal position
Bit 4:  Most significant bit of Sprite 4 horizontal position
Bit 5:  Most significant bit of Sprite 5 horizontal position
Bit 6:  Most significant bit of Sprite 6 horizontal position
Bit 7:  Most significant bit of Sprite 7 horizontal position

Setting one of these bites to 1 adds 256 to the horizontal position of
the corresponding sprite.  Resetting one of these bits to 0 restricts
the horizontal position of the corresponding sprite to a value of 255
or less"
"In the context of the C64, What is the purpose of the memory location at address $D001?","address         $D001          SP0Y
Sprite 0 Vertical Position"
"In the context of the C64, What is the purpose of the memory location at address $D002?","address         $D002          SP1X
Sprite 1 Horizontal Position"
"In the context of the C64, What is the purpose of the memory location at address $D011?","address              $D011          SCROLY
Vertical Fine Scrolling and Control Register

Bits 0-2:  Fine scroll display vertically by X scan lines (0-7)
Bit 3:  Select a 24-row or 25-row text display (1=25 rows, 0=24 rows)
Bit 4:  Blank the entire screen to the same color as the background
  (0=blank)
Bit 5:  Enable bitmap graphics mode (1=enable)
Bit 6:  Enable extended color text mode (1=enable)
Bit 7:  High bit (Bit 8) of raster compare register at 53266 ($D012)

This is one of the two important multifunction control registers on
the VIC-II chip.  Its defaule value is 155, which sets the high bit of
the raster compare to 1, selects a 25-row display, disables the
blanking feature, and uses a vertical scrolling offset of three scan
lines.

Bits 0-2.  These bits control vertical fine scrolling of the screen
display.  This feature allows you to move the entire text display
smoothly up and down, enabling the display area to act as a window,
scrolling over a larger text or character graphics display.

Since each row of text is eight scan lines high, if you simply move
each line of text up one row, the characters travel an appreciable
distance each time they move, which gives the motion a jerky quality.
This is called coarse scrolling, and you can see an example of it when
LISTing a program that is too long to fit on the screen all at one
time.

By placing a number from 1 to 7 into these three bits, you can move
the whole screen display down by from 1 to 7 dot spaces.  Stepping
through the values 1 to 7 allows you to smoothly make the transition
from having a character appear in one row on the screen to having it
appear in the next row.  To demonstrate this, type in the following
sample program, LIST it, and RUN.

10 FOR I= 1 TO 50:FOR J=0 TO 7
20 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I
30 FOR I= 1 TO 50:FOR J=7 TO 0 STEP-1
40 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I

As you can see, after the display has moved seven dot positions up or
down, it starts over at its original position.  In order to continue
the scroll, you must do a coarse scroll every time the value of the
scroll bits goes from 7 to 0, or from 0 to 7.  This is accomplished by
moving the display data for each line by 40 bytes in either direction,
overwriting the data for the last line, and introducing a line of data
at the opposite end of screen memory to replace it.  Obviously, ony a
machine language program can move all of these lines quickly enough to
maintain the effect of smooth motion.  The following BASIC program,
however, will give you an iea of what vertical fine scrolling is like:

10 POKE 53281,0:PRINTCHR$(5);CHR$(147)
20 FORI=1 TO 27:
30 PRINTTAB(15)CHR$(145)'            ':POKE 53265,PEEK(53265)AND248
40 WAIT53265,128:PRINTTAB(15)'I'M FALLING'
50 FOR J=1 TO 7
60 POKE53265,(PEEK(53265)AND248)+J
70 FORK=1TO50
80 NEXT K,J,I:RUN

Bit 3.  This bit register allows you to select either the normal
25-line text display (by setting the bit to 1), or a shortened 24-row
display (by resetting that bit to 0).  This shortened display is
created by extending the border to overlap the top or bottom row.  The
characters in these rows are still there; they are just covered up.

The shortened display is designed to aid vertical fine scrolling.  It
covers up the line into which new screen data is introduced, so that
the viewer does not see the new data being moved into place.

However, unlink the register at 53270 ($D016) which shortens the
screen by one character space on either side to aid horizontal
scrolling in either direction, this register can blank only one
vertical line at a time.  In order to compensate, it blanks the top
line when the three scroll bits in this register are set to 0, and
shifts the blanking one scan line at a time as the value of thee bits
increases.  Thus the bottom line is totally blanked when these bits
are set to 7.

Bit 4.  Bit 4 of this register controls the screen blanking feature.
When this bit is set to 0, no data can be displayed on the screen.
Instead, the whole screen will be filled with the color of the frame
(which is controlled by th eBorder Color Register at 53280 ($D020)).

Screen blanking is useful because of the way in which the VIC-II chip
interacts with the 6510 microprocessor.  Since the VIC-II and the 6510
both have to address the same memory, they must share the system data
bus.  Sharing the data bus means that they must take turns whenever
they want to address memory.

The VIC-II chip was designed so that it fetches most of the data it
needs during the part of the cycle in which the 6510 is not using the
data bus.  But certain operations, such as reading the 40 screen codes
needed for each line of text from video mmeory, or fetching sprite
data, require that the VIC-II chip get data at a faster rate than is
possible just by using the off half of the 6510 cycle.

Thus, the VIC-II chip must delay the 6510 for a short amount of time
while it is using the data bus to gather display information for text
or bitmap graphics, and must delay it a little more if sprites are
also enabled.  When you set the screen blanking bit to 0, these delays
are eliminated, and the 6510 processor is allowed to run at its full
speed.  This speeds up any processing task a little.

To demonstrate this, run the following short program.  As you will
see, leaving the screen on makes the processor run about 7 percent
slower than when you turn it off.  If you perform the same timing test
on the VIC-20, you will find that it runs at the same speed with its
screen on as the 64 does with its screen off.  And the same test on a
PET will run substantially slower.

10 PRINT CHR$(147);TAB(13);'TIMING TEST':PRINT:TI$='000000':GOTO 30
20 FOR I=1 TO 10000:NEXT I:RETURN
30 GOSUB 20:DISPLAY=TI
40 POKE 53265,11:TI$='000000'
50 GOSUB 20:NOSCREEN=TI:POKE 53265,27
60 PRINT 'THE LOOP TOOK';DISPLAY;' JIFFIES'
70 PRINT 'WITH NO SCREEN BLANKING':PRINT
80 PRINT 'THE LOOP TOOK';NOSCREEN;' JIFFIES'
90 PRINT 'WITH SCREEN BLANKING':PRINT
100 PRINT 'SCREEN BLANKING MAKE THE PROCESSOR'
110 PRINT 'GO';DISPLAY/NOSCREEN*100-100;'PERCENT FASTER'

The above explanation accounts for the screen being turned off during
tape read and write operations.  The timing of these operations is
rather critical, and would be affected by even the relatively small
delay caused by the video chip.  It also explains why the 64 has
difficulty loading programs from an unmodified 1540 Disk Drive, since
the 1540 was set up to transfer data from the VIC-20, which does not
have to contend with these slight delays.

If you turn off the 64 display with a POKE 53265,PEEEK(53265) AND 239,
you will be able to load programs correctly from an old 1540 drive.
The new 1541 drive transfers data at a slightly slower rate in the
default setting, and can be set from software to transfer it at the
higher rate for the VIC-20.

Bit 5.  Setting Bit 5 of this register to 1 enables the bitmap
graphics mode.  In this mode, the screen area is broken down into
64,000 separate dots of light, 320 dots across by 200 dots high.  Each
dot corresponds to one bit of display memory.  If the bit is set to 1,
the dot will be displayed in the foreground color.  If the bit is
reset to 0, it will be displayed in the background color.  This allows
the display of high-resolution graphics images for games, charts, and
graphs, etc.

Bitmapping is a common technique for implementing high-resolution
graphics on a microcomputer.  There are some features of the Commodore
system which are unusual, however.

Most systems display screen memory sequentially; that is, the first
byte controls the display of the first eight dots in the upper-left
corner of the screen, the second byte controls the eight dots to the
right of that, etc.  In the Commodore system, display memory is laid
out more along the lines of how character graphics dot-data is
arranged.

The first byte controls the row of eight dots in the top-left corner
of the screen, but the next byte controls the eight dots below that,
and so on until the ninth byte.  The ninth byte controls the eight
dots directly to the right of those controlled by the first byte of
display memory.  It is exactly the same as if the screen were filled
with 1000 programmable characters, with display memory taking the
place of the character dot-data.

The 64's bitmap graphics mode also resembles character graphics in
that the foreground color of the dots is set by a color map (although
it does not use the Color RAM for this purpose).  Four bits of each
byte of this color memory control the foreground color of one of these
eight-byte groups of display memory (which form an 8 by 8 grid of 64
dots).  Unlike character graphics, however, the other four bits
control the background color that will be seen in the eight-byte
display group where a bit has a value of 0.

Setting up a bitmap graphics screen is somewhat more complicated than
just setting this register bit to 1.  You must first choose a location
for the display memory area, and for the color memory area.  The
display memory area will be 8192 bytes long (8000 of which are
actually used for the display) and can occupy only the first or the
second half of the 16K space which the VIC-II chip can address.

Each byte of bitmap graphics color memory uses four bits for the
background color as well as four bits for the foreground color.
Therefore, the Color RAM nybbles at 55296 ($D800), which are wired for
four bits only, cannot be used.  Another RAM location must therefore
be found for color memory.

This color memory area will take up 1K (1000 bytes of which are
actually used to control the foreground and background colors of the
dots), and must be in the opposite half of VIC-II memory as the
display data.  Since bitmap graphics require so much memory for the
display, you may want to select a different 16K bank for VIC-II memory
(see the discussion of things to consider in selecting a VIC-II memory
bank at location 56576 ($DD00)).

To keep things simple, however, let's assume that you have selected to
use the default bank of VIC-II memory, which is the first 16K.  You
would have to select locations 8192-16383 ($2000-$3FFF) for screen
memory, because the VIC-II chip sees an image of the character ROM in
the first half of the 16K block (at locations 4096-8192
($1000-$1FFF)).  Color memory could be placed at the default location
of text display memory, at 1024-2047 ($400-$7FF).  Placement of bitmap
display and color memory is controlled by the VIC Memory Control
Register at 53272 ($D018).

When in bitmap mode, the lower four bits of this register, which
normally control the base address of character dot-data, now control
the location of the 8K bitmap.  Only Bit 3 is significant.  If it is
set to 1, the graphics display memory will be in the second 8K of
VIC-II memory (in this case, starting at 8192 ($2000)).  If that bit
contains a 0, the first 8K will be used for the bitmap.  The upper
four bits of this register, which normally control the location of the
Video Display Matrix, are used in bitmap mode to establish the
location of the color map within the VIC-II address space.  These four
bits can hold a number from 0 to 15, which indicates on which 1K
boundary the color map begins.  For example, if color memory began at
1024 (1K), the value of these four bits would be 0001.

Once the bitmap mode has been selected, and the screen and color
memory areas set up, you must establish a method for turning each
individual dot on and off.  The conventional method for identifying
each dot is to assign it to a horizontal (X) position coordinate and a
vertical (Y) coordinate.

Horizontal position values will range from 0 to 319, where dot 0 is at
the extreme left-hand side of the screen, and dot 319 at the extreme
right.  Vertical positions will range from 0 to 199, where dot 0 is on
the top line, and dot 199 is on the bottom line.

Because of the unusual layout of bitmap screen data on the 64, it is
fairly easy to transfer text characters to a bitmap screen, but it is
somewhat awkward finding the bit which affects the screen dot having a
given X-Y coordinate.  First, you must find the byte BY in which the
bit resides, and then you must POKE a vlue into that byte which turns
the desired bit on or off.  Given that the horizontal position of the
dot is stored in the variable X, its vertical position is in the
variable Y, and the base address of the bitmap area is in the variable
BASE, you can find the desired byte with the formula:

BY=BASE+40*(Y AND 256)+(Y AND 7)+(X AND 504)

To turn on the desired dot,

POKE BY, PEEK(BY) OR (2^(NOTX AND 7)

To turn the dot off,

POKE BY, PEEK(BY) AND (255-2^(NOTX AND 7))

The exponentation function takes a lot of time.  To speed things up,
an array can be created, each of whose elements corresponds to a power
of two.

FOR I=0 TO 7:BIT(I)=2^1:NEXT

After this is done, the expression 2^(I) can be replaced by BI(I).

The following sample program illustrates the bit-graphics concepts
explained above, and serves as a summary of that information.

10 FOR I=0 TO 7:BI(I)=2^I:NEXT: REM SET UP ARRAY OF POWERS OF 2 (BIT VALUE)
20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
30 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE
40 A$='':FOR I=1 TO 37:A$=A$+'C':NEXT:PRINT CHR$(19);
50 FOR I=1 TO 27:PRINTA$;:NEXT:POKE2023,PEEK(2022): REM SET COLOR MAP
60 A$='':FOR I=1 TO 27:A$=A$+'@':NEXT:FOR I=32 TO 63 STEP 2
70 POKE648,I:PRINT CHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLEAR HI-RES SCREEN
80 FORY=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM
90 X=INT(160+40*SIN(Y/10)): REM SINE WAVE SHAPE
100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504): REM FIND HI-RES BYTE
110 POKEBY,PEEK(BY)OR(BI(NOT X AND 7)):NEXT Y:REM POKE IN BIT VALUE
120 GOTO 120: REM LET IT STAY ON SCREEN

As you can see, using BASIC to draw in bit-graphics mode is somewhat
slow and tedious.  Machine language is much more suiable for
bit-graphics plotting.  For a program that lets you replace some BASIC
ommands with high-res drawing commands, see the article 'Hi-Res
Graphics Made Simple,' by Paul F. Schatz, in COMPUTE!'s First Book of
Commodore 64 Sound and Graphics.

There is a slightly lower resolution bitmap graphics mode available
which offers up to four colors per 8 by 8 dot matrix.  To enable this
mode, you must set the multicolor bit (Bit 4 of 53270 ($D016)) while
in bitmap graphics mode.  For more information on this mode, see the
entry for the multicolor enable bit.

Bit 6.  This bit of this register enables extended background color
mode.  This mode lets you select the background color of each text
character, as well as its foreground color.  It is able to increase
the number of background colors displayed, by reducing the number of
characters that can be shown on the screen.

Normally, 256 character shapes can be displayed on the screen.  You
can use them either by using the PRINT statement or by POKEing a
display code from 0 to 255 into screen memory.  If the POKEing method
is used, you must also POKE a color code from 0 to 15 into color
memory (for example, if you POKE 1024,1, and POKE 55296,1, a white A
appears in the top-left corner of the screen).

The background color of the screen is determined by Background Color
Register 0, and you can change this color by POKEing a new value to
that register, which is located at 53281 ($D021).  For example, POKE
53281,0 creates a black background.

When extended background color mode is activated, however, only the
first 64 shapes found in the table of the screen display codes can be
displayed on the screen.  This group includes the letters of the
alphabet, numerals, and punctuation marks.  If you try to print on the
screen a character having a higher display code, the shape displayed
will be from the first group of 64, but that character's background
will no longer be determined by the register at 53281 ($D021).
Instead, it will be determined by one of the other background color
registers.

When in extended background color mode, characters having display
codes 64- 127 will take their background color from register 1, and
location 53282 ($D022).  These characters include various SHIFTed
characters.  Those with codes 128-191 will have their background
colors determined by register 2, at 53283 ($D023).  These include the
reversed numbers, letters, and punctuation marks.  Finally, characters
with codes 192-255 will use register 4, at 53284 ($D024).  These are
the reversed graphics characters.

Let's try an experiment to see just how this works.  First, we will
put the codes for four different letters in screen memory:

FOR I=0 TO 3:POKE 1230+(I*8),I*64+I:POKE 55502+(I*8),1:NEXT

Four white letters should appear on the screen, an A, a shifted A, a
reversed A, and a reversed, shifted A, all on a blue background.
Next, we will put colors in the other background color registers:

POKE 53282,0:POKE53283,2:POKE53284,5

This sets the registers to black, red, and green, respectively.
Finally, we will activate extended color mode by setting Bit 6 of the
VIC-II register at location 53265 to a 1.  The BASIC statement that
turns this mode on is:

POKE 53265,PEEK(53265) OR 64

Notice that two things happened.  First, all of the letters took on
the same shape, that of the letter A.  Second, each took on the
background color of a different color register.  To get things back to
normal, turn off extended color mode with this statement:

POKE 53265,PEEK(53265) AND 191

Extended color mode can be a very useful enhancement for your text
displays.  It allows the creation of windows.  These windows, because
of their different background colors, make different bodies of text
stand out as visually distinct from one another.  For example, a text
adventure program could have one window to display the player's
current location, one to show an inventory of possessions, and one to
accept commands for the next move.

In this mode the background color of these windows can be changed
instantly, just by POKEing a new value to the color register.  This
technique lends itself to some dramatic effects.  A window can be
flashed to draw attention to a particular message at certain times.
And varying the foreground color can make either the window or the
message vanish and reappear later.

There are, however, a couple of problems involved in using these
windows.  The character shape that you want to use might not have a
screen code of less than 64.  In that case, the only solution is to
define your own character set, with the shape you want in one of the
first 64 characters.

Another problem is that characters within a PRINT statement in your
program listing are not always going to look the same on the screen.
Having to figure out what letter to print to get the number 4 with a
certain background color can be very inconvenient.  The easiest
solution to this problem is to have a subroutine to the translation
for you.  Since letters will appear normally in window 1, and window 3
characters are simply window 1 characters reversed, you will only have
problems with characters in windows 2 and 4.  To conver these
characters, put your message in A$, and use the following subroutine:

500 B$='':FOR I=1 TO LEN(A$):B=ASC(MID$(A$,I,1))
510 B=B+32:IF B<96 THEN B=B+96
520 B$=B$+CHR$(B):NEXT I:RETURN

This subroutine converts each letter to its ASCII equivalent, adds the
proper offset, and converts it back to part of the new string, B$.
When the conversion is complete, B$ will hold the characters necessary
to PRINT that message in window 2.  For window 4, PRINT
CHR$(18);B$;CHR$(146).  This will turn reverse video on before
printing the string, and turn it off afterwards.



Bit 7.  Bit 7 of this register is the high-order bit (Bit 8) of the
Raster Compare register at 53266 ($D012).  Even though it is located
here, it functions as part of that register (see the description below
for more information on the Raster Compare register).

Machine language programmers should note that its position here at Bit
7 allows testing this bit with the Negative flag.  Since scan lines
above number 256 are all off the screen, this provides an easy way to
delay changing the graphics display until the scan is in the vertical
blanking interval and the display is no longer being drawn:

LOOP  LDA $D011
      BPL LOOP

Sprites should always be moved when the raster is scanning off-screen,
because if they are moved while they are being scanned, their shapes
will waver slightly.

The BASIC equivalent of the program fragment above is the statement
WAIT 53265,128, but BASIC is usually not fast enough to execute the
next statement while still in the blanking interval.

53266          $D012         RASTER
Read Current Raster Scan Line/Write Line to Compare for Raster IRQ

The Raster Compare register has two different functions, depending on
whether you are reading from it or writing to it.  When this register
is read, it tells which screen line the electron beam is currently
scanning.

There are 262 horizontal lines which make up the American (NTSC)
standard display screen (312 lines in the European or PAL standard
screen).  Every one of these lines is scanned and updated 60 times per
second.  Only 200 of these lines (numbers 50-249) are part of the
visible display.

It is sometimes helpful to know just what line is being scanned,
because changing screen graphics on a particular line while that line
is being scanned may cause a slight disruption on the screen.  By
reading this register, it is possible for a machine language program
to wait until the scan is off the bottom of the screen before changing
the graphics display.

It is even possible for a machine language program to read this
register, and change the screen display when a certain scan line is
reached.  The program below uses this technique to change the
background color in midscreen, in order to show all 256 combinations
of foreground and background text colors at once.

40 FOR I=49152 TO 49188:READ A:POKE I,A:NEXT:POKE 53280,11
50 PRINT CHR$(147):FOR I=1024 TO I+1000:POKE I,160:POKE I+54272,11:NEXT I
60 FOR I=0 TO 15:FOR J=0 TO 15
70 P=1196+(48*I)+J:POKE P,J+I:POKE P+54272,J:NEXT J,I
80 PRINT TAB(15)CHR$(5)'COLOR CHART':FOR I=1 TO 19:PRINT:NEXT
85 PRINT 'THIS CHART SHOWS ALL COMBINATIONS OF   '
86 PRINT 'FOREGROUND AND BACKGROUND COLORS.      '
87 PRINT 'FOREGROUND INCREASES FROM LEFT TO RIGHT'
88 PRINT 'BACKGROUND INCREASES FROM TOP TO BOTTOM'
90 SYS 12*4096
100 DATA 169,90,133,251,169,0,141,33,208,162,15,120,173,17,208,48
105 DATA 251,173,18,208
110 DATA 197,251,208,249,238,33,208,24,105,8,133,251,202,16,233,48,219

Writing to this register designates the comparison value for the
Raster Compare Interrupt.  When that interrupt is enabled, a maskable
interrupt request will be issued every time the electron beam scan
reaches the scan line whose number was written here.  This is a much
more flexible technique for changing the display in midscreen than
reading this register as the sample program above does.  That
technique requires that the program continuously watch the Raster
Register, while the interrupt method will call the program when the
time is right to act.  For more information on raster interrupts, see
the entry for the Interrupt Mask Register (53274, $D01A).

It is very important to remember that this register requires nine
bits, and that this location only holds eight of those bits (the ninth
is Bit 7 of 53265 ($D011)).  If you forget to read or write to the
ninth bit, your results could be in error by a factor of 256.

For example, some early programs written to demonstrate the raster
interrupt took for granted that the ninth bit of this register would
be set to 0 on power-up.  When a later version of the Kernal changed
this initial value to a 1, their interrupt routines, which were
supposed to set the raster interrupt to occur at scan line number 150,
ended up setting it for line number 406 instead.  Since the scan line
numbers do not go up that high, no interrupt request was ever issued
and the program did not work.

Location Range: 53267-53268 ($D013-$D014)
Light Pen Registers

A light pen is an input device that can be plugged into joystick
Control Port #1.  It is shaped like a pen and has a light-sensitive
device at its tip that causes the trigger switch of the joystick port
to close at the moment the electron beam that updates the screen
display strikes it.  The VIC-II chip keeps track of where the beam is
when that happens, and records the corresponding horizontal and
vertical screen coordinates in the registers at these locations.

A program can read the position at which the light pen is held up to
the screen.  The values in these registers are updated once every
screen frame (60 times per second).  Once the switch is closed and a
value written to these registers, the registers are latched, and
subsequent switch closings during the same screen frame will not be
recorded.

A given light pen may not be entirely accurate (and the operator may
not have a steady hand).  It is probably wise to average the positions
returned from a number of samplings, particularly when using a machine
language driver."
"In the context of the C64, What is the purpose of the memory location at address $D01B?","address              $D01B          SP4COL
Sprite 4 Color Register (the default color value is 5, green)"
"In the context of the C64, What is the purpose of the memory location at address $BAE2?","address         $BAE2          MUL10
Multiply FAC1 by 10

This subroutine is called to help convert a floating point number to a
series of ASCII numerals."
"In the context of the C64, What is the purpose of the memory location at address $D401?","address              $D401          FREHI1
Voice 1 Frequency Control (high byte)

Location Range: 54274-54275 ($D402-$D403)
Voice 1 Pulse Waveform Width Control

As you will see below under the description of the Control Register at
54276 ($D404), you can select one of four different waveforms for the
output of each voice.  If the pulse waveform is selected, these
registers must be set to establish the pulse width.

The pulse width has a 12-bit resolution, being made up of the value in
the first register and the value in the lower nybble of the second
register.  The pulse width determines the duty cycle, or proportion of
the time that the rectangular wave will stay at the high part of the
cycle.

The following formula shows the relationship between the value in the
Pulse Width Register and the proportion of time that the wave stays at
the high part of the cycle:

PULSE WIDTH=(REGISTER VALUE/40.95)%

The possible range of the register values (0-4095) covers the range of
the duty cycles from 0 to 100 percent in 4096 steps.  Changing the
pulse width will vastly change the sound created with the pulse
waveform."
"In the context of the C64, What is the purpose of the memory location at address $D407?","address              $D407          FRELO2
Voice 2 Frequency Control (low byte)"
"In the context of the C64, What is the purpose of the memory location at address $BC5B?","address         $BC5B          FCOMP
Compare FAC1 to Memory

On entry to this routine, .A and .Y point to a five-byte floating
point number to be compared to FAC1.  After the comparison, .A holds 0
if the two are equal, a 1 if the value of FAC1 is greater than that in
the memory location, and 255 ($FF) if the value of FAC1 is less than
that in the memory location."
"In the context of the C64, What is the purpose of the memory location at address $4D?","address           $4D            OPMASK
Mask for Comparison Operation

The expression evaluation routine creates a mask here which lets it
know whether the current comparieson operation is a less-than (1),
equals (2), or greater-than (4) comparison."
"In the context of the C64, What is the purpose of the memory location at address $8?","address            $8             ENDCHR
Search Character for Statement Termination or Quote

Like location 7, this location is used as a work byte during the
tokenization of a BASIC statement.  Most of the time, its value is 0
or 34."
"In the context of the C64, What is the purpose of the memory location at address $6A-$6D?","address       $6A-$6D        ARGHO
Floating Point Accumulator #2: Mantissa"
"In the context of the C64, What is the purpose of the memory location at address $313?","address          $313
Unused"
"In the context of the C64, What is the purpose of the memory location at address $32C-$32D?","address       $32C-$32D      ICLALL
Vector to Kernal CLALL Routine (Currently at 62255 ($F32F))"
"In the context of the C64, What is the purpose of the memory location at address $97?","address          $97            XSAV
Temporary .X Register Save Area

This .X register save area is used by the routines that get and put an
ASCII character."
"In the context of the C64, What is the purpose of the memory location at address $A7?","address           $A7            INBIT
RS-232 Input Bits/Cassette Temporary Storage Area

This location is used to temporarily store each bit of serial data
that is received, as well as for miscellaneous tasks by tape I/O."
"In the context of the C64, What is the purpose of the memory location at address $2A5?","address           $2A5
Temporary Index to the Next 40-Column Line for Screen Scrolling"
"In the context of the C64, What is the purpose of the memory location at address $BA?","address           $BA            FA
Current Device Number

This location holds the number of the device that is currently being
used.  Device number assignments are as follows:

0    = Keyboard
1    = Datasette Recorder
2    = RS-232/User Port
3    = Screen
4-5  = Printer
8-11 = Disk"
"In the context of the C64, What is the purpose of the memory location at address $F6E4?","address              $F6E4          SETTIM
Set the Software Clock from the .A, .X, and .Y Registers

This documented Kernal routine can be entered from location 65499
($FFDB).

It performs the reverse operation from RDTIM, storing the value in the
.Y register into location 160 ($A0), the .X register into 161 ($A1),
and the Accumulator into 162 ($A2).  Interrupts are first disabled, to
make sure that the clock will not be updated while being set."
"In the context of the C64, What is the purpose of the memory location at address $285?","address           $285           TIMOUT
Flag: Kernal Variable for IEEE Time-Out

This location is used only with the external IEEE interface card
(which was not yet available from Commodore at the time of writing).
For more information, see the entry for the Kernal SETTMO routine at
65057 ($FE21)."
"In the context of the C64, What is the purpose of the memory location at address $294?","address           $294           M51CDR
RS-232: Mock 6551 Command Register

This location performs the same function as the 6551 UART chip's
command register, which specifies type of parity, duplex mode, and
handshaking protocol.

The type of parity used determines how the 64 will check that RS-232
data is received correctly.

The duplex mode can be either full duplex (the 64 will be able to
transmit at the same time it is receiving) or half duplex (it will
take turns sending and receiving).

The handshaking protocol has to do with the manner in which the
sending device lets the receiver know that it is ready to send data,
and the receiver lets the sender know that it has gotten the data
correctly.  The meanings of the bit patterns in this register are as
follows:

Bits 7-5: Parity
XX0 (bit value of
     0,64,128, or 192) = No Parity Generated or Received
001 (bit value of 32)  = Odd Parity Transmitted and Received
011 (bit value of 96)  = Even Parity Transmitted and Received
101 (bit value of 160) = Mark Parity Transmitted and Received
111 (bit value of 224) = Space Parity Transmitted and Received

Bit 4: Duplex
0 (bit value of 0)  = Full Duplex
1 (bit value of 16) = Half Duplex

Bits 3-1: Unused

Bit 0: Handshake Protocol
0 (bit value of 0) = 3 Line
1 (bit value of 1) = X Line

This register can be set at the user's option when opening RS-232
device (number 2).  The second character of the filename will be
stored here.  For example, the statement

OPEN 2,2,0,CHR$(6+32)+CHR$(32+16)

will set the value of this location to 48, which is the value of the
second character in the filename portion of the statement.  As you can
see from the above chart, this configures the RS-232 device for half
duplex data transfer using odd parity and three-line handshaking."
"In the context of the C64, What is the purpose of the memory location at address $F7D7?","address              $F7D7
Set I/O Area Start and End Pointers to Tape Buffer Start and End
Address"
"In the context of the C64, What is the purpose of the memory location at address $EEB3?","address              $EEB3
Perform a One-Millisecond Delay"
"In the context of the C64, What is the purpose of the memory location at address $EDFE?","address              $EDFE          UNLSN
Send UNLISTED to a Device on the Serial Bus

This is a documented Kernal routine whose entry in the jump table is
65454 ($FFAE).  It sends the UNLISTEN code (63, $3F) on the serial
bus.  This commands any LISTENers to get off the serial bus, and frees
up the bus for other users."
"In the context of the C64, What is the purpose of the memory location at address $ED09?","address              $ED09          TALK
Send TALK to a Device on the Serial Bus

This is a documented Kernal routine whose entry in the jump table is
65460 ($FFB4).  When called, it ORs the device number in the
Accumulator with the TALK code (64, $40) and sends it on the serial
bus.  This commands the device to TALK."
"In the context of the C64, What is the purpose of the memory location at address $A742?","address         $A742          FOR
Perform FOR

FOR is performed mostly by saving the needed information for the NEXT
part of the command on the stack (see the entry for 256 ($100) for
details).  This includes the TO termination value, so if the upper
limit is a variable, the current value of the variable will be stored,
and you cannot end the loop early by decreasing the value of the TO
variable within the loop (although you can end it early by increasing
the value of the FOR variable within the loop).

Also, since the TO expression is evaluated only once, at the time FOR
is performed, a statement such as FOR I=1 TO I+100 is valid.  The
terminating value is not checked until NEXT is executed, so the loop
statements always execute at least once.  The variable used by FOR
must be a nonarray floating point variable.  Reusing the same FOR
variable in a loop that is still active will cause the previous FOR
loop and all intervening loops to be cancelled."
"In the context of the C64, What is the purpose of the memory location at address $E891?","address              $E891
Output a Carriage Return

A carriage return is performed by clearing insert mode, reverse video,
and quote mode, and moving the cursor to the next line."
"In the context of the C64, What is the purpose of the memory location at address $E691?","address              $E691
Add a Character to the Screen

This is part of the routine that outputs a character to the screen.
It puts printable characters into screen memory."
"In the context of the C64, What is the purpose of the memory location at address $A435-$A468?","address   $A435-$A468    OMERR
OUT OF MEMORY Error Handler

This routine just sets the error message code, and falls through to
the general error handler."
"In the context of the C64, What is the purpose of the memory location at address $E8B3?","address              $E8B3
If at the End of a Screen Line, Move Cursor to the Next Line"
"In the context of the C64, What is the purpose of the memory location at address $A69C?","address         $A69C          LIST
Perform LIST

This routine saves the range of lines to be printed in pointers at
95-96 ($5F- $60) and 20-21 ($14-$15), and then prints them out,
translating any tokens back to their ASCII equivalent."
"In the context of the C64, What is the purpose of the memory location at address $A3FB-$A407?","address   $A3FB-$A407    GETSTK
Check for Space on Stack

Before undertaking an operation that requires stack space, this
routine is used to check if there is enough room on the stack.  If
there is not, an OUT OF MEMORY error is issued.

4"
"In the context of the C64, What is the purpose of the memory location at address $E6B6?","address              $E6B6
Advance the Cursor

This routine advances the cursor, and provides for such things as
scrolling at the end of the screen, and inserting a blank line in
order to add another physical line to the current logical line."
"In the context of the C64, What is the purpose of the memory location at address $8000?","address        $8000
Autostart ROM Cartridge

An 8K or 16K autostart ROM cartridge designed to use this as a
starting memory address may be plugged into the Expansion Port on the
back.  If the cartridge ROM at locations 32772-32776 ($8004-$8008)
contains the numbers 195, 194, 205, 56, 48 ($C3, $C2, $CD, $38, $30)
when the computer powers up, it will start the program pointed to by
the vector at locations 32768-32769 ($8000-$8001), and will use
32770-32771 ($8002-$8003) for a warm start vector when the RESTORE key
is pressed.  These characters are PETASCII for the inverse letters
CBM, followed by the digits 80.  An autostart cartridge may also be
addressed at 40960 ($A000), where it would replace BASIC, or at 61440
($F000), where it would replace the Kernal.

It is possible to have a 16K cartridge sitting at 32768 ($8000), such
as Simon's BASIC, which can be turned on and off so that the BASIC ROM
underneath can also be used.  Finally, it is even possible to have
bank-selected cartridges, which turn banks of memory in the cartidge
on and off alternately, so that a 32K program could fit into only 16K
of addressing space."
"In the context of the C64, What is the purpose of the memory location at address $EE97?","address              $EE97
Set Serial Bus Data Output Line Low

This subroutine clears the serial bus data output to 0 (Bit 5 of CIA
#2 Data Port A at 56576 ($DD00))."
"In the context of the C64, What is the purpose of the memory location at address $EDDD?","address              $EDDD          CIOUT
Send a Byte to an I/O Device over the Serial Bus

This is a documented Kernal routine which can be entered from the jump
table at 65448 ($FFA8).  Its purpose is to send a byte of data over
the serial bus.  In order for the data to be received, the serial
device must have first been commanded to LISTEN and been given a
secondary address if necessary.  This routine always buffers the
current character, and defers sending it until the next byte is
buffered.  When the UNLISTEN command is sent, the last byte will be
sent with an End or Identify (EOI)."
"In the context of the C64, What is the purpose of the memory location at address $287?","address           $287           GDCOL
Color of Character under Cursor

This location is used to keep track of the original color code of the
character stored at the present cursor location.  Since the blinking
cursor uses the current foreground color at 646 ($286), the original
value must be stored here so that if the cursor moves on without
changing that character, its color code can be restored to its
original value."
"In the context of the C64, What is the purpose of the memory location at address $F69B?","address              $F69B          UDTIM
Update the Software Clock and Check for the STOP Key

UDTIM is a documented Kernal routine which can be entered through the
jump table at 65514 ($FFEA).

It is normally called by the IRQ interrupt handler once every sixtieth
of a second.  It adds one to the value in the three-byte software
jiffy clock at 160-162 ($A0-$A2), and sets the clock back to zero when
it reaches the 24 hour point.  In addition, it scans the keyboard row
in which the STOP key is located, and stores the current value of that
key in location 145 ($91).  This variable is used by the STOP routine
which checks for the STOP key."
"In the context of the C64, What is the purpose of the memory location at address $F76A?","address              $F76A
Write Tape File Header Block"
"In the context of the C64, What is the purpose of the memory location at address $0297?","address           $297           $RSSTAT
RS-232: Mock 6551 Status Register

The contents of this register indicate the error status of RS-232 data
transmission.  That status can be determined by PEEKing this location
directly, by referencing the BASIC reserved variable ST, or by using
the Kernal READST (65031, $FE07) routine.

Note that if you use ST or Kernal, this location will be set to 0
after it is read.  Therefore, if you need to test more than one bit,
make sure that each test preserves the original value, because you
won't be able to read it again.  The meaning of each bit value is
specified below:

Bit 7: 1 (bit value of 128) = Break Detected
Bit 6: 1 (bit value of 64)  = DTR (Data Set Ready) Signal Missing
Bit 5: Unused
Bit 4: 1 (bit value of 16)  = CTS (Clear to Send) Signal Missing
Bit 3: 1 (bit value of 8)   = Receiver Buffer Empty
Bit 2: 1 (bit value of 4)   = Receiver Buffer Overrun
Bit 1: 1 (bit value of 2)   = Framing Error
Bit 0: 1 (bit value of 1)   = Parity Error

The user is responsible for checking these errors and taking
appropriate action.  If, for example, you find that Bit 0 or 1 is set
when you are sending, indicating a framing or parity error, you should
resend the last byte.  If Bit 2 is set, the GET#2 command is not being
executed quickly enough to empty the buffer (BASIC should be able to
keep up at 300 baud, but not higher).  If Bit 7 is set, you will want
to stop sending, and execute a GET#2 to see what is being sent."
"In the context of the C64, What is the purpose of the memory location at address $A5?","address           $A5            CNTDN
Cassette Synchronization Character Countdown

Used to count down the number of synchronization characters that are
sent before the actual data in a tape block."
"In the context of the C64, What is the purpose of the memory location at address $F34A?","address              $F34A          OPEN
Open a Logical I/O File

OPEN is a documented Kernal I/O routine.  It can be entered from the
jump table at 65472 ($FFC0).

The routine jumps through a RAM vector at 794 ($31A).  This routine
assigns a logical file to a device, so that it can be used for
Input/Output operations.  In order to specify the logical file number,
the device number, and the secondary address if any, the SETLFS
routine must first be called.  Likewise, in order to designate the
filename, the SETNAM routine must be used first.  After these two
routines are called, OPEN is then called."
"In the context of the C64, What is the purpose of the memory location at address $B8?","address           $B8            LA
Current Logical File Number

This location holds the logical file number of the device currently
being used.  A maximum of five disk files, and ten files in total, may
be open at any one time.

File numbers range from 1 to 255 (a 0 is used to indicate system
defaults).  When printing to a device with a file number greater than
127, an ASCII linefeed character will be sent following each carriage
return, which is useful for devices like serial printers that require
linefeeds in addition to carriage returns.

The BASIC OPEN command calls the Kernal OPEN routine, which sets the
value of this location.  In the BASIC statement OPEN 4,8,15, the
logical file number corresponds to the first parameter 4."
"In the context of the C64, What is the purpose of the memory location at address $310?","address          $310           USRPOK
Jump Instruction for User Function ($4C)

The value here (67, $4C) is first part of the 6510 machine language
JuMP instruction for the USR command."
"In the context of the C64, What is the purpose of the memory location at address $0328-$0329?","address       $328-$329      ISTOP
Vector to Kernal STOP Routine (Currently at 63213 ($F6ED))

This vector points to the address of the routine that tests the STOP
key.  The STOP key can be disabled by changing this with a POKE
808,239.  This will not disable the STOP/RESTORE combination, however.
To disable both STOP and STOP/ RESTORE, POKE 808,234 (POKEing 234 here
will cause the LIST command not to function properly).  To bring
things back to normal in either case, POKE 808, 237."
"In the context of the C64, What is the purpose of the memory location at address $50-$52?","address         $50-$52        DSCPNT
Temporary Pointer to the Current String Descriptor

The string assignment and handling routines use the first two bytes as
a temporary pointer to the current string descriptor, and the third to
hold the value of the string length."
"In the context of the C64, What is the purpose of the memory location at address $6F?","address           $6F            ARISGN
Result of a Signed Comparison of Accumulator #1 to Accumulator #2

Used to indicate whether the two Floating Point Accumulators have like
or unlike signs.  A 0 indicates like signs, a 255 ($FF) indicates
unlike signs."
"In the context of the C64, What is the purpose of the memory location at address $5-$6?","address          $5-$6          ADRAY2
Vector: Routine to Convert a Number from Integer to Floating Point

This vector points to the address of the BASIC routine which converts
an integer to a floating point number.  This routine is currently
located at 45969 ($B391).  BASIC does not appear to reference this
location.  It is available for use by the programmer who needs to make
such a conversion for a machine language program that interacts with
BASIC.  For an explanation of how to use this routine in connection
with the USR command, see the entry for the USR vector at 785 ($311)."
"In the context of the C64, What is the purpose of the memory location at address $D403?","address              $D403          PWHI1
Voice 1 Pulse Waveform Width (high nybble)"
"In the context of the C64, What is the purpose of the memory location at address $BAB7?","address         $BAB7          MULDIV
Add Exponent of FAC1 to Exponent of FAC2"
"In the context of the C64, What is the purpose of the memory location at address $BC39?","address         $BC39          SGN
Perform SGN

The SGN routine calls the above routine to put the sign of FAC1 into
.A, and then converts that value into a floating point number in FAC1."
"In the context of the C64, What is the purpose of the memory location at address $D409?","address              $D409          PWLO2
Voice 2 Pulse Waveform Width (low byte)"
"In the context of the C64, What is the purpose of the memory location at address $BF52?","address         $BF52
Unused area

This unused area is filled with byts of 170 ($AA)."
"In the context of the C64, What is the purpose of the memory location at address $D004?","address         $D004          SP2X
Sprite 2 Horizontal Position"
"In the context of the C64, What is the purpose of the memory location at address $D014?","address              $D014          LPENY
Light Pen Vertical Position

This location holds the vertical position of the light pen.  Since
there are only 200 visible scan lines on the screen, the value in this
register corresponds exactly to the current raster scan line."
"In the context of the C64, What is the purpose of the memory location at address $D013?","address              $D013          LPENX
Light Pen Horizontal Position

This location holds the horizontal position of the light pen.  Since
there are only eight bits available (which give a range of 256 values)
for 320 possible horizontal screen positions, the value here is
accurate only to every second dot position.  The number here will
range from 0 to 160 and must be multiplied by 2 in order to get a
close approximation of the actual horizontal dot position of the light
pen."
"In the context of the C64, What is the purpose of the memory location at address $D003?","address         $D003          SP1Y
Sprite 1 Vertical Position"
"In the context of the C64, What is the purpose of the memory location at address $BF71?","address         $BF71          SQR
Perform SQR

This routine moves the contents of FAC1 to FAC2, moves the constant
0.5 to FAC1, and falls through to the exponentation routine."
"In the context of the C64, What is the purpose of the memory location at address $BC58?","address         $BC58          ABS
Perform ABS

The FAC1 sign byte at 102 ($66) is shifted right by this command, so
that the top bit is a 0 (positive)."
"In the context of the C64, What is the purpose of the memory location at address $D40A?","address              $D40A          PWHI2
Voice 2 Pulse Waveform Width (high nybble)"
"In the context of the C64, What is the purpose of the memory location at address $D404?","address              $D404          VCREG1
Voice 1 Control Register

Bit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release
Bit 1:  Sync Bit:  1=Synchronize Oscillator with Oscillator 3 frequency
Bit 2:  Ring Modulation:  1=Ring modulate Oscillators 1 and 3
Bit 3:  Test Bit:  1=Disable Oscillator 1
Bit 4:  Select triangle waveform
Bit 5:  Select sawtooth waveform
Bit 6:  Select pulse waveform
Bit 7:  Select random noise waveform


Bit 0.  Bit 0 is used to gate the sound.  Setting this bit to a 1
while selecting one of the four waveforms will start the
attack/decay/sustain part of the cycle.  Setting this bit back to 0
(while keeping the same waveform setting) anytime after a note has
started playing will begin the release cycle of the note.  Of course,
in order for the gate bit to have an effect, the frequency and
attack/decay/sustain/release (ADSR) registers must be set, as well as
the pulse width, if necessary, and the volume control set to a nonzero
value.

Bit 1.  This bit is used to synchronize the fundamental frequency of
Oscillator 1 with the fundamental frequency of Oscillator 3, allowing
you to create a wide range of complex harmonic structures from voice
1.  Synchronization occurs when this bit is set to 1.  Oscillator 3
must be set to some frequency other than zero, but no other voice 3
parameters will affect the output from voice 1.

Bit 2.  When Bit 2 is set to 1, the triangle waveform output of voice
1 is replaced with a ring modulated combination of Oscillators 1 and
3.  This ring modulation produces nonharmonic overtone structures that
are useful for creating bell or gong effects.

Bit 3.  Bit 3 is the test bit.  When set to 1, it disables the output
of the oscillator.  This can be useful in generating very complex
waveforms (even speech synthesis) under software control.

Bit 4.  When set to 1, Bit 4 selects the triangle waveform output of
Oscillator 1.  Bit 0 must also be set for the note to be sounded.

Bit 5.  This bit selects the sawtooth waveform when set to 1.  Bit 0
must also be set for the sound to begin.

Bit 6.  Bit 6 chooses the pulse waveform when set to 1.  The harmonic
content of sound produced using this waveform may be varied using the
Pulse Width Registers.  Bit 0 must be set to begin the sound.

Bit 7.  When Bit 7 is set to 1, the noise output waveform for
Oscillator 1 is set.  This creates a random sound output whose
waveform varies with a frequency proportionate to that of Oscillator
1.  It can be used to imitate the sound of explosions, drums, and
other unpitched noises.

One of the four waveforms must be chosed in order to create a sound.
Setting more than one of these bits will result in a logical ANDing of
the waveforms.  Particularly, the combination of the noise waveform
and another is not recommended.

Location Range: 54277-54278 ($D405-$D406)
Voice 1 Envelop (ADSR) Control

When a note is played on a musical instrument, the volume does not
suddenly rise to a peak and then cut off to zero.  Rather, the volume
builds to a peak, levels off to an intermediate value, and then fades
away.  This creates what is known as a volume envelope.

The first phase of the envelope, in which the volume builds to a peak,
is known as the attack phase.  The second, in which it declines to an
intermediate level, is called the decay phase.  The third, in which
the intermediate leve of volume is held, is known as the sustain
period.  The final interval, in which the sound fades away, is called
the release part of the cycle.

The SID chip allows the volume envelope of each voice to be
controlled, so that specific instruments may be imitated, or new
sounds created.  This is done via the attack/decay and sustain/release
registers.  Each register devotes four bits (which can store a number
from 0 to 15) to each phase of the cycle.  When a note is gated by
writing a 1 to a waveform bit and to Bit 0 of the Control Register,
the attack cycle begins.

The volume of the sound builds to a peak over the period of time
specified by the high nybble of the attack/decay register.  Once it
has reached the peak volume, it falls to the intermediate level during
the period indicated by the low nybble of the attack/decay register
(this is the decay phase).  The volume of this intermediate or sustain
level is selected by placing a value in the high nybble of the
sustain/release register.  This volume level is held until a 0 is
written to the gate bit of the control register (while leaving the
waveform bit set).  When that happens, the release phase begins, and
the volume of the sound begins to taper off during the period
indicated by the low nybble of the sustain/release register.

You may notice the volume of the sound does not quite get to 0 at the
end of the release cycle, and you may need to turn off the sound to
get rid of the residual noise.  You can do this either by setting the
waveform bit back to 0, changing the frequency to 0, or setting the
volume to 0."
"In the context of the C64, What is the purpose of the memory location at address $BAD4?","address         $BAD4          MLDVEX
Handle Underflow or Overflow"
"In the context of the C64, What is the purpose of the memory location at address $6E?","address           $6E            ARGSGN
Floating Point Accumulator #2: Sign"
"In the context of the C64, What is the purpose of the memory location at address $3-$4?","address           $3-$4          ADRAY1
Vector: Routine to Convert a Number from Floating Point to Signed
Integer

This vector points to the address of the BASIC routine which converts
a floating point number to an integer.  In the current Kernal version,
the address that it points to is 45482 ($B1AA).  Disassembly of the
ROMs indicates that BASIC does not use this vector.  However, it may
be of real assistance to the programmer who wishes to use data that is
stored in floating point format.  The parameter that is passed by the
USR command is available only in that format, for example.

Since it is extremely difficult to decipher and use a floating point
number, the simplest way to deal with such data is to use the
conversion routines that are built into BASIC to change it into a
two-byte signed integer.  This could be accomplished by jumping
directly into the BASIC ROM, if you know the location of the routine.
Therefore, if the address changes in future versions of the 64 or
future Commodore computers, you won't have to modify your program to
make it work with them.

See the entry for the USR vector at 785 ($311) for an explanation of
how to use this routine in connection with the USR command."
"In the context of the C64, What is the purpose of the memory location at address $4E-$4F?","address         $4E-$4F        DEFPNT
Pointer to the Current FN Descriptor

During function definition (DEF FN) this location is used as a pointer
to the descriptor that is created.  During function execution (FN) it
points to the FN descriptor in which the evaluation results should be
saved."
"In the context of the C64, What is the purpose of the memory location at address $326-$327?","address      $326-$327      IBSOUT
Vector to Kernal CHROUT Routine (Currently at 61898 ($F1CA))"
"In the context of the C64, What is the purpose of the memory location at address $30F?","address           $30F           SPREG
Storage Area for .P (Status) Register

The Status (.P) register has seven different flags.  Their bit
assignments are as follows:

Bit 7 (bit value of 128) = Negative
Bit 6 (bit value of 64)  = Overflow
Bit 5 (bit value of 32)  = Not Used
Bit 4 (bit value of 16)  = BREAK
Bit 3 (bit value of 8)   = Decimal
Bit 2 (bit value of 4)   = Interrupt Disable
Bit 1 (bit value of 2)   = Zero
Bit 0 (bit value of 1)   = Carry

If you wish to clear any flag before a SYS, it is safe to clear them
all with a POKE 783,0.  The reverse is not true, however, as you must
watch out for the Interrupt disable flag.

A 1 in this flag bit is equal to an SEI instruction, which turns off
all IRQ interrupts (like the one that reads the keyboard, for
example).  Turning off the keyboard could make the computer very
difficult to operate!  To set all flags except for Interrupt disable
to 1, POKE 783,247."
"In the context of the C64, What is the purpose of the memory location at address $B9?","address           $B9            SA
Current Secondary Address

This location holds the secondary address of the device currently
being used.  The range of valid secondary address numbers is 0 through
31 for serial devices, and 0 through 127 for other devices.

Secondary device numbers mean something different to each device that
they are used with.  The keyboard and screen devices ignore the
secondary address completely.  But any device which can have more than
one file open at the same time, such as the disk drive, distinguishes
between these files by using the secondary address when opening a disk
file.  Secondary address numbers 0, 1, and 15-31 have a special
significance to the disk drive, and therefore device numbers 2-14 only
should be used as secondary addresses when opening a disk file.

OPENing a disk file with a secondary address of 15 enables the user to
communicate with the Disk Operating System through that channel.  A
LOAD command which specifies a secondary address of 0 (for example,
LOAD 'AT BASIC',8,0) results in the program being loaded not to the
address specified on the file as the starting address, but rather to
the address pointed to by the start of BASIC pointer (43, $2B).

A LOAD with a secondary address of 1 (for example, LOAD 'HERE',8,1)
results in the contents of the file being loaded to the address
specified in the file.  A disk file that has been LOADed using a
secondary address of 1 can be successfully SAVEd in the same manner
(SAVE 'DOS 5.1',8,1).

LOADs and SAVEs that do not specify a secondary address will default
to a secondary address of 0.

When OPENing a Datasette recorder file, a secondary address of 0
signifies that the file will be read, while a secondary address of 1
signifies that the file will be written to.  A value of 2 can be added
to indicate that an End of Tape marker should be written as well.
This marker tells the Datasette not to search past it for any more
files on the tape, though more files can be written to the tape if
desired.

As with the disk drive, the LOAD and SAVE commands use secondary
addresses of 0 and 1 respectively to indicate whether the operation
should be relocating or nonrelocating.

When the 1515 or 1525 Printer is opened with a secondary address of 7,
the uppercase/lowercase character set is used.  If it is openend with
a secondary address of 0, or without a secondary address, the
uppercase/graphics character set will be used."
"In the context of the C64, What is the purpose of the memory location at address $F49E?","address              $F49E          LOAD
Load RAM from a Device

This is a documented Kernal routine, whose entry in the jump table
appears at 65493 ($FFD5).

The routine jumps through a RAM vector at 816 ($330).  LOAD is used to
transfer data froma device directly to RAM.  It can also be used to
verify RAM, comparing its contents to those of a disk or tape file.
To choose between these operations you must set the Accumulator with a
0 for LOAD, or a 1 for VERIFY.

Since the LOAD routine performs an OPEN, it must be preceded by a call
to the SETLFS routine to specify the logical file number, device
number, and secondary address, and a call to the SETNAM routine to
specify the filename (a LOAD from tape can be performed without a
filename being specified).  Then the .X and .Y registers should be set
with the starting address for the load, and the LOAD routine called.
If the secondary address specified was a 1, this starting address will
be ignored, and the header information will be used to supply the load
address.  If the secondary address was a 0, the address supplied by
the call will be used.  In either case, upon return from the
subroutine, the .X and .Y registers will contain the address of the
highest RAM location that was loaded."
"In the context of the C64, What is the purpose of the memory location at address $A6?","address           $A6            BUFPNT
Count of Characters in Tape I/O Buffer

This location is used to count the number of bytes that have been read
in or written to the tape buffer.  Since on a tape write, no data is
sent until the 192 byte buffer is full, you can force output of the
buffer with the statement POKE 166,191."
"In the context of the C64, What is the purpose of the memory location at address $F7D0?","address              $F7D0
Put Pointer to Tape Buffer in .X and .Y Registers"
"In the context of the C64, What is the purpose of the memory location at address $298?","address          $298           BITNUM
RS-232: Number of Bits Left to be Sent/Received

This location is used to determine how many zero bits must be added to
the data character to pad its length out to the word length specified
in 659 ($293)."
"In the context of the C64, What is the purpose of the memory location at address $288?","address          $288           HIBASE
Top Page of Screen Memory

This location contains the value used by the Operating System routines
that print to the screen as the base address for screen RAM.  The top
of screen memory can be found by multiplying this location by 256.
The default value for screen RAM is set on power-up to location 1024
($400), and this location therefore usually contains a 4.

Screen display memory on the Commodore 64 can be moved to start on any
1K boundary (location evenly divisible by 1024).  This is done by
manipulating the VIC-II chip memory bank select at location 56576
($DD00).

It is important to note, however, that while any area may be
displayed, the Operating System will look here to find out where it
should PRINT characters.  Therefore, if you change the screen location
by altering the contents of one of the two addresses listed above, the
Operating System will still not know where to PRINT characters unless
you also change this address as well.  The result will be that
characters entered from the keyboard or PRINTed will not appear on the
screen.

Examples of how to properly relocate the screen can be found at the
entries for location 53272 ($D018) and 43 ($2B).

Since the PRINT command in essence just POKEs a lot of values to
screen and color memory, by changing this pointer you can print a
string of characters to memory locations other than screen RAM.  For
example, you could PRINT a sprite shape to memory without having to
READ a lot of DATA statements.  The program below PRINTs different
sprite shapes into the sprite data area:

10 SP=53248:POKESP,170:POKESP+1,125:POKESP+21,1:POKE 2040,13:PRINT CHR$(147)
20 A$='THIS TEXT WILL BE PRINTED TO THE SPRITE SHAPE DATA AREA AND DISPLAYED'
30 GOSUB 100
40 A$='THIS IS SOME DIFFERENT TEXT TO BE PRINTED TO THE SPRITE SHAPE AREA'
50 GOSUB 100
60 COUNT=COUNT+1:IF COUNT<15 THEN 20
70 END
100 POKE 648,3:PRINT CHR$(19);CHR$(17);SPC$(24);A$;:POKE 648,4:RETURN

Since PRINTing also changes color memory, you can change the pointer
to print the characters harmlessly to ROM, while changing a lot of
screen RAM at one time, as the following program demonstrates:

10 D$=CHR(94):FOR I=1 TO 4:D$=D$+D$:NEXT
20 PRINT CHR$(147);:FOR I=1 TO 7:PRINT TAB(10) D$:NEXT:PRINT:PRINT:PRINT:PRINT
30 PRINT TAB(9);CHR$(5);'HIT ANY KEY TO STOP'
40 DIM C(15):FOR I=0TO14:READ A:C(I)=A:NEXT:DATA2,8,7,5,6,4,1,2,8,7,5,6,4,1,2
50 POKE 53281,0:POKE 648,212:FOR J=0 TO 6:PRINT CHR$(19);
60 FOR I=J TO J+6:POKE 646,C(I):PRINT TAB(10) D$:NEXT I,J
70 GET A$:IF A$='' THEN 50
80 POKE 648,4:POKE 646,1"
"In the context of the C64, What is the purpose of the memory location at address $F6DD?","address              $F6DD          RDTIM
Read the Time From the Software Clock into the .A, .X, and .Y
Registers

This is a documented Kernal routine whose entry point in the jump
table is 65502 ($FFDE).

It reads the software clock (which counts sixtieths of a second) into
the internal registers.  The .Y register contains the most significant
byte (from location 160 ($A0)), the .X register contains the middle
byte (from location 161 ($A1)), and the Accumulator contains the least
significant byte (from location 162 ($A2))."
"In the context of the C64, What is the purpose of the memory location at address $EDC7?","address              $EDC7          TKSA
Send a Secondary Address to a Device on the Serial Bus after TALK

This is a documented Kernal routine that can be entered from the jump
table at 65430 ($FF96).  It sends a secondary address from the
Accumulator to the device on the serial bus that has just been
commanded to TALK.  This is usually done to give the device more
particular instructions on how the I/O is to be carried out before
information is sent."
"In the context of the C64, What is the purpose of the memory location at address $EE8E?","address              $EE8E
Set the Serial Clock Line High (Inactive)

This subroutine sets the serial bus clock pulse output bit to 1 (Bit 4
of CIA #2 Data Port A at 56576 ($DD00))."
"In the context of the C64, What is the purpose of the memory location at address $9000-$9FFF?","address   $9000-$9FFF
Character ROM Image for VIC-II Chip When Using Memory Bank 2

When the VIC-II chip is set up to use the third 16K block of memory
for graphics (as would be the case when the 64 is set up to emulate
the PET, which has its text screen memory at 32768 ($8000), it sees
the character generator ROM at this address (see entry at 4096 ($1000)
above for more details).

It should be noted that the character ROM is available only when the
VIC-II chip is using banks 0 or 2.  When using one of the other two
banks, the user must supply all of the character shape data in a RAM
table."
"In the context of the C64, What is the purpose of the memory location at address $A408-$A434?","address   $A408-$A434    REASON
Check for Space in Memory

This is the subroutine that checks to see if there is enough space in
free memory for proposed additions such as new lines of program text.
If not, it calls for garbage collection, and if this still does not
produce enough space, an OUT OF MEMORY error is issued."
"In the context of the C64, What is the purpose of the memory location at address $E701?","address              $E701
Move Cursor Back over a 40-Column Line Boundary"
"In the context of the C64, What is the purpose of the memory location at address $E8CB?","address              $E8CB
Check for a Color Change

This routine is used by the screen CHROUT routine to check if the
character to be printed is one that causes the current foreground
color to change (such as the CTRL-1 combination)."
"In the context of the C64, What is the purpose of the memory location at address $A717?","address         $A717          QPLOP
Print BASIC Tokens as ASCII Characters

This is the part of the LIST routine that chagnes one-byte program
tokens back to their ASCII text characters.  The routine is vectored
through RAM at 774 ($306), so it is possible to list out new command
words that you have added by changing this vector to detour through
your own routine."
"In the context of the C64, What is the purpose of the memory location at address $A3B8?","address         $A3B8          BLTU
Open a Space in Memory for a New Program Line or Variable

When a new nonarray variable is being created, or when a BASIC program
line is being added or replaced, this routine is used to make room for
the addition.  It first checks to see if space is available, and then
moves the program text and/or variables to make room."
"In the context of the C64, What is the purpose of the memory location at address $A642?","address        $A642          SCRTCH
Perform NEW

The NEW command stores two zeros in the link address of the first
program line to indicate the end of program, and sets the end of
program pointer at 45-46 ($2D-$2E) to point to the byte past those
zeros.  It continues through to the CLR command code."
"In the context of the C64, What is the purpose of the memory location at address $E9C8?","address              $E9C8
Move Screen Line

This subroutine is used by the scroll routine to move one screen line
(and its associated Color RAM) up a line."
"In the context of the C64, What is the purpose of the memory location at address $E684?","address              $E684
Test for Quote Marks

This subroutine checks if the current character is a quotation mark,
and if it is, toggles the quote switch at 212 ($D4)."
"In the context of the C64, What is the purpose of the memory location at address $A480-$A49B?","address   $A480-$A49B    MAIN
Main Loop, Receives Input and Executes Immediately or Stores as
Program Line

This is the main BASIC program loop.  It jumps through the RAM vector
at 770 ($302), so this routine can be diverted.  The routine gets a
line of input from the keyboard, and checks for a line number.  If
there is a line number, the program branches to the routine that
stores a line of program text.  If there is no line number, it
branches to the routine that executes statements."
"In the context of the C64, What is the purpose of the memory location at address $EEBB?","address              $EEBB
Send Next RS-232 Bit (NMI)

This subroutine is called by the NMI interrupt handler routine to send
the next bit of data to the RS-232 device."
"In the context of the C64, What is the purpose of the memory location at address $ED11?","address              $ED11
Send Command Code to a Device on the Serial Bus

This subroutine is used in common by many Kernal routines to send the
command code in the Accumulator to a device on the serial bus."
"In the context of the C64, What is the purpose of the memory location at address $AA?","address           $AA            RIDATA
RS-232 Input Byte Buffer/Cassette Temporary Storage

Serial routines use this area to reassemble the bits received into a
byte that will be stored in the receiving buffer pointer to by 247
($F7).  Tape routines use this as a flag to help determine whether a
received character should be treated as data or as a synchronization
character."
"In the context of the C64, What is the purpose of the memory location at address $F157?","address     83         $F157          CHRIN
Input a Character from the Current Device

This is a documented Kernal routine whose jump table entry point is at
65487 ($FFCF).

The routine jumps through a RAM vector at 804 ($324).  Its function is
to get a character from the current input device (whose device number
is stored at 153 ($99)).  This device must first have been OPENed and
then designated as the input channel by the CHKIN routine.

When this routine is called, the next byte of data available from this
device is returned in the Accumulator.  The only exception is the
routine for the keyboard device (which is the default input device).
It the keyboard is the current input device, this routine blinks the
cursor, fetches characters from the keyboard buffer, and echoes them
to the screen until a carriage return is encountered.  When a carriage
return is round, the routine sets a flag to indicate the length of the
last logical line before the return character, and reads the first
character of this logical line from the screen.

Subsequent calls to this routine will cause the next character in the
line to be read from the screen and returned in the Accumulator, until
the carriage return character is returned to indicate the end of the
line.  Any call after this character is received will start the whole
process over again.

Note that only the last logical line before the carriage return is
used.  Any time you type in more than 80 characters, a new logical
line is started.  This routine will ignore any characters on the old
logical line, and process only the most recent 80-character group."
"In the context of the C64, What is the purpose of the memory location at address $B5?","address          $B5            NXTBIT
RS-232 Next Bit to Send/Tape EOT Flag

This location is used by the RS-232 routines to hold the next bit to
be sent, and by the tape routines to indicate what part of a block the
read routine is currently reading."
"In the context of the C64, What is the purpose of the memory location at address $F5D2?","address              $F5D2
Print LOADING or VERIFYING"
"In the context of the C64, What is the purpose of the memory location at address $28C?","address          $28C           DELAY
Counter for Timing the Delay Until the First Key Repeat Begins

This location is used as a delay counter to determine how long a key
must be held down before the entry of that key should be repeated.

The initial value of 16 is counted down every 1/60 second, as long as
the same key remains pressed.  When the value gets to 0, location 651
($28B) is counted down from 6, and the key is repeated when the value
there reaches 0.  Thus a total of 22/60, or approximately 1/3, second
will elapse before the first repeat of a key.  The value here will be
held to 0 after the first repeat, so that subsequent keystroke
repititions occur much more quickly."
"In the context of the C64, What is the purpose of the memory location at address $293?","address          $293           M51CTR
RS-232: Mock 6551 Control Register

This location is used to control the RS-232 serial I/O baud rate
(speed at which data is transmitted and received), the word length
(number of bits per data character), and the number of stop bits used
to mark the end of a transmitted character.  It uses the same format
as that of the 6551 UART control register to set these parameters,
although, as you will see, some of the 6551 configurations are not
implemented by the software that emulates the UART device.  For
example, the standard baud rates which are higher than 2400 baud are
not implemented, presumably because the software cannot keep up at
higher rates.  The meanings of the various bit patterns are as
follows:

Bit 7: STOP Bits
0    (bit value of 0)   = 1 STOP Bit
1    (bit value of 128) = 0 STOP Bits

Bits 6-5: WORD LENGTH
00   (bit value of 0)   = 8 DATA Bits
01   (bit value of 32)  = 7 DATA Bits
10   (bit value of 64)  = 6 DATA Bits
11   (bit value of 96)  = 5 DATA Bits

Bit 4: Unused

Bits 3-0: BAUD RATE
0000 (bit value of 0)   = Nonstandard (User-Defined) Rate (Not Implemented)
0001 (bit value of 1)   = 50 Baud
0010 (bit value of 2)   = 75 Baud
0011 (bit value of 3)   = 110 Baud
0100 (bit value of 4)   = 134.5 Baud
0101 (bit value of 5)   = 150 Baud
0110 (bit value of 6)   = 300 Baud
0111 (bit value of 7)   = 600 Baud
1000 (bit value of 8)   = 1200 Baud
1001 (bit value of 9)   = 1800 Baud
1010 (bit value of 10)  = 2400 Baud
1011 (bit value of 11)  = 3600 Baud (Not Implemented on the Commodore 64)
1100 (bit value of 12)  = 4800 Baud (Not Implemented on the Commodore 64)
1101 (bit value of 13)  = 7200 Baud (Not Implemented on the Commodore 64)
1110 (bit value of 14)  = 9600 Baud (Not Implemented on the Commodore 64)
1111 (bit value of 15)  = 19200 Baud (Not Implemented on the Commodore 64)

This register is the only one which must be set when opening RS-232
device (number 2).  The first character of the filename will be stored
here.  For example, the statement OPEN 2,2,0,CHR$(6+32) will set the
value of this location to 38.  As you can see from the above chart,
this sets up the RS-232 device for a data transfer rate of 300 baud,
using seven data bits per character and one stop bit."
"In the context of the C64, What is the purpose of the memory location at address $F82E?","address              $F82E
Check Cassette Switch

This subroutine is used to check if a button on the recorder has been
pressed."
"In the context of the C64, What is the purpose of the memory location at address $57-$60?","address         $57-$60
BASIC Numeric Work Area

This is a very busy work area, used by many routines."
"In the context of the C64, What is the purpose of the memory location at address 0-255?","Page zero
Memory locations 0-255 ($0-$FF) have a special significance in 6502
machine language programming (the 6510 microprocessor in the Commodore
64 shares the same instruction set as the 6502).  Since these
addresses cn be expressed using just one byte, instructions which
access data stored in these locations are shorter and execute more
quickly than do instructions which operate on addresses in higher
memory, which requires two bytes.

Because of this relatively fast execution time, most 6502 software
makes heavy use of zero-page locations.  The 64 is no exception, and
uses this area for many important system variables and pointers.

In addition, locations 0 and 1 have special Input/Output functions on
the 6510.  In the case of the 64, this on-chip I/O port is used to
select the possible combinations of ROM, as we will se below, and to
control cassette I/O."
"In the context of the C64, What is the purpose of the memory location at address $68?","address          $68            BITS
Floating Point Accumulator #1: Overflow Digit

This location contains the overflow byte.  The overflow byte is used
in an intermediate step of conversion from an integer or text string
to a floating point number."
"In the context of the C64, What is the purpose of the memory location at address $314-$315?","address       $314-$315      CINV
Vector to IRQ Interrupt Routine

This vector points to the address of the routine that is executed when
an IRQ interrupt occurs (normally 59953 ($FA31)).

At power on, the CIA #1 Timer B is set to cause an IRQ interrupt to
occur every 1/60 second.  This vector is set to point to the routine
which updates the software clock and STOP key check, blinks the
cursor, maintains the tape interlock, and reads the keyboard.  By
changing this vector, the user can add or substitute a machine
language routine that will likewise execute every 1/60 second.  The
user who is writing IRQ interrupt routines should consider the
following:

1.  It is possible for an IRQ interrupt to occur while you are
changing this vector, which would cause an error from which no
recovery could be made.  Therefore, you must disable all IRQ
interrupts before changing the contents of this location, and reenable
them afterwards, by using the 6510 SEI and CLI instructions, or by
using the Kernal VECTOR routine (64794, $FD1A) to set this vector.

2.  There is some code in ROM that is executed before the interrupt
routine is directed through this vector.  This code checks whether the
source of the interrupt was an IRQ or BRK instruction.  If first
preserves the contents of all the registers by pushing them onto the
stack in the following sequence:  PHA, TXA, PHA, TYA, PHA.  It is up
to the user to restore the stack at the end of his routine, either by
exiting through the normal IRQ, or with the sequence:  PLA, TAY, PLA,
TAX, PLA, RTI.

3.  There is only one IRQ vector, but there are many sources for IRQ
interrupts (two CIA chips, and several VIC chip IRQs).  If you plan to
enable IRQs from more than one source, the IRQ routine here must
determine the source, and continue the routine in the appropriate
place for an IRQ from that source.

In the same vein, if you replace the normal IRQ routine with your own,
you should be aware that the keyboard's scanning and clock update will
not occur unless you call the old interrupt routine once every 1/60
second.  It is suggested that if you plan to use that routine, you
save the old vector address in some other location.  In that way, you
can JuMP to the keyboard interrupt routine through this alternate
vector, rather than assuming that the ROM address will never change
and that it is safe to jump into the ROM directly."
"In the context of the C64, What is the purpose of the memory location at address $31E-$31F?","address      $31E-$31F      ICHKIN
Vector to Kernal CHKIN Routine (Currently at 61966 ($F20E))"
"In the context of the C64, What is the purpose of the memory location at address $D000?","address         $D000          SP0X
Sprite 0 Horizontal Position"
"In the context of the C64, What is the purpose of the memory location at address $BB0F?","address         $BB0F          FDIV
Divide a Number in Memory by FAC1

This number in memory is stored to FAC2, and this routine falls
through to the next."
"In the context of the C64, What is the purpose of the memory location at address $D400?","address              $D400          FRELO1
Voice 1 Frequency Control (low byte)"
"In the context of the C64, What is the purpose of the memory location at address $D40E?","address              $D40E          FRELO3
Voice 3 Frequency Control (low byte)"
"In the context of the C64, What is the purpose of the memory location at address $BC0F?","address         $BC0F          MOVEF
Copy FAC1 to FAC2 Without Rounding"
"In the context of the C64, What is the purpose of the memory location at address $D007?","address         $D007          SP3Y
Sprite 3 Vertical Position"
"In the context of the C64, What is the purpose of the memory location at address $D00E?","address              $D00E          SP7X
Sprite 7 Horizontal Position"
"In the context of the C64, What is the purpose of the memory location at address $D00F?","address              $D00F          SP7Y
Sprite 7 Vertical Position"
"In the context of the C64, What is the purpose of the memory location at address $D008?","address         $D008          SP4X
Sprite 4 Horizontal Position"
"In the context of the C64, What is the purpose of the memory location at address $D40D?","address              $D40D          SUREL2
Voice 2 Sustain/Release Control Register

Bits 0-3:  Select release cycle duration (0-15)
Bits 4-7:  Select sustain volume level (0-15)"
"In the context of the C64, What is the purpose of the memory location at address $BC0C?","address         $BC0C          MOVAF
Round and Move a Floating Point Number from FAC1 to FAC2"
"In the context of the C64, What is the purpose of the memory location at address $BAFE?","address         $BAFE          DIV10
Divide FAC1 by 10"
"In the context of the C64, What is the purpose of the memory location at address $D400-$D41C?","address        $D400-$D41C
Sound Interface Device (SID) Registers

Mmeory locations 54272-54300 ($D400-$D41C) are used to address the
6581 Sound Interface Device (SID).

SID is a custom music synthesizer and sound effects generator chip
that gives the 64 its impressive musical capabilities.  It provides
three separate music channels, or voices, as they are called.  Each
voice has 16-bit frequency resolution, waveform control, envelope
shaping, oscillator synchronization, and ring modulation.  In
addition, programmable high-pass, low-pass, and band-pass filters can
be set and enabled or disabled for each sound channel.

Since quite a few of these locations must be used in concert to
produce sound, a brief summary of the interplay between some of these
registers may be helpful.

Often the first step is to select an overall volume level using the
Volume Register.  Then, the desired frequency or pitch of the note is
chosen by writing to each of the two bytes which make up the 16-bit
Frequency Register.

An ADSR envelope setting must be chosen by writing values to the
Attack/ Decay and Sustain/Release Register.  These determine the rate
of the rise and fall of the volume of the note from zero volume to
peak volume and back again.  These rates have a great influence on the
character of the sound.

Finally, the waveform must be selected, and the note started (or the
oscillator gated, as we say).  This is done by writing certain bits to
the Control Register.  The waveform control lets you select one of
four different waveforms, each of which has varying harmonic content
that affects the tone quality of the sound.  By writing a 1 to the
gate bit, you start the Attack/ Delay/Sustain cycle.  Afer rising to a
peak and declining to the Sustain volume, the volume will continue at
the same level until you write a 0 to the gate bit.  Then, the Release
cycle will start.  Make sure that you keep the same waveform bit set
to 1 while you write the 0 to the gate bit, so that the Release cycle
starts.  Otherwise, the sound will stop entirely, as it also will if
the Volume Register or the Frequency Register is set to 0.

It should be noted that except for the last four SID chip registers,
these addresses are write-only.  That means that their values cannot
be determined by PEEKing these locations.

Location Range: 54272-54273 ($D400-$D401)
Voice 1 Frequency Control

Together, these two locations control the frequency or pitch of the
musical output of voice 1.  Some frequency must be selected in order
for voice 1 to be heard.  This frequency may be changed in the middle
of a note to achieve special effects.  The 16-bit range of the
Frequency Control Register covers over eight full octaves, and allows
you to vary the pitch from 0 (very low) to about 4000 Hz (very high),
in 65536 steps.  The exact frequency of the output can be determined
by the equation

FREQUENCY=(REGISTER VALUE*CLOCK/16777216)Hz

where CLOCK equals the system clock frequency, 1022730 for American
(NTSC) systems, 985250 for European (PAL), and REGISTER VALUE is the
combined value of these frequency registers.  That combined value
equals the value of the low byte plus 256 times the value of the high
byte.  Using the American (NTSC) clock value, the equation works out
to

FREQUENCY=REGISTER VALUE*.060959458 Hz"
"In the context of the C64, What is the purpose of the memory location at address 53248-53264 ($D000-$D010)?","address 53248-53264 ($D000-$D010)
Sprite Horizontal and Vertical Position Registers

These locations determine the horizontal and vertical position at
which each sprite will be displayed on the screen.  Each sprite has
its own horizontal and vertical position register.  In addition, all
of the sprites share a common register which is used to extend the
range of horizontal positions.

Vertical positions for each sprite range from 0 to 255, and these
indicate the vertical position of the top line of the sprite's 21-line
length.  Since there are only 200 visible scan lines in the screen
display, some of these vertical positions will result in the sprite
being partially or wholly offscreen.

The visible viewing area starts at line 50 and extends to line 249.
Therefore, any sprite whose vertical psition is 29 ($1D) or less will
be completely above the visible picture.  At vertical position 30
($1E), the bottom line of the sprite display becomes visible at the
top of the screen.  At position 230 ($E6), the bottom line of the
sprite is lost from view off the bottom of the screen, and at vertical
position 250 ($FA), the entire sprite disappears from view off the
bottom edge of the screen.

Horizontal positioning is somewhat trickier, because the visible
display area is 320 dots wide, and one eight-bit register can hold
only 256 position values.  Therefore, an additional register is needed
to hold the ninth bit of each sprite's horizontal position.

Each sprite is assigned a single bit in the Most Significant Bit of
Horizontal Position register (MSB register) at 53264 ($D010).  If that
bit is set to 1, the value 256 is added to the horizontal position.
This extends the range of possible horizontal positions to 511.

In order to set a sprite's horizontal position, you must make sure
that both the values in the horizontal position register and the MSB
Register are correct.  For example, if you wish to set the horizontal
position of Sprite 5 to a value of 30, you must place a value of 30 in
the Sprite 5 Horizontal Position Register (POKE 53258,30 will do it
from BASIC), and you must also clear Bit 5 of the MSB Register (POKE
53264,PEEK(53264)AND(255-16)).  If you forget the MSB register, and
Bit 5 is set to 1, you will end up with position 286 instead of 30.

The horizontal position value indicates the position of the leftmost
dot of the sprite's 24-dot width.  The visible display is restricted
to the 320 dot positions between positions 24 and 344.  At position 0
the whole sprite is past the left edge of the visible screen.  At
position 1 the righmost dot enters the display area, and at position
24 ($18) the entire sprite is displayed on screen.  At position 321
($141) the rightmost dot goes past the right edge of the visible
display area, and a position 355 ($158) the whole sprite has moved out
of sight, off the right edge of the screen.

These registers are all intialized to 0 at power-up."
"In the context of the C64, What is the purpose of the memory location at address $320-$321?","address       $320-$321      ICKOUT
Vector to Kernal CKOUT Routine (Currently at 62032 ($F250))"
"In the context of the C64, What is the purpose of the memory location at address $316-$317?","address       $316-$317      CBINV
Vector: BRK Instruction Interrupt

This vector points to the address of the routine which will be
executed anytime that a 6510 BRK instruction (00) is encountered.

The default value points to a routine that calls several of the Kernal
initialization routines such as RESTOR, IOINIT and part of CINT, and
then jumps through the BASIC warm start vector at 40962.  This is the
same routine that is used when the STOP and RESTORE keys are pressed
simultaneously, and is currently located at 65126 ($Fe66).

A machine language monitor program will usually change this vector to
point to the monitor warm start address, so that break points may be
set that will return control to the monitor for debugging purposes."
"In the context of the C64, What is the purpose of the memory location at address $0?","Location Range: 0-143 ($0-$8F)
BASIC Working Storage

This portion of zero page is used by BASIC only.  Therefore, a program
written entirely in machine language that does not interact with BASIC
can freely use this area.

address            $0             D6510
6510 On-Chip I/O DATA Direction Register

Bit 0: Direction of Bit 0 I/O on port at next address.  Default = 1 (output)
Bit 1: Direction of Bit 1 I/O on port at next address.  Default = 1 (output)
Bit 2: Direction of Bit 2 I/O on port at next address.  Default = 1 (output)
Bit 3: Direction of Bit 3 I/O on port at next address.  Default = 1 (output)
Bit 4: Direction of Bit 4 I/O on port at next address.  Default = 0 (input)
Bit 5: Direction of Bit 5 I/O on port at next address.  Default = 1 (output)
Bit 6: Direction of Bit 6 I/O on port at next address.  Not used.
Bit 7: Direction of Bit 7 I/O on port at next address.  Not used.

This location is the first of a number of hardware registers that we
will discuss.  Although they can be written to and/or read like RAM,
they are connected to hardware devices, and their contents affect the
operation of the devices.

Each bit of this Data Direction Register determines whether the
contents of the corresponding bit on the Internal I/O Port (see
location 1) can be written to by peripheral devices.  If the bit is
set to 0, it indicates the direction of data flow as Input, which
means that the corresponding bit of the I/O port will be affected by
peripheral defices.  If the bit is set to 1, it indicates Output.  On
the 64, only Bits 0-5 are significant.  On power-up, this register is
set to 239 ($EF), which indicates that all bits, except for Bit 4
(which senses the cassette switch), are set up for Output."
"In the context of the C64, What is the purpose of the memory location at address $69-$6E?","address       $69-$6E        FAC2
Floating Point Accumulator #2

A second Floating Point Accumulator, used in conjunction with Floating
Point Accumulator #1 in the evaluation of products, sums,
differences--in short, any operation requiring more than one value.
The format of this accumulator is the same as FAC1."
"In the context of the C64, What is the purpose of the memory location at address $61-$66?","address        $61-$66        FAC1
Floating Point Accumulator #1

The Floating Point Accumulator is central to the execution of any
BASIC mathematical operation.  It is used in the conversion of
integers to floating point numbers, strings to floating point numbers,
and vice versa.  The results of most evaluations are stored in this
location.

The internal format of floating point numbers is not particularly easy
to understand (or explain).  Generally speaking, the number is broken
into the normalized mantissa, which represents a number between 1 and
1.99999..., and an exponent value, which represents a power of 2.
Multiplying the mantissa by 2 raised to the value of the exponent
gives you the value of the floating point number.

Fortunately, the BASIC interpreter contains many routines for the
manipulation and conversion of floating point number, and these
routines can be called by the user.  See the entries for locations 3
and 5

Floating Point Accumulator #1 can be further divided into the
following locations:"
"In the context of the C64, What is the purpose of the memory location at address $293-$297?","address ($293-$297)
RS-232 Pseudo 6551 Registers

For serial Input/Output via the RS-232 port, the internal software of
the Commodore 64 emulates the operation of a 6551 UART chip (that's
Universal Asynchronous Receiver/Transmitter, for you acronym buffs),
also known as an ACIA (Asynchronous Communications Interface Adapter).

These RAM locations are used to mimic the functions of that chip's
hardware command, control, and status registers.  Although RAM
locations are allocated for mimicking the 6551's ability to use either
an on-board baud rate generator or an external clock crystal, this
function is not implemented by the internal software.

Provisions have been made for the user to communicate with these
registers through the RS-232 OPEN command.  When device 2 is opened, a
filename of up to four characters may be appended.  These four
characters are copied to locations 659-662 ($293-$296), although the
last two, which specify a nonstandard baud rate, are not used because
that feature is not implemented."
"In the context of the C64, What is the purpose of the memory location at address $F817?","address              $F817
Test Cassette Buttons and Handle Messages for Tape Read

This routine tests the sense switch, and if no buttons are depressed
it prints the PRESS PLAY ON TAPE message, and loops until a cassette
button is pressed, or until the STOP key is pressed.  If a button is
pressed, it prints the message OK.

Since the message printing routine is entered after the test for
direct mode, these messages cannot be superseded by changing the flag
at 157 ($9D).  You could have them harmlessly printed to ROM, however,
by changing the value of HIBASE at 648 ($288) temporarily to 160, and
then back to 4."
"In the context of the C64, What is the purpose of the memory location at address $F5A5?","address              $F5A5
Print SEARCHING Message if in Direct Mode"
"In the context of the C64, What is the purpose of the memory location at address $28B?","address          $28B           KOUNT
Counter for Timing the Delay Between Key Repeats

This location is used as a delay counter to determine how long to wait
while a key is being held down until the next repeat printing of that
key.

The value here starts at 6.  If location 652 ($28C) contains a 0, the
value in this location is counted down once every 1/60 second, so long
as the same key is held down.  When this counter gets to 0, and if the
repeat flag at 650 ($28A) allows that key to repeat, its ASCII
equivalent will once again be placed in the keyboard buffer.  A value
of 4 is then placed in location 651, allowing subsequent repeats to
occur at a rate of 15 per second."
"In the context of the C64, What is the purpose of the memory location at address $B4?","address           $B4            BITTS
RS-232 Output Bit Count/Cassette Temporary Storage

RS-232 routines use this to count the number of bits transmitted, and
for parity and stop bit manipulation.  Tape load routines use this
location to flag when they are ready to receive data bytes."
"In the context of the C64, What is the purpose of the memory location at address $F13E?","address              $F13E          GETIN
Get One Byte from the Input Device

This is a documented Kernal routine whose jump table entry point is at
65508 ($FFE4).  The routine jumps through a RAM vector at 810 ($32A).
Its function is to get a character from the current input device
(whose device number is stored at 153 ($99)).  In practive, it
operates identically to the CHRIN routine below for all devices except
for the keyboard.  If the keyboard is the current input device, this
routine gets one character from the keyboard buffer at 631 ($277).  It
depends on the IRQ interrupt routine to rad the keyboard and put
characters into the buffer."
"In the context of the C64, What is the purpose of the memory location at address $A9?","address          $A9            RINONE
RS-232 Flag: Check for Start Bit

This flag is used when checking for a start bit.  A 144 ($90) here
indicates that no start bit was received, while a 0 means that a start
bit was received."
"In the context of the C64, What is the purpose of the memory location at address $ED40?","address              $ED40
Send a Byte on the Serial Bus

This subroutine is used in common by several Kernal routines to send
the byte in the serial bus character buffer at 149 ($95) on the serial
bus."
"In the context of the C64, What is the purpose of the memory location at address $EF2E?","address              $EF2E
Handle RS-232 Errors

This subroutine sets the appropriate error bits in the status register
at 663 ($297)."
"In the context of the C64, What is the purpose of the memory location at address $E632?","address              $E632
Input a Character from Screen or Keyboard

This routine is the portion of the Kernal CHRIN routine that handles
input from the keyboard and screen devices.  CHRIN gets one byte at a
time from the current screen position, or inputs a whole line from the
keyboard and returns it one byte at a time."
"In the context of the C64, What is the purpose of the memory location at address $A474-$A47F?","address   $A474-$A47F    READY
Print READY

This routine displays the word READY, sets the Kernal message flag to
show that direct mode is operative, and falls through to the main
BASIC loop."
"In the context of the C64, What is the purpose of the memory location at address $A613?","address        $A613          FINDLN
Search for Line Number

This routine searches through the program text, trying to match the
two-byte integer line number that is stored in 20-21 ($14-$15).  If it
is found, 95-96 ($5F-$60) will be set as a pointer to the address of
the link field for that line, and the Carry flag will be set.  If it
is not found, the Carry flag will be cleared."
"In the context of the C64, What is the purpose of the memory location at address $E965?","address              $E965
Insert a Blank Line on the Screen

This subroutine is used when INSERTing to add a blank physical line to
a logical line."
"In the context of the C64, What is the purpose of the memory location at address $A38A-$A3B7 ?","address   $A38A-$A3B7    FNDFOR
Find FOR on Stack

This routine searches the stack for the blocks of data entries which
are stored by each FOR command.  For more information on the data that
FOR places on the stack, see location 256 ($100)."
"In the context of the C64, What is the purpose of the memory location at address $EB79?","address              $EB79
Keyboard Decode Table Vectors

This table contains the two-byte addresses of the four keyboard decode
tables in low-byte, high-byte format."
"In the context of the C64, What is the purpose of the memory location at address $A49C?","address        $A49C          MAIN1
Add or Replace a Line of Program Text

This routine calls subroutines to get the line number, tokenize
keywords, and then looks for a line with the same line number.

If it finds a line with the same number, the routine deletes that line
by moving all higher program text and variables down to where it
started.  The new line is then added.  Since the CLR routine is
called, the value of all current program variables is lost."
"In the context of the C64, What is the purpose of the memory location at address $E5B4?","address              $E5B4          LP2
Get a Character from the Keyboard Buffer

This routine transfers the first character from the keybard buffer to
the .A register, bumps the rest of the characters one place up in
line, and decrements the pointer, showing how many characters are
waiting in the buffer."
"In the context of the C64, What is the purpose of the memory location at address $E8D1?","address              $E8D1
PETASCII Color Code Equivalent Table

This table gives the PETASCII values of the color change characters
for each of the 16 possible colors.  These values are:

144 ($90)  Change to color 0 (black)
  5 ($05)  Change to color 0 (white)
 28 ($1C)  Change to color 0 (red)
159 ($9F)  Change to color 0 (cyan)
156 ($9C)  Change to color 0 (purple)
 30 ($1E)  Change to color 0 (green)
 31 ($1F)  Change to color 0 (blue)
158 ($9E)  Change to color 0 (yellow)
129 ($81)  Change to color 0 (orange)
149 ($95)  Change to color 0 (brown)
150 ($96)  Change to color 0 (light red)
151 ($97)  Change to color 0 (dark gray)
152 ($98)  Change to color 0 (medium gray)
153 ($99)  Change to color 0 (light green)
154 ($9A)  Change to color 0 (light blue)
155 ($9B)  Change to color 0 (light gray)"
"In the context of the C64, What is the purpose of the memory location at address $A65E?","address         $A65E          CLEAR
Perform CLR

The CLR command closes all I/O files with the Kernal CLALL routine
(62255, $F32F).  It eliminates string variables by copying the end of
memory pointer at 55-56 ($37-$38) to the bottom of strings pointer at
51-52 ($33-$34).  It also copies the pointer to the end of BASIC
program text at 49-50 ($31-$31) to the pointer to the start of
nonarray variables at 45-46 ($2D-$2E) and the start of array variables
at 47-48 ($2F-$30).  This makes these variables unusable (although the
contents of these areas are not actually erased).  RESTORE is called
to set the data pointer back to the beginning, and the stack is
cleared."
"In the context of the C64, What is the purpose of the memory location at address $FF93?","address              $EDB9          SECOND
Send a Secondary Address to a Device on the Serial Bus after LISTEN

This is a documented Kernal routine that can be entered from the jump
table at 65427 ($FF93).  It sends a secondary address from the
Accumulator to the device on the serial bus that has just been
commanded to LISTEN.  This is usually done to give the device more
particular instructions on how the I/O is to be carried out before
information is sent."
"In the context of the C64, What is the purpose of the memory location at address $EF59?","address              $EF59
Receive Next RS-232 Bit (NMI)

This routine is called by the NMI interrupt handler routine to receive
the next bit of data from the RS-232 device."
"In the context of the C64, What is the purpose of the memory location at address $B6?","address           $B6            RODATA
RS-232 Output Byte Buffer

RS-232 routines use this area to disassemble each byte to be sent from
the transmission buffer pointed to by 249 ($F9)."
"In the context of the C64, What is the purpose of the memory location at address $30D?","address          $30D           SXREG
Storage Area for .X Index Register"
"In the context of the C64, What is the purpose of the memory location at address $AB?","address          $AB            RIPRTY
RS-232 Input Parity/Cassete Leader Counter

This location is used to help detect if data was lost during RS-232
transmission, or if a tape leader is completed."
"In the context of the C64, What is the purpose of the memory location at address $F838?","address              $F838
Test Cassette Buttons and Handle Messages for Tape Write

This routine tests the sense switch, and if no buttons are depressed
it prints the PRESS PLAY & RECORD message, and loops until a cassette
button is pressed, or until the STOP key is pressed.  If a button is
pressed, it prints the message OK.  These messages cannot be supressed
by changing the flag at 157 ($9D).  See the entry for 63511 ($F817)
for more information."
"In the context of the C64, What is the purpose of the memory location at address $0291?","address           $291           MODE
Flag: Enable or Disable Changing Character Sets with SHIFT/Logo
Keypress

This flag is used to enable or disable the feature which lets you
switch between the uppercase/graphics and upper/lowercase character
sets by pressing the SHIFT and Commodore logo keys simultaneously.

This flag affects only this special SHIFT key function, and does not
affect the printing of SHIFTed characters.  POKEing a value of 128
($80) here will disable this feature, while POKEing a value of 0 will
enable it once more.  The same effect can be achieved by PRINTing
CHR$(8) or CTRL-H to disable the switching of character sets, and
CHR$(9) or CTRL-I to enable it.  See entries for locations 53272
($D018) and 49152 ($C000) for more information on switching character
sets."
"In the context of the C64, What is the purpose of the memory location at address $289?","address           $289           XMAX
Maximum Keyboard Buffer Size

The value here indicates the maximum number of characters that the
keyboard buffer at 631 ($277) may hold at any one time.  Anytime that
the current buffer length in location 198 ($C6) matches the value
here, further keypresses will be ignored.

Although the maximum size of the keyboard buffer is usually 10
characters, it may be possible to extend it up to 15 characters by
changing the number here.  This could cause the Operating System
pointers to the bottom and top of memory at 641-644 ($281-$284) to be
overwritten, but no real harm should result."
"In the context of the C64, What is the purpose of the memory location at address $F5DD?","address              $F5DD          SAVE
Save RAM to a Device

This is a documented Kernal routine, whose entry in the jump table
appears at 65496 ($FFD8).

The routine jumps through a RAM vector at 818 ($332).  SAVE is used to
transfer data directly from RAM to an I/O device.  Since the SAVE
routine performs an OPEN, it must be preceded by a call to the SETLFS
routine to specify the logical file number, device number, and
secondary address, and a call to the SETNAM routine to specify the
filename (although a SAVE to the cassette can be performed without
giving a filename).  A Page 0 pointer to the starting address of the
area to be saved should be set up, with the low byte of the address
first.  The accumulator should be loaded with the Page 0 offset of
that pointer, then the .X and .Y registers should be set with the
ending address for the save, and the SAVE routine called."
"In the context of the C64, What is the purpose of the memory location at address $67?","address          $67            SGNFLG
Number of Terms in a Series Evaluation

This location is used by mathematical formula evaluation routines.  It
indicates the number of separate evaluations that must be done to
resolve a complex expression down to a single term."
"In the context of the C64, What is the purpose of the memory location at address $2?","address             $2
Unused"
"In the context of the C64, What is the purpose of the memory location at address $54-$56?","address         $54-$56        JMPER
Jump to Function Instruction

The first byte is the 6502 JMP instruction ($4C), followed by the
address of the required function taken from the table at 41042
($A052)."
"In the context of the C64, What is the purpose of the memory location at address $$324-$325?","address      $324-$325      IBASIN
Vector to Kernal CHRIN Routine (Currently at 61783 ($F157))"
"In the context of the C64, What is the purpose of the memory location at address $31A-$32D?","address ($31A-$32D)
Kernal Indirect Vectors

There are 39 Kernal routines for which there are vectors in the jump
table located at the top of the ROM (65409, $FF81).  For ten of these
routines, the jump table entry contains a machine language instruction
to jump to the address pointed to by the RAM vector in this table.
The addresses in this table are initialized to point to the
corresponding routines in the Kernal ROM.  Since these addresses are
in RAM, however, any entry in this table may be changed.  This enables
the user to add to these routines, or to replace them completely.

You will notice, for example, that many of these routines involve
Input/ Output functions.  By changing the vectors  to these routines,
it is possible to support new I/O devices, such as an IEEE disk drive
used through an adapter.

The user should be cautioned that since some of these routines are
interrupt-driven, it is dangerous to change these vectors without
first turning off all interrupts.  For a safe method of changing all
of these vectors at one time, along with the interrupt vectors above,
see the entry for the Kernal VECTOR routine at 64794 ($FD1A).

More specific information about the individual routines can be found
in the descriptions given for their ROM locations."
"In the context of the C64, What is the purpose of the memory location at address $A3-$A4?","address       $A3-$A4
Temporary Data Storage Area

These locations are used temporarily by the tape and serial I/O
routines."
"In the context of the C64, What is the purpose of the memory location at address $D021?","address              $D021          BGCOL0
Background Color 0

This register sets the background color for all text modes, sprite
graphics, and multicolor bitmap graphics.  The default color value is
6 (blue)."
"In the context of the C64, What is the purpose of the memory location at address $BC1B?","address         $BC1B          ROUND
Round Accumulator #1 by Adjusting the Rounding Byte

If doubling the rounding byte at location 112 ($70) makes it greater
than 128, the value of FAC1 is increased by 1."
"In the context of the C64, What is the purpose of the memory location at address $D40B?","address              $D40B          VCREG2
Voice 2 Control Register

Bit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release
Bit 1:  Sync Bit:  1=Synchronize oscillator with Oscillator 1 frequency
Bit 2:  Ring Modulation:  1=Ring modulate Oscillators 2 and 1
Bit 3:  Test Bit:  1=Disable Oscillator 2
Bit 4:  Select triangle waveform
Bit 5:  Select sawtooth waveform
Bit 6:  Select pulse waveform
Bit 7:  Select noise waveform"
"In the context of the C64, What is the purpose of the memory location at address $D01D?","address              $D01D          SP6COL
Sprite 6 Color Register (the default color value is 7, yellow)"
"In the context of the C64, What is the purpose of the memory location at address $BB12?","address         $BB12          FDIVT
Divide FAC2 by FAC1

This routine is used to divide the contents of FAC2 by the contents of
FAC1, with the result being stored in FAC1.  A check for division by 0
is made before dividing."
"In the context of the C64, What is the purpose of the memory location at address $D00D?","address              $D00D          SP6Y
Sprite 6 Vertical Position"
"In the context of the C64, What is the purpose of the memory location at address $D006?","address         $D006          SP3X
Sprite 3 Horizontal Position"
"In the context of the C64, What is the purpose of the memory location at address $D005?","address         $D005          SP2Y
Sprite 2 Vertical Position"
"In the context of the C64, What is the purpose of the memory location at address $D00C?","address              $D00C          SP6X
Sprite 6 Horizontal Position"
"In the context of the C64, What is the purpose of the memory location at address $D01E?","address              $D01E          SP7COL
Sprite 7 Color Register (the default color value is 12, medium gray)

Location Range: 53295-53311 ($D02F-$D03F)
Not Connected

The VIC-II chip has only 47 registers for 64 bytes of possible address
space.  Therefore, the remaining 17 addresses do not access any
memory.  When read, they will always give a value of 255 ($FF).  This
value will not change after writing to them.

Location Range: 53312-54271 ($D040-$D3FF)
VIC-II Register Images

Since the VIC-II requires only enough addressing lines to handle 64
locations (the minimum possible for its 47 registers), none of the
higher bits are decoded when addressing this 1K area.  The result is
that every 64 byte area in this 1K block is a mirror of every other.
POKE53281+64,1 has the same effect as POKE53281,1 or
POKE53281+10*64,1; they all turn the screen background to white.  For
the sake of clarity in your programs it is advisable to use the base
address of the chip."
"In the context of the C64, What is the purpose of the memory location at address $BBA2?","address         $BBA2          MOVFM
Move a Floating Point Number from Memory to FAC1

This routine loads FAC1 with the five-byte floating point number
pointed to by the address stored in the Accumulator (low byte) and the
.Y register (high byte)."
"In the context of the C64, What is the purpose of the memory location at address $BC2B?","address         $BC2B          SIGN
Put the Sign of Accumulator #1 into .A Register

On exit from this routine the Accumulator will hold a 0 if FAC1 is 0,
a 1 if it is positive, and a value of 255 ($FF) if it is negative."
"In the context of the C64, What is the purpose of the memory location at address $D40C?","address              $D40C          ATDCY2
Voice 2 Attack/Decay Register

Bits 0-3:  Select decay cycle duration (0-15)
Bits 4-7:  Select attack cycle duration (0-15)"
"In the context of the C64, What is the purpose of the memory location at address $D022?","address              $D022          BGCOL1
Background Color 1

This register sets the color for the 01 bit-pair of multicolor
character graphics, and the background color for characters having
screen codes 64-127 in extended background color text mode.  The
default color value is 1 (white)."
"In the context of the C64, What is the purpose of the memory location at address $318-$319?","address      $318-$319      NMINV
Vector: Non-Maskable Interrupt

This vector points to the address of the routine that will be executed
when a Non-Maskable Interrupt (NMI) occurs (currently at 65095
($FE47)).

There are two possible sources for an NMI interrupt.  The first is the
RESTORE key, which is connected directly to the 6510 NMI line.  The
second is CIA #2, the interrupt line of which is connected to the 6510
NMI line.

When an NMI interrupt occurs, a ROM routine sets the Interrupt disable
flag, and then jumps through this RAM vector.  The default vector
points to an interrupt routine which checks to see what the cause of
the NMI was.

If the cause was CIA #2, the routine checks to see if one of the
RS-232 routines should be called.  If the source was the RESTORE key,
it checks for a cartridge, and if present, the cartridge is entered at
the warm start entry point.  If there is no cartridge, the STOP key is
tested.  If the STOP key was pressed at the same time as the RESTORE
key, several of the Kernal initialization routines such as RESTOR,
IOINIT and part of CINT are executed, and BASIC is entered through its
warm start vector at 40962.  If the STOP key was not pressed
simultaneously with the RESTORE, the interrupt will end without
letting the user know that anything happened at all when the RESTORE
key was pressed.

Since this vector controls the outcome of pressing the RESTORE key, it
can be used to disable the STOP/RESTORE sequence.  A simple way to do
this is to change this vector to point to the RTI instruction.  A
simple POKE 792,193 will accomplish this.  To set the vector back,
POKE 792,71.  Note that this will cut out all NMIs, including those
required for RS-232 I/O."
"In the context of the C64, What is the purpose of the memory location at address $A0-$A02?","address       $A0-$A2        TIME
Software Jiffy Clock

These three locations are updated 60 times a second, and serve as a
software clock which counts the number of jiffies (sixtieths of a
second) that have elapsed since the computer was turned on.

The value of location 162 ($A2) is increased every jiffy (0.1667
second), 161 ($A1) is updated every 256 jiffies (4.2267 seconds), and
160 ($A0) changes every 65536 jiffies (or every 18.2044 minutes).
After 24 hours, these locations are set back to 0.

The jiffy clock is used by the BASIC reserved variables TI and TI$.
These are not ordinary variables that are stored in the RAM variable
area, but are functions that call the Kernal routines RDTIM (63197,
$F6DD), and SETTIM (63204, $F6E4).  Assigning the value of TI or TI$
to another variable reads these locations, while assigning a given
value to TI$ alters these locations.

To illustrate the relationship between these locations and TI$, try
the following program.  The program sets the jiffy clock to 23 hours,
50 minutes.  After the program has been running for one minute, all
these locations will be reset to 0.

100 TI$='235900'
110 PRINT TI$,PEEK(160),PEEK(161),PEEK(162)
120 GOTO 110

Since updating is done by the IRQ interrupt that reads the keyboard,
anything which affects the operation of that interrupt routine will
also interfere with this clock.  A typical example is tape I/O
operations, which steal the IRQ vector for their own use, and restore
it afterwards.  Obviously, user routines which redirect the IRQ and do
not send it back to the normal routine will upset software clock
operation as well."
"In the context of the C64, What is the purpose of the memory location at address $$322-$323?","address       $322-$323      ICLRCH
Vector to Kernal CLRCHN Routine (Currently at 62259 ($F333))"
"In the context of the C64, What is the purpose of the memory location at address $53?","address           $53            FOUR6
Constant for Garbage Collection

The constant contained here lets the garbage collection routines know
whether a three- or seven-byte string descriptor is being collected."
"In the context of the C64, What is the purpose of the memory location at address $66?","address          $66            FACSGN
Floating Point Accumulator #1: Sign

A value of 0 here indicates a positive number, while a value of 255
($FF) indicates a negative number."
"In the context of the C64, What is the purpose of the memory location at address 1?","address             $1             R6510

Bit 0: LORAM signal.  Selects ROM or RAM at 40960 ($A000).  1=BASIC, 0=RAM
Bit 1: HIRAM signal.  Selects ROM or RAM at 57344 ($E000).  1=Kernal, 0=RAM
Bit 2: CHAREN signal.  Selects character ROM or I/O devices.  1=I/O, 0=ROM
Bit 3: Cassette Data Output line.
Bit 4: Cassette Switch Sense.  Reads 0 if a button is pressed, 1 if not.
Bit 5: Cassette Motor Switch Control.  A 1 turns the motor on, 0 turns it off.
Bits 6-7: Not connected--no function presently defined.

The chief function of this register is to determine which blocks of
RAM and ROM the 6510 microprocessor will address.  The Commodore 64
comes with 64K RAM, even though it normally does not use all of that
RAM at once.  In addition, it has an 8K BASIC Interpreter ROM, an 8K
Operating System Kernal ROM, a 4K Character Generator ROM, a Sound
Interface Device (SID), a 6566 Video Interface Controller (VIC-II),
and two 6526 Complex Interface adapter chips.

To address all of these at once would require 88K, 24K past the
addressing limit of the 6510 microprocessor.  In order to allocate
address space, the I/O Port is used to affect the addressing lines,
and thus determine which segments of RAM and ROM will be addressed at
any one time.

Bit 0.  This bit controls the LORAM signal.  A 0 in this bit position
switches the BASIC ROM out, and replaces it with RAM at addresses
40960-49151 ($A000-$BFFF).  The default value of this bit is 1.

Bit 1.  Bit 1 controls the HIRAM signal.  A 0 in this bit position
switches the Kernal ROM out, and replaces it with RAM at 57344-65535
($E000-$FFFF).  As the BASIC interpreter uses the Kernal, it is also
switched out and replaced by RAM.  The default value of this bit is 1.

The system allows a wide range of combinations of RAM and ROM to be
utilized.  Of course, the BASIC programmer will have little need, in
the ordinary course of events, to switch out the BASIC ROM and the
Kernal.  To do so would just hang the system up.  But one way to make
use of this feature is to move the contents of ROM to the
corresponding RAM addresses.  That way, you can easily modify and
customize the BASIC interpreter and OS Kernal routines, which are
ordinarily fixed in ROM.  For examples, to move BASIC into RAM, just
type:

FOR I=40960 TO 49151:POKE I,PEEK(I):NEXT

Though it appears that such a program would not do anything, it in
fact copies bytes from ROM to RAM.  This is because any data which is
written to a ROM location is stored in the RAM which resides at the
same address.  So while you are PEEKing ROM, you are POKEing RAM.  To
switch to your RAM copy of BASIC, type in:

POKE 1,PEEK(1) AND 254.

Now you are ready to make modifications.  Examples of simple
modifications include changing the text which the interpreter prints,
such as the READY prompt, the power-up message, or the keyword table.

An example of the latter would be POKE 41122,69.  This changes the FOR
keyword to FER, so that BASIC would respond normally to a FER-NEXT
loop, but fail to recognize FOR as syntactically correct.

On the more practical side, you could change the prompt that INPUT
issues to a colon, rather than a question mark:

POKE 43846,58

You are not limited to just cosmetic changes of text.  Jim Butterfield
has given an example in COMPUTE! magazine of changing the interpreter
so that it assigns a null string the ASCII value 0.  In the ROM
version, the command PRINT ASC('') will return ?ILLEGAL QUANTITY
ERROR.  This is inconvenient when INPUTting a string, because if the
user presses RETURN and you try to check the ASCII value of the string
that has been entered, you will get this error.  By entering POKE
46991,5, this is changed so that PRINT ASC('') now responds with a
zero.

For the more serious machine language programmer, it is quite feasible
to add new commands or modify existing ones by diverting the vectors
which are discussed in the section covering the BASIC interpreter ROM.
For a good example of this technique, see the article 'Hi-Res Graphics
Made Simple' by Paul Schatz in COMPUTE!'s First Book of Commodore 64
Sound and Graphics.  The program example there inserts new graphics
commands into a RAM version of BASIC.  When you want to switch back to
the ROM BASIC, enter POKE 1,PEEK(1) OR 1.

For machine language applications, it would be possible to replace the
ROM programs with an entirely different operating system, or an
application that has its own screen editing and I/O functions
included.  Such an application would first have to be loaded from disk
into RAM.  A language other than BASIC could be loaded, and could then
just switch out the BASIC ROM, while still using the OS Kernal.

Or a spreadsheet application that contained its own I/O routines could
switch out all ROMs and have the use of all of RAM that is not
actually needed for the program itself, for data.  It should be
remembered, however, that before switching the Kernal out, it is
necessary to disable interrupts, as the vectors for these interrupts
are contained in the Kernal.

Bit 2.  This bit controls the CHAREN signal.  A 0 in this position
switches the character generator ROM in, so that it can be read by the
6510 at addresses 53248-57343 ($D000-$DFFF).  Normally, this bit is
set to 1, so that while the VIC-II chip has access to the character
generator ROM for purposes of creating the screen display, the user
cannot PEEK into it.  Since this ROM is switched into the system in
the same location as the I/O devices (SID chip, VIC-II chip, and 6526
CIA's), o I/O can occur when this ROM is switched in.

The ability to switch in the character generator ROM is very useful to
the programmer who wishes to expirement with user-defined characters.
Modified character graphics is one of the  more powerful graphics
tools available, but often the user will not want to redefine a whole
character set at one time.  By reading the character ROM and
duplicating its contents in RAM, the user can replace only a few
characters in the set.  The method for reading this ROM into RAM from
BASIC is as follows:

10 POKE 56333,127:POKE1,PEEK(1) AND 251:FOR I=0 TO 2048
20 POKE BASE+I,PEEK(53248+I):NEXT:POKE 1,PEEK(1) OR 4:POKE 56333,129

The first POKE is necessary to turn off the system timer interrupt.
Since the I/O devices are addressed in the same space as the character
ROM, switching that ROM in switches all I/O out, making it necessary
to turn off any interrupts which use these devices.

The second POKE is the one which switches in the character ROM.  The
program loop then reads this ROM memory into RAM, starting with the
address BASE.  Note that this address should start on an even 2K
boundary (an address evenly divisible by 2048) within the block of
memory presently being addresses by the VIC-II chip (for more
information on where to put user-defined character sets, and how to
use them, see the section on the VIC-II chip, under location 53272
($D018), the section on the character ROM at 49152 ($C000), and the
section on banking VIC-II memory at 56576 ($DD00)).  After reading the
contents of ROM into RAM, the next POKEs switch out the character ROM
and restore the interrupt.

It should be noted that while Bits 0-2 of this register allow software
control of some signals that determine the memory configuration that
is used by the Commodore 64 at any given time, they are not the only
determining factor.  Signals can also be generated by means of plug-in
expansion cartridges which are connected to the expansion port, and
these can change the memory map.

Two lines located on the exapansion port are called GAME and EXROM.
When used in conjunction with the software-controlled lines noted
above, these two hardware lines can enable cartridge ROM to replace
various segments of ROM and/or RAM.

Possible configurations include 8K of cartridge ROM to be switched in
at $8000-$9FFF, for a BASIC enhancement program; an 8K cartridge ROM
at $A000-$BFFF, replacing BASIC, or at $E000-$FFFF, replacing the
Kernal, or a 16k cartridge at $8000-$C000.

When cartridge ROM is selected to replace the Kernal, a Max emulator
mode is entered, which mimics the specification of the ill-fated Max
Machine, a game machine which Commodore never produced for sale int he
U.S.  In this mode, only the first 6K of RAM are used, there is no
access to the character ROM, and graphics data such as charactger
dot-data is mapped down from 57344 ($E000) to 8192 ($2000).  Further
hardware information may be obtained from the Commodore 64
Programmer's Reference Guide.

Bits 3-5 of this register have functions connected with the Datasette
recorder.  These are as follows:

Bit 3.  This is the Cassette Data Output line.  This line is connected
to the Cassette Data Write line on the cassette port, and is used to
send the data which is written to tape.

Bit 4.  This bit is the Cassette Switch Sense line.  This bit enables
a program to tell whether or not one of the buttons that moves the
recorder is pressed down.  If the switch on the recorder is down, this
bit will have a value of 1.  Remember that Bit 4 of the data direction
register at location 0 must contain a 0 for this bit to properly
reflect the status of the switch.

Bit 5.  Bit 5 is the Cassette Motor Control.  Setting this bit to zero
allows the motor to turn when you press one of the buttons on the
recorder, while setting it to one disables it from turning.

Most of the time, the setting of this bit will be controlled by the
interrupt routine that is used to read the keyboard every sixtieth of
a second.  If none of the buttons on the recorder is pressed, that
interrupt routine shuts the motor off and sets the interlock at
location 192 ($C0) to zero.  When a button is pressed, if the
interlock location is zero, Bit 5 of this register is set to zero to
turn the motor on.

When the interlock location contains a zero, the keyscan routine will
not let you control the setting of this bit of the register (and the
interlock is always set to zero when no buttons are pressed).  In
order for you to gain control of the motor, you must POKE a nonzero
value into 192 after a button on the recorder has been pressed.  You
can then shut off the motor and turn it back on as you please, by
manipulating this bit, so long as a button stays pressed."
"In the context of the C64, What is the purpose of the memory location at address $28A?","address          $28A           RPTFLAG
Flag: Which Keys Will Repeat?

The flag at this location is used to determine whether to continue
printing a character as long as its key is held down, or whether to
wait until the key is let up before allowing it to be printed again.
The default value here is 0, which allows only the cursor movement
keys, insert/delete key, and the space bar to repeat.

POKEing this location with 128 ($80) will make all keys repeating,
while a value of 64 ($40) will disable all keys from repeating."
"In the context of the C64, What is the purpose of the memory location at address $F68F?","address              $F68F
If in Direct Mode, Print SAVING and Filename"
"In the context of the C64, What is the purpose of the memory location at address $F841?","address              $F841
Start Reading a Block of Data from the Cassette

This subroutine tests the cassette switch and initializes various
flags for reading a block of data from cassette."
"In the context of the C64, What is the purpose of the memory location at address $292?","address           $292           AUTODN
Flag: Screen Scrolling Enabled

This location is used to determine whether moving the cursor past the
fortieth column of a logical line will cause another physical line to
be added to the logical line.

A value of 0 enables the screen to scroll the following lines down in
order to add that line; any nonzero value will disable the scroll.
This flag is set to disable the scroll temporarily when there are
characters waiting in the keyboard buffer (these may include cursor
movement characters that would eliminate the need for a scroll)."
"In the context of the C64, What is the purpose of the memory location at address $30E?","address           $30E           SYREG
Storage Area for .Y Index Register"
"In the context of the C64, What is the purpose of the memory location at address $AC-$AD?","address       $AC-$AD        SAL
Pointer to the Starting Address of a Load/Screen Scrolling

The pointer to the start of the RAM area to be SAVEd or LOADed at 193
($C1) is copied here.  This pointer is used as a working version, to
be increased as the data is received or transmitted.  At the end of
the operation, the initial value is restored here.  Screen management
routines temporarily use this as a work pointer."
"In the context of the C64, What is the purpose of the memory location at address $B7?","address          $B7            FNLEN
Length of Current Filename

This location holds the number of characters in the current filename.
Disk filenames may have from 1 to 16 characters, while tape filenames
range from 0 to 187 characters in length.

If the tape name is longer than 16 characters, the excess will be
truncated by the SEARCHING and FOUND messages, but will still be
present on the tape.  This means that machine language programs meant
to run in the cassette buffer may be saved as tape filenames.

A disk file is always referred to be a name, whether full or generic
(containing the wildcard characters * or ?).  This location will
always be greater than 0 if the current file is a disk file.  Tape
LOAD, SAVE, and VERIFY operations do not require that a name be
specified, and this location can therefore contain a 0.  If this is
the case, the contents of the pointer to the filename at 187 will be
irrelevant.

An RS-232 OPEN command may specify a filename of up to four
characters.  These characters are copied to locations 659-662
($293-$296), and determine baud rate, word length, and parity."
"In the context of the C64, What is the purpose of the memory location at address $#F4A?","address              $#F4A
Set the Word Length For the Current RS-232 Character

This routine takes the number of data bits to send per RS-232
character from the control register and puts it into the .X register
for use by the RS-232 routines."
"In the context of the C64, What is the purpose of the memory location at address $EDB0?","address              $EDB0
Time-Out Error on Serial Bus

This subroutine handles the case when the device does not respond by
setting the DEVICE NOT PRESENT error code and exiting."
"In the context of the C64, What is the purpose of the memory location at address $E8EA?","address              $E8EA
Scroll Screen

This subroutine moves all of the screen lines up, so that a blank line
is created at the bottom of the screen and the top screen line is
lost.  If the top logical line is two physical lines long, all lines
are moved up two lines.  Holding down the CTRL key will cause a brief
pause after the scroll."
"In the context of the C64, What is the purpose of the memory location at address $A68E?","address         $A68E          RUNC
Reset Pointer to Current Text Character to the Beginning of Program
Text

This routine resets the CHRGET pointer TXTPTR (122-123, $7A-$7B) so
that the next byte of text that the interpreter will read comes from
the beginning of program text."
"In the context of the C64, What is the purpose of the memory location at address $A533?","address         $A533          LINKPRG
Relink Lines of Tokenized Program Text

Each line of program text starts with a pointer to the address of the
next line (link address).  This routine scans each line to the end
(which is marked with a 0), and calculates the new link address by
adding the offset to the address of the current statement."
"In the context of the C64, What is the purpose of the memory location at address $E5CA?","address              $E5CA
Wait for a Carriage Return from the Keyboard

This subroutine is called by the portion of the CHKIN routine that
handles keyboard input.  It turns the cursor on, gets characters, and
echoes them to the screen until a carriage return has been entered.
It also looks for the shifted RUN/STOP key, and forces the output of
the commands LOAD and RUN if it finds it."
"In the context of the C64, What is the purpose of the memory location at address $EB81?","address              $EB81
Standard Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the standard keyboard,
one for each key which is struck by itself.  The table is in keycode
order (see the keycode table in Appendix H for the correspondence of
keycode to key).  A 65th byte with the value of 255 ($FF) marks the
end of the table (this corresponds to a keypress value of 64, no key
pressed)."
"In the context of the C64, What is the purpose of the memory location at address $A82C?","address         $A82C
Test STOP Key for Break in Program

The Kernal STOP routine is called from here, and if the key is
pressed, the STOP (63213, $F6ED) command, below, is executed."
"In the context of the C64, What is the purpose of the memory location at address $E460?","address              $E460          WORDS
Power-Up Messages

The ASCII text of the start-up messages '**** COMMODORE 64 BASIC V2
****' and 'BYTES FREE' is stored here.

Location Range: 58551-58623 ($E4B7-E4FF)
Patches Added to Later Kernal Versions

This area contains code that was not found in the original version of
the Kernal.  These additions were made to fix some bugs and to
increase Kernal compatibility between U.S. and European 64s."
"In the context of the C64, What is the purpose of the memory location at address $E500?","address              $E500          IOBASE
Store Base Address of Memory-Mapped I/O Devices in .X and .Y Registers

This is one of the documented Kernal routines for which there is a
vector in the jump table at 65523 ($FFF3).

When called, this routine sets the .X register to the low byte of the
base address of the memory-mapped I/O devices, and puts the high byte
in the .Y register.  This allows a user to set up a zero-page pointer
to the device, and to load and store indirectly through that pointer.
A program which uses this method, rather than directly accessing such
devices could be made to function without change on future Commodore
models, even though the I/O chips may be addressed at different
locations.  This of course assumes that the CIA or a similar chip will
be used.  This routine is of limited value for creating software that
is compatible with both the VIC-20 and the 64 because of the
differences in the VIA I/O chip that the VIC uses.

The current version of this routine loads the .X register with a 0,
and the .Y register with 220 ($DC), thus pointing to CIA #1, which is
at 56320 ($DC00)."
"In the context of the C64, What is the purpose of the memory location at address $AA80?","address         $AA80          PRINTN
Perform PRINT#

The PRINT# statement calls CMD and then closes the output channel with
the Kernal CLRCHN routine (62259, $F333)."
"In the context of the C64, What is the purpose of the memory location at address $AEA8?","address         $AEA8          PIVAL
PI Expressed as a Five-Byte Floating Point Number

The value of PI is stored here as a five-byte floating point number."
"In the context of the C64, What is the purpose of the memory location at address $B185","address         $B185          FINPTR
Return the Address of the Variable That Was Found or Created

This routine stores the address of the variable that was found or
created by the preceding routines in a pointer at 71-72 ($47-$48)."
"In the context of the C64, What is the purpose of the memory location at address $B3B3?","address         $B3B3          DEF
Perform DEF

DEF performs some syntax checking, and pushes five bytes onto the
stack:  the first byte of the function statement, a two-byte pointer
to the dependent variable (the X in FN(X)), and the address of the
first character of the definition itself, where it resides in the
program text.

The DEF statement must fit on one line, but functions can be extended
by nesting them (having one function call another)."
"In the context of the C64, What is the purpose of the memory location at address $FCB8?","address              $FCB8
Terminate Cassette I/O

This routine calls the subroutine above and returns from the
interrupt."
"In the context of the C64, What is the purpose of the memory location at address $26D-$276?","address       $26D-$276      SAT
Kernal Table of Secondary Addresses for Each Logical File"
"In the context of the C64, What is the purpose of the memory location at address $F3-$F4?","address       $F3-$F4        USER
Pointer to the Address of the Current Screen Color RAM Location

This poitner is synchronized with the pointer to the address of the
first byte of screen RAM for the current line kept in location 209
($D1).  It holds the address of the first byte of color RAM for the
corresponding screen line."
"In the context of the C64, What is the purpose of the memory location at address $FB8E?","address              $FB8E
Move the Tape SAVE/LOAD Address into the Pointer at 172"
"In the context of the C64, What is the purpose of the memory location at address $FF6E?","address              $FF6E
End of Routine to Set Timer for Sixtieth of a Second IRQ

This appears to be a patch added to compensate for the extra length of
the current version of this routine, which chooses either the PAL or
NTSC prescaler values for the timer."
"In the context of the C64, What is the purpose of the memory location at address $45-$46?","address        $45-$46        VARNAM
Current BASIC Variable Name

The current variable name being searched for is stored here, in the
same two- byte format as in the variable value storage area located at
the address pointed to by 45 ($2D).  See that location for an
explanation of the format."
"In the context of the C64, What is the purpose of the memory location at address $26-$2A?","address        $26-$2A        RESHO
Floating Point Multiplication Work Area

This location is used by BASIC multiplication and division routines.
It is also used by the routines which compute the size of the area
required to store an array which is being created."
"In the context of the C64, What is the purpose of the memory location at address $B9BC?","address         $B9BC          FONE
Floating Point Constant with a Value of 1

This five-byte floating point representation of the number 1 is stored
here for use by the floating point routines.  It is also used as the
default STEP value for the FOR statement."
"In the context of the C64, What is the purpose of the memory location at address $D420-$D7FF?","address     $D420-$D7FF
SID Register Images

Since the SID chip requires enough addressing lines for only 32
locations (the minimum possible for its 29 registers), none of the
higher bits are decoded when addressing the 1K area that has been
assigned to it.  The result is that every 32-byte area in this 1K
block is a mirror of every other.  For the sake of clarity in your
programs, it is advisable not to use these addresses at all."
"In the context of the C64, What is the purpose of the memory location at address $D417?","address              $D417          RESON
Filter Resonance Control Register

Bit 0:  Filter the output of voice 1?  1=yes
Bit 1:  Filter the output of voice 2?  1=yes
Bit 2:  Filter the output of voice 3?  1=yes
Bit 3:  Filter the output from the external input?  1=yes
Bits 4-7:  Select filter resonance 0-15

Bits 0-3 are used to control which of the voices will be altered by
the filters.  If one of these bits is set to 1, the corresponding
voice will be processed through the filter, and its harmonic content
will be changed accordingly.  If the bit is set to 0, the voice will
pass directly to the audio output.  Note that there is also a
provision for processing an external audio signal which is brought
through pin 5 of the Audio/Video Port.

Bits 4-7 control the resonance of the filter.  By placing a number
from 0 to 15 in these four bits, you may peak the volume of those
frequencies nearest the cutoff.  This creates an even sharper
filtering effect.  A setting of 0 causes no resonance, while a setting
of 15 gives maximum resonance."
"In the context of the C64, What is the purpose of the memory location at address $B7F7?","address         $B7F7          GETADR
Convert a Floating Point Number to an Unsigned Two-Byte Integer

This routine checks the number in the Floating Point Accumulator to
make sure that it is a positive number less than 65536, and then calls
the subroutine which conerts floatin point to integer.  It is used to
get address parameters, for commands such as PEEK."
"In the context of the C64, What is the purpose of the memory location at address $B6A3?","address         $B6A3          FRESTR
Discard a Temporary String

This routine calls the following routine which clears an entry from
the temporary descriptor stack.  If the descriptor was on the stack,
it exits after setting pointers to the string and its length.  If it
wasn't on the temporary stack and is at the bottom of string text
storage, the pointer to the bottom is moved up to deallocate the
string."
"In the context of the C64, What is the purpose of the memory location at address $E043?","address              $E043          POLY1
Function Series Evaluation Subroutine 1

This routine is used to evaluate more comples expressions, and calls
the following routine to do the intermediate evaluation."
"In the context of the C64, What is the purpose of the memory location at address $DD0C?","address              $DD0C          CI2SDR
Serial Data Port

The CIA chip has an on-chip serial port, which allows you to send or
receive a byte of data one bit at a time, with the most significant
bit (Bit 7) being transferred first.  For more information about its
use, see the entry for location 56332 ($DC0C).  The 64's Operating
System does not use this facility."
"In the context of the C64, What is the purpose of the memory location at address $DD0B?","address              $DD0B          TO2HRS
Time of Day Clock Hours

Bits 0-3:  Second digit of Time of Day hours (BCD)
Bit 4:  First digit of Time of Day hours (BCD)
Bits 5-6:  Unused
Bit 7:  AM/PM flag (1=PM, 0=AM)"
"In the context of the C64, What is the purpose of the memory location at address $E000?","address              $E000
Continuation of EXP Routine

This routine is split, with part on the BASIC ROM and the other part
here.  Since the two ROMs do not occupy contiguous memory as on most
Commodore machines, the BASIC ROM ends with a JMP $E000 instruction.
Thus, while the BASIC interpreter on the 64 is for the most part the
same as on the VIC, the addresses for routines in this ROM are
displaced by three bytes from their location on the VIC."
"In the context of the C64, What is the purpose of the memory location at address $B6DB?","address         $B6DB          FRETMS
Remove an Entry from the String Descriptor Stack

If the descriptor of a currently valid string is the same as one of
the entries on the temporary string descriptor stack, the stack entry
is removed."
"In the context of the C64, What is the purpose of the memory location at address $D418?","address              $D418          SIGVOL
Volume and Filter Select Register

Bits 0-3:  Select output volume (0-15)
Bit 4:  Select low-pass filter, 1=low-pass on
Bit 5:  Select band-pass filter, 1=band-pass on
Bit 6:  Select high-pass filter, 1=high-pass on
Bit 7:  Disconnect output of voice 4, 1=voice 3 off

Bits 0-3 control the volume of all outputs.  The possible volume
levels range from 0 (no volume) to 15 (maximum volume).  Some level of
volume must be set here before any sound can be heard.

Bits 4-6 control the selection of the low-pass, band-pass, or
high-pass filter.  A 1 in any of these bits turns the corresponding
filter on.  These filters can be combined, although only one cutoff
frequency can be chosen.  In order for the filter to have any effect,
at least one of the voices must be routed through it using the Filter
Resonance Control Register at 54295 ($D417).

When Bit 7 is set to 1,  it disconnects the output of voice 3.  This
allows you to use the output of the oscillator for modulating the
frequency of the other voices, or for generating random number,
without any undesired audio output.

Location Range: 54297-54298 ($D419-$D41A)
Game Paddle Inputs

These registers allow you to read the game paddles that plug into
joystick Controller Ports 1 and 2.  Each paddle uses a variable
resistor (also known as a potentiometer or pot), whose resistance is
controlled by turning a knob.  The varying resistance is used to vary
the voltage to two pins of the SID chip between 0 and +5 volts.
Analog-to-digital (A/D) converters in the chip interpret these voltage
levels as binary values and store the values in these registers.
These registers return a number from 0 (minumum resistance) to 255
(maximum resistance) for each paddle in either of the ports, depending
on the position of the paddle knob.

Since these registers will read the paddle values for only one
controller port, there is a switching mechanism which allows you to
select which of the two ports to read.  By writing a bit-pair of 01
(bit value of 64) to the last two bits of CIA #1 Data Port A (56320,
$DC00), you select the paddles on joystick Controller Port 1.  By
writing a bit-pair of 10 (bit value of 128), you select the paddles on
Controller Port 2.

If you look at the description of Data Port A (56320, $DC00), however,
you will notice that it is also used in the keyboard scanning process.
By writing to this port, you determine which keyboard column will be
read.

Since the IRQ interrupt keyboard scan routine and the routine that
checks for the STOP key are putting values into this location 60 times
per second, you cannot reliable select the pair of paddles you wish to
read from BASIC without first turning off the keyboard IRQ.  This can
be done with a POKE 56333,127.  You can then read the paddles with the
statements A=PEEK(54297) and B=PEEK(54298).  The IRQ can be restored
after a paddle read with a POKE 56333,129.  It may, however, be easier
and more accurate in the long run to use a machine language paddle
read subroutine such as that presented on page 347 of the Commodore 64
Programmer's Reference Guide.

The paddle fire buttons are read as Bits 2 and 3 of the Data Ports A
(56320, $DC00) and B (56321, $DC01).  On Port A, if Bit 2 is set to 0,
button 1 is pushed, and if Bit 3 is set to 0, button 2 is pushed.  On
Port B, if Bit 2 is set to 0, button 3 is pushed, and if Bit 3 is set
to 0, button 4 is pushed.

The BASIC statements to test these buttons, thereore, are:

PB(1)=(PEEK(56321)AND4)/4
PB(2)=(PEEK(56321)AND8)/8
PB(3)=(PEEK(56320)AND4)/4
PB(4)=(PEEK(56320)AND8)/8

If a 0 is returned by the PEEK statement, the button is pushed, and if
a 1 is returned, it is not."
"In the context of the C64, What is the purpose of the memory location at address $B80D?","address         $B80D          PEEK
Perform PEEK

PEEK reads the address parameter and converts it to a pointer.  Then
it gets the byte pointed to into the .Y register, and calls the part
of POS that converts a single integer in .Y to a floating point
number."
"In the context of the C64, What is the purpose of the memory location at address $B9C1?","address         $B9C1          LOGCN2
Table of Floating Point Constants for the LOG Function

This table of eight numeric constants in five-byte floating point
representation is used by the LOG function."
"In the context of the C64, What is the purpose of the memory location at address $D800-$DBFF?","address        $D800-$DBFF
Color RAM

The normal Commodore 64 text graphics system uses a screen RAM area to
keep track of the character shapes that are to be displayed.  But
since each character can be displayed in any of 16 foreground colors,
there must also be a parallel area which keeps track of the foreground
color.  This 1024-byte area is used for that purpose (actually, since
there are only 1000 screen positions, only 1000 byte actually affect
screen color).

These 1000 bytes each control the foreground color of one character,
with the first byte controlling the foreground color of the character
in the upper- left corner, and subsequent bytes controlling the
characters to the right and below that character.

Because only four bits are needed to represent the 16 colors
available, only the low four bits of each Color RAM location are
connected (this is why they are sometimes referred to as Color RAM
Nybbles).  Writing to the high bits will not affect them, and these
four bits will usually return a random value when read (a small number
of 64s return a constant value).

Therefore, in order to read Color RAM correctly, you must mask out the
top bits by using the logical AND function.  In BASIC, you can read
the first byte of Color RAM with the statement CR=PEEK(55296)AND15.
This will always return a color value between 0 and 15.  These color
values correspond to the following colors:

 0 = BLACK
 1 = WHITE
 2 = RED
 3 = CYAN (LIGHT BLUE-GREEN)
 4 = PURPLE
 5 = GREEN
 6 = BLUE
 7 = YELLOW
 8 = ORANGE
 9 = BROWN
10 = LIGHT RED
11 = DARK GRAY
12 = MEDIUM GRAY
13 = LIGHT GREEN
14 = LIGHT BLUE
15 = LIGHT GRAY

Color mapping affords a convenient method of changing the color of the
text display without changing the letters.  By POKEing the appropriate
section of Color RAM, you can change the color of a whole section of
text on the screen without affecting the content of the text.  You can
even use this method to make letters disappear by changing their
foreground colors to match the background (or by changing the
background to match the foreground), and later make them reappear by
changing them back, or by changing the background to a contrasting
color.  An interesting example program which changes Color RAM quickly
in BASIC can be found under the entry for 648 ($288).

A change in the Operating System causes newer 64s to set all of the
Color RAM locations to the same value as the current background color
whenever the screen is cleared.  Therefore, POKEing character codes to
the Screen RAM area will not appear to have any effect, because the
letters will be the same color as the background.  This can easily be
turned to your advantage, however, because it means that all you have
to do to set all of Color RAM to a particular value is to set the
background color to that value (using the register at 53281 ($D021)),
clear the screen, and return the background color in the desired
value.

The various garphics modes use this area differently than does the
regular text mode.  In high-resolution bitmap mode, this area is not
used at all, but in multicolor bitmap mode it is used to determine the
color of the 11 bit-pair for a given 8 by 8 dot area.

In multicolor text mode, only the lowest three bits are used, so only
colors 0-7 may be selected.  The fourth bit is used to determine
whether a character will be displayed in regular text or multicolor
text.  Characters with a color value over 7 are displayed as
multicolor characters, with the color of the 11 bit-pair determined by
the color value minus 8.  Characters with a color value under 8 are
displayed normally.

It should be noted that unlike the Screen RAM area, which can be moved
to any RAM location, the Color RAM area is fixed, and will function
normally regardless of where screen memory is located."
"In the context of the C64, What is the purpose of the memory location at address $22-$25?","address        $22-$25        INDEX
Miscellaneous Temporary Pointers and Save Area

This area is used by many BASIC routines to hold temporary pointers
and calculation results."
"In the context of the C64, What is the purpose of the memory location at address $43-$44?","address         $43-$44        INPPTR
Pointer in the Source of GET, READ, or INPUT Information

READ, INPUT and GET all use this as a pointer to the address of the
source of incoming data, such as DATA statements, or the text input
buffer at 512 ($200)."
"In the context of the C64, What is the purpose of the memory location at address $FF80?","address              $FF80
Kernal Version Identifier Byte

This last byte before the jump table can be used to identify the
version of the Kernal.  The first version has a 170 ($AA) stored here,
while the most current version at the time of this writing has a zero
in this location.

The PET 64, a one-piece version with an integrated monochrome display,
has an identifier byte of 100 ($64).  The Commodore 64 logo uses this
byte to recognize the PET 64, and adjust its display accordingly.

Location Range: 65409-65525 ($FF81-$FFF5)
Kernal Jump Table

The following jump table is provided by Commodore in an effort to
maintain stable entry points for key I/O routines.  Each three-byte
table entry consists of a 6510 JMP instruction and the actual address
of the routine in the ROM.  Although the actual address of the routine
may vary from machine to machine, or in later versions of the Kernal,
these addresses will stay where they are.  By jumping to the entry
point provided by this table, rather than directly into the ROM, you
insure your programs against changes in the Operating System.  In
addition, this jump table may help you write programs that will
function on more than one Commodore machine.  The 15 table entries
from 65472-65514 ($FFC0-$FFEA) are the same for all Commodore
machines, from the earliest PET on.

As an additional aid, some of these routines are also vectored through
the table which starts at 788 ($314).  Since this table is in RAM, you
can change those vectors to point to your own routines which support
additional I/O devices.  Programs that use the jump table entry points
to the I/O routines will be able to use these I/O devices without a
problem.

The following table will give the entry point, routine name, RAM
vector if any, its current address, and a brief summary of its
function.

65409 ($FF81) CINT   (65371, $FF5B) initialize screen editor and video chip
65412 ($FF84) IOINIT (64931, $FDA3) initialize I/O devices
65415 ($FF87) RAMTAS (64848, $FD50) initialize RAM, tape buffer, screen
65418 ($FF8A) RESTOR (64789, $FD15) restore default I/O vectors
65421 ($FF8D) VECTOR (64794, $FD1A) read/set I/O vector table
65424 ($FF90) SETMSG (65048, $FE18) set Kernal message control flag
65427 ($FF93) SECOND (60857, $EDB9) send secondary address after LISTEN
65430 ($FF96) TKSA   (60871, $EDC7) send secondary address after TALK
65433 ($FF99) MEMTOP (65061, $FE25) read/set top of memory pointer
65436 ($FF9C) MEMBOT (65076, $FE34) read/set bottom of memory pointer
65439 ($FF9F) SCNKEY (60039, $EA87) scan the keyboard
65442 ($FFA2) SETTMO (65057, $FE21) set time-out flag for IEEE bus
65445 ($FFA5) ACPTR  (60947, $FE13) input byte from serial bus
65448 ($FFA8) CIOUT  (60893, $EDDD) output byte to serial bus
65451 ($FFAB) UNTLK  (60911, $EDEF) command serial bus device to UNTALK
65454 ($FFAE) UNLSN  (60926, $EDFE) command serial bus device to UNLISTEN
65457 ($FFB1) LISTEN (60684, $ED0C) command serial bus device to LISTEN
65460 ($FFB4) TALK   (60681, $ED09) command serial bus device to TALK
65463 ($FFB7) READST (65031, $FE07) read I/O status word
65466 ($FFBA) SETLFS (65024, $FE00) set logical file parameters
65469 ($FFBD) SETNAM (65017, $FDF9) set filename parameters
65472 ($FFC0) OPEN   (via 794 ($31A) to 62282, $F34A) open a logical file
65475 ($FFC3) CLOSE  (via 796 ($31C) to 62097, $F291) close a logical file
65478 ($FFC6) CHKIN  (via 798 ($31E) to 61966, $F20E) define an input channel
65481 ($FFC9) CHKOUT (via 800 ($320) to 62032, $F250) define an output channel
65484 ($FFCC) CLRCHN (via 802 ($322) to 62259, $F333) restore default devices
65487 ($FFCF) CHRIN  (via 804 ($324) to 61783, $F157) input a character
65490 ($FFD2) CHROUT (via 806 ($326) to 61898, $F1CA) output a character
65493 ($FFD5) LOAD   (via 816 ($330) to 62622, $F49E) load from device
65496 ($FFD8) SAVE   (via 818 ($332) to 62941, $F5DD) save to a device
65499 ($FFDB) SETTIM (63204, $F6E4) set the software clock
65502 ($FFDE) RDTIM  (63197, $F6DD) read the software clock
65505 ($FFE1) STOP   (via 808 ($328) to 63213, $F6ED) check the STOP key
65508 ($FFE4) GETIN  (via 810 ($32A) to 61758, $F13E) get a character
65511 ($FFE7) CLALL  (via 812 ($32C) to 62255, $F32F) close all files
65514 ($FFEA) UDTIM  (63131, $F69B) update the software clock
65517 ($FFED) SCREEN (58629, $E505) read number of screen rows and columns
65520 ($FFF0) PLOT   (58634, $E50A) read/set position of cursor on screen
65523 ($FFF3) IOBASE (58624, $E500) read base address of I/O devices"
"In the context of the C64, What is the purpose of the memory location at address $F5-$F6?","address      $F5-$F6        KEYTAB
Vector: Keyboard Decode Table

KEYTAB points to the address of the keyboard matrix lookup table
currently being used.  Although there are only 64 keys on the keyboard
matrix, each key can be used to print up to four different characters,
depending on whether it is struck by itself or in combination with the
SHIFT, CTRL, or Commodore logo keys.

The tables pointed to y this address hold the ASCII value of each of
the 64 keys for one of these possible combinations of keypresses.
When it comes time to print the character, the table that is used
determines which character is printed.

The addresses of the four tables are:

60289 ($EB81) = default uppercase/graphics characters (unshifted)
60354 ($EBC2) = shifted characters
60419 ($EC03) = Commodore logo key characters
60536 ($EC78) = CTRL characters

The concept of the keyboard matrix tables should not be confused with
changing the character sets from uppercase/graphics to
upper/lowercase.  The former involves determining what character is to
be placed into screen memory, while the latter involves determining
which character data table is to be used to decode the screen memory
into individual dots for the display of characters on the screen.
That character base is determined by location 53272 ($D018) of the
VIC-II chip."
"In the context of the C64, What is the purpose of the memory location at address $FB97?","address              $FB97
Reset Counters for Reading or Writing a New Byte of Cassette Data"
"In the context of the C64, What is the purpose of the memory location at address $FCCA?","address              $FCCA
Turn Off the Tape Motor"
"In the context of the C64, What is the purpose of the memory location at address $277-$280?","address       $277-$280      KEYD
Keyboard Buffer (Queue)

This buffer, sometimes also referred to as the keyboard queue, holds
the ASCII values of the characters entered from the keyboard.  The
interrupt routine which scans the keyboard deposits a character here
each time a key is pressed.  When BASIC sees that there are characters
waiting, it removes and prints them, one by one, in the order in which
they were entered.

This kind of a buffer is known as FIFO, for First In, First Out.  The
buffer will hold up to ten characters, allowing you to type faster
than the computer prints characters, without losing characters.  The
maximum number of characters this buffer can hold at one time is ten
(as determined by the value at 649 ($289)).  Characters entered after
the buffer is full will be ignored.

The commands GET and INPUT retrieve characters from this buffer.  If
one of these is executed while there are already characters waiting in
the buffer, those characters will be fetched as if they were part of
the data being input.  To prevent this from happening, you can clear
the buffer by POKEing a 0 into location 198 ($C6), which holds the
number of characters that are waiting in the buffer.

One of the most interesting and useful techniques for programming
Commodore computers is to have a program simulate direct entry of
commands from the keyboard.  This dynamic keyboard trick is achieved
by first POKEing PETASCII characters, usually cursor movement
characters and carriage returns, into the buffer, and setting location
198 ($C6) to show how many characters are waiting in the buffer.

Next, you clear the screen, and PRINT the statements that you wish to
have executed on the screen, carefully positioning them so that the
first statement to be entered is on the fourth line of the screen.

You then home the cursor and execute an END statement.  This causes
the keyboard buffer to be read, and the carriage returns to be
executed, thus entering the printed lines as if they had been typed in
immediate or direct mode.  The program can be continued by including a
GOTO statement in the last line entered.

Many interesting effects can be achieved using this method.  Examples
of a few of these are included below.  For example, program lines can
be added, modified, or deleted, while the program is running.  The
following example shows how this is done:

10 REM THIS LINE WILL BE DELETED
20 REM A NEW LINE 30 WILL BE CREATED
40 PRINT CHR$(147):PRINT:PRINT
50 PRINT '80 LIST':PRINT'30 REM THIS LINE WASN'T HERE BEFORE'
60 PRINT '10':PRINT 'GOTO 80'CHR$(19)
70 FOR I=631 TO 634:POKE I,13:NEXT:POKE 198,4:END
80 REM THIS LINE WILL BE REPLACED

You can use this technique to enter numbered DATA statements
automatically, using values in memory.  These statements become a
permanent part of the program.

Another interesting application is taking ASCII program lines from a
tape data file, or sequential disk file, and having them entered
automatically.  This can be used for merging programs, or for
transferring programs between computers with a modem and a terminal
program.  To create the ASCII program file, you use CMD to direct a
LISTing to the desired device as follows:

For tape: OPEN 1,1,1,'ASCII':CMD 1:LIST
After the listing has ended: PRINT #1:CLOSE 1

For disk: OPEN 8,8,8,'ASCII,S,W':CMD 8:LIST
After the listing has ended: PRINT #8:CLOSE 8

This file can then be uploaded using a modem and appropriate terminal
software, entered by itself or merged with another program by using
the following program.  Be sure to save this program before you run
it, because it will erase itself when it is done.

60000 OPEN 1,8,8,'ASCII'
60010 POKE 152,1:B=0:GOSUB 60170
60020 GET #1,A$:IF A$=''THEN60020
60030 IF ST AND 64 THEN 60120
60040 IF A$=CHR$(13)AND B=0THEN60020
60050 PRINT A$;:B=1:IF A$=CHR$(34)THEN POKE 212,0
60060 IF A$<>CHR$(13) THEN 60020
60070 PRINT CHR$(5);'GOTO 60010';CHR$(5):PRINT:PRINT:POKE 198,0
60080 PRINT 'RETURN=KEEP LINE    S=SKIP LINE':B=0
60090 GET A$:IF A$=''THEN 60090
60100 IF A$='S' THEN 60010
60110 GOTO 60180
60120 PRINT 'END OF FILE--HIT RETURN TO FINISH MERGE'
60130 IF PEEK(197)<>1THEN60130
60140 A=60000
60150 GOSUB 60170:FOR I=A TO A+60 STEP10:PRINTI:NEXT
60160 PRINT 'A='I':GOTO 60150':GOTO 60180
60170 PRINT CHR$(147):PRINT:PRINT:RETURN
60180 FOR I=631TO640:POKEI,13:NEXT:POKE198,10:PRINTCHR$(19);:END

If you wish to merge additional programs at the same time, when it
indicates that the file has ended, press the STOP key rather than
RETURN, enter the name of the new file in line 60000, and RUN 60000"
"In the context of the C64, What is the purpose of the memory location at address $B3A6?","address         $B3A6          ERRDIR
Check If the Program is Running in Direct Mode, and If So Issue an Error

This routine is called by statements that prohibit execution in direct
mode.  It checks a flag that is set when a line without a linenumber
is entered, and causes an ILLEGAL DIRECT error if the flag is set."
"In the context of the C64, What is the purpose of the memory location at address $B11D?","address         $B11D          NOTFNS
Create a New BASIC Variable

This routine makes space for a seven-byte descriptor by moving the
variable storage area seven bytes higher in memory, and then creates
the descriptor."
"In the context of the C64, What is the purpose of the memory location at address $AEF1?","address         $AEF1          PARCHK
Evaluate Expression Within Parentheses

This routine evaluates an expression within parentheses by calling the
syntax checking routines that look for opening and closing
parentheses, and then calling FRMEVL (4446, $AD9E) for each level of
parentheses."
"In the context of the C64, What is the purpose of the memory location at address $E505?","address              $E505          SCREEN
Store Number of Screen Rows and Columns in .Y and .X

This is a documented Kernal routine which is vectored in the jump
table at 65517 ($FFED), and is provided to allow for program
compatibility between computers.

When called, this subroutine returns the number of screen columns in
the .X register, and the number of screen rows in .Y.  Thus, a program
can detect the screen format of the machine on which it is running,
and make sure that text output is formatted accordingly.

The present version of this routine loads the .X register with 40
($28) and the .Y register with 25 ($19)."
"In the context of the C64, What is the purpose of the memory location at address $AA86?","address        $AA86          CMD
Perform CMD

This routine calls the Kernal CHKOUT routine (62032, $F250), and calls
PRINT to send any included text to the device.  Unlike PRINT# it
leaves the output channel open, so that output continues to go to that
device."
"In the context of the C64, What is the purpose of the memory location at address $A831?","address        $A831          END
Perform END

The current line number and text pointers are preserved for a possible
CONT command, and the READY prompt is printed.  If a STOP key break
occured, the BREAK message is printed first."
"In the context of the C64, What is the purpose of the memory location at address $E4AD?","address              $E4AD
Patch for BASIC Call of CHKOUT

This patch was made to preserve the .A register if there was no error
returned from BASIC's call of the Kernal CHKOUT routine.  Apparently,
the first version could cause a malfunction of the CMD and PRINT#
commands."
"In the context of the C64, What is the purpose of the memory location at address $AB1E?","address         $AB1E          STROUT
Print Message from a String Whose Address Is in the .Y and .A
Registers

This part of the PRINT routine outputs a string whose address is in
the Accumulator (low byte) and .Y register (high byte), and which ends
in a zero byte."
"In the context of the C64, What is the purpose of the memory location at address $E4EC?","address              $E4EC
Baud Rate Table for European (PAL) Standard Monitors

This table of prescaler values was added to later Kernal versions to
allow the same Kernal software to be used with either U.S. or European
64s.  It contains the values which are required to obtain interrupts
at the proper frequency for the standard RS-232 baud rates, and
corresponds exactly in format to the table of values for the U.S.
(NTSC) monitor format at 65218 ($FEC2).  Separate tables are required
because the prescaler values are derived from dividing the system
clock rate by the baud rate, and PAL machines operate with a slightly
slower clock frequency."
"In the context of the C64, What is the purpose of the memory location at address $E453?","address              $E453
Copy BASIC Vectors to RAM

The cold start routine calls this subroutine to copy the table of
vectors to important BASIC routines to RAM, starting at location 768
($300)."
"In the context of the C64, What is the purpose of the memory location at address $A871?","address         $A871          RUN
Perform RUN

RUN is executed by calling the Kernal SETMSG (65048, $FE18) routine to
set the message flag for RUN mode and performing a CLR to start the
program.  If a line followed RUN, a GOTO is executed after the CLR."
"In the context of the C64, What is the purpose of the memory location at address $E394?","address              $E394
Cold Start BASIC

This initialization routine is executed at the time of power-up.  The
RAM vectors to important BASIC routines are set up starting at 768
($300), the interpreter is initialized, the start-up messages are
printed, and the main loop entered through the end of the warm start
routine."
"In the context of the C64, What is the purpose of the memory location at address $B391?","address         $B391          GIVAYF
Convert 16-Bit Signed Integer to Floating Point

This routine treats the value in the Accumulator as the high byte of a
16-bit signed integer, and the value in the .Y register as the low
byte, and converts the signed integer into a floating point number in
the Floating Point Accumulator.

The address of this routine is pointed to by the RAM vector at 5-6,
and the routine can be used to return an argument from the USR call in
the Floating Point Accumulator."
"In the context of the C64, What is the purpose of the memory location at address $B08B?","address         $B08B          PTRGET
Search for a Variable and Set It Up If It Is Not Found

This routine attempts to locate a variable by searching for its name
in the variable area.  If an existing variable of that name cannot be
found, one is created with the NOTFNS routine below."
"In the context of the C64, What is the purpose of the memory location at address $FBC8?","address              $FBC8
Write Data to Cassette--Part 2 (IRQ)

This IRQ handler routine is one part of the write data to cassette
routine"
"In the context of the C64, What is the purpose of the memory location at address $D9-$F2?","address       $D9-$F2        LDTB1
Screen Line Link Table/Editor Temporary Storage

This table contains 25 entries, one for each row of the screen
display.  Each entry has two functions.  Bits 0-3 indicate on which of
the four pages of screen memory  the first byte of memory for that row
is located.  This is used in calculating the pointer to the starting
address of a screen line at 209 ($D1).

While earlier PETs used one table for the low bytes of screen rows and
another for the high bytes, this is not possible on the 64, where
screen memory is not fixed in any one spot.  Therefore, the Operating
System uses a table of low bytes at 60656 ($ECF0), but calculates the
high byte by adding the value of the starting page of screen memory
held in 648 ($288) to the displacement page held here.

The other function of this table is to establish the makeup of logical
lines on the screen.  While each screen line is only 40 characters
long, BASIC allows the entry of program lines that contain up to 80
characters.  Therefore, some method must be used to determine which
pairs of physical lines are linked into a longer logical line, so that
this longer logical line may be edited as a unit.

The high bit of each byte here is used as a flag by the screen editor.
That bit is set (leaving the value of the byte over 128 ($80)) when a
line is the first or only physical line in a logical line.  The high
bit is reset to 0 only when a line is the second half of a logical
line."
"In the context of the C64, What is the purpose of the memory location at address $263-$26C?","address       $263-$26C      FAT
Kernal Table of Device Numbers for Each Logical File"
"In the context of the C64, What is the purpose of the memory location at address $FCDB?","address              $FCDB
Advance the Tape Read/Write Pointer

This routine is used to move the pointer to the current read/write
address up a byte."
"In the context of the C64, What is the purpose of the memory location at address $CC?","address          $CC            BLNSW
Cursor Blink Enable: 0=Flash Cursor

When this flag is set to a nonzero value, it indicates to the routine
that normally flashes the cursor not to do so.  The cursor blink is
turned off when there are characters in the keyboard buffer, or when
the program is running.

You can use this location to turn the cursor on during a program (for
a series of GET operations, for example, to show the user that input
is expected) by using the statement POKE 204,0."
"In the context of the C64, What is the purpose of the memory location at address $17-$18?","address         $17-$18        LASTPT
Pointer to the Address of the Last String in the Temporary String
Stack

This pointer indicates the last slot used in the temporary string
descriptor stack.  Therefore, the value stored at 23 ($17) should be 3
less than that stored at 22 ($16), while 24 ($18) will contain a 0."
"In the context of the C64, What is the purpose of the memory location at address $3F-$40?","address         $3F-$40        DATLIN
Current DATA Line Number

This location holds the line number of the current DATA statement
being READ.  It should be noted that this information is not used to
determine where the next DATA item is read from (that is the job of
the pointer at 65-66 ($41-$42) below).  But if an error concerning the
DATA occurs, this number will be moved to 57 ($39), so that the error
message will show that the error occurred in the line that contains
the DATA statement, rather than in the line that contains the READ
statement."
"In the context of the C64, What is the purpose of the memory location at address $B82D?","address         $B82D          FUWAIT
Perform WAIT

WAIT gets an address parameter and an integer parameter to use as a
mask.  WAIT then looks for an optional parameter to use as a pattern
for the exclusive OR.  Then, the address location is read, its value
is exclusive ORed with the optional pattern value (or 0 if there is
none).  This value is ANDed with the mask value.  The command loops
continuously until the result is not- zero.

The purpose of this command is to allow the program to watch a
location which can be changed by the system or by outside hardware
(such as the software clock or keycode value locations).

The AND function lets you check if a bit changes from 0 to 1, while
the EOR function allows you to check if a bit changes from 1 to 0.
For more information, see the article 'All About the Wait
Instruction,' by Louis Sander and Doug Ferguson, in COMPUTE!'s First
Book of Commodore 64."
"In the context of the C64, What is the purpose of the memory location at address $D416?","address              $D416          CUTHI
Filter Cutoff Frequency (high byte)"
"In the context of the C64, What is the purpose of the memory location at address $D41C?","address              $D41C          ENV3
Envelope Generator 3 Output

This register allows you to read the output of the voice 3 Envelope
generator, in much the same way that the preceding register lets you
read the output of Oscillator 3.  This output can also be added to
another oscillator's Frequency Control Registers, Pulse Width
Registers, or the Filter Frequency Control Register.  In order to
produce any output from this register, however, the gate bit in
Control Register 3 must be set to 1.  Just as in the production of
sound, setting the gate bit to 1 starts the attack/decay/sustain
cycle, and setting it back to 0 starts the release cycle.

Location Range: 54301-54303 ($D41D-$D41F)
Not Connected

The SID chip has been provided with enough addresses for 32 different
registers, but as it has only 29, the remaining three addresses are
not used.  Reading them will always return a value of 255 ($FF), and
writing to them will have no effect."
"In the context of the C64, What is the purpose of the memory location at address $BA28?","address         $BA28          FMULT
Multiply FAC1 with FAC2

This routine multiplies the contents of FAC1 by the contents of FAC2
and stores the result in FAC1"
"In the context of the C64, What is the purpose of the memory location at address $DD06?","address              $DD06          TI2BLO
Timer B (low byte)"
"In the context of the C64, What is the purpose of the memory location at address $DD0D?","address              $DD0D          CI2ICR
Interrupt Control Register

Bit 0:  Read / did Timer A count down to 0?  (1=yes)
        Write/ enable or disable Timer A interrupt (1=enable, 0=disable)
Bit 1:  Read / did Timer B count down to 0?  (1=yes)
        Write/ enable or disable Timer B interrupt (1=enable, 0=disable)
Bit 2:  Read / did Time of Day Clock reach the alarm time?  (1=yes)
        Write/ enable or disable TOD clock alarm interrupt (1=enable,
        0=disable)
Bit 3:  Read / did the serial shift register finish a byte?  (1=yes)
        Write/ enable or disable serial shift register interrupt (1=enable,
        0=disable)
Bit 4:  Read / was a signal sent on the FLAG line?  (1=yes)
        Write/ enable or disable FLAG line interrupt (1=enable, 0=disable)
Bit 5:  Not used
Bit 6:  Not used
Bit 7:  Read / did any CIA #2 source cause an interrupt?  (1=yes)
        Write/ set or clear bits of this register (1=bits written with 1 will
        be set, 0=bits written with 1 will be cleared)

This register is used to control the five interrupt sources on the
6526 CIA chip.  For details on its operation, see the entry for 56333
($DC0D).  The main difference between these two chips pertaining to
this register is that on CIA #2, the FLAG line is connected to Pin B
of the User Port, and thus is available to the user who wishes to take
advantage of its ability to cause interrupts for handshaking purposes.

Location Range: 56590-$56591 ($DD0E-$DD0F)
See locations 56334 and 56334 for details"
"In the context of the C64, What is the purpose of the memory location at address $E059?","address              $E059          POLY2
Function Series Evaluation Subroutine 2

This is the main series evaluation routine, which evaluates
expressions by using a table of the various values that must be
operated on in sequence to obtain the proper result."
"In the context of the C64, What is the purpose of the memory location at address $E08D?","address              $E08D          RMULC
Multiplicative Constant for RND

A five-byte floating point number which is multiplied by the seed
value as part of the process of obtaining the next value for RND>"
"In the context of the C64, What is the purpose of the memory location at address $DD0E?","address              $DD0E          CI2CRA
Control Register A

Bit 0:  Start Timer A (1=start, 0=stop)
Bit 1:  Select Timer A output on Port B (1=Timer A output appears on
        Bit 6 of Port B)
Bit 2:  Port B output mode (1=toggle Bit 6, 0=pulse Bit 6 for one
        cycle)
Bit 3:  Timer A run mode (1=one-shot, 0=continuous)
Bit 4:  Force latched value to be loaded to Timer A counter (1=force
        load strobe)
Bit 5:  Timer A input mode (1=count microprocessor cycles, 0=count
        signals on CNT line at pin 4 of User Port)
Bit 6:  Serial Port (56588, $DD0C) mode (1=output, 0=input)
Bit 7:  Time of Day Clock frequency (1=50 Hz required on TOD pin,
        0=60 Hz)"
"In the context of the C64, What is the purpose of the memory location at address $DD05?","address              $DD05          TI2AHI
Timer A (high byte)"
"In the context of the C64, What is the purpose of the memory location at address $D41B?","address              $D41B          RANDOM
Read Oscillator 3/Random Number Generator

This register lets you read the upper eight bits of the waveform
output of Oscillator 3.  The kinds of numbers generated by this output
depend on the type of waveform selected.

If the sawtooth waveform is chosen, the output read by this register
will be a series of numbers which start at 0 and increase by 1 to a
maximum of 255, at which time they start over at 0.

When the triangle waveform is chosen, they increase from 0 to 255, at
which time they decrease to 0 again.  The rate at which these numbers
change is determined by the frequency of Oscillator 3.

If the pulse waveform is selected, the output here will be either 255
or 0.

Finally, selecting the noise waveform will produce a random series of
numbers between 0 and 255.  This allows you to use the register as a
random number generator for games.

There are many other uses for reading Oscillator 3, however,
particularly for modulation of the other voices through machine
language software.  For example, the output of this register could be
added to the frequency of another voice.  If the triangle waveform
were selected for this purpose, it would cause the frequency of the
other voice to rise and fall, at the frequency of Oscillator 3
(perhaps for vibrato effects).  This output can also be combined with
the Filter Frequency or Pulse Width Registers to vary the values in
these registers quickly over a short period of time.

Normally, when using Oscillator 3 for modulation, the audio output of
voice 3 should be turned off by setting Bit 7 of the Volume and Filter
Select Register at 54296 ($d418) to 1.  It is not necessary to gate
Bit 0 of Control Register 3 to use the oscillator, however, as its
output is not affected by the ADSR envelope cycle."
"In the context of the C64, What is the purpose of the memory location at address $B9EA?","address         $B9EA          LOG
Perform LOG to Base E

The LOG to the base e of the number in FAC1 is performed here, and the
result left in FAC1."
"In the context of the C64, What is the purpose of the memory location at address $B824?","address         $B824          POKE
Perform POKE

POKE gets a pointer to the address parameter, and stores the next
parameter there."
"In the context of the C64, What is the purpose of the memory location at address $D415?","address              $D415          CUTLO

Bits 0-2:  Low portion of filter cutoff frequency
Bits 5-7:  Unused"
"In the context of the C64, What is the purpose of the memory location at address $41-$42?","address         $41-$42        DATPTR
Pointer to the Address of the Current DATA Item

This location points to the address (not the line number) within the
BASIC program text area where DATA is currently being READ.  RESTORE
sets this pointer back to the address indicated by the start of BASIC
pointer at location 43 ($2B).

The sample program below shows how the order in which DATA statements
are READ can be changed using this pointer.  The current address of
the statement before the DATA statement is stored in a variable, and
then used to change this pointer.

10 A1=PEEK(61):A2=PEEK(62)
20 DATA THIS DATA WILL BE USED SECOND
30 B1=PEEK(61):B2=PEEK(62)
40 DATA THIS DATA WILL BE USED FIRST
50 C1=PEEK(61):C2=PEEK(62)
60 DATA THIS DATA WILL BE USED THIRD
70 POKE 65,B1:POKE 66,B2:READ A$:PRINT A$
80 POKE 65,A1:POKE 66,A2:READ A$:PRINT A$
90 POKE 65,C1:POKE 66,C2:READ A$:PRINT A$"
"In the context of the C64, What is the purpose of the memory location at address $19-$21?","address        $19-$21        TEMPST
Descriptor Stack for Temporary Strings

The temporary string descriptor stack contains information about
temporary strings which hve not yet been assigned to a string
variable.  An examples of such a temporary string is the literal
string 'HELLO' in the statement PRINT 'HELLO'.

Each three-byte descriptor in this stack contains the length of the
string, and its starting and ending locations, expresses as
displacements within the BASIC storage area."
"In the context of the C64, What is the purpose of the memory location at address $CB?","address           $CB            SFDX
Matrix Coordinate of Current Key Pressed

The keyscan interrupt routine uses this location to indicate which key
is currently being pressed.  The value here is then used as an index
into the appropriate keyboard table to determine which character to
print when a key is struck.

The correspondence between the key pressed and the number stored here
is as follows:

0  = INST/DEL                34 = J
1  = RETURN                  35 = 0
2  = CRSR RIGHT              36 = M
3  = F7                      37 = K
4  = F1                      38 = O
5  = F3                      39 = N
6  = F5                      40 = +
7  = CRSR DOWN               41 = P
8  = 3                       42 = L
9  = W                       43 = -
10 = A                       44 = .
11 = 4                       45 = :
12 = Z                       46 = @
13 = S                       47 = ,
14 = E                       48 = LIRA (BRITISH POUND SIGN)
15 = NOT USED                49 = *
  (WOULD BE LEFT SHIFT)      50 = ;
16 = 5                       51 = CLR/HOME
17 = R                       52 = NOT USED
18 = D                         (WOULD BE RIGHT SHIFT)
19 = 6                       53 = =
20 = C                       54 = UP ARROW
21 = F                         (EXPONENTATION SIGN)
22 = T                       55 = /
23 = X                       56 = 1
24 = 7                       57 = LEFT ARROW
25 = Y                       58 = NOT USED
26 = G                         (WOULD BE CTRL)
27 = 8                       59 = 2
28 = B                       60 = SPACE BAR
29 = H                       61 = NOT USED
30 = U                         (WOULD BE COMMODORE LOGO)
31 = V                       62 = Q
32 = 9                       63 = RUN/STOP
33 = I                       64 = NO KEY PRESSED

The RESTORE key is not accounted for, because it is not part of the
normal keyboard matrix.  Instead, it is connected directly to the
microprocessor NMI line, and causes an NMI interrupt whenever it is
pressed."
"In the context of the C64, What is the purpose of the memory location at address $259-$262?","address      $259-$262      LAT
Kernal Table of Active Logical File Numbers"
"In the context of the C64, What is the purpose of the memory location at address $FCD1?","address              $FCD1
Check the Tape Read/Write Pointer

This routine compares the current tape read/write address with the
ending read/write address."
"In the context of the C64, What is the purpose of the memory location at address $FBA6?","address              $FBA6
Toggle the Tape Data Output Line

This routine sets the CIA #1 Timer B, and toggles the Tape Data Output
line on the 6510 on-chip I/O port (Bit 3 of location 1)."
"In the context of the C64, What is the purpose of the memory location at address $D8?","address          $D8            INSRT
Flag: Insert Mode (Any Number Greater Than 0 Is the Number of Inserts)

When the INST key is pressed, the screen editor shifts the line to the
right, allocates another physical line to the logical line if
necessary (and possible), updates the screen line length in 213 ($D5),
and adjusts the screen line link table at 217 ($D9).  This location is
used to keep track of the number of spaces that has been opened up in
this way.

Until the spaces that have been opened up are filled, the editor acts
as if in quote mode (see location 212 ($D4), the quote mode flag).
This means that cursor control characters that are normally
nonprinting will leave a printed equivalent on the screen when
entered, instead of having their normal effect on cursor movement,
etc.  The only difference between insert and quote mode is that the
DELETE key will leave a printed equivalent in insert mode, while the
INST key will insert spaces as normal."
"In the context of the C64, What is the purpose of the memory location at address $B113?","address         $B113
Check If .A Register Holds Alphabetic ASCII Character

This is part of the check for a valid variable name (it must start
with an alphabetic character)."
"In the context of the C64, What is the purpose of the memory location at address $B39E?","address         $B39E          POS
Perform POS

The POS command calls the Kernal PLOT routine (58634, $E50A) to get
the position of the cursor on the logical line.  What it really does
is an equivalent of PEEK(211).  Remember, since we are dealing with a
logical line, this number can be over 39.  The statement 'THIS
SENTENCE IS LONGER THAN ONE PHYSICAL LINE';POS(X) will return a value
of 48 for the POS(X)."
"In the context of the C64, What is the purpose of the memory location at address $E38B?","address              $E38B
Error Message Handler

This routine to print error messages is pointed to by the vector at
768 ($300).  Using the .X register as an index, it either prints an
error message from the table at 41363 ($A193) or the READY prompt, and
continues through the vector at 770 ($302) to the main BASIC loop."
"In the context of the C64, What is the purpose of the memory location at address $E447?","address              $E447
Table of Vectors to Important BASIC Routines

This table contains the vectors which point to the addresses of some
important BASIC routines.  The contents of this table are moved to the
RAM table at 768 ($300)."
"In the context of the C64, What is the purpose of the memory location at address $A857?","address         $A857          CONT
Perform CONT

The CONT statement is performed by moving the saved pointers back to
the current statement and current text character pointers.  If the
saved pointers cannot be retrieved, the CAN'T CONTINUE error statement
is printed."
"In the context of the C64, What is the purpose of the memory location at address $AAA0?","address         $AAA0          PRINT
Perform PRINT

The PRINT routine has many segments, which are required for the
various options which can be added to it:  TAB, SPC, comman,
semicolon, variables, PI, ST, TI, and TI$.  Eventually, all output is
converted to strings, and the Kernal CHROUT routine is called to print
each character."
"In the context of the C64, What is the purpose of the memory location at address $E4E0?","address              $E4E0
Pause after Finding a File on Cassette

This routine is a patch to the routine which finds a file on cassette.
After the file is found, the message FILETITLE FOUND appears on the
screen.  On the original versions of the Kernal, the user would then
have to hit the Commodore key to continue the load.  On the newer
versions, this patch causes a slight pause after the tape file is
round, during which time a keypress is looked for.  If a key is
pressed, the loading process continues immediately.  If it is not, the
load continues by itself after the end of the pause."
"In the context of the C64, What is the purpose of the memory location at address $E264?","address              $E264          COS
Perform COS

COS is executed by adding PI/2 to the contents of FAC1 and dropping
through to SIN."
"In the context of the C64, What is the purpose of the memory location at address $E50A?","address              $E50A          PLOT
Read/Set Location of the Cursor

The jump table entry for this documented Kernal is at 65520 ($FFF0).

The routine allows the user to read or set the position of the cursor.
If the carry flag is set with the SEC instruction before calling this
subroutine, cursor column (X position) will be returned in the .X
register, and the cursor row (Y position) will be returned in the .Y
register.  If the carry flag is cleared with a CLC instruction before
entering this routine, and the .Y and .X registers are loaded with the
desired row and column positions respectively, this routine will set
the cursor position accordingly.

The current read routine loads .X and .Y from locations 214 ($D6) and
211 ($D3) respectively.  The cursor set routine stores .X and .Y in
these locations, and calls the routine that sets the screen pointers
at 58732 ($E56C).

The user can access this routine from BASIC by loading the .X, .Y, and
.P register values desired to the save area starting at 780 ($30C)."
"In the context of the C64, What is the purpose of the memory location at address $A96B?","address         $A96B          LINGET
Convert an ASCII Decimal Number to a Two-Byte Binary Line Nmumber

This subroutine is used by several statements to read a decimal
number, convert it to a two-byte integer line number (in low-byte,
high-byte format), and check that it is in the correct range of
0-63999."
"In the context of the C64, What is the purpose of the memory location at address $A8D2?","address         $A8D2          RETURN
Perform RETURN

The RETURN statement finds the saved GOSUB data on the stack, and uses
it to restore the pointers to the current line and current character.
This will cause execution to continue where it left off when GOSUB was
executed."
"In the context of the C64, What is the purpose of the memory location at address $E3A2?","address              $E3A2          INITAT
Text of the CHRGET Routine Which Runs at 115 ($73)

The text of the CHRGET routine is stored here, and moved to Page 0 by
the BASIC initialization routine.  When creating a wedge in CHRGET, it
is possible to execute all or part of this code in place of the RAM
version."
"In the context of the C64, What is the purpose of the memory location at address $B248?","address         $B248          FCERR
Print ILLEGAL QUANTITY Error Message"
"In the context of the C64, What is the purpose of the memory location at address $B1A5?","address         $B1A5          N32768
The Constant -32768 in Five-Byte Floating Point Format

This constant is used for range checking in the conversion of a
floating point number to a signed integer (the minimum inter value is
-32768)."
"In the context of the C64, What is the purpose of the memory location at address $D6?","address           $D6            TBLX
Current Cursor Physical Line Number

This location contains the current physical screen line position of
the cursor (0-24).  It can be used in a fashion to move the cursor
vertically, by POKEing the target screen line (1-25) minus 1 here,
followed by a PRINT command.  For example,

POKE 214,9:PRINT:PRINT 'WE'RE ON LINE ELEVEN'

prints the message on line 11.  The first PRINT statement allows the
system to update the other screen editor variables so that they will
also show the new line.  The cursor can also be set or read using the
Kernal PLOT routine (58634, $E50A) as explained in the entry from
locations 780-783 ($30C-$30F)."
"In the context of the C64, What is the purpose of the memory location at address $F7-$F8?","address       $F7-$F8        RIBUF
Pointer: RS-232 Input Buffer

When device number 2 (the RS-232 channel) is opened, two buffers of
256 bytes each are created at the top of memory.  This location points
to the address of the one which is used to store characters as they
are received.  A BASIC program should always OPEN device 2 before
assigning any variables to avoid the consequences of overwriting
variables which were previously located at the top of memory, as BASIC
executes a CLR after opening this device."
"In the context of the C64, What is the purpose of the memory location at address $F92C?","address             $F92C
Read Tape Data (IRQ)

This is the IRQ handler routine that is used for reading data from the
cassette.  At the end of the read, the IRQ vector is restored to the
normal IRQ routine."
"In the context of the C64, What is the purpose of the memory location at address $FD10?","address              $FD10
Text for Autostart Cartridge Check

The characters stored here must be the fifth through the ninth
characters in the cartridge in order for it to be started on power-up.
These characters are the PETASCII values for CBM, each with the high
bit set (+128), and the characters '80'."
"In the context of the C64, What is the purpose of the memory location at address $100-$13E?","address       $100-$13E      BAD
Tape Input Error Log

Each tape block is saved twice consecutively, in order to minimize
loss of data from transmission errors.  These 62 bytes serve as
indices of which bytes in the tape block were not received corectly
during the first transmission, so that corrections might be made on
the second pass."
"In the context of the C64, What is the purpose of the memory location at address $2D-$2E?","address         $2D-$2E        VARTAB
Pointer to the Start of the BASIC Variable Storage Area

This location points to the address which marks the end of the BASIC
program text area, and the beginning of the variable storage area.
All nonarray variables are stored here, as are string descriptors (for
the address of the area where the actual text of strings is stored,
see location 51 ($33)).

Seven bytes of memory are allocated for each variable.  The first two
bytes are used for the variable name, which consists of the ASCII
value of the first two letters of the variable name.  If the variable
name is a single letter, the second byte will contain a zero.

The seventh bit of one or both of these bytes can be set (which would
add 128 to the ASCII value of the letter).  This indicates the
variable type.  If neither byte has the seventh bit set, the variable
is the regular floating point type.  If only the first byte has its
seventh bit set, the variable is a string.  If only the second byte
has its seventh bit set, the variable is a defined function (FN).  If
both bytes have the seventh bit set, the variable is an integer.

The use of the other five bytes depends on the type of variable.  A
floating point variable will use the five bytes to store the value of
the variable in floating point format.  An integer will have its value
stored in the third and fourth bytes, high byte first, and the other
three will be unused.

A string variable will use the third byte for its length, and the
fourth and fifth bytes for a pointer to the address of the string
text, leaving the last two bytes unused.  Note that the acrual string
text that is pointed to is located either in the part of the BASIC
program where the string is first assigned a value, or in the string
text storage area pointed to by location 51 ($33).

A function definition will use the third and fourth bytes for a
pointer to the address in the BASIC program text where the function
definition starts.  It uses the fifth and sixth bytes for a pointer to
the dependent variable (the X of FN A(X)).  The final byte is not
used.

Knowing something about how variables are created can help your BASIC
programming.  For example, you can see that nonarray integer variables
take up no less space than floating point variables, and since most
BASIC commands convert the integers to floating point, they do not
offer a speed advantage either, and in many cases will actually slow
the program down.  As will be seen below, however, integer arrays can
save a considerable amount of space.

Variables are stored in the order in which they are created.
Likewise, when BASIC goes looking for a variable, it starts its search
at the beginning of this area.  If commonly used variables are defined
at the end of the program, and are thus at the back of this area, it
will take longer to find them.  It may help program execution speed to
define the variables that will be used most frequently right at the
beginning of the program.

Also, remember that once created, variables do not go away during
program execution.  Even if they are never used again, they still take
up space in the variable storage area, and they slow down the routine
that is used to search for variables that are referenced.

Another point to consider about the order in which to define variables
is that arrays are created in a separate area of memory which starts
at the end of the nonarray variable area.  Therefore, every time a
nonarray variable is created, all of the arrays must be moved seven
bytes higher in memory in order to make room for the new variable.
Therefore, it may help performance to avoid defining nonarray
variables after defining arrays.

This pointer will be reset to one byte past the end of the BASIC
program text whenever you execute the statements CLR, NEW, RUN, or
LOAD.  Adding or modifying a BASIC statement will have the same
effect, because the higher numbered BASIC statements have to be moved
up into memory to make room for the new statements, and can therefore
overwrite the variable storage area.  This means that if you wish to
check the value of a variable after stopping a program, you can only
do so before modifying the program.

The exception to the above is when the LOAD command is issued from a
program.  The purpose of not resetting this pointer in such a case is
to allow the chaining of programs by having one program load and then
run the next (that is also why a LOAD issued from a program causes a
RUN from the beginning of the program).  This allows the second
program to share variables with the first.  There are problems with
this, however.  Some string variable descriptors and function
definitions have their pointers set to areas within the program text.
When this text is replaced by a load, these pointers are no longer
valid, which will lead to errors if the FN or string value is
referenced.  And if the second program text area is larger than that
of the first, the second program will overwrite some of the first
program's variables, and their values will be lost.

The ability to chain short programs is a holdover from the days of the
8K PET, for which this BASIC was written, but with the vastly
increased memory of the 64, program chaining should not be necessary.

You should also note that SAVE uses this pointer as the address of the
byte after the last byte to SAVE."
"In the context of the C64, What is the purpose of the memory location at address $39-$3A?","address         $39-$3A        CURLIN
Current BASIC Line Number

This location contains the line number of the BASIC statement which is
currently being executed, in LSB/MSB format.  A value of 255 ($FF) in
location 58 ($3A), which translates to a line number of 65280 or above
(well over the 63999 limit for a program line), means that BASIC is
currently in immediate mode, rather than RUN mode.

BASIC keywords that are illegal in direct mode check 58 ($3A) to
determine whether or not this is the current mode.

When in RUN mode, this location is updated as each new BASIC line is
fetched for execution.  Therefore, a TRACE function could be added by
diverting the vector at 776 ($308), which points to the routine that
executes the next token, to a user-written routine which prints the
line number indicated by this location before jumping to the token
execution routine.  (LISTing the line itself would be somewhat harder,
because LIST uses many Page 0 locations that would have to be
preserved and restored afterwards.)

This line number is used by BREAK and error messages to show where
program execution stopped.  The value here is copied to 59 ($3B) by
STOP, END, and the stop-key BREAK, and copied back by CONT."
"In the context of the C64, What is the purpose of the memory location at address $FFFA?","address              $FFFA
Non-Maskable Interrupt Hardware Vector

This vector points to the main NMI routine at 65091 ($FE43)."
"In the context of the C64, What is the purpose of the memory location at address $14-$15?","address         $14-$15        LINNUM
Integer Line Number Value

The target line number for GOTO, LIST, ON, and GOSUB is stored here in
low- byte, high-byte integer format, as is the number of a BASIC line
that is to be added or replaced.

LIST saves the highest line number to list (or 65535 ($FFFF) if
program is to be listed to the end) at this location.

GOTO tests the target line number to see if it is greater than the
line number currently being executed.  If it is greater, GOTO starts
its search for the target line at the current line number.  If it is
not greater, GOTO must search for the target line from the first line
of the program.  It is interesting to note that the test is of the
most significant byte only.  Therefore, INT(TARGETLINE/256) must be
greater than INT(CURRENTLINE/256) in order for the search to start
with the current line, instead of at the beginning of the program.

PEEK, POKE, WAIT, and SYS use this location as a pointer to the
address which is the subject of the command.

22            $16            TEMPPT
Pointer to the Next Available Space in the Temporary String Stack

This location points to the next available slot in the temporary
string descriptor stack located at 25-33 ($19-$21).  Since that stack
has room for three descriptors of three bytes each, this location will
point to 25 ($19) if the stack is empty, to 28 ($1C) if there is one
entry, to 31 ($1F) if there are two entries, and to 34 ($22) if the
stack is full.

If BASIC needs to add an entry to the temporary string descriptor
stack, and this location holds a 34, indicating that the stack is
full, the FORMULA TOO COMPLEX error message is issued.  Otherwise, the
entry is added, and three is added to this pointer."
"In the context of the C64, What is the purpose of the memory location at address $DC0C?","address              $DC0C          CIASDR
Serial Data Port

The CIA chip has an on-chip serial port, which allows you to send or
receive a byte of data one bit at a time, with the most significant
bit (Bit 7) being transferred first.  Control Register A at 56334
($DC0E) allows you to choose input or output modes.  In input mode, a
bit of data is read from the SP line (pin 5 of the User Port) whenever
a signal on the CNT line (pin 4) appears to let you know that it is
time for a read.  After eight bits are received this way, the data is
placed in the Serial Port Register, and an interrupt is generated to
let you know that the register should be read.

In output mode, you write data to the Serial Port Register, and it is
sent out over the SP line (pin 5 of the User Port), using Timer A for
the baud rate generator.  Whenever a byte of data is written to this
register, transmission will start as long as Timer A is running and in
continuous mode.  Data is sent at half the Timer A rage, and an output
will appear on the CNT line (pin 4 of the User Port) whenever a bit is
sent.  After all eight bits have been sent, an interrupt is generated
to indicate that it is time to load the next byte to send into the
Serial Register.

The Serial Data Register is not used by the 64, which does all of its
serial I/O through the regular data ports."
"In the context of the C64, What is the purpose of the memory location at address $D411?","address              $D411          PWHI3
Voice 3 Pulse Waveform Width (high nybble)"
"In the context of the C64, What is the purpose of the memory location at address $B853?","address         $B853          FSUBT
BASIC's Subtraction Operation

This routine subtracts the contents of FAC2 from FAC1 by complementing
its sign and adding."
"In the context of the C64, What is the purpose of the memory location at address $B97E?","address         $B97E          OVERR
Print Overflow Error Message"
"In the context of the C64, What is the purpose of the memory location at address $DC00-$DC0F?","address        $DC00-$DC0F
Complex Interface Adapter (CIA) #1 Registers

Locations 56320-56335 ($DC00-$DC0F) are used to communicate with the
Complex Interface Adapter chip #1 (CIA #1).  This chip is a successor
to the earlier VIA and PIA devices used on the VIC-20 and PET.  This
chip functions the same way as the VIA and PIA:  It allows the 6510
microprocessor to communicate with peripheral input and output
devices.  The specific devices that CIA #1 reads data from and sends
data to are the joystick controllers, the paddle fire buttons, and the
keyboard.

In addition to its two data ports, CIA #1 has two timers, each of
which can count an interval from a millionth of a second to a
fifteenth of a second.  Or the timers can be hooked together to count
much longer intervals.  CIA #1 has an interrupt line which is
connected to the 6510 IRQ line.  These two timers can be used to
generate interrupts at specified intervals (such as the 1/60 second
interrupt used for keyboard scanning, or the more complexly timed
interrupts that drive the tape read and write routines).  As you will
see below, the CIA chip has a host of other features to aid in
Input/Output functions."
"In the context of the C64, What is the purpose of the memory location at address $DD0A?","address              $DD0A          TO2MIN
Time of Day Clock Minutes

Bits 0-3:  Second digit of Time of Day minutes (BCD)
Bits 4-6:  First digit of Time of Day minutes (BCD)
Bit 7:  Unused"
"In the context of the C64, What is the purpose of the memory location at address $E12A?","address              $E12A          SYS
Perform SYS

Before executing the machine language subroutine (JSR) at the address
indicated, the .A, .X, .Y, and .P registers are loaded from the
storage area at 780-783 ($30C-$30F).  After the return from subroutine
(RTS), the new values of those registers are stored back at 780-783
($30C-$30F)."
"In the context of the C64, What is the purpose of the memory location at address $E0F9?","address              $E0F9
Call Kernal I/O Routines

This section is used when BASIC wants to call the Kernal I/O routines
CHROUT, CHRIN, CHKOUT, CHKIN, and GETIN.  It handles any errors that
result from the call, and creates a 512-byte buffer space at the top
of BASIC and executes a CLR if the RS-232 device is opened."
"In the context of the C64, What is the purpose of the memory location at address $DD09?","address              $DD09          TO2SEC
Time of Day Clock Seconds

Bits 0-3:  Second digit of Time of Day seconds (BCD)
Bits 4-6:  First digit of Time of Day seconds (BCD)
Bit 7:  Unused"
"In the context of the C64, What is the purpose of the memory location at address $B983?","address         $B983          MULSHF
SHIFT Routine"
"In the context of the C64, What is the purpose of the memory location at address $DC00-$DC01?","address      ($DC00-$DC01)
CIA #1 Data Ports A and B

These registers are where the actual communication with outside
devices takes place.  Bits of data written to these registers can be
sent to external devices, while bits of data that those devices send
can be read here.

The keyboard is so necessary to the computer's operation that you may
have a hard time thinking of it as a peripheral device.  Nonetheless,
it cannot be directly read by the 6510 microprocessor.  Instead, the
keys are connected in a matrix of eight rows by eight columns to CIA
#1 Ports A and B.  The layout of this matrix is shown below.

WRITE TO PORT A               READ PORT B (56321, $DC01)
56320/$DC00
         Bit 7   Bit 6   Bit 5   Bit 4   Bit 3   Bit 2   Bit 1   Bit 0

Bit 7    STOP    Q       C=      SPACE   2       CTRL    <-      1

Bit 6    /       ^       =       RSHIFT  HOME    ;       *       LIRA

Bit 5    ,       @       :       .       -       L       P       +

Bit 4    N       O       K       M       0       J       I       9

Bit 3    V       U       H       B       8       G       Y       7

Bit 2    X       T       F       C       6       D       R       5

Bit 1    LSHIFT  E       S       Z       4       A       W       3

Bit 0    CRSR DN F5      F3      F1      F7      CRSR RT RETURN  DELETE

As you can see, there are two keys which do not appear in the matrix.
The SHIFT LOCK key is not read as a separate key, but rather is a
mechanical device which holds the left SHIFT key switch in a closed
position.  The RESTORE key is not read like the other keys either.  It
is directly connected to the NMI interrupt line of the 6510
microprocessor, and causes an NMI interrupt to occur whenever it is
pressed (not just when it is pressed with the STOP key).

In order to read the individual keys in the matrix, you must first set
Port A for all outputs (255, $FF), and Port B for all inputs (0),
using the Data Direction Registers.  Note that this is the default
condition.  Next, you must write a 0 in the bit of Data Port A that
corresponds to the column that you wish to read, and a 1 to the bits
that correspond to columns you wish to ignore.  You will then be able
to read Data Port B to see which keys in that column are being pushed.

A 0 in any bit position signifies that the key in the corresponding
row of the selected column is being pressed, while a 1 indicates that
the key is not being pressed.  A value of 255 ($FF) means that no keys
in that column are being pressed.

Fortunately for us all, an interrupt routine causes the keyboard to be
read, and the results are made available to the Operating System
automatically every 1/60 second.  And even when the normal interrupt
routine cannot be used, you can use the Kernal SCNKEY routine at 65439
($FF9F) to read the keyboard.

These same data ports are also used to read the joystick controllers.
Although common sense might lead you to believe that you could read
the joystick that is plugged into the port marked Controller Port 1
from Data Port A, and the second joystick from Data Port B, there is
nothing common about the Commodore 64.  Controller Port 1 is read from
Data Port B, and Controller Port 2 is read from CIA #1 Data Port A.

Joysticks consist of five switches, one each for up, down, right, and
left directions, and another for the fire button.  The switches are
read like the key switches--if the switch is pressed, the
corresponding bit will read 0, and if it is not pressed, the bit will
be set to 1.  From BASIC, you can PEEK the ports and use the AND and
NOT operators to mask the unused bits and inverse the logic for easier
comprehension.  For example, to read the joystick in Controller Port
1, you could use the statement:

S1=NOT PEEK(56321)AND15

The meaning of the possible numbers returned are:

 0 = none pressed
 1 = up
 2 = down
 4 = left
 5 = up left
 6 = down left
 8 = right
 9 = up right
10 = down right

The same technique can be used for joystick 2, by substituting 56320
as the number to PEEK.  By the way, the 3 and 7 aren't listed because
they represent impossible combinations like up-down.

To read the fire buttons, you can PEEK the appropriate port and use
the AND operator to mask all but bit 4:

T1=(PEEK(56321)AND16)/16

The above will return a 0 if the button is pressed, and a 1 if it is
not.  Substitute location 56320 as the location to PEEK for Trigger
Button 2.

Since CIA #1 Data Port B is used for reading the keyboard as well as
joystick 1, some confusion can result.  The routine that checks the
keyboard has no way of telling whether a particular bit was set to 0
by a keypress or one of the joystick switches.  For example, if you
plug the joystick into Controller Port 1 and push the stick to the
right, the routine will interpret this as the 2 key being pressed,
because both set the same bit to 0.  Likewise, when you read the
joystick, it will register as being pushed to the right if the 2 key
is being pressed.

The problem of mistaking the keyboard for the joystick can be solved
by turning off the keyscan momentarily when reading the stick with a
POKE 56333, 127:POKE 56320,255, and restoring it after the read with a
POKE 56333,129.  Sometimes you can use the simpler solution of
clearing the keyboard buffer after reading the joystick, with a POKE
198,0.

The problem of mistaking the joystick for a keypress is much more
difficult--there is no real way to turn off the joystick.  Many
commercially available games just use Controller Port 2 to avoid the
conflict.  So, if you can't beat them, sit back and press your
joystick to the left in order to slow down a program listing (the
keyscan routine thinks that it is the CTRL key).

As if all of the above were not enough, Port A is also used to control
which set of paddles is read by the SID chip, and to read the paddle
fire buttons.  Since there are two paddles per joystick Controller
Port, and only two SID registers for reading paddle positions, there
has to be a method for switching the paddle read from joystick Port 1
to joystick Port 2.

When Bit 7 of Port A is set to 1 and Bit 6 is cleared to 0, the SID
registers will read the paddles on Port 1.  When Bit 7 is set to 0 and
Bit 6 is set to 1, the paddles on Port 2 are read by the SID chip
registers.  Note that this also conflicts with the keyscan routine,
which is constantly writing different values to CIA #1 Data Port A in
order to select the keyboard column to read (most of the time, the
value for the last column is written to this port, which coincides
with the selection of paddles on joystick Port 1).  Therefore, in
order to get an accurate reading, you must turn off the keyscan IRQ
and select which joystick port you want to read.  See POTX at 54297
($D419), which is the SID register where the paddles are read, for the
exact technique.

Although the SID chip is used to read the paddle settings, the fire
buttons are read at CIA #1 Data Ports A and B.  The fire buttons for
the paddles plugged into Controller Port 1 are read at Data Port B
(56321, $DC01), while those for the paddles plugged into Controller
Port 2 are read from Data Port A (56320, $DC00).  The fire buttons are
read at Bit 2 and Bit 3 of each port (the same as the joystick left
and joystick right switches), and as usual, the bit will read 0 if the
corresponding button is pushed, and 1 if it is not.

Although only two of the rout paddle values can be read at any one
time, you can always read all four paddle buttons.  See the game
paddle input description at 54297 ($D419) for the BASIC statements
used to read these buttons.

Finally, Data Port B can also be used as an output by either Timer A
or B.  It is possible to set a mode in which the timers do not cause
an interrupt when they run down (see the descriptions of Control
Registers A and B at 56334-5 ($DC0E-F)).  Instead, they cause the
output on Bit 6 or 7 of Data Port B to change.  Timer A can be set
either to pulse the output of Bit 6 for one machine cycle, or to
toggle that bit from 1 to 0 or 0 to 1.  Timer B can use Bit 7 of this
register for the same purpose."
"In the context of the C64, What is the purpose of the memory location at address $D412?","address              $D412          VCREG3
Voice 3 Control Register

Bit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release
Bit 1:  Sync Bit:  1=Synchronize oscillator with Oscillator 2 frequency
Bit 2:  Ring Modulation:  1=Ring modulate Oscillators 3 and 2
Bit 3:  Test Bit:  1=Disable Oscillator 3
Bit 4:  Select triangle waveform
Bit 5:  Select sawtooth waveform
Bit 6:  Select pulse waveform
Bit 7:  Select noise waveform"
"In the context of the C64, What is the purpose of the memory location at address $B867?","address         $B867          FADD
Add FAC1 to a Number in Memory

This routine is used to add the contents of the Floating Point
Accumulator (FAC1) to a number in memory, by moving that number into
FAC2, and falling through to the next routine."
"In the context of the C64, What is the purpose of the memory location at address $DC0D?","address              $DC0D          CIAICR
Interrupt Control Register

Bit 0:  Read / did Timer A count down to 0?  (1=yes)
        Write/ enable or disable Timer A interrupt (1=enable, 0=disable)
Bit 1:  Read / did Timer B count down to 0?  (1=yes)
        Write/ enable or disable Timer B interrupt (1=enable, 0=disable)
Bit 2:  Read / did Time of Day Clock reach the alarm time?  (1=yes)
        Write/ enable or disable TOD clock alarm interrupt (1=enable,
        0=disable)
Bit 3:  Read / did the serial shift register finish a byte? (1=yes)
        Write/ enable or disable serial shift register interrupt (1=enable,
        0=disable)
Bit 4:  Read / was a signal sent on the flag line?  (1=yes)
        Write/ enable or disable FLAG line interrupt (1=enable, 0=disable)
Bit 5:  Not used
Bit 6:  Not used
Bit 7:  Read / did any CIA #1 source cause an interrupt?  (1=yes)
        Write/ set or clear bits of this register (1=bits written with 1 will
        be set, 0=bits written with 1 will be cleared)

This register is used to control the five interrupt sources on the
6526 CIA chip.  These sources are Timer A, Timer B, the Time of Day
Clock, the Serial Register, and the FLAG line.  Timers A and B cause
an interrupt when they count down to 0.  The Time of Day Clock
generates an interrupt when it reaches the ALARM time.  The Serial
Shift Register interrupts when it compiles eight bits of input or
output.  An external signal pulling the CIA hardware line called FLAG
low will also cause an interrupt (on CIA #1, this FLAG line is
connected to the Cassette Read line of the Cassette Port).

Even if the condition for a particular interrupt is satisfied, the
interrupt must still be enabled for an IRQ actually to occur.  This is
done by writing to the Interrupt Control Register.  What happens when
you write to this register depends on the way that you set Bit 7.  If
you set it to 0, any other bit that was written to with a 1 will be
cleared, and the corresponding interrupt will be disabled.  If you set
Bit 7 to 1, any bit written to with a 1 will be set, and the
corresponding interrupt will be enabled.  In either case, the
interrupt enable flags for those bits written to with a 0 will not be
affected.

For example, in order to disable all interrupts from BASIC, you could
POKE 56333, 127.  This sets Bit 7 to 0, which clears all of the other
bits, since they are all written with 1's.  Don't try this from BASIC
immediate mode, as it will turn off Timer A which causes the IRQ for
reading the keyboard, so that it will in effect turn off the keyboard.

To turn on the Timer A interrupt, a program could POKE 56333,129.  Bit
7 is set to 1 and so is Bit 0, so the interrupt which corresponds to
Bit 0 (Timer A) is enabled.

When you read this register, you can tell if any of the conditions for
a CIA Interrupt were satisfied because the corresponding bit will be
set to a 1.  For example, if Timer A counts down to 0, Bit 0 of this
register will be set to 1.  If, in addition, the mask bit that
corresponds to that interrupt source is set to 1, and an interrupt
occurs, Bit 7 will also be set.  This allows a multi-interrupt system
to read one bit and see if the source of a particular interrupt was
CIA #1.  You should note, however, that reading this register clears
it, so you should preserve its contents in RAM if you want to test
more than one bit."
"In the context of the C64, What is the purpose of the memory location at address $13?","address            $13            CHANNL
Current I/O Channel (CMD Logical File) Number

Whenever BASIC inputs or outputs data, it looks here to determine
which I/O device is currently active for the purpose of prompting or
output control.  It uses location 184 ($B8) for purposes of deciding
what device actually to put input from or output to.

When the default input device (number 0, the keyboard) or output
device (number 3, the display screen) is used, the value here will be
a zero, and the format of prompting and output will be the standard
screen output format.

When another device is used, the logical file number (CMD channel
number) will be placed here.  This lets the system now that it may
have to make some subtle changes in the way it performs the I/O
operation.  For example, if TAB is used with the PRINT command, cursor
right characters are used if the device PRINTed to is the screen.
Otherwise, spaces are output when the number here is other than zero
(the assumption being that you can't tab a printer like you can the
screen).

Likewise, the ? prompt for INPUT is suppressed if the file number here
is nonzero, as is the EXTRA IGNORED message, and input of a carriage
return by itself is ignored, rather than being treated as a null
string ('').  Therefore, by OPENing the screen as a device, and
issuing the CMD statement, you can force the suppression of the ?
prompt, and the other effects above.

CMD places the new output file number here, and calls the Kernal to
open the device for output, leaving it LISTENing for output (such as
the READY prompt, which is diverted to the new device).

Many routines reset this location and UNLISTEN the device, defeating
the CMD and once again sending the output to the screen.  If an error
message has to be displayed, for example, this location will be reset
and the message will be displayed on the screen.  GET, GET#, INPUT,
INPUT#, and PRINT# all will reset this location after the I/O is
completed, effectively redirecting output back to the screen.  PRINT
and LIST are the only I/O operations that will not undo the CMD.

This location can also be used to fool BASIC into thinking that data
it is reading from the tape is actually being entered into the
keyboard in immediate mode.

For a look at a technique that uses a different approach to accomplish
the same thing for disk or tape users, see location 512 ($200), the
keyboard buffer."
"In the context of the C64, What is the purpose of the memory location at address 65530-65535 ($FFFA-$FFFF)?","address      65530-65535 ($FFFA-$FFFF)
6510 Hardware Vectors

The last six locations in memory are reserved by the 6510 processor
chip for three fixed vectors.  These vectors let the chip know at what
address to start executing machine language program code when an NMI
interrupt occurs, when the computer is turned on, or when an IRQ
interrupt or BRK occurs."
"In the context of the C64, What is the purpose of the memory location at address $37-$38?","address         $37-$38        MEMSIZ
Pointer to the Highest Address Used by BASIC

The power-on/reset routine tests each byte of RAM until it comes to
the BASIC ROM, and sets this pointer to the adress of the highest byte
of consecutive RAM found (40959, $9FFF).

There are two circumstances under which this pointer may be changed
after power-up to reflect an address lower than the actual top of
consecutive RAM:

1.  Users may wish to lower this pointer themselves, in order to set
aside an area of free RAM that will not be disturbed by BASIC.  For
example, to set aside a 1K area at the top of BASIC, start your
program with the line:

POKE 56,PEEK(56)-4:CLR

The CLR is necessary to insure that the string text will start below
your safe area.

You may wish to store machine language programs, sprites, or alternate
character sets in such an area.  For the latter two applications,
however, keep in mind the 16K addressing range limitation of the
VIC-II chip.  If you do not assign the VIC-II to a bank other than the
default memory bank of 0-16383 ($0-$3FFF), you must lower the top of
memory below 16383 ($3FFF) if you wish your sprite or character data
area to be within its addressing range.

2.  Then the RS-232 device (number 2) is opened, this pointer and the
pointer to the end of user RAM at 643 are lowered by 512 bytes in
order to create two 256-byte buffers, one for input and the other for
output.

Since the contents of these buffers will overwrite any variables at
the top of memory, a CLR command is issued at the time device 2 is
opened.  Therefore, the RS-232 device should be opened before defining
any variables, and before setting aside a safe area for machine
language programs or other uses, as described above.

5"
"In the context of the C64, What is the purpose of the memory location at address $2B-$2C?","address         $2B-$2C        TXTTAB
Pointer to the Start of BASIC Program Text

This two-byte pointer lets BASIC know where program text is stored.
Ordinarily, such text is located beginning at 2049 ($801).  Using this
pointer, it is possible to change the program text area.  Typical
reasons for doing this include:

1.  Conforming the memory configuration to that of other Commodore
computers.  On 32K PET and CBM computers, for example, screen memory
starts at 32768 ($8000), and BASIC text begins at 1025 ($401).  You
can emulate this configuration with the 64 with the following short
program:

10 POKE 55,0:POKE 56,128: CLR: REM LOWER TOP OF MEMORY TO 32768
20 POKE 56576,PEEK(56576) AND 253: REM ENABLE BANK 2
30 POKE 53272,4: REM TEXT DISPLAY MEMORY NOW STARTS AT 32768
40 POKE 648,128:REM OPERATING SYSTEM PRINTS TO SCREEN AT 32768 (128*256)
50 POKE 44,4:POKE 1024,0: REM MOVE START OF BASIC TO 1025 (4*256+1)
60 POKE 792,193: REM DISABLE RESTORE KEY
70 PRINT CHR$(147);'NOW CONFIGURED LIKE PET':NEW
80 REM ALSO SEE ENTRIES FOR LOCATION 55, 56576, AND 648

Such reconfiguring can be helpful in transferring programs from the 64
to the PET, or vice versa.  Since the 64 automatically relocates BASIC
program text, it can load and list PET programs even though the
program file indicates a loading addresss that is different from the
64 start of BASIC.  The PET does not have this automatic relocation
feature, however, and it loads all BASIC programs at the two-byte
address indicated at the beginning of the disk or tape file.

So if the PET loads a 64 program at its normal starting address of
2049 ($801), it will not recognize its presence because it expects a
BASIC program to start at 1025 ($401).  Therefore, if you want to let
a PET and 64 share a program, you must either reconfigure the 64 to
start BASIC where the PET does, or reconfigure the PET to start BASIC
where the 64 does (with a POKE 41,8:POKE 2048,0).

2.  Raising the lowest location used for BASIC text in order to create
a safe area in low memory.  For example, if you wish to use the
high-resolution graphics mode, you may want to put the start of screen
memory at 8192 ($2000).  The high-resolution moe requires 8K of
memory, and you cannot use the lowest 8K for this purpose because it
is already being used for the zero-page assignments.

Since BASIC program text normally starts at 2048 ($801), this means
that you only have 6k for program text before your program runs over
into screen memory.  One way around this is by moving the start of
basic to 16385 ($4001) by typing in direct entry mode:

POKE 44,64: POKE 64*256,0:NEW

Other uses might include setting aside a storage area for sprite shape
data, or user-defined character sets.

3.  Keeping two or more programs in memory simultaneously.  By
changing this pointer, you can keep more than one BASIC program in
memory at one time, and switch back and forth betwenn them.  Examples
of this application can be found in COMPUTE!'s First Book of PET/CBM,
pages 66 and 163.

This technique has a number of offshoots that are perhaps of more
practical use.

a) You can store two programs in memory simultaneously for the purpose
of appending one to the other.  This technique requires that the line
numbers of the two programs do not overlap.  (See Programming the
PET/CBM by Raeto Collin West, pages 41-42, for a discussion of this
technique).

b) You can have two programs in memory at once and use the concept in
(2) above to allow an easier way to create a safe area in low memory.
The first program is just onw line that sets the start of BASIC
pointer to the address of the second program which is located higher
in memory, and then runs that second program.

4. Since this address is used as the address of the first byte to
SAVE, you can save any section of memory by changing this pointer to
indicate the starting address, and the pointer 45-46 ($2D-$2D) to
indicate the address of the byte after the last byte that you wish to
save."
"In the context of the C64, What is the purpose of the memory location at address $FD15?","address              $FD15          RESTOR
Restore RAM Vectors for Default I/O Routines

This documented Kernal routine can be entered through the jump table
at 65418 ($FF8A).

It sets the values for the 16 RAM vectors to the interrupt and
important Kernal I/O routines in the table that starts at 788 ($314)
to the standard values held in the ROM table at 64816 ($FD30)."
"In the context of the C64, What is the purpose of the memory location at address $13F-$1FF?","address       $13F-$1FF

This area is exclusively for the microprocessor stack.  Some BASIC
commands, such as FOR-NEXT loops require many stack entries at a time.
Therefore, BASIC frequently checks the stack before pushing entries
on, and returns an OUT OF MEMORY error if an operation would result in
less than 62 bytes of available stack memory.

Each FOR statement causes 18 bytes to be pushed onto the stack, which
come off in the following order:

First comes a one-byte constant of 129 ($81).  Next is a two-byte
pointer to the address of the subject variable (the X of FOR X=1 to
10).  This is followed by the five-byte floating point representation
of the TO value.  Finally comes the two-byte line number of the line
to which the program returns after a NEXT, and the two-byte address of
the next character to read in that line after the FOR statement.

Each GOSUB call places five bytes on the stack.  The first byte to
come off is a one-byte constant of 141 ($8D).  The next two bytes
contain the line number of the statement to which the program will
RETURN after the subroutine ends.  And the final two bytes are a
pointer to the address of the BASIC program text for that statement in
which the program RETURNs.

DEF also leaves a five-byte entry on the stack.  It is the same as
that described for GOSUB, except that instead of a constant byte of
141, the first number is a dummy byte, whose value has no
significance."
"In the context of the C64, What is the purpose of the memory location at address $F9-$FA?","address       $F9-$FA        ROBUF
Pointer: RS-232 Output Buffer

This location points to the address of the 256-byte output buffer
which is used for transmitting data to RS-232 devices (device number
2)l"
"In the context of the C64, What is the purpose of the memory location at address $FA60?","address              $FA60
Receive and Store the Next Character from Cassette

This is the part of the cassette read IRQ routine that actually gets
the next byte of data from the cassette."
"In the context of the C64, What is the purpose of the memory location at address $D7?","address           $D7
Temporary Storage Area for ASCII Value of Last Character Printed

The ASCII value of the last character printed to the screen is held
here temporarily."
"In the context of the C64, What is the purpose of the memory location at address $B194?","address         $B194          ARYGET
Allocate Space for Array Descriptors

This routine allocates five bytes plus two bytes for every dimension
specified for the array descriptor."
"In the context of the C64, What is the purpose of the memory location at address $B245?","address         $B245          BSERR
Print BAD SUBSCRIPT Error Message"
"In the context of the C64, What is the purpose of the memory location at address $A8F8?","address         $A8F8          DATA
Perform DATA

DATA uses the next subroutine to find the offset to the next
statement, and adds the offset to the current pointers so that the
next statement will be executed.  If effect, it skips the statement,
much like REM."
"In the context of the C64, What is the purpose of the memory location at address $E3BA?","address              $E3BA
Initial RND Seed Value

At power-up time, this five-byte floating point constant is
transferred to 139 ($8B), where it functions as the starting RND seed
number.  Thus, if RND is not initialized with a negative or zero
argument, it will always return the same sequence of numbers."
"In the context of the C64, What is the purpose of the memory location at address $E518?","address              $E518
Initialize Screen and Keyboard

This is the original CINT Kernal routine, to which additions were made
in later versions of the Kernal.

After calling the routine at 58784 ($E5A0) to set up default I/O
values, this routine initializes the cursor blink flags, the keyboard
decode vector, the key repeat delay and frequency counters, the
current color code, and maximum keyboard buffer size.  It then falls
through to the next routine."
"In the context of the C64, What is the purpose of the memory location at address $A9A5?","address         $A9A5          LET
Perform LET

The LET command causes variables to be created and initialized, or to
have a new value assigned.  It handles all types of array or nonarray
variables:  strings, floating point, integers, ST, TI, and TI$.  The
routine is composed of several subroutines that evaluate the variable,
evaluate the assigned expression, check that the assigned value is
suitable for a variable of that type, and then assign a value to the
existing variable, or create a new variable."
"In the context of the C64, What is the purpose of the memory location at address $E268?","address              $E268          SIN
Perform SIN

This routine evaluates the SIN of the number in FAC1 (which represents
the angle in radians), and leaves the result there."
"In the context of the C64, What is the purpose of the memory location at address $B018?","address         $B018          DIM
Perform DIM

This command calls the next routine to create an array for every
variable dimensioned (since a statement can take the form DIM A(12),
B(13), C(14)...).  If the array element is referenced before a DIM
statement (for example, A(3)=4), the array will be dimensioned to 10
(as if DIM A(10) were executed).  Remember, DIMensioning an array to
10 really creates 11 elements (10).  The 0 element should always be
considered in calculating the size to DIMension your array."
"In the context of the C64, What is the purpose of the memory location at address $E422?","address              $E422
Print BASIC Start-Up Messages

This routine prints the start-up message '**** COMMODORE 64 BASIC V2
****', calculates the amount of free memory, and prints the BYTES FREE
message."
"In the context of the C64, What is the purpose of the memory location at address $A8A0?","address         $A8A0          GOTO
Perform GOTO

This statement scans BASIC for the target line number (the scan starts
with the current line if the target line number is higher, otherwise
it starts with the first line).  When the line is found, the pointers
to the current statement and text character are changed, so that the
target statement will be executed next."
"In the context of the C64, What is the purpose of the memory location at address $A94B?","address         $A94B          ONGOTO
Perform ON GOTO or ON GOSUB

ON is performed by converting the argument to an integer, and then
skipping a number between commas each time that the integer is
decremented until the argument reaches 0.  If a GOTO or GOSUB is the
next token, the current number between commas is used to execute one
of those statements.  If the numbers between commas are used up before
the argument reaches 0, the statement has no effect, and the next
statement is executed."
"In the context of the C64, What is the purpose of the memory location at address $E566?","address              $E566
Home the Cursor

This routine sets PNTR (211, $D3) and TBLX (214, $D6) to 0, and falls
through to the next routine."
"In the context of the C64, What is the purpose of the memory location at address $B1AA?","address         $B1AA
Convert a Floating Point Number to a Signed Integer in .A and .Y Registers

This subroutine calls AYINT, below, which checks to make sure that the
number in the Floating Point Accumulator is between 32767 and -32768,
and converts it to a 16-bit signed integer in 100-101 ($64-$65), high
byte first.  It leaves the high byte of the integer in the
Accumulator, and the low byte in the .Y register.

Although this routine does not appear to be referenced anywhere in
BASIC, the vector at locations 3-4 points to its address.  Presumably,
it is provided for the benefit of the user who wishes to pass
parameters in a USR call, or the like."
"In the context of the C64, What is the purpose of the memory location at address $B34C?","address         $B34C          UMULT
Compute the Size of a Multidimensional Array

This routine calculates the size of a multidimensional array by
multiplying the dimensions."
"In the context of the C64, What is the purpose of the memory location at address $FE34?","address              $FE34          MEMBOT
Read/Set Bottom of RAM Pointer

This is a documented Kernal routine, which can be entered through the
jump table at location 65436 ($FF9C).

It can be used to either read or set the bottom of RAM pointer.  If
called with the Carry flag set, the address in the pointer willbe
loaded into the .X and .Y registers.  If called with the Carry flag
cleared, the pointer will be changed to the address found in the .X
and .Y registers."
"In the context of the C64, What is the purpose of the memory location at address $200-$258?","address      $200-$258      BUF
BASIC Line Editor Input Buffer

When you are in the BASIC immediate mode, and type in a line of
characters, those characters are stored here.  BASIC then scans the
string of characters, converts the text to tokenized BASIC program
format, and either stores it or executes the line, depending on
whether or not it started with a line number.

This same area is also used to store data which is received via the
INPUT and GET commands.  This explains why these commands are illegal
in immediate mode--they must use the same buffer space that is
required by the immediate mode statement itself.

It is interesting to note that this buffer is 89 bytes long.  The
screen editor will allow a maximum of only 80 characters in a program
line, with one extra byte required for a 0 character, marking the end
of the line.  This presumable is a carry over from the VIC, which
allows a line length of up to 88 characters.  The last eight bytes of
this buffer are therefore normally not used, and can be considered
free space for the programmer to use as he or she sees fit.

Location Range: 601-630 ($259-$276)
Tables for File Numbers, Device Numbers, and Secondary Addresses

All three of the tables here have room for ten one-byte entries, each
of which represents an active Input/Output file.  When an I/O file is
opened, its logical file number is put into the table at 601 ($259),
the device number of the I/O device is put into the table at 611
($263), and its secondary address is put into the table at 621 ($26D).

The entry for any particular I/O file will occupy the same position in
each of the three tables.  That is, if logical file number 2 is the
third entry in the file number table, its secondary address will be
the third entry in the secondary address table, and its corresponding
device number will occupy the third spot in the device number table.

Every time a device is OPENed, its information is added as the last
entry in each table, and the value at location 152 ($98) is increased
by one, indicating that there is one more active I/O file.  When a
device is CLOSEd, the value at location 152 is decreased by one, and
all entries that occupy a position in the tables that is higher than
that of the closed device are moved down one position, thus
eliminating the entry for that device.  The Kernal CLALL routine
(62255, $F32F) simply zeros location 152, which has the effect of
emptying these tables."
"In the context of the C64, What is the purpose of the memory location at address $FD02?","address              $FD02
Check for an Autostart Cartridge

This routine tests for an autostart cartridge by comparing the
characters at location 32772-6 ($8004-8) to the text below.  The Zero
flag will be set if they match, and cleared if they don't."
"In the context of the C64, What is the purpose of the memory location at address $F8E2?","address              $F8E2
Adjust CIA #1 Timer A for Tape Bit Timing"
"In the context of the C64, What is the purpose of the memory location at address $FF?","address          $FF            BASZPT
BASIC Temporary Data for Floating Point to ASCII Conversion

This location is used for temporary storage in the process of
converting floating point numbers to ASCII characters.."
"In the context of the C64, What is the purpose of the memory location at address $3B-$3C?","address        $3B-$3C        OLDLIN
Previous BASIC Line Number

When program execution ends, the last line number executed is stored
here, and restored to location 57 ($39) by CONT."
"In the context of the C64, What is the purpose of the memory location at address $2F-$30?","address          $2F-$30       ARYTAB
Pointer to the Start of the BASIC Array Storage Area

This location points to the address of the end of nonarray variable
storage, and the beginning of array variable storage.  The format for
array storage is as follows:

The first two bytes hold the array name.  The format and high-bit
patterns are the same as for nonarray variables (see 45 ($2D) above),
except that there is no equivalent to the function definition.

Next comes a two-byte offset to the start of the next array, low byte
first.  Then there is a one-byte value for the number of array
dimensions (e.g., 2 for a two-dimensional array like A(x,y)).  That
byte is followed by pairs of bytes which hold the value of each array
dimension+1 (DIMensioning an array always makes space for 0, so A(0)
can be used).

Finally come the values of the variables themselves.  The format for
these values is the same as with nonarray values, but each value only
takes up the space required; that is, floating point variables use
five bytes each, integers two bytes, and string descriptors three
bytes each.

Remember that as with nonarray string, the actual string text is
stored elsewhere, in the area which starts at the location pointed to
in 51-52 ($33- $34)."
"In the context of the C64, What is the purpose of the memory location at address $FFFC?","address              $FFFC
System Reset (RES) Hardware Vector

This vector points to the power-on routine at 64738 ($FCE2)."
"In the context of the C64, What is the purpose of the memory location at address $B7EB?","address         $B7EB          GETNUM
Get a 16-Bit Address Parameter and an 8-Bit Parameter (for POKE and WAIT)

This routine gets the next numeric parameter from the current place in
program text.  The routine evaluates it, checks that it is a positive
integer within the range 0-65535, and changes it from floating point
to a two-byte integer in 20-21 ($14-$15).  It checks for and skips a
comma, then gets a one-byte integer parameter in the .X register.  The
routine is used to get the parameters for POKE an WAIT."
"In the context of the C64, What is the purpose of the memory location at address $DC01?","address              $DC01          CIAPRB
Data Port Register B

Bit 0:  Read keyboard row 0
        Read joystick 1 up direction
Bit 1:  Read keyboard row 1
        Read joystick 1 down direction
Bit 2:  Read keyboard row 2
        Read joystick 1 left direction
        Read paddle 1 fire button
Bit 3:  Read keyboard row 3
        Read joystick 1 right direction
        Read paddle 2 fire button
Bit 4:  Read keyboard row 4
        Read joystick 1 fire button
Bit 5:  Read keyboard row 5
Bit 6:  Read keyboard row 6
        Toggle or pulse data output for Timer A
Bit 7:  Read keyboard row 7
        Toggle or pulse data output for Timer B

Location Range: 56322-56323 ($DC02-$DC03)
CIA #1 Data Direction Registers A and B

These Data Direction Registers control the direction of data flow over
Data Ports A and B.  Each bit controls the direction of the data on
the corresponding bit of the port.  If teh bit of the Direction
Register is set to a 1, the corresponding Data Port bit will be used
for data output.  If the bit is set to a 0, the corresponding Data
Port bit will be used for data input.  For example, Bit 7 of Data
Direction Register A controls Bit 7 of Data Port A, and if that
direction bit is set to 0, Bit 7 of Data Port A will be used for data
input.  If the direction bit is set to 1, however, data Bit 7 on Port
A will be used for data output.

The default setting for Data Direction Register A is 255 (all
outputs), and for Data Direction Register B it is 0 (all inputs).
This corresponds to the setting used when reading the keyboard (the
keyboard column number is written to Data Port A, and the row number
is then read in Data Port B)."
"In the context of the C64, What is the purpose of the memory location at address $B947?","address         $B947          NEGFAC
Replace FAC1 with Its 2's Complement"
"In the context of the C64, What is the purpose of the memory location at address $B850?","address         $B850          FSUB
Subtract FAC1 from a Number in Memory

This routine is used to subtract the Floating Point Accumulator from a
number in memory.  It moves the number in memory into FAC2, and falls
through to the next routine."
"In the context of the C64, What is the purpose of the memory location at address $D414?","address              $D414          SUREL3
Voice 3 Sustain/Release Control Register

Bits 0-3:  Select release cycle duration (0-15)
Bits 4-7:  Select sustain volume level (0-15)

Location Range: 54293-54296 ($D415-$D418)
Filter Controls

In addition to the controls detailed above for each voice, the SID
chip also provides a filtering capability which allows you to
attenuate (make quieter) certain ranges of frequencies.  Any one or
all three voices can be filtered, and there is even a provision for
filtering an external signal that is input through pin 5 of the
monitor jack.

A low-pass filter is available, which suppresses the volume of those
frequency components that are above a designated cutoff level.  The
high-pass filter reduces the volume of frequency components that are
below a certain level.  The band-pass filter reduces the volume of
frequency components on both sides of the chosen frequency, thereby
enhancing that frequency.  Finally, the high-pass and low-pass filters
can be combined to form a notch reject filter, which reduces the
folume of the frequency components nearest the selected frequency.
These various filters can dramatically change the quality of the sound
produced.

The first two registers are used to select the filter cutoff
frequency.  This is the frequency above or below which any sounds will
be made quieter.  The further away from this level any frequency
components are, the more their output volume will be suppresed (high-
and low-pass filters reduce the volume of those components by 12 dB
per octave away from the center frequency, while the band-pass filter
attenuates them by 6 dB per octave).

The cutoff frequency has an 11-bit range (which corresponds to the
numbers 0 to 2047).  This is made up of a high-byte and three low
bits.  Therefore, to compute the frequency represented by the value in
these registers, you must multiply the value in the high byte by 8,
and add the value of the low three bits.  The range of cutoff
freqnencies represented by these 2048 values stretches from 30 Hz to
about 12,000 Hz.  The exact frequency may be calculated with the
formula:

FREQUENCY=(REGISTER VALUE*5.8)+30Hz

An additional element in filtering is the resonance control.  This
allows you to peak the volume of the frequency elements nearest the
cutoff frequency."
"In the context of the C64, What is the purpose of the memory location at address $E092?","address              $E092          RADDC
Additive Constant for RND

The five-byte floating point number stored here is added to the seed
as part of the process of obtaining the value for RND."
"In the context of the C64, What is the purpose of the memory location at address $DD07?","address              $DD07          TI2BHI
Timer B (high byte)

Location Range: 56584-56587 ($DD08-$DD0B)
Time of Day Clock

In addition to the two general purpose timers, the 6526 CIA chip has a
special purpose Time of Day Clock, which keeps time in a format that
humans can understand a little more easily than microseconds.  For
more information about this clock, see the entry for Location Range
56328-56331 ($DC08-$DC0B).  The 64's Operating system does not make
use of these registers."
"In the context of the C64, What is the purpose of the memory location at address $DD08?","address              $DD08          TO2TEN
Time of Day Clock Tenths of Seconds

Bits 0-3:  Time of Day tenths of second digit (BCD)
Bits 4-7:  Unused"
"In the context of the C64, What is the purpose of the memory location at address $E097?","address              $E097          RND
Perform RND

This routine comes up with a random number in one of three ways,
depending on the argument X of RND(X).  If the argument is positive,
the next RND value is obtained by multiplying the seed value in
location 139 ($8B) by one of the constants above, adding the other
constant, and scrambling the resulting bytes.  This produces the next
number in a sequence.  So many numbers can be produced in this way
before the sequence begins to repear that it can be considered random.

If the argument is negative, the argument itself is scrambled, and
made the new seed.  This allows creation of a sequence that can be
duplicated.

If the argument is 0, four bytes of the Floating Point Accumulator are
loaded from the low and high byte of Timer A, and the tenths of second
and second Time of Day Clock registers, all on CIA #1.  This provides
a somewhat random value determined by the setting of those timers at
the moment that the command is executed, which becomes the new seed
value.  The RND(1) command should then be used to generate further
random numbers.

The RND(0) implementation on the 64 has serious problems which make it
unusable for generating a series of random numbers when used by
itself.  First of all, the Time of Day Clock on CIA #1 (see
56328-56331 ($DC08-$DC0B)) does not start running until you write to
the tenth of second register.  The Operating System never starts this
clock, and therefore the two registers used as part of the floating
point RND(0) value always have a value of 0.  Even if the clock was
started, however, these registers keep time in Binary Coded Decimal
(BCD) format, which means that they do not produce a full range of
numbers from 0 to 255.  In addition, the Timer A high register output
ranges only from 0 to 66, which also imits the range of the final
floating point value so that certain numbers are never chosen."
"In the context of the C64, What is the purpose of the memory location at address $B849?","address         $B849          FADDH
Add .5 to Contents of Floating Point Accumulator #1"
"In the context of the C64, What is the purpose of the memory location at address $D413?","address              $D413          ATDCY3
Voice 3 Attack/Decay Register

Bits 0-3:  Select decay cycle duration (0-15)
Bits 4-7:  Select attack cycle duration (0-15)"
"In the context of the C64, What is the purpose of the memory location at address $DC00?","address              $DC00          CIAPRA
Data Port Register A

Bit 0:  Select to read keyboard column 0
        Read joystick 2 up direction
Bit 1:  Select to read keyboard column 1
        Read joystick 2 down direction
Bit 2:  Select to read keyboard column 2
        Read joystick 2 left direction
        Read paddle 1 fire button
Bit 3:  Select to read keyboard column 3
        Read joystick 2 right direction
        Read paddle 2 fire button
Bit 4:  Select to read keyboard column 4
        Read joystick 2 fire button
Bit 5:  Select to read keyboard column 5
Bit 6:  Select to read keyboard column 6
        Select to read paddles on Port A or B
Bit 7:  Select to read keyboard column 7
        Select to read paddles on Port A or B"
"In the context of the C64, What is the purpose of the memory location at address $B8FE?","address         $B8FE          NORMAL
Normalize Floating Point Accumulator #1"
"In the context of the C64, What is the purpose of the memory location at address $B7AD?","address         $B7AD          VAL
Perform VAL

The VAL routine obtains the string pointer, and reads the string one
character at a time until an invalid character is found (ASCII
numbers, sign character, a single decimal point, exponent, and spaces
are all valid).  Then the string is changed to floating point.  If no
valid characters are found, a 0 is returned."
"In the context of the C64, What is the purpose of the memory location at address $FFFE?","address              $FFFE
Maskable Interrupt Request and Break Hardware Vectors

This vector points to the main IRQ handler routine at 65352 ($FF48)."
"In the context of the C64, What is the purpose of the memory location at address $31-$32?","address         $31-$32        STREND
Pointer to End of the BASIC Array Storage Area (+1), and the Start of
Free RAM

This location points to the address of the end of BASIC array storage
space and the start of free RAM.  Since string text starts at the top
of memory and builds downwards, this location can also be thought of
as the last possible address of the string storage area.  Defining new
variables pushes this pointer upward, toward the last string text.

If a string for which space is being allocated would cross over this
boundary into the array storage area, garbage collection is performed,
and if there still is not enough room, an OUT OF MEMORY error occurs.
FRE performs garbage collection, and returns the difference between
the addresses pointed to here and the address of the end of string
text storage pointed to by location 51 ($33)."
"In the context of the C64, What is the purpose of the memory location at address $3D-$3E?","address         $3D-$3E        OLDTXT
Pointer to the Address of the Current BASIC Statement

This location contains the address (not the line number) of the text
of the BASIC statement that is being executed.  The value of TXTPTR
(122, $7A), the pointer tot he address of the BASIC text character
currently being scanned, is stored here each time a new BASIC line
begins execution.

END, STOP, and the STOP-key BREAK save the value of TXTPTR here, and
CONT restores this value to TXTPTR.  CONT will not continue if 62
($3E) has been changed to a zero by a LOAD, a modification to the
program text, or by error routines."
"In the context of the C64, What is the purpose of the memory location at address $F8D0?","address              $F8D0
Test the STOP Key during Cassette I/O Operations

This subroutine is used to test the STOP key during tape I/O
oeprations, and to stop I/O if it is pressed."
"In the context of the C64, What is the purpose of the memory location at address $FB-$FE?","address       $FB-$FE        FREEZP
Four Free Bytes of Zero Page for User Programs

These locations were specifically set aside for user-written ML
routines that require zero-page addressing.  While other zero-page
locations can be used on a noninterference basis, it is guaranteed
that BASIC will not alter these locations."
"In the context of the C64, What is the purpose of the memory location at address $0300-$03FF?","page 2 and 3

This area is used to store important information for the Operating
System and BASIC.  It contains vectors to certain BASIC routines as
well as Operating System Kernal routines.  Registers for RS-232 serial
I/O are located here.  Buffer space is allocated in this area for tape
I/O, BASIC text input, and the keyboard queue.  In addition, there are
a number of Operating System variables and pointers here which the
programmer can utilize."
"In the context of the C64, What is the purpose of the memory location at address $FCE2?","address              $FCE2
Power-On Reset Routine

This is the RESET routine which is pointed to by the 6510 hardware
RESET vector at 65532 ($FFFC).

This routine is automatically executed when the computer is first
turned on.  First, it sets the Interrupt disable flag, sets the stack
pointer, and clears the Decimal mode flag.  Next, it tests for an
autostart cartridge.  If one is found, the routine immediately jumps
through the cartridge cold start vector at 32768 ($8000).  If no
cartridge is found, the Kernal initialization routines IOINIT, RAMTAS,
RESTOR, and CINT are called, the Interrupt disable flag is cleared,
and the BASIC program is entered through the cold start vector at
40960 ($A000)."
"In the context of the C64, What is the purpose of the memory location at address $FE25?","address              $FE25          MEMTOP
Read/Set Top of RAM Pointer

This is a documented Kernal routine, which can be entered through the
jump table at location 65433 ($FF99).

It can be used to either read or set the top of RAM pointer.  If
called with the Carry flag set, the address in the pointer will be
loaded into the .X and .Y registers.  If called with the Carry flag
cleared, the pointer will be changed to the address found in the .X
and .Y registers."
"In the context of the C64, What is the purpose of the memory location at address $B37D?","address         $B37D          FRE
Perform FRE

The FRE function calls the garbage collection routine at 46374 ($B526)
to get rid of unused string text, and calculates the difference
between the bottom of string text and the top of array storage.  It
then drops through to the follow routine, which assumes that the free
memory value is a 16-bit signed integer, and converts it to floating
point accordingly.

Of course, while the free memory space on the PET might have always
been 32767 or less (the maximum value of a signed integer), sich is
definitely not the case on the 64.  Because conversion is from a
signed integer, any memory value over 32767 will be regarded as
negative (the high bit is treated as a sign bit).  Therefore, for
these higher values you must add twice the bit value of the high bit
(65536) in order to come up with the correct value.  The expression
FRE(0)-6556*(FRE(0)<0) will always return the correct amount of free
memory."
"In the context of the C64, What is the purpose of the memory location at address $B1B2?","address        $B1B2          INTIDX
Input and Convert a Floating Point Subscript to a Positive Integer

This routine converts a floating point subscript value to an integer,
making sure first that it is positive."
"In the context of the C64, What is the purpose of the memory location at address $A93B?","address         $A93B          REM
Perform REM

The REM statement is executed by skipping all program text until the
beginning of the next statement.  It is actually a part of the IF
statement, which continues for a few bytes after the REM part."
"In the context of the C64, What is the purpose of the memory location at address $E544?","address              $E544
Initialize the Screen Line Link Table and Clear the Screen

This routine initializes the screen line link table at 217 ($D9),
clears the screen, and clears the Color RAM to the background color.
It falls through to the next routine."
"In the context of the C64, What is the purpose of the memory location at address $E3BF?","address              $E3BF          INIT
Initialize BASIC

This routine is called by the cold start routine to initialize all of
the BASIC zero-page locations which have a fixed value.  This includes
copying the CHRGET routine from the ROM location above, to 115 ($73)."
"In the context of the C64, What is the purpose of the memory location at address $A883?","address         $A883          GOSUB
Perform GOSUB

This statement pushes the pointers to the current text character and
current line onto the stack, along with a constant 141 ($8D) which
identifies the block as saved GOSUB information to be used by RETURN.
The GOTO is called."
"In the context of the C64, What is the purpose of the memory location at address $B016?","address         $B016          DORE1
Perform Comparisons

This routine does the greater than (>), less than (<), and equal (=)
comparisons for foating point numbers and strings.  The result in the
Floating Point Accumulator will be 0 if the comparison is false, and
-1 if it is true."
"In the context of the C64, What is the purpose of the memory location at address $ABBF?","address         $ABBF          INPUT
Perform INPUT

The INPUT routine checks to make sure that direct mode is not active,
prints prompts, receives a line of input from the device, and jumps to
the common code in READ that assigns the input to the variables which
were named."
"In the context of the C64, What is the purpose of the memory location at address $E219?","address              $E219
Set Parameters for OPEN and CLOSE

This routine is used in common by OPEN and CLOSE for setting the
filename, the logical file, device number, and secondary address, all
of which must be done prior to these operations."
"In the context of the C64, What is the purpose of the memory location at address $E2EA?","address              $E2EA          FR4
The Five-Byte Floating Point Representation of the Constant 1/4"
"In the context of the C64, What is the purpose of the memory location at address $AFA7?","address         $AFA7          ISFUN
Dispatch and Evaluate a Function

If a BASIC function (like ASC('A')) is part of an expression, this
routine will use the function dispatch table at 42242 ($A502) to set
up the address of th proper function routine, and then branch to that
routine."
"In the context of the C64, What is the purpose of the memory location at address $A928?","address         $A928          IF
Perform IF

IF uses the FRMEVL routine at 44446 ($AD9E) to reduce the expression
which follows to a single term.  If the expression evaluates to 0
(false), the routine falls through to REM.  If it is not 0, GOTO or
the statement following THEN is executed."
"In the context of the C64, What is the purpose of the memory location at address $FE66?","address              $FE66
BRK, Warm Start Routine

This routine is executed when the STOP/RESTORE combination of
keypresses occurs.  In addition, it is the default target address of
the BRK instruction vector.  This routine calls the Kernal
intialization routines RESTOR, IOINIT, and part of CINT.  It then
exits through the BASIC warm start vector at 40962 ($A002)."
"In the context of the C64, What is the purpose of the memory location at address $D5?","address          $D5            LNMX
Maximum Length of Physical Screen Line

The line editor uses this location when the end of a line has been
reached to determine whether another physical line can be added to the
current logical line, or if a new logical line must be started."
"In the context of the C64, What is the purpose of the memory location at address $C5?","address           $C5            LSTX
Matrix Coordinate of Last Key Pressed, 64=None Pressed

During every normal IRQ interrput this location is set with the value
of the last keypress, to be used in keyboard debouncing.  The
Operating System can check if the current keypress is the same as the
last one, and will not repeat the character if it is.

The value returned here is based on the keyboard matrix values as set
forth in the explanation of location 56320 ($DC00).  The values
returned for each key pressed are shown at the entry for location 203
($CB)."
"In the context of the C64, What is the purpose of the memory location at address $FE07?","address              $FE07          READST
Read the I/O Status Word

This is a documented Kernal routine, which can be entered through the
jump table at location 65463 ($FFB7).

Whenever an I/O error occurs, a bit of the Status Word is set to
indicate what the problem was.  The routine allows you to read the
status word (it is returned in the Accumulator).  If the device was
the RS-232, its status register is read and cleared to zero.  For the
meanings of the various status codes, see the entry for location 144
($90) or 663 ($297) for the RS-232 device."
"In the context of the C64, What is the purpose of the memory location at address $FD30?","address     816         $FD30
Table of RAM Vectors to the Default I/O Routines

This table contains the 16 RAM I/O vectors that are moved to 788-819
($314-$333)."
"In the context of the C64, What is the purpose of the memory location at address $11?","address            $11            INPFLG
Flag: Is Data Input to GET, READ or INPUT?

Since the keywords GET, INPUT, and READ perform similar functions,
BASIC executes some of the same instructions for all three.  There are
also many areas of difference, however, and this flag indicates which
of the three keywords is currently being executed, so that BASIC will
know whether or not to execute the instructions which relate to the
areas in which the commands differ (152 ($98)=READ, 64 ($40)=GET,
0=INPUT).

As a result, INPUT will show the ? prompt, will echo characters back
to the screen, and will wait for a whole line of text ended by a
carriage return.  GET gives no prompt and accepts one character
without waiting.  The colon character and the comma are valid data for
GET, but are treated as delimiters between data by INPUT and READ.

As each command has its own error messages, this flag is used to
determine the appropriate message to issue in case of an error."
"In the context of the C64, What is the purpose of the memory location at address $B77C?","address         $B77C          LEN
Perform LEN

The LEN function is performed by obtaining the string length from the
descriptor and converting it to a floating point number."
"In the context of the C64, What is the purpose of the memory location at address $DD00?","address              $DD00          CI2PRA
Data Port Register A

Bits 0-1:  Select the 16K VIC-II chip memory bank (11=bank 0, 00=bank 3)
Bit 2:  RS-232 data output (Sout)/Pin M of User Port
Bit 3:  Serial bus ATN signal output
Bit 4:  Serial bus clock pulse output
Bit 5:  Serial bus data output
Bit 6:  Serial bus clock pulse input
Bit 7:  Serial bus data input"
"In the context of the C64, What is the purpose of the memory location at address $DC0B?","address              $DC0B          TODHRS
Time of Day Clock Hours

Bits 0-3:  Second digit of Time of Day hours (BCD)
Bit 4:  First digit of Time of Day hours (BCD)
Bits 5-6:  Unused
Bit 7:  AM/PM Flag (1=PM, 0=AM)"
"In the context of the C64, What is the purpose of the memory location at address $B487?","address         $B487          STRLIT
Scan and Set Up Pointers to a String in Memory

This routine calculates the length of the string, and calls the
routine that allocates space in memory.  It then saves the string, or
creates a pointer to its location in the BASIC text input buffer at
512 ($200)."
"In the context of the C64, What is the purpose of the memory location at address $B8A7?","address         $B8A7          FADD4
Make the Result Negative If a Borrow Was Done"
"In the context of the C64, What is the purpose of the memory location at address $E156?","address              $E156          SAVE
Perform SAVE

This routine sets the range of addresses to be saved from the start of
BASIC program text and end of BASIC program text pointers at 43 ($2B)
and 45 ($2D), and calls the Kernal SAVE routine.  This means that any
area of memory can be saved by altering these two pointers to point to
the starting and ending address of the desired area, and then changing
them back."
"In the context of the C64, What is the purpose of the memory location at address $E165?","address              $E165          VERIFY
Perform VERIFY

This routine sets the load/verify flag at 10 ($A), and falls through
to the LOAD routine."
"In the context of the C64, What is the purpose of the memory location at address $B86A?","address         $B86A          FADDT
Perform BASIC's Addition Operation

This routine adds the contents of FAC1 and FAC2 and stores the results
in FAC1."
"In the context of the C64, What is the purpose of the memory location at address $DC0A?","address              $DC0A          TODMIN
Time of Day Clock Minutes

Bits 0-3:  Second digit of Time of Day minutes (BCD)
Bits 4-6:  First digit of Time of Day minutes (BCD)
Bit 7:  Unused"
"In the context of the C64, What is the purpose of the memory location at address $B465?","address         $B465          STRD
Perform STR$

STR$ first checks to make sure that the parameter is a number, and
then calls the routines that convert floating point to ASCII and crate
the pointers to a string constant."
"In the context of the C64, What is the purpose of the memory location at address $B761?","address         $B761          PREAM
Pull String Function Parameters from Stack for LEFT$, RIGHT$, and MID$

This routine is used to obtain the first two parameters for all three
of these commands."
"In the context of the C64, What is the purpose of the memory location at address $DD00-$DD0F?","address        $DD00-$DD0F
Complex Interface Adapter (CIA) #2 Registers

Locations 56576-56591 ($DD00-$DD0F) are used to address the Complex
Interface Adapter chip #2 (CIA #2).  Since the chip itself is
identical to CIA #1, which is addressed at 56320 ($DC00), the
discussion here will be limited to the use which the 64 makes of this
particular chip.  For more general information on the chip registers,
please see the corresponding entries for CIA #1.

One of the significant differences between CIA chips #1 and #1 is the
use to which Data Ports A and B are put.  The peripheral input and
output devices that CIA #2 controls are those on the Serial Bus (such
as the 1541 Disk Drive and 1525 printer), the RS-232 device (which is
used for telecommunications), and the User Port, an eight-bit parallel
port that can be turned to whatever purpose the user desires.  In
addition, Data Port A has the important task of selecting the 16K bank
ofmemory that will be used by the VIC-II chip for graphics.

Another significant difference between CIA chips #1 and #2 is that the
interrupt line of CIA #1 is wired to the 6510 IRQ line, while that of
CIA #2 is wired to the NMI line.  This means that interrupts from this
chip cannot be masked by setting the Interrupt disable flag (SEI).
They can be disabled from CIA's Mask Register, though.  Be sure to use
the NMI vector when setting up routines to be driven by interrupts
generated by this chip.

Location Range: 56576-56577 ($DD00-$DD01)
CIA #2 Data Ports A and B

These registers are where the communication with the Serial Bus,
RS-232 device, and User Port take place.  The Serial Bus is like the
IEEE bus which is used by the PET, in that it allows more than one
device to be connected to the port at a time, in a daisychain
arrangement.  Since each byte of data is sent one bit at a time,
however, the Serial Bus is at least eight times slower than the IEEE.
It is presently used to control the 1541 Disk Drive and 1525 printer,
and other devices (such as printer interface for Centronics- type
parallel pritners and stringy floppy wafer tape storage units) can be
placed on this bus.

Data Port A is used for communication with the Serial Bus.  Bits 5 and
7 are used for Serial Bus Data Output and Input, respectively, and
Bits 4 and 6 are used for the Serial Bus Clock Pulse Output and Input.
Bit 3 of Data Port A is used to send the ATN signal on the Serial Bus.

The 64 has built-in software to handle RS-232 communications through a
modem or other device plugged in the RS-232/User Port.  The RS-232
device uses Bit 2 of Data Port A for data output (it is the only line
from Port A that is connected to the RS-232/User Port jack).  It also
makes heavy use of Port B, using Bit 7 for the Data Set Ready (DSR)
signal, Bit 6 for the Clear to Send (CTS), Bit 4 for the Carrier
Detect (DCD), Bit 3 for the Ring Indicator (RI), Bit 2 for Data
Terminal Ready (DTR), Bit 1 for Request to Send (RTS), and Bit 0 for
data input.  See locations 659-660 ($293-$294) for more details on the
RS-232 device.

All of the data lines which the RS-232 device uses are also available
to the user as part of the User Port.  All of the Port B data lines,
and Bit 2 of Port A, are brought out to the User Port connector on the
back of the 64.  These data bits are utilized in the normal way:  The
port connections are made to TTL-level input or output devices, and
the direction of data is determined by the Data Direction Registers.

In addition, the User Port has pins connected to the two CIA Serial
Ports (whose eight-bit shift registers are well-suited for
serial-to-parallel and parallel-to-serial conversion),and the two CNT
lines which aid in the operation of the Serial Ports.  The CNT lines
can also be used in conjunction with the CIA Timers, and allow them to
be used as frequency counters, event counters, interval timers, etc.
The advanced features of the CIA chip make almost any type of
interfacing application possible, and in the near future we will
probably see many interesting applications for the User Port on the
64.  A pin description of tthe User Port connector is provided below:

User         RS-232
Port  CIA    DB-25
Pin   Line   Pin     Description

1                    Ground
2                    +5 Volts (100 milliamps maximum)
3                    RESET (grounding this pin causes a cold start)
4     CNT1           CIA #1 Serial Port and Timer Counter
5     SP1            CIA #1 Serial Data Port
6     CNT2           CIA #2 Serial Port and Timer Counter
7     SP2            CIA #2 Serial Data Port
8     PC2            CIA #2 handshaking line
9                    Connected to the ATN line of the Serial Bus
10                   9 Volts AC (+ phase, 50 milliamps maximum)
11                   9 volts AC (- phase, 50 milliamps maximum)
12                   Ground
A            1       Ground
B     FLAG2          CIA #2 handshaking line
C     PB0    3       Port B Bit 0--RS-232 Received Data (SIN)
D     PB1    4       Port B Bit 1--RS-232 Request to Send (RTS)
E     PB2    20      Port B Bit 2--RS-232 Data Terminal Ready (DTR)
F     PB3    22      Port B Bit 3--RS-232 Ring Indicator (RI)
H     PB4    8       Port B Bit 4--RS-232 Carrier Detect (DCD)
J     PB5            Port B Bit 5
K     PB6    5       Port B Bit 6--RS-232 Clear to Send (CTS)
L     PB7    6       Port B Bit 7--RS-232 Data Set Ready (DSR)
M     PA2    2       Port A Bit 2--RS-232 Transmitted Data (Sout)
N            7       Ground

One of the handshaking lines on the above chart, PC2, was not covered
in the discussion of CIA #1, because that line of CIA #1 is not
connected to anything.  The CIA #2 PC line is accessible from the User
Port, however.  This line will go low for one cycle following a read
or write of Port B on CIA #2.  This signal lets external devices know
when data has been read or written.

Bits 0 and 1 of CIA #2 Port A have an extremely important function.
As mentioned in the section on the VIC-II chip (53248, $D000), the
video chip can address only 16K of memory at a time, and all graphics
data must be stored in that 16K block in order to be displayed.
Within this area, sprite graphics data may be placed in any of 256
groups of 64 bytes each.  Character data can be stored in any of eight
2K blocks.  Text screen memory may be in any of 16 1K areas, and
bitmap screen memory may be in either of two 8K sections.

When you turn the power on, the VIC-II uses the bottom 16K of memory
for graphics.  Unfortunately, this block of memory is also used
extensively for other important purposes.  Though some means of
eliminating these conflicts are discussed above, in many situations
you will want to change from the default 16K bank at the low end of
memory.

Bits 0 and 1 select the current 16K bank for video memory from the
four possible choices using the following bit patterns:

00 (bit value of 0) Bank 3 (49152-65535, $C000-$FFFF)
01 (bit value of 1) Bank 2 (32768-49151, $8000-$BFFF)
10 (bit value of 2) Bank 1 (16384-32767, $4000-$7FFF)
11 (bit value of 3) Bank 0 (0-16383, $0-$3FFF)

The technique for making this change from BASIC is discussed below.
But before we go ahead and start changing banks, let's briefly review
the contents of these areas, and the considerations for using them for
graphics.

Block 0.  This is normally used for system variables and BASIC program
text.  Locations 1024-2047 ($400-$7FF) are reserved for the default
position of screen memory.

There is an addition limitation on memory usage of this block, as the
VIC-II sees the character generator ROM at 4096-8191 ($1000-$1FFF),
making this portion of memory unavailable for other graphics data.
Generally, there is little free space here for graphics display data.
Locations 679-767 ($2A7- $2FF) are unused, and could hold one sprite
shape (number 11) or data for 11 characters.  The area from 820-1023
($334-$3FF), which includes the cassette I/O buffer, is available for
graphics memory, and is large enough to hold three sprite shapes
(numbers 13, 14, and 15), or data for 25 characters (numbers 103-127).
But getting enough memory for bitmap graphics requires that you either
reserve memory after the end of BASIC text by lowering the end of
BASIC pointer at 56 ($38), or raise the start of BASIC pointer at 44
($2C).  See the entries for these pointers for more details.

Block 1.  Block 1 is normally used for BASIC program storage.  When
using this bank, the VIC-II does not have access to the character
generator ROM.  Providing that you lower the top of memory so that
BASIC programs do not interfere, this area is wide open for sprite
shapes, character graphics, and bitmap graphics.

The drawbacks to useing this bank are the unavailability of the
character ROM and the limitation on BASIC program space (as little as
14K).  The absence of the character ROM is a relatively minor
nuisance, because you can always switch in the ROM and copy any or all
of the characters to RAM (see the entries for location 1 and the
alternate entry for 53248 ($D000), the Character ROM, for details).
This block may be a good alternate choice to avoid potential conflicts
with other applications that use higher memory.

Block 2.  The third block (Block 2) consists of 8K of RAM, half of
which is seen by the VIC-II chip as character ROM, and the 8K BASIC
interpreter ROM.  The BASIC ROM area is available for graphics.  This
is possible because of the 64's special addressing.  The VIC-II chip
reads only from RAM, and thus sees the RAM underneath the BASIC ROM,
even if the 6510 has ROM switched in.  The 6510, on the other hand,
always writes to RAM, even when dealing with memory it reads as ROM.
Whatever is written to the RAM underlying the BASIC ROM is displayed
normally by the VIC-II chip.  This opens up an extra 8K are for
sprites and character data under the BASIC ROM.

You should keep in mind that while you can write to this area, you
cannot read it from BASIC.  This may not be a serious problem when it
comes to character sets and sprite data, but it's more of a drawback
if you want to use this RAM for screen memory.

For example, the Operating System has to read the text screen to move
the cursor properly, and if it reads the ROM value instead of the RAM
screen data, it gets hopelessly confused, making it impossible to type
in any commands.

Likewise, you would not be able to read the high-resolution screen if
it were placed here, without some machine language trickery.  With
locations 36863-40959 ousted by the character ROM, only 4K of true RAM
remains for use as screen memory, not enough for a complete
high-resolution screen.  Therefore, this block is not recommended for
use in bitmap mode if your program needs to check the screen.
Otherwise, this is a good place for graphics memory, particularly if
you need to emulate the screen configuration of the PET.

Block 3.  Normally Block 3 contains 4K of RAM that is completely
unused by the system, 4K if I/O registers, and the 8K Operating System
Kernal ROM.  It is very convenient to use when you need a lot of
memory space for both graphics and a BASIC program.  Although the
character ROM is not available, it can be copied to RAM.  The area
under the Kernal ROM can be used as explained above.  One possible
conflict that you should be aware of is that the current version of
the DOS support program is written to reside at 52224 ($CC00).  It
would be safest to avoid using 52224-53247 for graphics if you plan to
use DOS support.

Changing banks.  Once you have selected a bank of 16K to use, the
procedure for making the change from BASIC is as follows:

1.  Set the Data Direction Register if necessary.  In order to use
Bits 0 and 1 of Port A to change banks, these bits must be set as
outputs in Data Direction Register A.  Since this is the default
condition on powering-up, this step normally will not be needed.

2.  Select a bank.  Banks 0-3 can be chosen by entering the following
lines:

POKE 56578,PEEK(56578) OR 3: REM SET FOR OUTPUT IF NOT ALREADY
POKE 56576,(PEEK(56576) AND 252) OR (3-BANK): REM BANK IS BANK #, MUST
  BE 0-3

3.  Set the VIC-II register for character memory.  As explained at the
entry for location 53272 ($D018), the formula for this is:

POKE 53272,(PEEK(53272) AND 240) OR TK: REM TK IS 2 KBYTE OFFSET FROM
  BEGINNING OF BLOCK

4.  Set the VIC-II register for display memory.  As explained at the
entry for location 53272 ($D018), the formula for this is:

POKE 53272,(PEEK(53272) AND 15) OR K*16: REM K IS KBYTE OFFSET FROM
  BEGINNING OF BLOCK

Since steps 3 and 4 operate on the same register, you could combine
these steps and just POKE 53272,(16*K+TK).

5.  Set the Operating System pointer for display memory at 648 ($288).
Even though you have just told the VIC-II chip where to display memory
for the screen, the Operating System does not yet know where to write
its text characters.  Let it know with this statement:

POKE 648,AD/256: REM AD IS THE ACTUAL ADDRESS OF SCREEN MEMORY

After you make this change, you must watch out for the STOP/RESTORE
key combination.  The BRK initialization changes the screen display
default to location 1024 in Bank 0, but not the Operating System
pointer at 648 ($288).  As a result, what you are typing will not be
displayed on the screen.  The computer will lock up until you turn the
power off and back on again.  The simplest way to avoid this problem
is to disable the RESTORE key entirely (see the entries for 792 ($318)
and 808 ($328) for more information).

Below is a sample program which switches to Bank 3.  It includes a
machine language transfer routine to move the ROM character set to
RAM, and a short interrupt routine to correct the RESTORE key problem.
After the switch is made, a loop isused to POKE characters into the
new screen memory area.  Next, the character data is slowly erased, to
show that the character set is now in RAM.  Then, a loop is used to
read the locations of the character set, and write to the same
locations.  This demonstrates that the 6510 reads the Kernal ROM when
you PEEK those locations, but POKEs to the RAM which is being
displayed.  Finally, the machine language move is used again to show
how quickly the set is restored.

20 FOR I=1 TO 33:READ A:POKE 49152+I,A:NEXT: REM SET UP ML ROUTINE
30 GOSUB 200: REM ML COPY OF ROM CHARACTER SET TO RAM
40 POKE 56576,PEEK(56576) AND 252: REM STEP 1, ENABLE BANK 3
50 POKE 53272,44: REM STEPS 2-3, POINT VIC-II TO SCREEN AND CHARACTER MEMORY
60 REM SCREEN OFFSET IS 2*16, CHARACTER OFFSET IS 12
70 POKE 648,200: REM STEP 4, POINT OS TO SCREEN AT 51200 (200*256)
80 PRINT CHR$(147): REM CLEAR SCREEN
90 FOR I=53236 TO 53245:READ A:POKE I,A:NEXT: REM NEW INTERRUPT ROUTINE
100 POKE 53246,PEEK(792):POKE 53247,PEK(793): REM SAVE OLD NMI VECTOR
110 POKE 792,244:POKE 793,207: REM ROUTE THE INTERRUPT THROUGH THE NEW ROUTINE
120 FOR I=0 TO 255:POKE 51400+I,I:POKE 55496+I,1:NEXT
125 REM POKE CHARACTERS TO SCREEN
130 FOR J=1 TO 8:FOR I=61439+J TO I+2048 STEP 8
140 POKE I,0:NEXT I,J: REM ERASE CHARACTER SET
150 FOR I=61440 TO I+2048:POKE I,PEEK(I):NEXT: REM POKE ROM TO RAM
160 GOSUB 200:END: REM RESTORE CHARACTER SET
200 POKE 56334,PEEK(56334) AND 254: REM DISABLE INTERRUPTS
210 POKE 1,PEEK(1) AND 251:REM SWITCH CHARACTER ROM INTO 6510 MEMORY
220 SYS 49152: REM COPY ROM CHARACTER SET TO RAM AT 61440
230 POKE 1,PEEK(1) OR 4: REM SWITCH CHARACTER ROM OUT OF 6510 MEMORY
240 POKE 56334,PEEK(56334)OR 1: REM ENABLE INTERRUPTS
250 RETURN
300 REM DATA FOR ML PROGRAM TO COPY CHARACTER SET TO RAM
310 DATA169,0,133,251,133,253,169,208,133,252,169,240,133,254,162,16
320 DATA160,0,177,251,145,253,136,208,249,230,252,230,254,202,208,240,96
330 REM NEXT IS ML PROGRAM TO MAKE THE RESTORE KEY RESET OS POINTER TO SCREEN
340 DATA 72,169,4,141,136,02,104,108,254,207

See also the sample program showing how to configure your 64 like a
PET at location 43 ($2B)."
"In the context of the C64, What is the purpose of the memory location at address $12?","address           $12            TANSGN
Flag: Sign of the Result of the TAN or SIN Function

This location is used to determine whether the sign of the value
returned by the functions SIN or TAN is positive or negative.

Additionally, the string and numeric comparison routines use this
location to indicate the outcome of the comparison.  For a comparison
of variable A to variable B, the value here will be 1 if A is greater
than B, 2 if A equals B, and 4 if a is less than B.  If more than one
comparison operator was used to compare the two variables (e.g., >= or
<=), the value here will be a combination of the above values."
"In the context of the C64, What is the purpose of the memory location at address $FD1A?","address              $FD1A          VECTOR
Set the RAM Vector Table from the Table Pointed to by .X and .Y

This documented Kernal routine can be entered through the jump table
at 65421 ($FF8D).

It is used to read or change the values for the 16 RAM vectors to the
interrupt and important Kernal I/O routines in the table that starts
at 788 ($314).  If the Carry flag is set when the routine is called,
the current value of the 16 vectors will be stored at a table whose
address is pointed to by the values in the .X and .Y registers.  If
the Carry flag is cleared, the RAM vectors will be loaded from the
table whose address is pointed to by the .X and .Y registers.  Since
this routine can change the vectors for the IRQ and NMI interrupts,
you might expect that the Interrupt disable flag would be set at its
beginning.  Such is not the case, however, and therefore it would be
wise to execute an SEI before calling it and a CLI afterwards (as the
power-on RESET routine does) just to be safe.

64"
"In the context of the C64, What is the purpose of the memory location at address $C1-$C2?","address       $C1-$C2        STAL
I/O Start Address

This location points to the beginning address of the area in RAM which
is currently being LOADed or SAVEd.  For tape I/O, it will point to
the cassette buffer, and the rest of the data is LOADed or SAVEd
directly to or from RAM.  This location points to the beginning
address of the area of RAM to be used for the blocks of data that come
after the initial header."
"In the context of the C64, What is the purpose of the memory location at address $FE00?","address              $FE00          SETLFS
Set Logical File Number, Device Number, and Secondary Address

This is a documented Kernal routine, which can be entered through the
jump table at location 65466 ($FFBA).

It stores the value in the Accumulator in the location which holds the
current logical file number, the value in the .X register is put in
the location that holds the current device number, and the value in
the .Y register is stored in the location that holds the current
secondary address.  If no secondary address is used, the .Y register
should be set to 255 ($FF).  It is necessary to set the values of the
current file number, device number, and secondary address before you
OPEN a file, or LOAD or SAVE."
"In the context of the C64, What is the purpose of the memory location at address $FE43?","address              $FE43
NMI Interrupt Entry Point

This routine is the NMI interrupt handler entry, which is pointed to
by the hardware NMI vector at 65530 ($FFFA).

Any time an NMI interrupt occurs, the Interrupt disable flag will be
set, and the routine will jump through the RAM vector at 792 ($318),
which ordinarily points to the continuation of this routine.  The
standard handler first checks to see if the NMI was caused by the
RS-232 device.  If not, the RESTORE key is assumed.  The routine
checks for a cartridge, and if one is found it exits through the
cartridge warm start vector at 32770 ($8002).  If not, the STOP key is
checked, and if it is being pressed, the BRK routine is executed.  If
the RS-232 device was the cause of the NMI, the cartridge and STOP key
checks are bypassed, and the routine skips to the end, where it checks
whether it is time to send or receive a data bit via the RS-232
device."
"In the context of the C64, What is the purpose of the memory location at address $D4?","address          $D4            QTSW
Flag: Editor in Quote Mode? 0=No

A nonzero value in this location indicates that the editor is in quote
mode.  Quote mode is toggled every time that you type in a quotation
mark on a given line--the first quote mark turns it on, the second
turns it off, the third turns it back on, etc.

If the editor is in this mode when a cursor control character or other
nonprinting character is entered, a printed equivalent will appear on
the screen instead of the cursor movement or other control operation
taking place.  Instead, that action is deferred until the string is
sent to the string by a PRINT statement, at which time the cursor
movement or other control operation will take place.

The exception to this rule is the DELETE key, which will function
normally within quote mode.  The only way to print a character which
is equivalent to the DELETE key is by entering insert mode (see
loctaion 216 ($D8)).  Quote mode may be exited by printing a closing
quote, or by hitting the RETURN or SHIFT-RETURN keys.

Sometimes, it would be handy to be able to escape from quote mode or
insert mode without skipping to a new line.  The machine language
program below hooks into the keyscan interrupt routine, and allows you
to escape quote mode by changing this flag to 0 when you press the f1
key:

10 FOR I=850 TO I+41:READ A:POKE I,A:NEXT
20 PRINTCHR$(147)'PRESS F1 KEY TO ESCAPE QUOTE MODE'
30 PRINT'TO RESTART AFTER RESTORE ONLY, SYS 850':SYS850:NEW
40 DATA  173 , 143 , 2 , 141 , 46 , 3 , 173 , 144 , 2 , 141
50 DATA 47 , 3 , 120 , 169 , 107 , 141 , 143 , 2 , 169 , 3
60 DATA 141 , 144 , 2 , 88 , 96 , 165 , 203 , 201 , 4 , 208
70 DATA 8 , 169 , 0 , 133 , 212 , 133 , 216 , 133 , 199 , 108 , 46 , 3"
"In the context of the C64, What is the purpose of the memory location at address $A906?","address        $A906          DATAN
Search Program Text for the End of the Current BASIC Statement

This routine starts at the current byte of program text and searches
until it finds a zero character (line delimiter) or a colon character
that is not in quotes (statement delimiter)."
"In the context of the C64, What is the purpose of the memory location at address $E2E5?","address              $E2E5          TWOPI
The Five-Byte Floating Point Representation of the Constant 2*PI"
"In the context of the C64, What is the purpose of the memory location at address $AF2B?","address         $AF2B          ISVAR
Get the Value of a Variable"
"In the context of the C64, What is the purpose of the memory location at address $ABA5?","address        $ABA5          INPUTN
Perform INPUT#

This routine opens an input channel with the Kernal CHKIN routine,
calls INPUT, and then closes the channel with a CHKOUT routine (62032,
$F250).  Extra data is discarded without an EXTRA IGNORED message, and
a FILE DATA ERROR message is issued when the data type is not suitable
for the type of variable used."
"In the context of the C64, What is the purpose of the memory location at address $E20E?","address              $E20E
Check for Comma

This subroutine checks for a comma, moves the text pointer past it if
found, and returns an error if it is not found."
"In the context of the C64, What is the purpose of the memory location at address $AFE6?","address         $AFE6          OROP
Perform OR

The OR routine sets the .Y register as a flag, and falls through to
the AND routine, which also performs OR."
"In the context of the C64, What is the purpose of the memory location at address $E2B4?","address              $E2B4          TAN
Perform TAN

This routine evaluates the tangent of the number in FAC1 (which
represents the angle in radians) by dividing its sine by its cosine.

Location Range: 58080-58125 ($E2E0-$E30D)
Table of Constants for Evaluation of SIN, COS, and TAN"
"In the context of the C64, What is the purpose of the memory location at address $E200?","address              $E200
Skip Comma and Get Integer in .X

This subroutine is used to skip the comma between parameters and get
the following integer value in the .X register."
"In the context of the C64, What is the purpose of the memory location at address $AC06?","address         $AC06          READ
Perform READ

This routine includes the READ command and common code for GET and
INPUT.  The READ command locates the next piece of DATA, reads the
text, and converts it to the appropriate type of data to be assigned
to a numeric or string variable."
"In the context of the C64, What is the purpose of the memory location at address $E56C?","address              $E56C
Set Pointer to Current Screen Line

This routine sets the pointer PNT (209, $D1) to the address of the
first byte of the current logical line.  In figuring this address, it
takes into account the status of the screen line link table, which can
indicate that two physical lines should be joined as one logical line."
"In the context of the C64, What is the purpose of the memory location at address $B1D1?","address         $B1D1          ISARY
Find Array Element or Create New Array in RAM

This routine searches for an array.  If it is found, the subscript
value is checked to see if it is valid, and pointers to the array and
element of the array are set.  If it is not found, the array is
created, and the pointers set."
"In the context of the C64, What is the purpose of the memory location at address $FE18?","address              $FE18          SETMSG
Set the Message Control Flag

This documented Kernal routine can be entered through its jump table
vector at 65424 ($FF90).

The routine controls the printing of error messages and control
messages by the Kernal.  It Bit 6 is seto to 1 (bit value of 64),
Kernal control messages can be printed.  These messages include
SEARCHING FOR, LOADING, and the like.  If Bit 6 is cleared to 0, these
messages will not be printed (BASIC will clear this bit when a program
is running so that the messages do not appear when I/O is performed
from a program).  Setting Bit 6 will not suppress the PRESS PLAY ON
TAPE or PRESS PLAY & RECORD messages, however.

If Bit 7 is set to 1 (bit value of 128), Kernal error messages can be
printed.  If Bit 7 is set to 0, those error messages (for example, I/O
ERROR #nn) will be suppressed.  Note that BASIC has its own set of
error messages (such as FILE NOT FOUND ERROR) which it uses in
preference to the Kernal's message."
"In the context of the C64, What is the purpose of the memory location at address $BF?","address           $BF            MYCH
Tape Input Byte Buffer

This is used by the tape routines as a work area in which incoming
characters area assembled."
"In the context of the C64, What is the purpose of the memory location at address $D1-$D2?","address       $D1-$D2        PNT
Pointer to the Address of the Current Screen Line

This location points to the address in screen RAM of the first column
of the logical line upon which the cursor is currently positioned."
"In the context of the C64, What is the purpose of the memory location at address $FE72?","address              $FE72
NMI RS-232 Handler

This is the part of the NMI handler that checks if it is time to
receive or send a bit on the RS-232 channel, and takes the appropriate
action if it is indeed the time."
"In the context of the C64, What is the purpose of the memory location at address $100-$1FF?","address       $100-$1FF
Microprocessor Stack Area

Locations 256-511 are reserved for the 6510 microprocessor hardware
stack.  The organization of this temporary storage area has often been
compared to that of a push-down stack of trays at a cafeteria.  The
first number placed on the stack goes to the bottom, and subsequent
entries are placed on top of it.  Then you pull a number off the
stack, you come up with the last number that was pushed on (such a
stack is called a Last In, First Out, or LIFO stack).

The stack is controlled by one of the microprocessor registers called
the Stack Pointer, which keeps track of the last stack location used.
The first number placed on the stack goes to location 511 ($1FF), and
subsequent entries are built downward toward 256 ($100).  If more than
256 numbers are pushed onto the stack, the Stack Pointer will start
counting from 0 again, and an overflow error will result.  Likewise,
if you try to pull more items off the stack than have been pushed on,
an underflow error will result.  Most often, such errors will cause
the system to go haywire, and nothing will operate until you turn the
power off and on again.

The stack is used by the system to keep track of the return addresses
of machine language subroutines and interrupt calls and to save the
contents of internal registers.  The stack can also be used by the
programmer for temporary storage.  BASIC and the Kernal make heavy use
of the stack.

Microsoft BASIC uses part of the stack for a temporary work area.
Therefore, the stack may be broken down into the following subregions:"
"In the context of the C64, What is the purpose of the memory location at address $35-$36?","address         $35-$36        FRESPC
Temporary Pointer for Strings

This is used as a temporary pointer to the most current string added
by the routines which build strings or move them in memory."
"In the context of the C64, What is the purpose of the memory location at address $10?","address            $10            SUBFLG
Flag: Subscript Reference to an Array or User-Defined Function Call (FN)

This flag is used by the PTRGET routine which finds or creates a
variable, at the time it checks whether the name of a variable is
valid.  If an opening parenthesis is found, this flag is set to
indicate that the variable in question is either an array variable or
a user-defined function.

You should note that it is perfectly legal for a user-defined function
(FN) to have the same name as a floating point variable.  Moreover, it
is also legal to redefine a function.  Using a FN name in an already
defined function results in the new definition of the function."
"In the context of the C64, What is the purpose of the memory location at address $B4F4?","address         $B4F4          GETSPA
Allocate Space in Memory for String

The amount of space needed for a string is passed to this routine, and
the routine checks if there is that amount of space available in free
memory.  If not, it does a garbage collection and tries again."
"In the context of the C64, What is the purpose of the memory location at address $DC08?","address              $DC08          TODTEN
Time of Day Clock Tenths of Seconds

Bits 0-3:  Time of Day tenths of second digit (BCD)
Bits 4-7:  Unused"
"In the context of the C64, What is the purpose of the memory location at address $DC0E?","address              $DC0E          CIACRA
Control Register A

Bit 0:  Start Timer A (1=start, 0=stop)
Bit 1:  Select Timer A output on Port B (1=Timer A output appears on Bit 6 of
        Port B)
Bit 2:  Port B output mode (1=toggle Bit 6, 0=pulse Bit 6 for one cycle)
Bit 3:  Timer A run mode (1=one-shot, 0=continuous)
Bit 4:  Force latched value to be loaded to Timer A counter (1=force load
        strobe)
Bit 5:  Timer A input mode (1=count microprocessor cycles, 0=count signals on
        CNT line at pin 4 of User Port)
Bit 6:  Serial Port (56332, $DC0C) mode (1=output, 0=input)
Bit 7:  Time of Day Clock frequency (1=50 Hz required on TOD pin, 0=60 Hz)

Bits 0-3.  This nybble controls Timer A.  Bit 0 is set to 1 to start
the timer counting down, and set to 0 to stop it.  Bit 3 sets the
timer for one-shot or continuous mode.

In one-shot mode, the timer counts down to 0, sets the counter value
back to the latch value, and then sets Bit 0 back to 0 to stop the
timer.  In continuous mode, it reloads the latch value and starts all
over again.

Bits 1 and 2 allow you to send a signal on Bit 6 of Data Port B when
the timer counts.  Setting Bit 1 to 1 forces this output (which
overrides the Data Direction Register B Bit 6, and the normal Data
Port B value).  Bit 2 allows you to choose the form this output to Bit
6 of Data Port B will take.  Setting Bit 2 to a value of 1 will cause
Bit 6 to toggle to the opposite value when the timer runs down (a
value of 1 will change to 0, and a value of 0 will change to 1).
Setting Bit 2 to a value of 0 will cause a single pulse of a one
machine-cycle duration (about a millionth of a second) to occur.

Bit 4.  This bit is used to load the Timer A counter with the value
that was previously written to the Timer Low and High Byte Registers.
Writing a 1 to this bit will force the load (although there is no data
stored here, and the bit has no significance on a read).

Bit 5.  Bit 5 is used to control just what it is Timer A is counting.
If this bit is set to 1, it counts the microprocessor machine cycles
(which occur at the rate of 1,022,730 cycles per second).  If the bit
is set to 0, the timer counts pulses on the CNT line, which is
connected to pin 4 of the User Port.  This allows you to use the CIA
as a frequency counter or an event counter, or to measure pulse width
or delay times of external signals.

Bit 6.  Whether the Serial Port Register is currently inputting or
outputting data (see the entry for that register at 56332 ($DC0C) for
more information) is controlled by this bit.

Bit 7.  This bit allows you to select from software whether the Time
of Day Clock will use a 50 Hz or 60 Hz signal on the TOD pin in order
to keep accurate time (the 64 uses a 60 Hz signal on that pin)."
"In the context of the C64, What is the purpose of the memory location at address $B78B?","address         $B78B          ASC
Perform ASC

This routine gets the first character of the string in the .Y register
(if it's not a null string).  Then it calls the part of POS that
converts a one- byte integer in .Y to a floating point number."
"In the context of the C64, What is the purpose of the memory location at address $DC02?","address              $DC02          CIDDRA
Data Direction Register A

Bit 0:  Select Bit 0 of Data Port A for input or output (0=input, 1=output)
Bit 1:  Select Bit 1 of Data Port A for input or output (0=input, 1=output)
Bit 2:  Select Bit 2 of Data Port A for input or output (0=input, 1=output)
Bit 3:  Select Bit 3 of Data Port A for input or output (0=input, 1=output)
Bit 4:  Select Bit 4 of Data Port A for input or output (0=input, 1=output)
Bit 5:  Select Bit 5 of Data Port A for input or output (0=input, 1=output)
Bit 6:  Select Bit 6 of Data Port A for input or output (0=input, 1=output)
Bit 7:  Select Bit 7 of Data Port A for input or output (0=input, 1=output)"
"In the context of the C64, What is the purpose of the memory location at address $DC03?","address              $DC03          CIDDRB
Data Direction Register B

Bit 0:  Select Bit 0 of Data Port B for input or output (0=input, 1=output)
Bit 1:  Select Bit 1 of Data Port B for input or output (0=input, 1=output)
Bit 2:  Select Bit 2 of Data Port B for input or output (0=input, 1=output)
Bit 3:  Select Bit 3 of Data Port B for input or output (0=input, 1=output)
Bit 4:  Select Bit 4 of Data Port B for input or output (0=input, 1=output)
Bit 5:  Select Bit 5 of Data Port B for input or output (0=input, 1=output)
Bit 6:  Select Bit 6 of Data Port B for input or output (0=input, 1=output)
Bit 7:  Select Bit 7 of Data Port B for input or output (0=input, 1=output)

Location Range: 56324-56327 ($DC04-$DC07)
Timers A and B Low and High Bytes

These four timer registers (two for each timer) have different
functions depending on whether you are reading from them or writing to
them.  When you read from these registers, you get the present value
of the Timer Counter (which counts down from its initial value to 0).
When you write data to these registers, it is stored in the Timer
Latch, and from there it can be used to load the Timer Counter using
the Force Load bit of Control Register A or B (see 56334-5 ($DC0E-F)
below).

These interval timers can hold a 16-bit number from 0 to 65535, in
normal 6510 low-byte, high-byte format (VALUE=LOW BYTE+256*HIGH BYTE).
Once the Timer Counter is set to an initial value, and the timer is
started, the timer will count down one number every microprocessor
clock cycle.  Since the clock speed of the 64 (using the American NTSC
television standard) is 1,022,730 cycles per second, every count takes
approximately a millionth of a second.  The formula for calculating
the amount of time it will take for the timer to count down from its
latch value to 0 is:

TIME=LATCH VALUE/CLOCK SPEED

where LATCH VALUE is the value written to the low and high timer
registers (LATCH VALUE=TIMER LOW+256*TIMER HIGH), and CLOCK SPEED is
1,022,370 cycles per second for American (NTSC) standard television
monitors, or 985,250 for European (PAL) monitors.

When Timer Counter A or B gets to 0, it will set Bit 0 or 1 in the
Interrupt Control Register at 56333 ($DC0D).  If the timer interrupt
has been enabled (see 56333 ($DC0D)), an IRQ will take place, and the
high bit of the Interrupt Control Register will be set to 1.
Alternately, if the Port B output bit is set, the timer will write
data to Bit 6 or 7 of Port B.  After the timer gets to 0, it will
reload the Timer Latch Value, and either stop or count down again,
depending on whether it is in one-shot or continuous mode (determined
by Bit 3 of the Control Register).

Although usually a timer will be used to count the microprocessor
cycles, Timer A can count either the microprocessor clock cycles or
external pulses on the CTN line, which is connected to pin 4 of the
User Port.

Timer B is even more versatile.  In addition to these two sources,
Timer B can count the number of times that Timer A goes to 0.  By
setting Timer A to count the microprocessor clock, and setting Timer B
to count the number of times that Timer A zeros, you effectively link
the two timers into one 32-bit timer that can count up to 70 minutes
with accuracy within 1/15 second.

In the 64, CIA #1 Timer A is used to generate the interrupt which
drives the routine for reading the keyboard and updating the software
clock.  Both Timers A and B are also used for the timing of the
routines that read and write tape data.  Normally, Timer A is set for
continuous operation, and latched with a value of 149 in the low byte
and 66 in the high byte, for a total Latch Value of 17045.  This means
that it is set to count to 0 every 17045/1022730 seconds, or
approximately 1/60 second.

For tape reads and writes, the tape routines take over the IRQ
vectors.  Even though the tape write routines use the on-chip I/O port
at location 1 for the actual data output to the cassette, reading and
writing to the cassette uses both CIA #1 Timer A and Timer B for
timing the I/O routines."
"In the context of the C64, What is the purpose of the memory location at address $DC0F?","address              $DC0F          CIACRB
Control Register B

Bit 0:  Start Timer B (1=start, 0=stop)
Bit 1:  Select Timer B output on Port B (1=Timer B output appears on
        Bit 7 of Port B)
Bit 2:  Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one
        cycle)
Bit 3:  Timer B run mode (1=one-shot, 0=continuous)
Bit 4:  Force latched value to be loaded to Timer B counter (1=force
        load strobe)
Bits 5-6:  Timer B input mode
           00 = Timer B counts microprocessor cycles
           01 = Count signals on CNT line at pin 4 of User Port
           10 = Count each time that Timer A counts down to 0
           11 = Count Timer A 0's when CNT pulses are also present
Bit 7:  Select Time of Day write (0=writing to TOD registers sets
        alarm, 1=writing to TOD registers sets clock)

Bits 0-3.  This nybble performs the same functions for Timer B that
Bits 0-3 of Control Register A perform for Timer A, except that Timer
B output on Data Port B appears at Bit 7, and not Bit 6.

Bits 5 and 6.  These two bits are used to select what Timer B counts.
If both bits are set to 0, Timer B counts the microprocessor machine
cycles (which occur at the rate of 1,022,730 cycles per second).  If
Bit 6 is set to 0 and Bit 5 is set to 1, Timer B counts pulses on the
CNT line, which is connected to pin 4 of the User Port.  If Bit 6 is
set to 1 and Bit 5 is set to 0, Timer B counts Timer A underflow
pulses, which is to say that it counts the number of times that Timer
A counts down to 0.  This is used to link the two numbers into one
32-bit timer that can count up to 70 minutes with accuracy to within
1/15 second.  Finally, if both bits are set to 1, Timer B counts the
number of times that Timer A counts down to 0 and there is a signal on
the CNT line (pin 4 of the User Port).

Bit 7.  Bit 7 controls what happens when you write to the Time of Day
registers.  If this bit is set to 1, writing to the TOD registers sets
the ALARM time.  If this bit is cleared to 0, writing to the TOD
registers sets the TOD clock.

Location Range: 56336-56575 ($DC10-$DCFF)
CIA #1 Register Images

Since the CIA chip requires only enough addressing lines to handle 16
registers, none of the higher bits are decoded when addressing the
256-byte area that has been assigned to it.  The result is that every
16-byte area in this 256-byte block is a mirror of every other.  Even
so, for the sake of clarity in your programs it is advisable to use
the base address of the chip, and not use the higher addresses to
communicate with the chip."
"In the context of the C64, What is the purpose of the memory location at address $B79B?","address         $B79B          GETBYTC
Input a Parameter Whose Value Is Between 0 and 255

This routine reads numeric ASCII program text, converts it to an
integer, checks that it is in the range 0-255, and stores it in the .X
register.  This routine can be useful for reading parameters from a
USR statement or new commands."
"In the context of the C64, What is the purpose of the memory location at address $B526?","address         $B526          GARBAG
String Garbage Collection

Whenever a string is changed in any way, the revised version of the
text is added to the bottom of the string text area, leaving the old
version higher up in memory, wasting space.

In order to reclaim that space, the descriptor for every string whose
text is in the string text area (rather than in the program text area)
must be searched to find the valid text that is highest in memory.  If
that string is not as high as it could be, it is moved up to replace
any string that is no longer valid.  Then all of the string
descriptors must be searched again to find the next highest string and
move it up.  This continues until every string that is un use has been
covered.  After all have been moved up, the pointer to the bottom of
string text at 51-52 ($33-$34) is changed to show the new bottom
location.

If there are more than a few strings whose text is in the string text
storage area, rather than in the body of the program, scanning every
string as many times as there are strings can take an awful lot of
time.  The computer may seem as if it had died (the STOP key is not
even checked during the procedure).

The collection will take about as long whether there is any spare
space or not; the full collection will be done even if it is done
immediately after the last collection.  Although the increased memory
capacity of the 64 helps to forestall the need for garbage collection,
a large program with many string arrays may still experience lengthy
collection delays."
"In the context of the C64, What is the purpose of the memory location at address $DC09?","address              $DC09          TODSEC
Time of Day Clock Seconds

Bits 0-3:  Second digit of Time of Day seconds (BCD)
Bits 4-6:  First digit of Time of Day seconds (BCD)
Bit 7:  Unused"
"In the context of the C64, What is the purpose of the memory location at address $F?","address            $F             GARBFL
Flag for LIST, Garbage Collection, and Program Tokenization

The LIST routine uses this byte as a flag to let it know when it has
come to a character string in quotes.  It will then print the string,
rather than search it for BASIC keyword tokens.

The garbage collection routine uses this location as a flag to
indicate that garbage collection has already been tried before adding
a new string.  If there is still not enough memory, an OUT OF MEMORY
message will result.

This location is also used as a work byte for the process of
converting a line of text in the BASIC input buffer (512, $200) into a
linked program line of BASIC keyword tokens."
"In the context of the C64, What is the purpose of the memory location at address $33-$34?","address        $33-$34        FREETOP
Pointer to the Bottom of the String Text Storage Area

This pointer marks the current end of the string text area, and the
top of free RAM (strings are built from the top of memory downward).
Additional string texts are added, to the area below the address
pointed to here.  After they are added, this pointer is lowered to
point below the newly added string text.  The garbage collection
routine (which is also called by FRE) readjusts this pointer upward.

While the power-on/reset routines set this pointer to the top of RAM,
the CLR command sets this pointer to the end of BASIC memory, as
indicated in location 55 ($37).  This allows the user to set aside an
area of BASIC memory that will not be disturbed by the program, as
detailed at location 55 ($37)."
"In the context of the C64, What is the purpose of the memory location at address $100-$10A?","address       $100-$10A
Work Area for Floating Point to String Conversions

Used in the conversion of numbers to the equivalent ASCII digits, and
in scanning strings."
"In the context of the C64, What is the purpose of the memory location at address $D3?","address          $D3            PNTR
Cursor Column on Current Line

The number contained here is the cursor column position within the
logical line pointed to by 209 ($D1).  Since a logical line can
contain up to two physical lines, this value may be from 0 to 79 (the
number here is the value returned by the POS function)."
"In the context of the C64, What is the purpose of the memory location at address $FEC2?","address              $FEC2
RS-232 Baud Rate Tables for U.S. Television Standard (NTSC)

This table contains the ten prescaler values for the ten standard baud
rates implemented by the RS-232 Control Register at 659 ($293).  The
table starts with the two values needed for the lowest baud rate (50
baud) and finishes with the entries for the highest baud rate, 2400
baud.  The RS-232 routines are handled by NMI interrupts which are
caused by the timers on CIA #2.  Since the RS-232 device could both
receive and send a bit in a single cycle, the time between interrupts
should be a little less than half of the clock frequency divided by
the baud rate.  The exact formula used is:

((CLOCK/BAUD)/2)-100

where CLOCK is the processor clock speed and BAUD is the baud rate.
The clock frequency for machines using the U.S. television standard
(NTSC) is 1,022,730 cycles per second, while the frequency for the
European (PAL) standard is 985,250 cycles per second.  For this
reason, separate baud rate tables were added for European machines at
58604 ($E4EC)."
"In the context of the C64, What is the purpose of the memory location at address $E21?","address              $E21           SETTMO
Set Time-Out Flag for IEEE Bus

This documented Kernal routine can be entered fromthe jump table at
65442 ($FFA2).

The routine sets the time-out flag for the IEEE bus.  When timeouts
are enabled, the Commodore will wait for a device for 64 milliseconds,
and if it does not receive a response to its signal it will issue a
time-out error.  Loading the Accumulator with a value less than 128
and calling this routine will enable time-outs, while using a value
over 128 will disable time-outs.

This routine is for use only with the Commodore IEEE add-on card,
which at the time of this writing was not yet available."
"In the context of the C64, What is the purpose of the memory location at address $C0?","address           $C0            CAS1
Tape Motor Interlock

This location is maintained by the IRQ interrupt routine that scans
the keyboard.  Whenever a button is pressed on the recorder, this
location is checked.  If it contains a 0, the motor is turned on by
setting Bit 5 of location 1 to 0.  When the button is let up, the tape
motor is turned off, and this location is set to 0.

Since the interrupt routine is executed 60 times per second, you will
not be able to keep the motor bit set to keep the motor on if no
buttons are pushed.  Likewise, if you try to turn the motor off when a
button is pressed and this location is set to 0, the interrupt routine
will turn it back on.

To control the motor via software, you must set this location to a
nonzero value after one of the buttons on the recorder has been
pressed."
"In the context of the C64, What is the purpose of the memory location at address $B1BF?","address         $B1BF          AYINT
Convert a Floating Point Number to a Signed Integer

This subroutine first checks to make sure that the number in the
Floating Point Accumulator is between 32767 and -32768.  If it is not,
an ILLEGAL QUANTITY error results.  If it is, the routine converts it
to a 16-bit signed integer with the high byte in location 100 ($64),
and the low byte in location 101 ($65)."
"In the context of the C64, What is the purpose of the memory location at address $E5A0?","address              $E5A0
Set Default I/O Devices and Set Default Values for VIC-II Chip
Registers

This routine sets the keyboard and screen as the current input and
output devices.  It then writes the default values found in the table
at 60601 ($ECB9) to the VIC-II chip."
"In the context of the C64, What is the purpose of the memory location at address $E206?","address              $E206
Fetch Current Character and Check for End of Line

This subroutine gets the current character, and if it is 0 (end of
line), it pulls its own return address off the stack and returns.
This terminates both its own execution and that of the subroutine
which called it."
"In the context of the C64, What is the purpose of the memory location at address $ACFC?","address         $ACFC          EXIGNT
ASCII Text for Input Error Messages

The text stored here is ?EXTRA IGNORED and ?REDO FROM START, each
followed by a carriage return and a zero byte."
"In the context of the C64, What is the purpose of the memory location at address $AFE9?","address         $AFE9          ANDOP
Perform AND

The AND routine changes the parameters to two-byte integer values, and
performs the appropriate logical operation (AND or OR).  A result of 0
signifies false, while a result of -1 signifies true."
"In the context of the C64, What is the purpose of the memory location at address $E2E0?","address              $E2E0          PI2
The Five-Byte Floating Point Representation of the Constant PI/2"
"In the context of the C64, What is the purpose of the memory location at address $E4DA?","address              $E4DA
Clear Color RAM to the Color in Background Color Register 0

This routine is a patch added to the more recent versions of the
Kernal.  It is called by the routine which clears a screen line
(59903, $E9FF), and it places the color value in Background Color
Register 0 (53281, $D021) into the current byte of Color RAM pointed
to by USER (243, $F3).

In the original version of the Kernal, the routine that cleared a
screen line set the corresponding Color RAM to a value of 1, which
gives text characters a white foreground color.  This was changed when
the white color was found to sometimes cause light flashes during
screen scrolling.  It was that white foreground color, however, that
enabled the user to POKE the screen code for a character into screen
RAM, and make that character appear on the screen in a color that
contrasted the blue background.  This change to the Operating System
causes colors POKEd to screen RAM to be the same color as the
background, and thus they are invisible.

This is a fairly serious problem, because the technique of POKEing
characters to screen RAM has long been a staple of Commodore graphics
programming.  Fortunately, the problem has an easy colution.  Since
the Color RAM will be set to whatevere color is in Background Color
Register 0, what you have to do to initialize Color RAM to the color
you desire is change the background color to the desired foreground
color, clear the screen, and then change the background color back
again:

C=PEEK(53281):POKE 53281,HUE:PRINT CHR$(147):POKE 53281,C"
"In the context of the C64, What is the purpose of the memory location at address $E30E?","address              $E30E          ATN
Perform ATN

The arc tangent of the number in FAC1 (which represents the angle in
radians) is evaluated using the 12-term series of operations from the
constant table which follows.  The answer is left in FAC1."
"In the context of the C64, What is the purpose of the memory location at address $AF08?","address         $AF08          SNERR
Print Syntax Error Message"
"In the context of the C64, What is the purpose of the memory location at address $AE83?","address         $AE83          EVAL
Convert a Single Numeric Term from ASCII Text to a Floating Point
Number

This routine reduces a single arithmetic term which is part of an
expression from ASCII text to its floating point equivalent.

If the term is a constant, the routine sets the data type flag to
number, sets the text pointer to the first ASCII numeric character,
and jumps to the routine which converts the ASCII string to a floating
point number.

If the term is a variable, the variable value is retrieved.  If it is
the PI character, the value of PI is moved into the Floating Point
Accumulator.

This routine is vectored through RAM at 778 ($30A)."
"In the context of the C64, What is the purpose of the memory location at address $E1BE?","address              $E1BE          OPEN
Perform OPEN

The BASIC OPEN statement calls the Kernal OPEN routine."
"In the context of the C64, What is the purpose of the memory location at address $B3E1?","address         $B3E1          GETFNM
Check DEF and FN Syntax

This routine checks to make sure that FN follow SEG, and that the
dependent variable has a valid floating point variable name.  It calls
the routine to find or create a variable to get the pointer to its
address."
"In the context of the C64, What is the purpose of the memory location at address $283-284?","address       $283-284       MEMSIZ
Pointer: O.S. End of Memory

When the power is first turned on, or a cold start RESET is performed,
the Kernal routine RAMTAS (64848, $FD50) performs a nondestructive
test of RAM from 1024 ($400) up, stopping when the test fails,
indicating the presence of ROM.  This will normally occur at 40960
($A000), the location of the BASIC ROM.  The top of user RAM pointer
is then set to point to that first ROM location.

After BASIC has been started, the system will alter this location only
when an RS-232 channel (device number 2) is OPENed or CLOSEd.  As 512
bytes of memory are required for the RS-232 transmission and reception
buffers, this pointer, as well as the end of BASIC pointer at 55
($37), is lowered to create room for those buffers when the device is
opened.  CLOSing the device resets these pointers.

The Kernal routine MEMTOP (65061, $FE25) may be used to read or set
this pointer."
"In the context of the C64, What is the purpose of the memory location at address $C7?","address          $C7            RVS
Flag: Print Reverse Characters? 0=No

When the [CTRL][RVS-ON] characters are printer (CHR$(18)), this flag
is set to 18 ($12), and the print routines will add 128 ($80) to the
screen code of each character which is printed, so that the caracter
will appear on the screen with its colors reversed.

POKEing this location directly with a nonzero number will achieve the
same results.  You should remember, however, that the contents of this
location are returned to 0 not only upon entry of a [CTRL][RVS-OFF]
character (CHR$(146)), but also at every carriage return.  When this
happens, characters printed thereafter appear with the normal
comination of colors."
"In the context of the C64, What is the purpose of the memory location at address $FDF9?","address              $FDF9          SETNAM
Set Filename Parameters

This is a documented Kernal routine, which can be entered through the
jump table at location 65469 ($FFBD).

It puts the value in the Accumulator into the location which stores
the number of characters in the filename, and sets the pointer to the
address of the ASCII text of the filename from the .X and .Y
registers.  This sets up the filename for the OPEN, LOAD, or SAVE
routine."
"In the context of the C64, What is the purpose of the memory location at address $FF5B?","address              $FF5B          CINT
Initialize Screen Editor and VIC-II Chip

This is a documented Kernal routine whose entry in the jump table is
located at 65409 ($FF81).

The start of the routine appears to be a patch that was added to later
versions of the Kernal.  It first calls the old routine at 58648
($E518).  This initializes the VIC-II chip to the default values, sets
the keyboard as the input device and the screen as the output device,
initializes the cursor flash variables, builds the screen line link
table, clears the screen, and homes the cursor.  The new code then
checks the VIC Interrupt register to see if the conditions for a
Raster Compare IRQ have been fulfilled.  Since the Raster Register was
initialized to 311, that can only occur when using a PAL system (NTSC
screens do not have that many scan lines).  The PAL/NTSC register at
678 ($2A6) is set on the basis of the outcome of this test.  The CIA
#1 Timer A is then set to cause an IRQ interrupt every sixtieth of a
second, using the prescaler figures for a PAL or NTSC system, as
appropriate."
"In the context of the C64, What is the purpose of the memory location at address $CE?","address           $CE            GDBLN
Character Under Cursor

The cursor is formed by printing the inverse of the character that
occupies the cursor position.  If that characters is the letter A, for
example, the flashing cursor merely alternates between printing an A
and a reverse-A.  This location keeps track of the normal screen code
of the character that is located at the cursor position, so that it
may be restored when the cursor moves on."
"In the context of the C64, What is the purpose of the memory location at address $B?","address           $B             COUNT
Index into the Text Input Buffer/Number of Array Subscripts

The routines that convert the text in the input buffer at 512 ($200)
into lines of executable program tokes, and the routines that link
these program lines together, use this location as an index into the
input buffer area.  When the job of converting text to tokens is
finished, the value in this location is equal to the length of the
tokenized line.

The routines which build an array or locate an element in an array use
this location to calculate the number of DIMensions called for and the
amount of storage required for a newly created array, or the number of
subscripts specified when referencing an array element."
"In the context of the C64, What is the purpose of the memory location at address $47-$48?","address         $47-$48        VARPNT
Pointer to the Current BASIC Variable Value

This location points to the address of the descriptor of the current
BASIC variable (see location 45 ($2D) for the format of a variable
descriptor).  Specifically, it points to the byte just after the
two-character variable name.

During a FN call, this location does not point to the dependent
variable (the A of FN A), so that a real variable of the same name
will not have its value changed by the call."
"In the context of the C64, What is the purpose of the memory location at address $D41A?","address              $D41A          POTY
Read Game Paddle 2 (or 4) Position"
"In the context of the C64, What is the purpose of the memory location at address $DC05?","address              $DC05          TIMAHI
Timer A (high byte)"
"In the context of the C64, What is the purpose of the memory location at address $B67A?","address         $B67A          MOVINS
Move a String in Memory

This is the routine which is used to move a string to the bottom of
the string text area for the above routine.  It is generally used as a
utility routine to move strings."
"In the context of the C64, What is the purpose of the memory location at address $B737?","address         $B737          MIDD
Perform MID$

MID$ manipulates its parameters so that the tail end of LEFT$ can be
used to create a temporary string descriptor for a new string.  This
new string contains the number of characters from the position in the
middle of the string that is specified in the command."
"In the context of the C64, What is the purpose of the memory location at address $DD02?","address              $DD02          C2DDRA
Data Direction Register A

Bit 0:  Select Bit 0 of data Port A for input or output (0=input, 1=output)
Bit 1:  Select Bit 1 of data Port A for input or output (0=input, 1=output)
Bit 2:  Select Bit 2 of data Port A for input or output (0=input, 1=output)
Bit 3:  Select Bit 3 of data Port A for input or output (0=input, 1=output)
Bit 4:  Select Bit 4 of data Port A for input or output (0=input, 1=output)
Bit 5:  Select Bit 5 of data Port A for input or output (0=input, 1=output)
Bit 6:  Select Bit 6 of data Port A for input or output (0=input, 1=output)
Bit 7:  Select Bit 7 of data Port A for input or output (0=input, 1=output)"
"In the context of the C64, What is the purpose of the memory location at address $B72C?","address         $B72C          RIGHTD
Perform RIGHT$

RIGHT$ manipulates its parameters so that the tail end of LEFT$ can be
used to create a temporary string descriptor for a new string.  This
new string contains the number of characters from the right side of
the string that is specified in the command."
"In the context of the C64, What is the purpose of the memory location at address $DD01?","address              $DD01          CI2PRB
Data Port B

Bit 0:  RS-232 data input (SIN)/ Pin C of User Port
Bit 1:  RS-232 request to send (RTS)/ Pin D of User Port
Bit 2:  RS-232 data terminal ready (DTR)/ Pin E of User Port
Bit 3:  RS-232 ring indicator (RI)/ Pin F of User Port
Bit 4:  RS-232 carrier detect (DCD)/ Pin H of User Port
Bit 5:  Pin J of User Port
Bit 6:  RS-232 clear to send (CTS)/ Pin K of User Port
        Toggle or pulse data output for Timer A
Bit 7:  RS-232 data set ready (DSR)/ Pin L of User Port
        Toggle or pulse data output for Timer B

Location Range: 56578-56579 ($DD02-$DD03)
CIA #2 Data Direction Registers A and B

These Data Direction registers control the direction of data flow over
Data Ports A and B.  For more details on the operation of these
registers, see the entry for the CIA #1 Data Direction Registers at
56322 ($DC02).

The default setting for Data Direction Register A is 63 (all bits
except 6 and 7 are outputs), and for Data Direction Register B the
default setting is 0 (all inputs).  Bits 1 and 2 of Port B are changed
to output when the RS-232 device is opened."
"In the context of the C64, What is the purpose of the memory location at address $DC04?","address              $DC04          TIMALO
Timer A (low byte)"
"In the context of the C64, What is the purpose of the memory location at address $B63D?","address         $B63D          CAT
Concatenate Two Strings

This routine is used to add the text of one string onto the end of
another (A$+B$).  Error checking is done to see if the length of the
combined string is within range, the allocation routine is called to
allocate space, and the new string is built at the bottom of the
string text area."
"In the context of the C64, What is the purpose of the memory location at address $D419?","address              $D419          POTX
Read Game Paddle 1 (or 3) Position"
"In the context of the C64, What is the purpose of the memory location at address $49-$4A?","address         $49-$4A        FORPNT
Temporary Pointer to the Index Variable Used by FOR

The address of the BASIC variable which is the subject of a FOR/NEXT
loop is first stored here, but is then pushed onto the stack.  That
leaves this location free to be used as a work area by such statements
as INPUT, GET, READ, LIST, WAIT, CLOSE, LOAD, SAVE, RETURN, and GOSUB.

For a description of the stack entries made by FOR, see location 256
($100)."
"In the context of the C64, What is the purpose of the memory location at address $C?","address            $C             DIMFLG
Flags for the Routines That Locate or Build an Array

This location is used as a flag by the routines that build an array or
reference an existing array.  It is used to determine whether a
variable is in an array, whether the array has already been
DIMensioned, and whether a new array should assume the default
dimensions."
"In the context of the C64, What is the purpose of the memory location at address $FF48?","address              $FF48
Main IRQ/BRK Interrupt Entry Point

The 6510 hardware IRQ/BRK vector at 65534 ($FFFE) points to this
address.

Anytime the BRK instruction is encountered or an IRQ interrupt occurs,
this routine will be executed.  The routine first saves the .A, .X,
and .Y registers on the stack, and then tests the BRK bit of the
status register (.P) to see if a BRK was executed.  If it was, the
routine exits through the RAM BRK vector at 790 ($316), where it will
usually be directed to the BRK routine at 65126 ($FE66).  If not, the
routine exits through the RAM IRQ vector at 788 ($314), where it will
usually be directed to the handler that scans the keyboard at 59953
($EA31).

If you plan to change either of these vectors to your own routine,
remember to pull the stored register values off the stack before
finishing.

Location Range: 65371-65407 ($FF5B-$FF7F)
Patches Added to Later Kernal Versions

This area contains additional code not found in the original version
of the Kernal.  It is used to test whether a European (PAL) or U.S.
(NTSC) standard monitor is used, and to compensate so that the
sixtieth of a second interrupt will be accurately timed on either
system."
"In the context of the C64, What is the purpose of the memory location at address $CD?","address          $CD            BLNCT
Timer: Countdown to Blink Cursor

The interrupt routine that blinks the cursor uses this location to
tell when it's time for a blink.  First the number 20 is put here, and
every jiffy (1/60 second) the value here is decreased by one, until it
reaches zero.  Then the cursor is blinked, the number 20 is put back
here, and the cycle starts all over again.  Thus, under normal
circumstances, the cursor blinks three times per second."
"In the context of the C64, What is the purpose of the memory location at address $C6?","address           $C6            NDX
Number of Characters in Keyboard Buffer (Queue)

The value here indicates the number of charracters waiting in the
keyboard buffer at 631 ($277).  The maximum number of characters in
the keyboard buffer at any one time is determined by the value in
location 649 ($289), which defaults to 10.

If INPUT or GET is executed while there are already characters in the
buffer, those characters will be read as part of the data stream.  You
can prevent this by POKEing a 0 to this location before those
operations, which will always cause any character in the buffer to be
ignored.  This technique can be handy when using the joystick in
Controller Port #1, which sometimes causes fake keypresses to be
registered, placing unwanted characters in the keyboard buffer.

Not only is this location handy for taking unwanted characters out of
the keyboard buffer, but it can also be used to put desired characters
into the buffer, and thus to program the keyboard buffer.  This
technique (dynamic keyboard) allows you to simulate keyboard input in
direct mode from a program.

The dynamic keyboard technique is an extremely useful one, as it
enables you to add, delete, or modify program lines while the program
is running.  The basic scheme is to POKE the PETASCII character values
that you wish to be printed (including cursor control characters and
carriage returns) into the buffer.  Then, when an END statement is
executed, the characters in the buffer will be printed, and entered by
the carriage return.

This technique can help with the problem of trying to use data
separation and terminator characters with INPUT statements.  If you
try to INPUT a string that has a comma or colon, the INPUT will read
only up to that character and issue an EXTRA IGNORED error message.
You can avoid this by entering the input string in quotes, but this
places on the user the burder of remembering the quote marks.  One
solution is to use the statements:

POKE 198,3:POKE 631,34: POKE 632,34: POKE 633,20

before the input.  This will force two quote marks and a delete into
the buffer.  The first quote mark allows the comma or colon to be
INPUT, the second is used to get the editor out of quote mode, and the
delete removes that second quote.

For more specific information and programming examples, see the
description of location 631 ($277), the keyboard buffer."
"In the context of the C64, What is the purpose of the memory location at address $FDA3?","address              $FDA3          IOINIT
Initialize CIA I/O Devices

This documented Kernal routine, which can be entered through the jump
table at 65412 ($FF84), intializes the Complex Interface Adapter (CIA)
devices, and turns the volume of the SID chip off.  As part of this
initialization, it sets CIA #1 Timer A to cause an IRQ interrupt every
sixtieth of a second."
"In the context of the C64, What is the purpose of the memory location at address $281-282?","address       $281-282       MEMSTR
Pointer: O.S. Start of Memory

When the power is first turned on, or a cold start RESET is performed,
the Kernal routine RAMTAS (64848, $FD50) sets this location to point
to address 2048 ($800).  This indicates that this is the starting
address of user RAM.  BASIC uses this location to set its own start of
memory pointer at location 43 ($2B), and thereafter uses only its own
pointer.

The Kernal routine MEMBOT (65076, $FE34) may be used to read or set
this pointer, or these locations may be directly PEEKed or POKEd from
BASIC."
"In the context of the C64, What is the purpose of the memory location at address $B3F4?","address         $B3F4          FNDOER
Perform FN

The FN evaluation is done by evaluating the FN argument (for example,
FN(A+B*C/D)) and then getting the rest of the expression from the text
of the function definition statement.  The function variable
descriptor area is used as a work area, and the dependent variable is
not disturbed (so that if the definition used FN(X), the value of X
will not be changed by the function call)."
"In the context of the C64, What is the purpose of the memory location at address $AD9E?","address         $AD9E          FRMEVAL
Evaluate Expression

This is the beginning point of a very powerful group of subroutines
which are used extensively by BASIC.

The main purpose of these routines is to read in the ASCII text of
BASIC expressions, separate the operators and terms of the expression,
check them for errors, combine the individual terms by performing the
indicated operations, and obtain a single value which the BASIC
program can use.

This can be a very complex task, and expressions an be of the string
or numeric type, and can contain any type of variable, as well as
constants.

At the end, the flag which shows whether the resulting value is string
or numeric at 13 ($D) is set, and if the value is numeric, the flag at
14 ($E) is set as well, to show if it is an integer or floating point
numer."
"In the context of the C64, What is the purpose of the memory location at address $E168?","address              $E168          LOAD
Perform LOAD

This routine sets the load address to the start of BASIC (from pointer
at 43 ($2B)), and calls the Kerneal LOAD routine.  If the load is
successful, it relinks the BASIC program so that the links agree with
the address to which it is loaded, and it resets the end of BASIC
pointer to reflect the new end of program text.  If the LOAD was done
while a program was running, the pointers are reset so that the
program starts executing all over again from the beginning.  A CLR is
not performed, so that the variables build so far are retained, and
their values are still accessible.  The pointer to the variable area
is not changed, but if the new program is longer than the one that
loaded it, the variable table will be partially overwritten.  This
will cause errors when the overwritten variables are referenced.
Likewise, strings whose text was referenced at its location within the
original program listing will be incorrect.

Since a LOAD from a program causes the program execution to continue
at the first line, when loading a machine language routine or data
file with a nonrelocating load (for example, LOAD'FILE',8,1) from a
program, you should read a flag and GOTO the line after the LOAD if
you don't want the program to keep rerunning indefinitely:

10 IF FLAG=1 THEN GOTO 30
20 FLAG=1:LOAD'FILE',8,1
30 REM PROGRAM CONTINUES HERE"
"In the context of the C64, What is the purpose of the memory location at address $E2EF?","address              $E2EF          SINCON
Table of Constants for Evaluation of SIN, COS, and TAN

This table starts with a counter byte of 5, indicating that there are
six entries in the table.  This is followed by the six floating point
constants of five bytes each."
"In the context of the C64, What is the purpose of the memory location at address $AEFF?","address         $AEFF          CHKCOM
Check for and Skip Comma

This syntax checking device is the same in substance as the two
checking routines above.  It is used when the next character should be
a comma.  If it is not, a SYNTAX ERROR retults.  If it is, the
character is skipped and the next character is read.  Any character
can be checked for and skipped this way by loading the character into
the Accumulator and entering this routine from SYNCHR at 44799
($AEFF)."
"In the context of the C64, What is the purpose of the memory location at address $E4B7?","address              $E4B7
35 Unused Bytes (all have the value of 170 ($AA)

Locaiton Range: 58586-65535 ($E4DA-$FFFF)
Kernal I/O Routines

After the conclusion of BASIC comes the part of this ROM which can be
considered the Kernal proper.  This part contains all of the vectored
routines found in the jump table starting at 65409 ($FF81)."
"In the context of the C64, What is the purpose of the memory location at address $AB4D?","address         $AB4D          DOAGIN
Error Message Formatting Routines for GET, INPUT, and READ"
"In the context of the C64, What is the purpose of the memory location at address $E1C7?","address              $E1C7          CLOSE
Perform CLOSE

The BASIC CLOSE statement calls the Kernal CLOSE routine."
"In the context of the C64, What is the purpose of the memory location at address $AD1E?","address        $AD1E          NEXT
Perform NEXT

NEXT is executed by finding the appropriate FOR data on the stack,
adding the STEP value to the FOR variable, and comparing the result to
the TO value.  If the loop is done, the stack entries for that FOR
command are removed from the stack.  If the loop hasn't reached its
limit, the pointers to the current statement and text character are
updated from the FOR stack entry, which causes execution to continue
with the statement after the FOR statement."
"In the context of the C64, What is the purpose of the memory location at address $AEF7?","address         $AEF7          CHKCLS
Check for and Skip Closing Parentheses"
"In the context of the C64, What is the purpose of the memory location at address $E33E?","address              $E33E          ATNCON
Table of Constants for ATN Evaluation

The table begins with a count byte of 11, which is followed by 12
constants in five-byte floating point representation."
"In the context of the C64, What is the purpose of the memory location at address $FC6A?","address              $FC6A
Write Data fo Cassette--Part 1 (IRQ)

This IRQ handler routine is the other part of the write data to
cassette routine."
"In the context of the C64, What is the purpose of the memory location at address $CF?","address           $CF            BLNON
Flag: Was Last Curson Blink on or off?

This location keeps track of whether, during the current cursor blink,
the character under the cursor was reversed, or was restored to
normal.  This location will contain a 0 if the character is reversed,
and a 1 if the character is restored to its nonreversed status."
"In the context of the C64, What is the purpose of the memory location at address $FED6?","address              $FED6
RS-232 Receive the Next Bit (NMI)

The NMI handler calls this subroutine to input the next bit on the
RS-232 bus.  It then calls the next subroutine to reload the timer
that causes the interrupts."
"In the context of the C64, What is the purpose of the memory location at address $FD50?","address              $FD50          RAMTAS
Perform RAM Test and Set Pointers to the Top and Bottom of RAM

This documented Kernal routine, which can be entered through location
65415 ($FF87) of the jump table, performs a number of initialization
tasks.

First, it clears Pages 0, 2, and 3 of memory to zeros.  Next, it sets
the tape buffer pointer to address 828 ($33C), and performs a
nondestructive test of RAM from 1024 ($400) up.  When it reaches a
non-RAM address (presumably the BASIC ROM at 40960 ($A000)), that
address is placed in the top of memory pointer at 643-4 ($283-4).  The
bottom of memory pointer at 641-2 ($281-2) is set to point to address
2048 ($800), which is the beginning of BASIC program text.  Finally,
the pointer to screen memory at 648 ($288) is set to 4, which lets the
Operating System know that screen memory starts at 1024 ($400)."
"In the context of the C64, What is the purpose of the memory location at address $C8?","address          $C8            INDX
Pointer: End of Logical Line for Input

This pointer indicates the column number of the last nonblank
character on the logical line that is to be input.  Since a logical
line can be up to 80 characters long, this number can range from 0-79."
"In the context of the C64, What is the purpose of the memory location at address $E?","address            $E             INTFLG
Flat: Type of Numeric Data (Integer or Floating Point)

If data which BASIC is using is determined to be numeric, it is
further classified here as either a floating point number or as an
integer.  A 128 ($80) in this location identifies the number as an
integer, and a 0 indicates a floating point number."
"In the context of the C64, What is the purpose of the memory location at address $BA59?","address         $BA59          MLTPLY
Multiply a Byte Subroutine

This subroutine is used to repetitively add a mantissa byte of FAC2 to
FAC1 the number of times specified in the .A register."
"In the context of the C64, What is the purpose of the memory location at address $DD03?","address              $DD03          C2DDRB
Data Direction Register B

Bit 0:  Select Bit 0 of data Port B for input or output (0=input, 1=output)
Bit 1:  Select Bit 1 of data Port B for input or output (0=input, 1=output)
Bit 2:  Select Bit 2 of data Port B for input or output (0=input, 1=output)
Bit 3:  Select Bit 3 of data Port B for input or output (0=input, 1=output)
Bit 4:  Select Bit 4 of data Port B for input or output (0=input, 1=output)
Bit 5:  Select Bit 5 of data Port B for input or output (0=input, 1=output)
Bit 6:  Select Bit 6 of data Port B for input or output (0=input, 1=output)
Bit 7:  Select Bit 7 of data Port B for input or output (0=input, 1=output)

Location Range: 56580-56583 ($DD04-$DD07)
Timer A and B Low and High Bytes

These four timer registers are used to control Timers A and B.  For
details on the operation of these timers, see the entry for Location
Range 56324-56327 ($DC04-$DC07).

The 64 Operating System uses the CIA #2 Timers A and B mostly for
timing RS-232 send and receive operations.  Serial Bus timing uses CIA
#1 Timer B."
"In the context of the C64, What is the purpose of the memory location at address $B6EC?","address         $B6EC          CHRD
Perform CHR$

The CHR$ routine creates a descriptor on the temporary string stack
for the one-byte string whose value is specified in the command, and
sets a pointer to that string."
"In the context of the C64, What is the purpose of the memory location at address $B5BD?","address         $B5BD
Check for Most Eligible String to Collect

This part of the garbage collection routine checks to see if the
current string is the highest in memory."
"In the context of the C64, What is the purpose of the memory location at address $DC06?","address              $DC06          TIMBLO
Timer B (low byte)"
"In the context of the C64, Give explanations about the kernal","As with the section on the BASIC ROM, this section is not meant to be
a complete explanation of the Kernal ROM, but rather a guidepost for
further exploration.  Where the exact instructions the Kernal ROM
routines use are important to your programming, it will be necessary
for you to obtain a disassembly listing of those routines and look at
the code itself.

Keep in mind that there is 8K of RAM underlying the Kernal ROM that
can be used by turning off interrupts and switching out the Kernal ROM
temporarily.  Even without switching out the Kernal ROM, this RAM may
be read by the VIC-II chip if it is banked to use the top 16K of
memory, and may be used for graphics data.  The Kernal and BASIC ROMs
may be copied to RAM, and the RAM versions modified to change existing
features or add new ones.

There are some differences between the version of the Kernal found on
the first few Commodore 64s and those found on the majority of newer
models.  Those differences are discussed in the entries for the
sections on later Kernal additions (patches) at 58541-58623
($E4AD-$E4FF) an 65371-67407 ($FF5B-$FF7F).

The most obvious change causes the Color RAM at 55296 ($D800) to be
initialized to the background color when the screen is cleared on
newer models, instead of white as on the original models.  Other
changes allow the new Kernal software to be used by either U.S. or
European 64s.  Keep in mind that the Kernal is always subject to
change, and that the following discussion, while accurate at the time
written (mid-1983), may not pertain to later models.  If future
changes are like past ones, however, they are likely to be minor ones.
The first place to look for these changes would be in the patch
sections identified above."
"In the context of the C64, What is the purpose of the memory location at address $DD0F?","address              $DD0F          CI2CRB
Control Register B

Bit 0:  Start Timer B (1=start, 0=stop)
Bit 1:  Select Timer B output on Port B (1=Timer B output appears on
        Bit 7 of Port B)
Bit 2:  Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one
        cycle)
Bit 3:  Timer B run mode (1=one shot, 0=continuous)
Bit 4:  Force latched value to be loaded to Timer B counter (1=force
        load strobe)
Bits 5-6:  Timer B input mode
           00 = Timer B counts microprocessor cycles
           01 = Count signals on CNT line at pin 4 of User Port
           10 = Count each time that Timer A counts down to 0
           11 = Count Timer A 0's when CNT pulses are also present
Bit 7:  Select Time of Day write (0=writing to TOD registers sets
           alarm, 1=writing to ROD registers sets clock)

Location Range: 56592-56831 ($DD10-$DDFF)
CIA #2 Register Images

Since the CIA chip requires only enough addressing lines to handle 16
registers, none of the higher bits are decoded when addressing the
256-byte area that has been assigned to it.  The result is that every
16-byte area in this 256-byte block is a mirror of every other.  For
the sake of clarity in your programs, it is advisable not to use these
addresses.

Location Range: 56832-57087 ($DE00-$DEFF)
Reserved for I/O Expansion

This range of locations is not used directly by the 64's internal
hardware.  It is, however, accessible via pin 7 of the Expansion Port.
It can be used to control cartridges which are connected to this port.
For example, the CP/M module uses this space to control which
microprocessor is in control of the system.  The Z-80 microprocessor
is turned on and off by writing to 56832 ($DE00).

Another cartridge which uses this space is Simon's BASIC.  This 16K
cartridge is addressed at memory locations 32768-49151 ($8000-$BFFF),
which means that it overlaps the regular BASIC ROM at 40960-49151
($A000-$BFFF).  But since it contains additions to BASIC, it must use
the BASIC ROM as well.  This problem is solved by copying the
cartridge at 32768-40959 ($8000-$9FFF) to RAM, and turning the
cartridge on and off by writing to or reading from location 56832
($DE00).

Location Range: 57088-57343 ($DF00-$DFFF)
CIA #2 Register Images

This range of locations is not used directly by the 64's internal
hardward, but is accessible via pin 10 of the Expansion Port.  One
possible use for this I/O memory that Commodore has mentioned is an
inexpensive parallel disk drive (which presumable would be much faster
than the current serial model).

Alternate 53248-57343 ($D000-$DFFF)
Character Generator ROM

The character generator ROM supplies the data which is to form the
shapes of the text and graphics characters that are displayed on the
screen.  Each character requires eight bytes of shape data, and these
eight-byte sequences are arranged in order in which the characters
appear in the screen code chart (see Appendix G).  For example, the
first eight bytes of data in the ROM hold the shape information for
the commercial at sign (@), the next eight hold the shape of the
letter A, etc.  In all, there are 4096 bytes, representing shape data
for two complete character sets of 256 characters each--1K each for
uppercase/graphics, reverse uppercase/reverse graphics, lowercase/
uppercase, and reverse lowercase/reverse uppercase.

The shape of each character is formed by an 8 by 8 matrix of screen
dots.  Whether any of the 64 dots is lit up or not is determined by
the bit patterns of the character data.  Each byte of the Character
ROM holds a number from 0 to 255.  This number can be represented by
eight binary digits of 0 or 1.  The leftmost bit of these eight is
known as Bit 7, while the rightmost bit is called Bit 0.  Each of
these binary digits has a bit value that is two times greater than the
last.  The values of a bit set to 1 in each of the bit places are:

Bit    0    1     2    3    4    5    6    7
Value  1    2     4    8   16   32   64  128

A byte whose value is 255 has every bit set to 1
(128+64+32+16+8+4+2+1=255), while a byte whose value is 0 is made up
of all zero bits.  Numbers in between are made up of combinations of
bits set to 1 and bits set to 0.  If you think of every bit that holds
0 as a dot on the screen which is the color of the screen background,
and every bit that holds a 1 as a dot whose color is that of the
appropriate nybble in Color RAM, you can begin to get an idea of how
the byte values relate to the shape of the character.  For example, if
you PEEK at the first eight bytes of the character ROM (the technique
is explained in the entry for location 1), you will see the numbers
60, 102, 110, 110, 96, 98, 60, 0.  Breaking these data bytes down into
their bit values gives us a picture that looks like the following:

00111100   0 +   0 +  32 +  16 +   8 +   4 +   0 +   0 =  60
01100110   0 +  64 +  32 +   0 +   0 +   4 +   2 +   0 = 101
01101110   0 +  64 +  32 +   0 +   8 +   4 +   2 +   0 = 110
01101110   0 +  64 +  32 +   0 +   8 +   4 +   2 +   0 = 110
01100000   0 +  64 +  32 +   0 +   0 +   0 +   0 +   0 =  96
01100010   0 +  64 +  32 +   0 +   0 +   0 +   2 +   0 =  98
00111100   0 +   0 +  32 +  16 +   8 +   4 +   0 +   0 =  60
00000000   0 +   0 +   0 +   0 +   0 +   0 +   0 +   0 =   0

If you look closely, you will recognize the shape of the commercial at
sign (@) as it's displayed on your screen.  The first byte of data is
60, and you can see that Bits 5, 4, 3, and 2 are set to 1.  The chart
above shows that the bit values for these bits are 32, 16, 8, and 4.
Adding these together, you get 32+16+8+4=60.  This should give you an
idea of how the byte value corresponds to the patterns of lit dots.
For an even more graphic display, type in the following program, which
shows the shape of any of the 512 characters in the ROM, along with
the number value of each byte of the shape.

10 DIM B%(7),T%(7):FOR I=0 TO 7:T%(I)=2^I:NEXT
20 POKE 53281,2:PRINT CHR$(147):POKE 53281,1:POKE 53280,0:POKE 646,11
30 POKE 214,20:PRINT:INPUT' CHARACTER NUMBER (0-511)';C$
40 C=VAL(C$):GOSUB 80:FOR I=0 TO 7
50 POKE 214,6+I:PRINT:PRINT TAB(23);B%(I);CHR$(20);'   '
60 FOR J=7 TO 0 STEP-1:POKE 1319+(7-J)+I*40,32-128*((B%(I)ANDT%(J))=T%(J))
70 NEXT J,I:POKE 214,20:PRINT:PRINT TAB(27)'    ':GOTO 30
80 POKE 56333,127:POKE 1,51:FOR I=0 TO 7
90 B%(I)=PEEK(53248+C*8+I):NEXT:POKE 1,55:POKE 56333,129:RETURN

If you have read about the VIC-II video chip, you know that it can
address only 16K of memory at a time, and that all display data such
as screen memory, character shape data, and sprite shape data must be
stored within that 16K block.

Since it would be very inconvenient for the VIC-II chip to be able to
access the character data only at the 16K block which includes
adresses 53248-57343 ($D000-$DFFF), the 64 uses an addressing trick
that makes the VIC-II chip see an image of the Character ROM at
4096-8191 ($1000-$1FFF) and at 36864-40959 ($9000-$9FFF).  It is not
available in the other two blocks.  To generate characters in these
blocks, you must supply your own user-defined character set, or copy
the ROM data to RAM.  A machine language routine for doing this is
included in a sample program at the entry for 56576 ($DD00).

As indicated above, you are by no means limited to useing the
character data furnished by the ROM.  The availability of user-defined
characters greatly extends the graphics power of the 64.  It allows
you to create special text characters, like math or chemistry symbols
and foreign language alphabets.  You can also develop special graphics
characters as a substitute for plotting points in bitmap graphics.
You can achieve the same resolution using a custom character as in
high-resolution bitmap mode, but with less memory. Once you have
defined the character, it is much faster to print it to the screen
than in would be to plot out all of the individual points.

To employ user-defined characters, you must first pick a spot to put
the shape data.  This requires choosing a bank of 16K for video chip
memory (see the entry under Bits 0-1 of 56576 ($DD00) for the
considerations involved), and setting the pointer to the 2K area of
character memory in 53272 ($D018).  It is then up to you to supply the
shape data for the characters.  You can use part of the ROM character
set by reading the ROM and transferring the data to your character
shape area (see the entry for location 1 for a method of reading the
ROM).

Your original characters may be created by darkening squares on an 8
by 8 grid, converting all darkened squares to their bit values, and
then adding the bit values for each of the eight bytes.  Or, you may
use one of the many character graphics editor programs that are
available commercially to generate the data interactively by drawing
on the screen.

One graphics mode, multicolor text mode, almost requires that you
define your own character set in order to use it effectively.
Multicolor mode is enabled by Bit 4 of location 53270 ($D016).
Instead of using each bit to control whether an individual dot will be
foreground color (1) or background color (0), that mode breaks down
each byte of shape data in four bit-pairs.  These bit pairs control
whether a dot will be the color in Background Color Register #0 (00),
the color in Background Color Register #1 (01), the color in
Background Color Register #2 (10), or the color in the appropriate
nybble of Color RAM (11).  Since each pair of bits controls one dot,
each character is only four dots across.  To make up for this, each
dot is twice as wide as a normal high-resolution dot."
"In the context of the C64, What is the purpose of the memory location at address $B606?","address         $B606
Collect a String

This part of the garbage collection routine moves the string to high
memory and updates the descriptor to point to its new location."
"In the context of the C64, What is the purpose of the memory location at address $DC07?","address              $DC07          TIMBHI
Timer B (high byte)

Location Range: 56328-56331 ($DC08-$DC0B)
Time of Day Clock (TOD)

In addition to the two general-purpose timers, the 6526 CIA chip has a
special-purpose Time of Day Clock, which keeps time in a format that
humans can understand a little more easily than microseconds.

This Time of Day Clock even has an alarm, which can cause an interrupt
at a specific time.  It is organized in four registers, one each for
hours, minutes, seconds, and tenths of seconds.  Each register reads
out in Binary Coded Decimal (BCD) format, for easier conversion to
ASCII digits.  A BCD byte is divided into two nybbles, each of which
represents a single digit in base 10.  Even though a four-bit nybble
can hold a number from 0 to 15, only the base 10 digits of 0-9 are
used.  Therefore, 10 0'clock would be represented by a byte in the
hours register with the nybbles 0001 and 0000, which stand for the
digits 1 and 0.  The binary value of this byte would be 16 (16 times
the high nybble plus the low nybble).  Each of the other registers
operates in the same manner.  In addition, Bit 7 of the hours register
is used as an AM/PM flag.  If that bit is set to 1, it indicates PM,
and if it is set to 0, the time is AM.

The Time of Day Clock Registers can be used for two purposes,
depending on whether you are reading them or writing to them.  If you
are reading them, you will always be reading the time.  There is a
latching feature associated with reading the hours register in order
to solve the problem of the time changing while you are reading the
registers.  For example, if you were reading the hours register just
as the time was changing from 10:59 to 11:00, it is possible that you
would read the 10 in the hours register, and by the time you read the
minutes register it would have changed from 59 to 00.  Therefore, you
would read 10:00 instead of either 10:59 or 11:00.

To prevent this kind of mistake, the Time of Day Clock Registers stop
updating as soon as you read the hours register, and do not start
again until you read the tenths of seconds register.  Of course, the
clock continues to keep time internally even though it does not update
the registers.  If you want to read only minutes, or seconds or tenths
of seconds, there is no problem, and no latching will occur.  But
anytime you read hours, you must follow it by reading tenths of
seconds, even if you don't care about them, or else the registers will
not continue to update.

Writing to these registers either sets the time or the alarm,
depending on the setting of Bit 7 of Control Register B (56335,
$DC0F).  If that bit is set to 1, writing to the Time of Day registers
sets the alarm.  If the bit is set to 0, writing to the Time of Day
registers sets the Time of Day clock.  In either case, as with reading
the registers, there is a latch function.  This function stops the
clock from updating when you write to the hours register.  The clock
will not start again until you write to the tenths of seconds
registers.

The only apparent use of the Time of Day Clock by the 64's Operating
System is in the BASIC RND statement.  There, the seconds and tenths
of seconds registers are read and their values used as part of the
seed value for the RND(0) command.

Nonetheless, this clock can be an invaluable resource for the 64 user.
It will keep time more accurately than the software clock maintained
at locations 60-162 ($A0-$A2) by the Timer A interrupt routine.  And
unlike that software clock, the Time of Day Clock will not be
disturbed when I/O operations disrupt the Timer A IRQ, or when the IRQ
vector is diverted elsewhere.  Not even a cold start RESET will
disrupt the time.  For game timers, just set the time for 00:00:00:0
and it will keep track of elapsed time in hours, minutes, seconds and
tenths of seconds format.

The following digital clock program, written in BASIC, will
demonstrate the use of these timers:

10 PRINT CHR$(147):GOSUB 200
20 H=PEEK(56331):POKE 1238,(H AND 16)/16+48:POKE 1239,(H AND 15)+48
30 M=PEEK(56330):POKE 1241,(M AND 240)/16+48:POKE 1242,(M AND 15)+48
40 S=PEEK(56329):POKE 1244,(S AND 240)/16+48:POKE 1245,(S AND 15)+48
50 T=PEEK(56328)AND15:POKE 1247,T+48:GOTO 20
200 INPUT'WHAT IS THE HOUR';H$:IF H$='' THEN 200
210 H=0:IF LEN(H$)>1 THEN H=16
220 HH=VAL(RIGHT$(H$,1)):H=H+HH:POKE56331,H
230 INPUT 'WHAT IS THE MINUTE';M$:IF M$=''THEN 200
240 M=0:IF LEN(M$)>1 THEN M=16*VAL(LEFT$(M$,1))
250 MM=VAL(RIGHT$(M$,1)):M=M+MM:POKE56330,M
260 INPUT 'WHAT IS THE SECOND';S$:IF S$=''THEN 200
270 S=0:IF LEN(S$)>1 THEN S=16*VAL(LEFT$(S$,1))
280 SS=VAL(RIGHT$(S$,1)):S=S+SS:POKE56329,S:POKE56328,0
290 POKE 53281,1:PRINT CHR$(147):POKE 53281,6
300 POKE 1240,58:POKE 1243,58:POKE 1246,58:GOTO 20"
"In the context of the C64, What is the purpose of the memory location at address $DD04?","address              $DD04          TI2ALO
Timer A (low byte)"
"In the context of the C64, What is the purpose of the memory location at address $B700?","address         $B700          LEFTD
Perform LEFT$

LEFT$ creates a temporary string descriptor for a new string which
contains the number of characters from the left side of the string
that is specified in the command."
"In the context of the C64, What is the purpose of the memory location at address $BA8C?","address         $BA8C          CONUPK
Move a Floating Point Number from Memory into FAC2

This subroutine loads FAC2 from the four-byte number (three mantissa
and one sign) pointed to by the .A and .Y registers."
"In the context of the C64, What is the purpose of the memory location at address $D?","address            $D             VALTYP
Flag: Type of Data (String or Numeric)

This flag is used internally to indicate whether data being operated
upon is string or numeric.  A value of 255 ($FF) in this location
indicates string data, while a 0 indicates numeric data.  This
determination is made every time a variable is located or created."
"In the context of the C64, What is the purpose of the memory location at address $FD9B?","address              $FD9B
Table of IRQ Vectors

This table holds the vectors to the four IRQ routines which the system
uses.  The first points to Part 1 of the cassette write routine at
64618 ($FC6A), the second to Part 2 of the cassette write routine at
64461 ($FBCD), the third to the standard scan keyboard IRQ at 59953
($EA31), and the last to the cassette read routine at 63788 ($F92C)."
"In the context of the C64, What is the purpose of the memory location at address $C9-$CA?","address       $C9-$CA        LXSP
Cursor X,Y Position at Start of Input

These locations keep track of the logical line that the cursor is on,
and its column position on that logical line (in line, column format).

Each logical line may contain one or two 40-column physical lines.
Thus there may be as many as 25 logical lines, or as few as 13 at any
one time.  Therefore, the logical line number might be anywhere from
1-25.  Depending on the length of the logical line, the cursor column
may be from 1-40 or 1-80.

For a more detailed exaplanation of logical lines, see the description
of the screen line link talbe, 217 ($D9)."
"In the context of the C64, What is the purpose of the memory location at address $D0?","address          $D0            CRSW
Flag: Input from Keyboard or Screen

This flag is used by the Kernal CHRIN (61783, $F157) routine to
indicate whether input is available from the screen (3), or whether a
new line should be obtained from the keyboard (0)."
"In the context of the C64, What is the purpose of the memory location at address $FF1A?","address              $FF1A
Load the Timer with Prescaler Values from the Baud Rate Lookup Table"
"In the context of the C64, What is the purpose of the memory location at address $FC93?","address              $FC93
Restores the Default IRQ Routine

At the end of the tape I/O operations, this subroutine is used to turn
the screen back on and stop the cassette motor.  It then resets the
CIA #1 Timer A to generate an interrupt every sixtieth of a second,
and restores the IRQ vector to point to the normal interrupt routine
that updates the software clock and scans the keyboard."
"In the context of the C64, What is the purpose of the memory location at address $AEFA?","address         $AEFA          CHKOPN
Check for and Skip Opening Parentheses"
"In the context of the C64, What is the purpose of the memory location at address $E37B?","address              $E37B
Warm Start BASIC

This is the entry point into BASIC from the BRK routine at 65126
($FE66), which is executed when the STOP and RESTORE keys are both
pressed.  It first executes the Kernal CLRCHN routine which closes all
files.  It then sets the default devices, resets the stack and BASIC
program pointers, and jumps through the vector at 768 ($300) to the
next routine to print the READY prompt and enter the main BASIC loop."
"In the context of the C64, What is the purpose of the memory location at address $E1D4?","address              $E1D4
Set Parameters for LOAD, VERIFY, and SAVE

This routine is used in common by LOAD, SAVE, and VERIFY for setting
the filename, the logical file, device number, and secondary address,
all of which must be done prior to these operations."
"In the context of the C64, What is the purpose of the memory location at address $AD8A?","address         $AD8A          FRMNUM
Evaluate a Numeric Expression and/or Check for Data Type Mismatch

This routine can be called from different entry points to check the
current data against the desired data type (string or numeric) to see
if they match.  If they don't, a TYPE MISMATCH error will result."
"In the context of the C64, What is the purpose of the memory location at address $AB7B?","address         $AB7B          GET
Perform GET and GET#

The GET routine first makes sure that the program is not in direct
mode.  It opens an input channel using the Kernal CHKIN routine
(61966, $F20E) if a number sign was added to make GET#.  Then it calls
the common I/O routines in READ to get a single character, and causes
the input channel to be closed if one was opened."
"In the context of the C64, What is the purpose of the memory location at address $EA31?","address              $EA31
IRQ Interrupt Entry

This is the entry point to the standard IRQ interrupt handler.  Timer
A of CIA #1 is set at power-on to cause an IRQ interrupt to occur
every 1/60 second.  When the interrupt occurs, program flow is
transferred here via the CINV vector at 788 ($314).  This routine
updates the software clock at 160-162 ($A0-$A2), handles the cursor
flash, and maintains the tape interlock which keeps the cassette motor
on if a button is pushed and the interlock flag is on.  Finally, it
calls the keyboard scan routine, which checks the keyboard and puts
any character it finds into the keyboard buffer."
"In the context of the C64, What is the purpose of the memory location at address $33C-$3FB?","address     $33C-$3FB      TBUFFER
Cassette I/O Buffer

This 192-byte buffer area is used to temporarily hold data that is
read from or written to the tape device (device number 1).

When not being used for tape I/O, the cassette buffer has long been a
favorite place for Commodore programmers to place short machine
language routines (although the 64 has 4K of unused RAM above the
BASIC ROM at 49152 ($C000) that would probably better serve the
purpose).

Of more practical interest to the 64 programmer is the possible use of
this area for VIC-II chip graphics memory (for example, sprite shape
data or text character dot data).  If the VIC-II chip is banked to the
lowest 16K of memory (as is the default selection), there is very
little memory space which can be used for such things as sprite shape
data without conflict.  If the tape is not in use, locations 832-895
($340-$37F) can be used as sprite data block number 13, and locations
896-959 ($380-$3BF) can be used as sprite data block number 14.

The types of tape blocks that can be stored here are program header
blocks, data header blocks, and data storage blocks.

The first byte of any kind of block (which is stored at location 828
($33C)) identifies the block type.  Header blocks follow this
identifier byte with the two-byte starting RAM address of the tape
data, the two-byte ending RAM address, and the filename, padded with
blanks so that the total length of the name portion equals 187 bytes.
Data storage blocks have 191 bytes of data following the identifier
byte.  The meanings of the various identifier blocks are as follows:

A value of 1 signifies that the block is the header for a relocatable
program file, while a value of 3 indicates that the block is the
header for a nonrelocatable program file.

A relocatable file is created when a program is SAVEd with a secondary
address of 0 (or any even number), while a nonrelocatable program file
is created if the secondary SAVE address is 1 (or any odd number).
The difference between the two types of files is that a nonrelocatable
program will always load at the address specified in the header.  A
relocatable program will load at the current start of BASIC address
unless the LOAD statement uses a secondary address of 1, in which case
it will also be loaded at the addrss specified in the header.

You should note that a program file uses the cassette buffer only to
store the header block.  Actual program data is transferred directly
to or from RAM, without first being buffered.

An identifier value of 4 means that the block is a data file header.
Such a header block is stored in the cassette buffer whenever a BASIC
program OPENs a tape data file for reading or writing.  Subsequent
data blocks start with an identifier byte of 2.  These blocks contain
the actual data byte written by the PRINT #1 command, and read by the
GET #1 and INPUT #1 commands.  Unlike the body of a program file,
these blocks are temporarily stored in the cassette byffer when being
written or read.

An identifier byte of 5 indicates that this block is the logical end
of the tape.  This signals the Kernal not to search past this point,
even if there are additional tape blocks physically present on the
tape.

1020-1023     $3FC-$3FF
Unused

Four more free bytes."
"In the context of the C64, What is the purpose of the memory location at address $A080-$A09D?","address  $A080-$A09D    OPTAB
Operator Dispatch Vector Table

This table contains two-byte vectors, each of which points to an
address which is one byte before the address of one of the routines
that perform a BASIC math operation.

For the reasoning behind the one-byte offset to the true address, see
the entry for location 40972 ($A00C).  In addition, each entry has a
one-byte number which indicates the degree of precedence that
operation takes.  Operations with a higher degree of precedence are
performed before operations of a lower degree (for example, in the
expression A=3+4*6, the 4*6 operation is performed first, and 3 is
added to the total).  The order in which they are performed is:

1.  Expressions in parentheses
2.  Exponentation (raising to a power, using the up-arrow symbol)
3.  Negation of an expression (-5, -A)
4.  Multiplication and division
5.  Addition and subtraction
6.  Relation tests (=, <>, <, >, <=, >= all have the same precedence)
7.  NOT (logical operation)
8.  AND (logical operation)
9.  OR (logical operation)

The substance of this table, which can be used to locate the addresses
of the math routines, is given below.  Note that less that, equal, and
greater than operators all use the same routines, though they have
different token numbers."
"In the context of the C64, What is the purpose of the memory location at address $EBC2?","address              $EBC2
SHIFTed Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the shifted keyboard,
one for each key which is struck while the SHIFT key is pressed.  The
table is in keycode order (see the keycode table in Appendix H for the
correspondence of keycode to key).  A 65th byte with the value of 255
($FF) marks the end of the table (this corresponds to a keypress value
of 64, no key pressed)."
"In the context of the C64, What is the purpose of the memory location at address $E9E0?","address              $E9E0
Set Temporary Color Pointer for Scrolling

This subrouting sets up a pointer in 17-175 ($AE-$AF) to the Color RAM
address that corresponds to the temporary screen line address in
172-173 ($AC-$AD)."
"In the context of the C64, What is the purpose of the memory location at address $306-$307?","address      $306-$307      IQPLOP
Vector to the Routine That Lists BASIC Program Token as ASCII Text

This vector points to the address of the QPLOP routine at 42778
($A71A)."
"In the context of the C64, What is the purpose of the memory location at address $F250?","address              $F250          CHKOUT
Designate a Logical File As the Current Output Channel

This is a documented Kernal routine which can be entered from the jump
table at 65481 ($FFC9).

The routine jumps through a RAM vector at 800 ($320).  If you wish to
output data to any device other than the screen, this routine must be
called after OPENing the device, and before you output a data byte
with the CHROUT routine.  When called, the routine will designate the
logical file whose file number is in the .X register as the current
file, its device as the current device, and its secondary address as
the current secondary address.  If the device on the channel uses the
serial bus, and therefore requires a LISTEN command and possibly a
secondary address, this information will be sent on the bus."
"In the context of the C64, What is the purpose of the memory location at address $F0BD?","address              $F0BD
Kernal Control Messages

The ASCII text of the Kernal I/O control messages is stored here.  The
last byte of every message has Bit 7 set to 1 (ASCII value + 128).
The messages are:

I/O ERROR
SEARCHING
FOR
PRESS PLAY ON TAPE
PRESS RECORD & PLAY ON TAPE
LOADING
SAVING
VERIFYING
FOUND
OK"
"In the context of the C64, What is the purpose of the memory location at address $29C?","address          $29C           RIDBS
RS-232: Index to Start of Receive Buffer

This index points to the starting byte within the 256-byte RS-232
receive buffer, and is used to remove data from that buffer."
"In the context of the C64, What is the purpose of the memory location at address $28D?","address           $28D           SHFLAG
Flag: SHIFT/CTRL/Logo Keypress

This flag signals which of the SHIFT, CTRL, or Commodore logo keys are
currently being pressed, if any.

A value of 1 signifies that one of the SHIFT keys is being pressed, a
2 shows that the Commodore logo key is down, and 4 means that the CTRL
key is being pressed.  If more than one key is held down, these values
will be added; for example, a 3 indicates that SHIFT and logo are both
held down.

The value here is used by the Operating System when determining how to
convert a keypress into a PETASCII character.  There are four
different tables used to translate one of the 64 keys on the keyboard
matrix into a PETASCII character, and the combination of special SHIFT
keys determines which of these tables will be used (see the entry for
location 245 ($F5) for more details on the keyboard tables).

Pressing the SHIFT and Commodore logo keys at the same time will
toggle the character set that is presently being used between the
uppercase/graphics set, and the lowercase/uppercase set (provided that
the flag at 657 ($291) has not been set to disable this switch).

This changes the appearance of all of the characters on the screen at
once.  It has nothing whatever to do with the keyboard shift tables,
however, and should not be confused with the printing of SHIFTed
characters, which affects only one character at a time.  Rather, it is
the result of the value of the character dot data table base address
in 53272 ($D018) being changed.  The came result may be obtained by
POKEing that address directly."
"In the context of the C64, What is the purpose of the memory location at address $62-$65?","address        $62-$65        FACHO
Floating Point Accumulator #1: Mantissa

The most significant digit can be assumed to be a 1 (remember that the
range of the mantissa is from 1 to 1.99999...) when a floating point
number is stored to a variable.  The first bit is used for the sign of
the number, and the other 31 bits of the four-byte mantissa hold the
other significant digits.

The first two bytes (98-99, $62-$63) of this location will hold the
signed integer result of a floating point to integer conversion, in
high-byte, low- byte order."
"In the context of the C64, What is the purpose of the memory location at address $9D?","address           $9D            MSGFLG
Flag: Kernal Message Control

This flag is set by the Kernal routine SETMSG (65048, $FE18), and it
controls whether or not Kernal error messages or control messages will
be displayed.

A value of 192 ($C0) here means that both Kernal error and control
messages will be displayed.  This will never normally occur when using
BASIC, which prefers its own plain text error messages over the
Kernal's perfunctory I/O ERROR (number).  The Kernal error messages
might be used, however, when you are SAVEing or LOADing with a machine
language monitor.

A 128 ($80) means that control messages only will be displayed.  Such
will be the case when you are in the BASIC direct or immediate mode.
These messages include SEARCHING, SAVING, FOUND, etc.

A value of 64 means that Kernal error messages only are on.  A 0 here
suppresses the display of all Kernal messages.  This is the value
placed here when BASIC enters the program or RUN mode."
"In the context of the C64, What is the purpose of the memory location at address $8B-$8F?","address       $8B-$8F        RNDX
RND Function Seed Value

This location holds the five-byte floating point value returned by the
RND function.  It is initially set to a seed value copied from ROM
(the five bytes are 128, 79, 199, 82, 88--$80, $4F, $C7, $52, $58).

When the function RND(X) is called, the numeric value of X does not
affect the number returned, but its sign does.  If X is equal to 0,
RND generates a seed value from chip-level hardware timers.  If X is a
positive number, RND(X) will return the next number in an arithmetic
sequence.  This sequence continues for such a long time without
repeating itself, and gives such an even distribution of numbers, that
it can be considered random.  If X is negative, the seed value is
changed to a number that corresponds to a scrambled floating point
representation of the number X itself.

Given a particular seed value, the same pseudorandom series of numbers
will always be returned.  This can be handy for debugging purposes,
but not where you wish to have truly random numbers.

The traditional Commodore method of selecting a random seed is by
using the expression RND(-TI), mostly because RND(0) didn't function
correctly on early PETs.  While the RND(0) form doesn't really work
right on the 64 either (see location 57495 ($E097)), the expression
RND(-RND(0)) may produce a more random seed value.

Location Range: 144-255 ($90-$FF)
Kernal Work Storage Area

This is the zero-page storage area for the Kernal.  The user should
take into account what effect changing a location here will have on
the operation of the Kernal functions before making any such changes.

At power-on, this range of locations is first filled with zeros, and
then initialized from values stored in ROM as needed."
"In the context of the C64, What is the purpose of the memory location at address $D023?","address              $D023          BGCOL2
Background Color 2

This register sets the color for the 10 bit-pair of multicolor
character graphics, and the background color for characters habing
screen codes 128-191 in extended background color text mode.  The
default color value is 2 (red)."
"In the context of the C64, What is the purpose of the memory location at address $D000-$D02E?","address   $D000-$D02E
VIC-II Chip Registers

The Video Interface Controller (VIC-II chip) is a specially designed
processor that is in charge of the 64's video display.  It is this
chip which makes possible the 64's wide range of graphics
capabilities.

The VIC-II chip's ability to address memory is independent of the 6510
microprocessor.  It can address only 16K at a time, and any of the
four blocks of 16K can be chosen for video memory.  The system default
is for it to use the first 16K.

All of the video display memory, character dot data, and sprite shapes
must be stored within the chosen 16K block.  Locations 53248-53294
($D000-$D02E) are registers which allow the user to communicate with
the VIC-II chip.  Although for the most part they can be written to
and read like ordinary memory locations, their contents directly
control the video display.  Since many of these locations work in
close conjunction with others, a general overview of some of the
different graphics systems on the 64 is in order.

The most familiar type of graphics display is the ordinary text that
appears when you turn the machine on.  The area of RAM which is
displayed on the screen is determined by the Video Matrix Base Address
Nybble of the VIC-II Memory Control Register (53272, $D018).  The
address of the dot-data which is used to assign a shape to each text
character based on an 8 by 8 matrix of lit or unlit dots is determined
by the other half of the Memory Control Register at 53272 ($D018).
More information on how the data is used to represent the character
shapes may be found at the alternate entry for 49152 ($C000), the
Character Generator ROM.

Text character graphics may employ one of the two sets of text and
graphics characters in the Character Generator ROM, or the user may
substitute a completely different set of graphics or text characters
in RAM.

Normally, the text graphics screen uses a background color which is
common to all text characters, and that value is stored in Background
Color Register 0 (53281, $D021).  The color of the frame around the
screen is determined by the Border Color Register at 53280 ($D020).

The color of each character is determined by one nybble of the Color
RAM which starts at 55296 ($D800).  There are, however, two variations
which alter this scheme somewhat.

The first is called multicolor text mode, and is set by Bit 4 of 53270
($D016).  Instead of each bit selecting either the foreground or the
background color for each dot in the character, bit-pairs are used to
select one of four colors for each double-width dot.  This results in
the horizontal resolution being cut to four dots across per character,
but allows two extra colors to be introduced from Background Color
Registers 1 and 2 (53282-53283, $D022-$D023).

The other text mode is called Extended Background Color Mode.  In this
mode, the foreground color is always selected by the Color RAM.  The
background color depends on the actual screen code of the character.
In this mode, only the first 64 character shapes are available, but
each can have one of four different background colors.

The background color for each character is determined by its screen
code as follows:

1.  If the screen code is from 0-63 (this includes the normal
alphanumerics), the value in Background Color Register 0 (53281,
$D021) will determine the background color, as is usual.

2.  Characters with codes 64-255 will have the same shape as the
corresponding character in the group with codes 0-63.

3.  For characters with codes 64-127 (SHIFTed characters), the
background colors are deterined by the value in Background Color
Register 1 (53282, $D022).

4.  The value in Background Color Register 2 (53283, $D023) is used
for characters with codes 128-191 (reversed alphanumerics).

5.  For characters with codes 192-255, the value in Background Color
Register 3 (53284, $D024) is used to determine the background color.


In place of the normal text mode, a bitmap graphics mode is also
abailable by setting Bit 5 of location 53265 ($D011).  In this mode,
each bit of data determines whether one dot on the screen will be set
to either the background color or foreground color.  Within an 8 by 8
dot area, the foreground and background colors may be individually
selected.

The bitmap area is 320 dots wide and 200 dots high.  The area which
contains the graphics data, the bitmap, is determined by the Character
Dot Data Base Address in the lower nybble of the VIC-II Memory Control
Register (53272, $D018).  The Video Matrix Base Address in the upper
nybble, which normally determines which area of memory will be
displayed, instead determines where the color memory for each 8 by 8
ground of dots will be located.

The Color RAM is not used for high-resolution bitmap graphics.  But
multicolor mode is also available for bitmap graphics, and it uses the
Color RAM to determine the foreground color of each dot.

As with multicolor text mode, the horizontal resolution is but in half
(to 160 dots across), so that in addition to the foreground and
background colors, each dot can be one of two other colors as well.
This mode gets the value for the two extra colors from the two nybbles
of each byte of bitmap color memory, the location of which is
determined by the Video Matrix Base Address.

Multicolor text mode offers four colors, three of which will be common
to all characters, and one of which can be selected individually.
Multicolor bitmap mode offers a choice of four colors, three of which
can be individually selected within an 8 by 8 dot area.

The 64 also contains an entirely separate graphics system, whose
character shapes, colors, and positions are derived and displayed
without any reference to the Video Matrix and Character Dot-Data
addresses.  Best of all, these characters may be moved quickly and
easily to any position on the screen, greatly facilitating games and
animated graphics of all types.  This system is known as sprite
graphics.

Sprite graphics takes its name from the graphics characters it
displays, each of which is called a sprite.  There are eight sprites,
known as Sprites 0-7.  Each sprite character is 24 dots wide by 21
dots high.  This is about eight times as large as a regular text
character, which is only 8 dots wide by 8 dots high.

A sprite takes its shape from 63 bytes of data in one of the 256 data
blocks, each 64 bytes long, that can fit into the 16K space which the
VIC-II chip can address.  The block currently assigned to any given
sprite is determined by the Sprite Data Pointers, which are located at
the last eight bytes of the screen memory area (the default locations
are 2040-2047, $7F8-$7FF).

The first Sprite Data Pointer determines the data block used for the
shape of Sprite 0, the second for the shape of Sprite 1, etc.  The
number in the pointer times 64 equals the address of the first byte of
the data block within the VIC-II addressing range.

For example, using the default values for VIC-II addressing area and
screen memory, a value of 11 in location 2040 ($7F8) would mean that
the shape of Sprite0 is determined by the data in the 63-byte block
starting at location 704 (11*64).  It should be noted that it is
possible for more than one sprite to take its shape data from the same
block, so that only 64 bytes of data are required to create eight
sprites, each having the same shape.

The dot patterns of each sprite correspond to the bit patterns of the
sprite shape data.  Each byte of shape data in memory consists of a
number from 0 to 255.  This number can be represented by eight binary
digits of 0 or 1.

Each binary digit has a bit value that is two times greater than the
last.  If the digit in the zero bit place is a 1, it has a value of 1
(we count bit places from 0 to 7).  A 1 in the first bit place has a
value of 2, the second bit has a value of 4, the third has a value of
8, the fourth has a vlue of 16, the fifth a value of 32, the sixth a
value of 64, and the seventh a value of 128.

By making all of the possible combinations of 0's and 1's in all eight
bit places, and adding the bit values of every bit place that contains
a 1, we can represent every number from 0 to 255 as a series of 1's
and 0's.

If you think of every 0 as a dot having the same color as the
background, and every 1 as a dot which is the color of the sprite, you
can see how a series of bytes could be used to represent the sprite
shape.

Since each line of the sprite is 24 dots wide, it takes 3 bytes of
memory (24 bits) per line to portray its shape.  Let's take a look at
a couple of sample sprite lines.

00000000 01111110 00000000 = 0, 126, 0

As you can see, the first and last bytes are all 0's, so nothing will
be displayed there.  The middle byte has six 1's, so it will be
displayed as a line six dots long.  By adding the values of these dix
bits (64+32+16+8+4+2), we get a byte value of 126.  Let's try another
line.

00011111 11111111 11111000 = 21, 255, 248

The first byte has five bits set to 1, having values of 16, 8, 4, 2,
and 1, for a total of 31.  The second byte has all bits set to 1, so
it has the maximum value of 255.  The third byte also has five bits
set to 1, having values of 128, 64, 32, 16, and 8, for a total of 248.
The result is that this line of sprite data will display a line that
is 18 dots long.

We can put these two kinds of lines together to show how a large cross
might be drawn using bytes of sprite data."
"In the context of the C64, What is the purpose of the memory location at address $BDC0?","address         $BDC0          INPRT
Print IN Followed by a Line Number"
"In the context of the C64, What is the purpose of the memory location at address $D01D?","address              $D01D          XXPAND
Sprite Horizontal Expansion Register

Bit 0:  Expand Sprite 0 horizontally (1=double-width sprite, 0=normal
        width)
Bit 1:  Expand Sprite 1 horizontally (1=double-width sprite, 0=normal
        width)
Bit 2:  Expand Sprite 2 horizontally (1=double-width sprite, 0=normal
        width)
Bit 3:  Expand Sprite 3 horizontally (1=double-width sprite, 0=normal
        width)
Bit 4:  Expand Sprite 4 horizontally (1=double-width sprite, 0=normal
        width)
Bit 5:  Expand Sprite 5 horizontally (1=double-width sprite, 0=normal
        width)
Bit 6:  Expand Sprite 6 horizontally (1=double-width sprite, 0=normal
        width)
Bit 7:  Expand Sprite 7 horizontally (1=double-width sprite, 0=normal
        width)

This register can be used to double the width of any sprite.  Setting
any bit of this register to 1 will cause each dot of the corresponding
sprite shape to be displayed twice as wide as normal, so that without
changing its horizontal resolution, the sprite takes up twice as much
space.  The horizontal expansion feature can be used alone, or in
combination with the vertical expansion register at 53271 ($D017).

Location Range: 53278-53279 ($D01E-$D01F)
Sprite Collision Detection Registers

While Bit 2 of the VIC IRQ Register at 53273 ($D019) is set to 1
anytime two sprites overlap, and Bit 1 is set to 1, when a sprite
shape is touching the foreground text or bit-graphics display, these
registers specify which sprites were involved in the collision.  Every
bit that is set to 1 indicates that the corresponding sprite was
involved in the collision.  Reading these registers clears them so
that they can detect the next collision.  Therefore, if you plan to
make multiple tests on the values stored here, it may be necessary to
copy it to a RAM variable for further reference.

Note that while these registers tell you what sprites were involved in
a collision, they do not necessarily tell you what objects have
collided with each other.  It is quite possible to have three sprites
lined up in a row, where Sprite A is on the left, Sprite B is in the
middle, touching Sprite A, and Sprite C is on the right, touching
Sprite B but not touching Sprite A.  The Sprite-Sprite Collision
register would show that all three are involved.  The only way to make
absolutely certain which collided with which is to check the position
of each sprite, and calculate for each sprite display line if a sprite
of that size would touch either of the others.  As you can imagine,
this is no easy task.

There are a few simple rules concerning what does or does not cause a
collision.  Though the sprite character consists of 504 dots in a 24
by 21 matrix, does which represent data bits that are equal to 0 (or
multicolor bit- pairs equal to 00), and therefore always displayed in
the background color, do not count when it comes to collision.

A collision can occur only if a dot which represents a sprite shape
data bit of 1 touches another dot of nonzero graphics data.  Consider
the case of two invisible sprites.  The first sprite is enabled, its
color set to contrast the background, and it is positioned on the
screen, but its shape data bytes are all 0.  This sprite can never be
involved in a collision, because it displays no nonzero data.  The
second sprite is enabled, positioned on the screen, and its shape
pointer set for a data read that is filled with bytes having a value
of 255.  Even if that sprite's color is set to the same value as the
background color, making the sprite invisible, it can still be
involved in collisions.  The only exception to this rule is the 01
bit-pair of multicolor graphics data.  This bit-pair is considered
part of the background, and the dot it displays can never be involved
in a collision.

The other rule to remember about collisions is that they can occur in
areas that are covered by the screen border.  Collision between
sprites can occur when the sprites are offscreen, and collisions
between sprites and foreground display data can occur when that data
is in an area that is covered by the border due to the reduction of
the display to 38 columns or 24 rows."
"In the context of the C64, What is the purpose of the memory location at address $D40F?","address              $D40F          FREHI3
Voice 3 Frequency Control (high byte)"
"In the context of the C64, What is the purpose of the memory location at address $D00B?","address              $D00B          SP5Y
Sprite 5 Vertical Position"
"In the context of the C64, What is the purpose of the memory location at address $D009?","address         $D009          SP4Y
Sprite 4 Vertical Position

53258         $D00A          SP5X
Sprite 5 Horizontal Position"
"In the context of the C64, What is the purpose of the memory location at address $D410?","address              $D410          PWLO3
Voice 3 Pulse Waveform Width (low byte)"
"In the context of the C64, What is the purpose of the memory location at address $BDCD?","address         $BDCD          LINPRT
Output a Number in ASCII Decimal Digits

This routine is used to output the line number for the routine above.
It converts thenumber whose high byte is in .A and whose low byte is
in .X to a floating point number.  It also calls the routine below,
which converts the floating point number to an ASCII string."
"In the context of the C64, What is the purpose of the memory location at address $D01E?","address              $D01E          SPSPCL
Sprite to Sprite Collision Register

Bit 0:  Did Sprite 0 collide with another sprite?  (1=yes)
Bit 1:  Did Sprite 1 collide with another sprite?  (1=yes)
Bit 2:  Did Sprite 2 collide with another sprite?  (1=yes)
Bit 3:  Did Sprite 3 collide with another sprite?  (1=yes)
Bit 4:  Did Sprite 4 collide with another sprite?  (1=yes)
Bit 5:  Did Sprite 5 collide with another sprite?  (1=yes)
Bit 6:  Did Sprite 6 collide with another sprite?  (1=yes)
Bit 7:  Did Sprite 7 collide with another sprite?  (1=yes)"
"In the context of the C64, What is the purpose of the memory location at address $D024?","address              $D024          BGCOL3
Background Color 3

This register sets the background color for characters having screen
codes between 192 and 255 in extended background color text mode.  The
default color value is 3 (cyan)."
"In the context of the C64, What is the purpose of the memory location at address $73-$8A?","address       $73-$8A        CHRGET
Subroutine: Get Next BASIC Text Character

This is actually a machine language subroutine, which at the time of a
BASIC cold start (such as when the power is turned on) is copied from
MOVCHG (58274, $E3A2) in the ROM to this zero page location.

CHRGET is a crucial routine which BASIC uses to read text characters,
such as the text of the BASIC program which is being interpreted.  It
is placed on zero page to make the routine run faster.  Since it keeps
track of the address of the character being read within the routine
itself, the routine must be in RAM in order to update that pointer.
The pointer to the address of the byte currently being read is really
the operand of a LDA instruction.  When entered from CHRGET, the
routine increments the pointer by modifying the operand at TXTPTR
(122, $7A), thus allowing the next character to be read.

Entry at CHRGOT (121, $79) allows the current character to be read
again.  The CHRGET routine skips spaces, sets the various flags or the
status register (.P) to indicate whether the character read was a
digit, statement terminator, or other type of character, and returns
with the retrieved character in the Accumulator (.A).

Since CHRGET is used to read every BASIC statement before it is
executed, and since it is in RAM, and therefore changeable, it makes a
handy place to intercept BASIC to add new features and commands (and
in the older PET line, it was the only way to add such features).
Diversion of the CHRGET routine for this purpose is generally referred
to as a wedge.

Since a wedge can greatly slow down execution speed, mose of the time
it is set up so that it performs its preprocessing functions only when
in direct or immediate mode.  The most well-known example of such a
wedge is the 'Universal DOS Support' program that allows easier
communication with the disk drive command channel.

As this is such a central routine, a disassembly listing is given
below to provide a better understanding of how it works.

115 $73   CHRGET  INC TXTPTR   ; increment low byte of TXTPTR
117 $75           BNE CHRGOT   ; if low byte isn't 0, skip next
119 $77           INC TXTPTR+1 ; increment high byte of TXTPTR
121 $79   CHRGOT  LDA          ; load byte from where TXTPTR points
                               ; entry here does not update TXTPTR,
                               ; allowing you to readl the old byte again
122 $7A   TXTPTR  $0207        ; pointer is really the LDA operand
                               ; TXTPTR+1 points to 512-580 ($200-$250)
                               ; when reading from the input buffer
                               ; in direct mode
124 $7C   POINTB  CMP #$3A     ; carry flag set if > ASCII numeral 9
126 $7E           BCS EXIT     ; character is not a numeral--exit
128 $80           CMP #$20     ; if it is an ASCI space...
130 $82           BEQ CHRGET   ; ignore it and get next character
132 $84           SEC          ; prepare to subtract
133 $85           SBC #$30     ; ASCII 0-9 are between 48-57 ($30-$39)
135 $87           SEC          ; prepare to subtract again
136 $88           SBC #$D0     ; if < ASCII 0 (57, $39) then carry is set
138 $8A   EXIT    RTS          ; carry is clear only for numeral on return

The Accumulator (.A register) holds the character that was read on
exit from the routine.  Status register (.P) bits which can be tested
for on exit are:

  Carry Clear if the character was an ASCII digit 0-9.
  Carry Set, otherwise.
  Zero Set only if the character was a statement terminator 0 or an
ASCII colon, 58 ($3A).
  Zero Clear, otherwise.


One wedge insertion technique is to change CHRGET's INC $7A to a JMP
WEDGE, have your wedge update TXTPTR itself, and then JSR CHRGOT.
Another is to change the CMP #$3A at location 124 ($7C), which I have
labeled POINTB, to a JMP WEDGE, do your wedge processing, and then
exit through the ROM version of POINTB, which is located at 48283
($E3AB).  For more detailed information about wedges, see Programming
the PET/CBM, Raeto Collin West, pages 365-68.

While the wedge is a good, quick technique for adding new commands, a
much more elegant method exists for accomplishing this task on the
VIC-20 and 64 withouth slowing BASIC down to the extent that the wedge
does.  See the entries for the BASIC RAM vector area at 768-779
($300-$30B) for more details."
"In the context of the C64, What is the purpose of the memory location at address $9C?","address           $9C            DPSW
Flag: Tape Byte Received

This location is used as a flag to indicate whether a complete byte of
tape data has been received, or whether it has only been partially
received."
"In the context of the C64, What is the purpose of the memory location at address $61?","address            $61            FACEXP
Floating Point Accumulator #1: Exponent

This exponent represents the closest power of two to the number, with
129 added to take care of the sign problem for negative exponents.  An
exponent of 128 is used for the value 0; an exponent of 129 represents
2 to the 0 power, or 1; an exponent of 130 represents 2 to the first
power, or 2; 131 is 2 squared, or 4; 132 is 2 cubed, or 8; and so on."
"In the context of the C64, What is the purpose of the memory location at address $28E?","address           $28E           LSTSHF
Last Pattern of SHIFT/CTRL/Logo Keypress

This location is used in combination with the one above to debounce
the special SHIFT keys.  This will keep the SHIFT/logo combination
from changing character sets back and forth during a single pressing
of both keys.

655-656       $28F-$290      KEYLOG
Vector to Keyboard Table Setup Routine

This location points to the address of the Operating System routine
which actually determines which keyboard matrix lookup table will be
used.

The routine looks at the value of the SHIFT flag at 653 ($28D), and
based on what value it finds there, stores the address of the correct
table to use at location 245 ($F5).

The interrupt driven keyboard-scanning routine jumps through this RAM
vector to get to the table setup routine.  Therefore, it is possible
to alter the address contained in this vector, and direct the keyscan
routine to your own routine, which can check the keypress and SHIFT
combination, and act before a character is printed.

Since this routine comes after the keypress, but before it is printed,
this is a very good place to have your preprocessor routine check for
a particular keypress.  An excellent example of such a program is the
'VICword' program by Mark Niggemann, COMPUTE!'s Second Book of VIC.
This program adds a machine language routine that checks if the SHIFT
or Commodore logo key is pressed while not in quote mode.  If it finds
one of these keypresses, it substitutes an entire BASIC keyword for
the letter (A-Z) of the key that was pressed.  An adaptation of that
program for the 64 appears below.

100 IF PEEK(PEEK(56)*256)<>120THENPOKE56,PEEK(56)-1:CLR
110 HI=PEEK(56):BASE=HI*256
120 PRINTCHR$(147)'READING DATA'
130 FOR AD=0 TO 211:READ BY
140 POKE BASE+AD,BY:NEXT AD
150 :
200 REM RELOCATION ADJUSTMENTS
210 POKE BASE+26,HI:POKE BASE+81,HI
220 POKE BASE+123,HI:POKE BASE+133,HI
230 :
240 PRINT CHR$(147) TAB(15)'***64WORD***':PRINT
250 PRINT'TO TOGGLE THE PROGRAM ON/OFF:':PRINT:PRINT:PRINT 'SYS';BASE;
260 PRINT CHR$(145);CHR$(145);
270 DATA 120,173,143,2,201,32
280 DATA 208,12,169,220,141,143
290 DATA 2,169,72,141,144,2
300 DATA 88,96,169,32,141,143
310 DATA 2,169,0,141,144,2
320 DATA 88,96,165,212,208,117
330 DATA 173,141,2,201,3,176
340 DATA 110,201,0,240,106,169
350 DATA 194,133,245,169,235,133
360 DATA 246,165,215,201,193,144
370 DATA 95,201,219,176,91,56
380 DATA 233,193,174,141,2,224
390 DATA 2,208,3,24,105,26
400 DATA 170,189,159,0,162,0
410 DATA 134,198,170,160,158,132
420 DATA 34,160,160,132,35,160
430 DATA 0,10,240,16,202,16
440 DATA 12,230,34,208,2,230
450 DATA 35,177,34,16,246,48
460 DATA 241,200,177,34,48,17
470 DATA 8,142,211,0,230,198
480 DATA 166,198,157,119,2,174
490 DATA 211,0,40,208,234,230
500 DATA 198,166,198,41,127,157
510 DATA 199,2,230,198,169,20
520 DATA 141,119,2,76,72,235
530 DATA 76,224,234
550 REM TOKENS FOR SHIFT KEY
570 DATA 153,175,199,135,161,129
580 DATA 141,164,133,137,134,147
590 DATA 202,181,159,151,163,201
600 DATA 196,139,192,149,150,155
610 DATA 191,138
630 REM TOKENS FOR COMMODORE KEY
650 DATA 152,165,198,131,128,130
660 DATA 142,169,132,145,140,148
670 DATA 195,187,160,194,166,200
680 DATA 197,167,186,157,165,184
690 DATA 190,158,0"
"In the context of the C64, What is the purpose of the memory location at address $F12B?","address              $F12B
Print Kernal Error Message if in Direct Mode

This routine first checks location 157 ($9D) to see if the messages
are enabled.  If they are, it prints the message indexed by the .Y
register."
"In the context of the C64, What is the purpose of the memory location at address $29D?","address          $29D           RODBS
RS-232: Index to Start of Transmit Buffer

This index points to the starting byte within the 256-byte RS-232
transmit buffer, and is used to remove data from that buffer."
"In the context of the C64, What is the purpose of the memory location at address $308-$309?","address      $308-$309      IGONE
Vector to the Routine That Executes the Next BASIC Program Token

This vector points to the address of the GONE routine at 42980 ($A7E4)
that executes the next program token."
"In the context of the C64, What is the purpose of the memory location at address $F291?","address              $F291          CLOSE
Close a Logical I/O File

CLOSE is a documented Kernal routine which can be entered via the jump
table at 65475 ($FFC3).

The routine jumps through a RAM vector at 796 ($31C).  It is used to
close a logical file after all I/O operations involving that file have
been completed.  This is accomplished by loading the Accumulator with
the logical file number of the file to be closed, and calling this
routine.

Closing an RS-232 file will de-allocate space at the top of memory for
the receiving and trasmit buffers.  Closing a cassette file that was
opened for writing will force the last block to be written to
cassette, even if it is not a full 192 bytes.  Closing a serial bus
device will send an UNLISTEN command on the bus.  Remember, it is
necessary to properly CLOSE a cassette or disk data file in order to
retrieve the file later.

For all types of files, CLOSE removes the file's entry from the tables
of logical files, device, and secondary address at 601, 611, and 621
($259, $263, $26D), and moves all higher entries in the table down one
space."
"In the context of the C64, What is the purpose of the memory location at address $E9F0?","address              $E9F0
Set Pointer to Screen Address of Start of Line

This subroutine puts the address of the first byte of the screen line
designated by the .X register into locations 209-210 ($D1-$D2)."
"In the context of the C64, What is the purpose of the memory location at address $A09E-$A19D?","address  $A09E-$A19D    RESLST
List of Keywords

This table contains a complete list of the reserved BASIC keywords
(those combinations of ASCII text characters that cause BASIC to do
something).  The ASCII text characters of these words are stored in
token number order.  Bit #7 of the last letter of each word is set to
indicate the end of the word (the last letter has 128 added to its
true ASCII value).

When the BASIC program text is stored, this list of words is used to
reduce any keywords to a single-byte value called a token.  The
command PRINT, for example, is not stored in a program as five ASCII
bytes, but rather as the single token 153 ($99).

When the BASIC program is listed, this table is used to convert these
tokens back to ASCII text.  The entries in this table consist of the
following:

1.  The statements found in STMDSP at 40972 ($A00C), in the token
number order indicated (token numbers 128-162).

2.  Some miscellaneous keywords which never begin a BASIC statement:

Token #    Keyword
162 $A3    TAB(
164 $A4    TO
165 $A5    FN
166 $A6    SPC(
167 $A7    THEN
168 $A8    NOT
169 $A9    STEP

3.  The math operators found in OPTAB at 41088 ($A080), in the token
number order indicated (token numbers 170-179).

4.  The functions found in FUNDSP at 41042 ($A052), in the token
number order indicated (token numbers 182-202).

5.  The word GO (token number 203 ($CB)).  This word was added to the
table to make the statement GO TO legal, to afford some compatibility
with the very first PET BASIC, which allowed spaces within keywords.

41374-41767   $A19E-$A327    ERRTAB
ASCII Text of BASIC Error Messages

This table contains the ASCII text of all of the BASIC error messages.
As in the keyword table, Bit 7 of the last letter of each message is
set to indicate the end of the message.  Although we've all seen some
of them at one time or another, it's somewhat daunting to see the
whole list at once.  The possible errors you can make include:

 1.  TOO MANY FILES
 2.  FILE OPEN
 3.  FILE NOT OPEN
 4.  FILE NOT FOUND
 5.  DEVICE NOT PRESENT
 6.  NOT INPUT FILE
 7.  NOT OUTPUT FILE
 8.  MISSING FILENAME
 9.  ILLEGAL DEVICE NUMBER
10.  NEXT WITHOUT FOR
11.  SYNTAX
12.  RETURN WITHOUT GOSUB
13.  OUT OF DATA
14.  ILLEGAL QUANTITY
15.  OVERFLOW
16.  OUT OF MEMORY
17.  UNDEF'D STATEMENT
18.  BAD SUBSCRIPT
19.  REDIM'D ARRAY
20.  DIVISION BY ZERO
21.  ILLEGAL DIRECT
22.  TYPE MISMATCH
23.  STRING TOO LONG
24.  FILE DATA
25.  FORMULA TOO COMPLEX
26.  CAN'T CONTINUE
27.  UNDEF'D FUNCTION
28.  VERIFY
29.  LOAD

Message number 30, BREAK, is located in the Miscellaneous Messages
table below.

41768-41828   $A328-$A364
Error Message Vector Table

This table contains the two-byte address of the first letter of each
of the 30 error messages.

41829-41865   $A365-$A389
Miscellaneous Messages

The text of some of the other messages that BASIC can give you is
stored here.  This text includes cursor movement characters, and each
message ends with a 0 character.  The messages are:

1) Carriage return, OK, carriage return
2) Space, space, ERROR
3) Space, IN, space
4) Carriage return, linefeed, READY., carraige return, linefeed
5) Carriage return, linefeed, BREAK"
"In the context of the C64, What is the purpose of the memory location at address $EC03?","address              $EC03
Commodore Logo Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the logo keyboard, one
for each key which is struck while the Commodore logo key is pressed.
The table is in keycode order (see the keycode table in Appendix H for
the correspondence of keycode to key).  A 65th byte with the value of
255 ($FF) marks the end of the table (this corresponds to a keypress
value of 64, no key pressed)."
"In the context of the C64, What is the purpose of the memory location at address $EA87?","address              $EA87          SCNKEY
Read the Keyboard

This subroutine is called by the IRQ interrupt handler above to read
the keyboard device which is connected to CIA #1 (see entry for 56320
($DC00) for details on how to read the keyboard).

It is the Kernal routine SCNKEY which can be entered from the jump
table at 65439 ($FF9F).  This routine returns the keycode of the key
currently being pressed in 203 ($CB), sets the shift/control flag if
appropriate, and jumps through the vector at 655 ($28F) to the routine
that sets up the proper table to translate the keycode to PETASCII.
It concludes with the next routine, which places the PETASCII value of
the character in the keyboard buffer."
"In the context of the C64, What is the purpose of the memory location at address $400-$7FF?","address     $400-$7FF      VICSCN
Video Screen Memory Area

This is the default location of the video screen memory area, which
contains the video matrix and the sprite data pointers.  Keep in mind,
however, that the video screen memory area can be relocated to start
on any even 1K boundary.  Its location at any given moment is
getermined by the VIC-II chip memory control register at 53272
($D018), and the VIC-II memory bank select bits on CIA #2 Data Port A
(56576, $DD00)."
"In the context of the C64, What is the purpose of the memory location at address $EC5E?","address              $EC5E
Set Flag to Enable or Disable Switching Character Sets

This subroutine is also used to check for special characters to print.
In this case, it checks for the characters that enable or disable the
SHIFT/logo combination from toggling the character set currently in
use (CHR$(8) and CHR$(9)).  If one of these is to be printed, the flag
at 657 ($291) is changed."
"In the context of the C64, What is the purpose of the memory location at address $A052-$A07F?","address   $A052-$A07F    FUNDSP
                             TABLE
Function Dispatch Vector Table

This table contains two-byte vectors, each of which points to the
address of one of the routines that performs a BASIC function.

A function is distinguished by a following argument, in parentheses.
The expression in the parentheses is first evaluated by the routines
which begin at 44446 ($AD9E).  Then this table is used to find the
address of the function that corresponds to the token number of the
function to be executed.

The substance of this table, which can be used for locating the
addresses of these routines, is reproduced below.  Note that the
address for the USR function is 784 ($310), which is the address of
the JMP instruction which precedes the user-supplied vector."
"In the context of the C64, What is the purpose of the memory location at address $334-$33B?","address       $334-$33B
Unused

Eight free bytes for user vectors or other data."
"In the context of the C64, What is the purpose of the memory location at address $Eb48?","address              $Eb48
Set Up the Proper Keyboard Decode Table

This routine is pointed to by the vector at 655 ($28F).  Its function
is to read the shift/control flag at 653 ($28D), and set the value of
the decode table pointer at 245 ($F5) accordingly.

First it checks if the SHIFT/Commodore logo combination was pressed,
and if the toggle enable at 657 (291) will allow a change, the
character set will be changed to lowercase/uppercase or
uppercase/graphics by changing the VIC Memory Control Register at
53272 ($D018), and no character will be printed.

Next it sets the decode table pointer.  There are 64 keys, and each
can have four different PETASCII values, depending on whether the key
is pressed by itself, or in combination with the SHIFT, CTRL, or
Commodore logo keys.  Therefore, there are four tables of 64 entries
each to translate the keycode to PETASCII:  the standard table, the
SHIFT table, the Commodore logo table, and the CONTROL table.  The
routine will set up the pointer for the appropriate table, depending
on whether the SHIFT, CTRL, or logo key was pressed.  The CTRL key
takes precedence, so that if another of these keys is pressed along
with the CTRL key, the CONTROL table is used."
"In the context of the C64, What is the purpose of the memory location at address $A579?","address         $A579          CRUNCH
Tokenize Line in Input Buffer

When a line of program text has been input into the BASIC text buffer
at 512 ($200), this routine goes through the line and changes any
keywords or their abbreviations, which do not appear in quotes, into
their corresponding token.  This command is vectored through RAM at
772 ($304), so it can be diverted in order to add new commands."
"In the context of the C64, What is the purpose of the memory location at address $EF7E?","address              $EF7E
Setup to Receive a New Byte from RS-232

61"
"In the context of the C64, What is the purpose of the memory location at address $29F-$2A0?","address       $29F-$2A0      IRQTMP
SAve Area for IRQ Vector During Cassette I/O

The routines that read and write tape data are driven by an IRQ
interrupt.  In order to hook one of these routines into the interrupt,
the RAM IRQ vector at 788-789 ($314-$315) must be changed to point to
the address at which it starts.  Before that change is made, the old
IRQ vector address is saved at these locations, so that after the tape
I/O is finished, the interrupt that is used for scanning the keyboard,
checking the stop key, and updating the clock can be restored.

You will note that all of the above functions will be suspended during
tape I/O."
"In the context of the C64, What is the purpose of the memory location at address $F0A4?","address              $F0A4
Stop CIA #2 RS-232 NMIs for Serial/Cassette Routines

This subroutine turns off the NMIs that drive the RS-232 routines
before any I/O is done using the serial bus or cassette device.  Such
interrupts could throw off the timing of those I/O routines, and
interfere with the transmission of data."
"In the context of the C64, What is the purpose of the memory location at address $B0-$B1?","address       $B0-$B1        CMP0
Tape Timing

Location 176 ($B0) is used to determine the value of the adjustable
timing constant at 146 ($92).  Location 199 is also used in the timing
of tape reads.

178-179       $B2-$B3        TAPE1
Pointer: Start of Tape Buffer

On power-on, this pointer is set to the address of the cassette buffer
(828, $33C).  This pointer must contain an address greater than or
equal to 512 ($200), or an ILLEGAL DEVICE NUMBER error will be sent
when tape I/O is tried."
"In the context of the C64, What is the purpose of the memory location at address $F20E?","address              $F20E          CHKIN
Designate a Logical File As the Current Input Channel

This is a documented Kernal routine which can be entered from the jump
table at 65478 ($FFC6).

The routine jumps through a RAM vector at 798 ($31E).  If you wish to
get data from any device other than the keyboard, this routine must be
called after OPENing the device, before you can get a data byte with
the CHRIN or GETIN routine.  When called, the routine will designate
the logical file whose file number is in the .X register as the
current file, its device as the current device, and its secondary
address as the current secondary address.  If the device on the
channel is a serial device, which requires a TALK command and
sometimes a secondary address, this routine will send them over the
serial bus."
"In the context of the C64, What is the purpose of the memory location at address $30C?","address          $30C           SAREG
Storage Area for .A Register (Accumulator)"
"In the context of the C64, What is the purpose of the memory location at address $F875?","address              $F875
Common Code for Reading a Data Block from Tape and Writing a Block to Tape

This routine sets the actual reading or writing of a block of data.
It sets CIA #1 Timer B to call the IRQ which drives the actual reading
or writing routine, saves the old IRQ vector, and sets the new IRQ
vector to the read or write routine.  It also blanks the screen so
that the video chip's memory addressing (which normally takes away
some of the 6510 microprocessor's addressing time) will not interfere
with the timing of the routines."
"In the context of the C64, What is the purpose of the memory location at address $90?","address           $90            STATUS
Kernal I/O Status Word (ST)

The Kernal routines which open I/O channels or perform input/output
functions check and update this location.  The value here is almost
always the same as that returned to BASIC by use of the reserved
variable ST.  Note that BASIC syntax will not allow an assignment such
as ST=4.  A table of status codes for cassette and serial devices
follows below:

Cassette:
Bit 2 (Bit Value of 4) = Short Block
Bit 3 (Bit Value of 8) = Long Block
Bit 4 (Bit Value of 16) = Unrecoverable error (Read), mismatch
Bit 5 (Bit Value of 32) = Checksum error
Bit 6 (Bit Value of 64) = End of file

Serial Devices:
Bit 0 (Bit Value of 1) = Time out (Write)
Bit 1 (Bit Value of 2) = Time out (Read)
Bit 6 (Bit Value of 64) = EOI (End or Identify)
Bit 7 (Bit Value of 128) = Device not present

Probably the most useful bit to test is Bit 6 (end of file).  When
using the GET statement to read in individual bytes from a file, the
statement IF ST AND 64 will be true if you have got to the end of the
file.

For status codes for the RS-232 device, see the entry for location 663
($297)."
"In the context of the C64, What is the purpose of the memory location at address $9E?","address           $9E            PTR1
Tape Pass 1 Error Log Index

This location is used in setting up an error log of bytes in which
transmission parity errors occur the first time that the block is
received (each tape block is sent twice to minimize data loss from
transmission error)."
"In the context of the C64, What is the purpose of the memory location at address $31A-$31B?","address      $31A-$31B      IOPEN
Vector to Kernal OPEN Routine (Currently at 62282 ($F34A))"
"In the context of the C64, What is the purpose of the memory location at address $D020?","address              $D020          EXTCOL
Border Color Register

The color value here determines the color of the border or frame
around the central display area.  The entire screen is set to this
color when the blanking feature of Bit 4 of 53265 ($D011) is enabled.
The default color value is 14 (light blue)."
"In the context of the C64, What is the purpose of the memory location at address $BDB3?","address         $BDB3          NO999

This table of three floating point constants holds the values
99,999,999.5, 999,999,999.5 and 1,000,000,000.  These values are used
in converting strings to floating point numbers."
"In the context of the C64, What is the purpose of the memory location at address $D000-$DFFF?","address  $D000-$DFFF

This 4K block of memory is used for several key functions.  Normally,
the 6510 microprocessor addresses the two Complex Interface Adapter
(CIA) Input/Output chips here, along with the VIC-II video controller
chip, the Sound Interface Device (SID) music synthesizer, and the
Color RAM.

Alternatively, the 6510 can address the character ROM here (though
normally only the VIC-II chip has access to it).  Finally, there is
also 4K of RAM here, although to use it may require banking it in only
when necessary, as the I/O devices are needed for such niceties as
reading he keyboard, and updating the screen display.

It will appear from the map of the I/O devices below that many of the
locations are not accounted for.  That is beause these devices tie up
more addressing space than they actually use.  Each of them uses only
a few addresses, mostly on the bit level.

The missing addresses either consist of images of the hardware
registers, or cannot be addressed in this configuration.  In addition,
some address space is left open for the use of future hardware devices
which might be plugged into the expansion port, like the CP/M card.

As mentioned above, memory usage by these I/O devices is to intensive
that to work with them often requires that you turn individual bits on
and off.  Here is a quick reminder of how to manipulate bits.

The bit values for each bit are:

Bit 0 = 1
Bit 1 = 2
Bit 2 = 4
Bit 3 = 8
Bit 4 = 16
Bit 5 = 32
Bit 6 = 64
Bit 7 = 128

To set a bit to 1 from BASIC, POKE address, PEEK(address) OR Bitvalue.
To reset a bit to 0 from BASIC, POKE address, PEEK(address) AND
255-Bitvalue."
"In the context of the C64, What is the purpose of the memory location at address $D026?","address              $D026          SPMC1
Sprite Multicolor Register 1

This register sets the color that is displayed by the 11 bit-pair in
multicolor sprite graphics.  The default color value is 0 (black).

Location Range: 53287-53294 ($D027-$D02E)
Sprite Color Registers

These registers are used to set the color to be displayed by bits of
hi-res sprite data having a value of 1, and by bit-pairs of multicolor
sprite data having a value of 10.  The color of each sprite is
determined by its own individual color register."
"In the context of the C64, What is the purpose of the memory location at address $BBFC?","address         $BBFC          MOVFA
Move a Floating Point Number from FAC2 to FAC1"
"In the context of the C64, What is the purpose of the memory location at address $BBC7?","address         $BBC7          MOV2F
Move a Floating Point Number from FAC1 to Memory

This routine is used to move a number from the Floating Point
Accumulator (FAC1) to memory at either 92-96 ($5C-$60) or 87-91
($57-$5B), depending on the entry point to the routine."
"In the context of the C64, What is the purpose of the memory location at address $C000-$CFFF?","address   $C000-$CFFF
4K Free RAM

Locations 49152 to 53247 ($C000 to $CFFF) are free RAM.  Since this
area is not contiguous with the BASIC program text RAM area, it is not
available for BASIC program or variable storage (it is not counted in
the FRE(0) total).

This area is fully available for any other use, however, sudh as
storing machine language subroutines for use with BASIC, alternate I/O
drivers for parallel or IEEE devices, character graphics or sprite
data, etc.

This large free area is such a tempting spot for system additions that
many such applications may be competing for the same RAM space.  For
example, the Universal Wedge DOS Support program that adds easy access
to the disk communications channel is usually loaded at 52224 ($CC00).
Programs that use that part of RAM will therefore overwrite the DOS
support program, with the result that they may not run correctly, or
even at all.  Likewise, Simon's BASIC, the extended language which
Commodore has released on cartridge, uses several locations in this
range.  Be aware of this potential problem when you buy hardware
additions that use this spot to hook into the system."
"In the context of the C64, What is the purpose of the memory location at address $D025?","address              $D025          SPMC0
Sprite Multicolor Register 0

This register sets the color that is displayed by the 01 bit-pair in
multicolor sprite graphics.  The default color value is 4 (purple)."
"In the context of the C64, What is the purpose of the memory location at address $D01F?","address              $D01F          SPBGCL
Sprite to Foreground Collision Register

Bit 0:  Did Sprite 0 collide with the foreground display?  (1=yes)
Bit 1:  Did Sprite 1 collide with the foreground display?  (1=yes)
Bit 2:  Did Sprite 2 collide with the foreground display?  (1=yes)
Bit 3:  Did Sprite 3 collide with the foreground display?  (1=yes)
Bit 4:  Did Sprite 4 collide with the foreground display?  (1=yes)
Bit 5:  Did Sprite 5 collide with the foreground display?  (1=yes)
Bit 6:  Did Sprite 6 collide with the foreground display?  (1=yes)
Bit 7:  Did Sprite 7 collide with the foreground display?  (1=yes)

Location Range: 53280-53294 ($D020-$D02E)
VIC-II Color Register

Although these color registers are used for various purposes, all of
them have one thing in common.  Like the Color RAM Nybbles, only the
lower four bits are connected.  Therefore, when reading these
registers, you must mask out the upper four bits (that is,
BORDERCOLOR=PEEK(53280)AND15) in order to get a true reading."
"In the context of the C64, What is the purpose of the memory location at address $BD7E?","address         $BD7E          FINLOG
Add Signed Integer to FAC1

This routine is used to add an ASCII digit that has been converted to
a signed integer to FAC1."
"In the context of the C64, What is the purpose of the memory location at address $9F?","address           $9F            PTR2
Tape Pass 2 Error Log Correction Index

This location is used in correcting bytes of tape data which were
transmitted incorrectly on the first pass."
"In the context of the C64, What is the purpose of the memory location at address $$31C-$31D ?","address       $31C-$31D      ICLOSE
Vector to Kernal CLOSE Routine (Currently at 62097 ($F291))"
"In the context of the C64, What is the purpose of the memory location at address $91?","address          $91            STKEY
Flag: Was STOP Key Pressed?

This location is updated every 1/60 second during the execution of the
IRQ routine that reads the keyboard and updates the jiffy clock.

The value of the last row of the keyboard matrix is placed here.  That
row contains the STOP key, and although this location is used
primarily to detect when that key has been pressed, it can also detect
when any of the other keys in that row of the matrix have been
pressed.

In reading the keyboard matrix, a bit set to 1 means that no key has
been pressed, while a bit reset to 0 indicates that a key is pressed.
Therefore, the following values indicate the keystrokes detailed
below:

255 $FF  = no key pressed
254 $FE  = 1 key pressed
253 $FD  = (left arrow) key pressed
251 $FB  = CTRL key pressed
247 $F7  = 2 key pressed
239 $EF  = space bar pressed
223 $DF  = Commodore logo key pressed
191 $BF  = Q key pressed
127 $7F  = STOP key pressed

VIC owners will notice that the 64's keyboard matrix is very different
from the VIC's.  One of the advantages of this difference is that you
can test for the STOP key by following a read of this location with a
BPL instruction, which will cause a branch to occur anytime that the
STOP key is pressed."
"In the context of the C64, What is the purpose of the memory location at address $F864?","address              $F864
Start Writing a Block of Data to the Cassette

This subroutine tests the cassette switch and initializes various
flags for writing a block of data to cassette."
"In the context of the C64, What is the purpose of the memory location at address $F1CA?","address              $F1CA          CHROUT
Output a Byte

This is a documented Kernal routine whose jump table entry point is at
65490 ($FFD2).  The routine jumps through a RAM vector at 806 ($326).
It is probably one of the best known and most used Kernal routines,
because it sends the character in the Accumulator to the current
output device.  Unless a device has been OPENed and designated as the
current output channel using the CHKOUT routine, the character is
printed to the screen, which is the default output device.  If the
cassette is the current device, outputting a byte will only add it to
the buffer.  No actual transmission of data will occur until the
192-byte buffer is full."
"In the context of the C64, What is the purpose of the memory location at address $AE-$AF?","address       $AE-$AF        EAL
Pointer to Ending Address of Load (End of Program)

This location is set by the Kernal routine SAVE to point to the ending
address for SAVE, LOAD, or VERIFY."
"In the context of the C64, What is the purpose of the memory location at address $30A-$30B?","address      $30A-$30B      IEVAL
Vector to the Routine That Evaluates a Single-Term Arithmetic
Expression

This vector points to the address of the EVAL routinea t 44678 ($AE86)
which, among other things, is used to evaluate BASIC functions such as
INT and ABS.

Location Range: 780-783 ($30C-$30F)
Register Storage Area

The BASIC SYS command uses this area to store 6510 internal
registers--the Accumulator (.A), the .X and .Y index registers, and
the status register, .P.

Before every SYS command, each of the registers is loaded with the
value found in the corresponding storage address.  After the ML
program finished executing, and returns to BASIC with an RTS
instruction, the new value of each register is stored in the
appropriate storage address.  This is only true of SYS, not of the
similar USR command.

This feature allows you to place the necessary preentry values into
the registers from BASIC before you SYS to a Kernal or BASIC ML
routine.  It also enables you to examine the resulting effect of the
routine on the registers, and to preserve the condition of the
registers on exit for subsequent SYS calls.

An extremely practical application comes immediately to mind.
Although the 64's BASIC 2 has many commands for formatting printed
characters on the monitor screen (for example, TAB, SPC, PRINT A$,B),
there is none to adjust the vertical cursor position.

There is a Kernal routine, PLOT (58634, $E50A), which will allow you
to position the cursor anywhere on the screen.  In order to use it,
you must first clear the carry flag (set it to 0), and then place the
desired horizontal column number in the .Y register and the vertical
row number in the .X register before entering the routine with a SYS
65520.  Using the register storage area, we can print the work HELLO
at row 10, column 5 with the following BASIC line:

POKE 781,10:POKE 782,5:POKE 783,0:SYS 65520:PRINT 'HELLO'

You can also use these locations to help you take advantage of Kernal
routines that return information in the register.  For example, the
SCREEN routine (58629,$E505) returns the number of screen rows int he
.Y register, and the number of columns in the .X register.  Using this
routine, a BASIC program could be written to run on machines with
different screen formats (for example, the 64 and the VIC-20).  Just
PEEK(781) after a SYS 65517 to see how many screen columns the
computer display has."
"In the context of the C64, What is the purpose of the memory location at address $29E?","address         $29E           RODBE
RS-232: Index to End of Transmit Buffer

This index points to the ending byte within the 256-byte RS-232
transmit buffer, and is used to add data to that buffer."
"In the context of the C64, What is the purpose of the memory location at address $F086?","address              $F086
GETIN for the RS-232 Device

The Kernal GETIN routine calls this subroutine to remove the next byte
of data from the RS-232 receive buffer and return it in the
Accumulator.  The routine checks for the Receive Buffer Empty Error.
It is also called by the Kernal CHRIN routine, which essentially does
the same thing as GETIN for the RS-232 device."
"In the context of the C64, What is the purpose of the memory location at address $EF90?","address     328         $EF90
Test If Start Bit Received from RS-232"
"In the context of the C64, What is the purpose of the memory location at address $A560?","address         $A560          INLIN
Input a Line to Buffer from Keyboard

This subroutine calls the Kernal CHRIN routine (61783, $F157) to
obtain a line of input from the current input device (usually the
keyboard).  It stores the characters in the BASIC text input buffer at
512 ($200) until a carriage return or 89 characters have been
received.  The keyboard device will never return more than 80
characters before a carriage return, but other devices can output a
longer line.  An error will occur if the line goes over 80 characters."
"In the context of the C64, What is the purpose of the memory location at address $332-$333","address       $332-$333      ISAVE
Vector: Kernal SAVE Routine (Currently at 62941 ($F5DD))"
"In the context of the C64, What is the purpose of the memory location at address $EAE0?","address              $EAE0
Decode the Keystroke and Place its ASCII Value in the Keyboard Buffer

This is the continuation of the IRQ keyscan routine.  It decodes the
keycode with the proper PETASCII table, and compares it with the last
keystroke.  If if is the same, it checks to see if it is okay to
repeat the character without waiting for the key to be let up.  If the
character should be printed, it is moved to the end of the keyboard
buffer at 631 ($277)."
"In the context of the C64, What is the purpose of the memory location at address $EC44?","address              $EC44
Set Lowercase/Uppercase or Uppercase/Graphics Character Set

The part of the Kernal CHROUT routine that outputs to the screen uses
this subroutine to check for the special nonprinting characters that
switch the character set (CHR$(14) and CHR$(142)).  If one of these is
the character to be printed, this routine makes the switch by setting
the location 53272 ($D018) accordingly."
"In the context of the C64, What is the purpose of the memory location at address $A00C-$A051?","address   $A00C-$A051    STMDSP
Statement Dispatch Vector Table

This table contains two-byte vectors, each of which points to an
address which is one byte before the address of one of the routines
that perform a BASIC statement.

The statements are in token number order.  When it comes time to
execute a statement, the NEWSTT routine at 42926 ($A7AE) places this
address-1 on the stack and jumps to the CHRGET routine.  The RTS
instruction at the end of that routine causes the statement address to
be pulled off the stack, incremented, and placed in the Program
Counter, just as if it were the actual return address."
"In the context of the C64, What is the purpose of the memory location at address $A7E4?","address         $A7E4          GONE
Read and Execute the Next Statement

This is the routine which gets the next token and executes the
statement.  It is vectored through RAM at 776 ($308) to allow the
addition and execution of new statement tokens.

Since a statement must always start with a token or an implied LET
statement, this routine checks to see if the first character is a
valid token.  If it is, the address is placed on the stack, so that a
call to CHRGET will return to the address of the code that executes
the statement (see the table of statement tokens at 40972 ($A00C)).

An invalid token will cause a SYNTAX ERROR.  A character whose ASCII
value is less that 128 will cause LET to be executed."
"In the context of the C64, What is the purpose of the memory location at address $A000 to $BFFF?","Locations 40960 to 49152 ($A000 to $BFFF) are used by the BASIC ROM
when it is selected (which is the default condition).  BASIC is the
64's main program, which is always run if there is no autostart
cartridge inserted at power-up time.  When the 64 tells you READY,
that's BASIC talking.

The BASIC interpreter that comes with the 64 is, aside from being
located in a different memory space, almost identical to the Microsoft
BASIC interpreter found on the VIC-20.  Both of these interpreters are
slightly modified versions of PET BASIC 2.0, also known as PET BASIC
3.0 or Upgrade BASIC, because it was an upgraded version of the BASIC
found on the original PET.

This is a somewhat mixed blessing, because while PET BASIC was, in its
day, quote an advanced language for use with an eight-bit
microprocessor, it lacks several of the features (such as error
trapping) which are now standard on most home computers.  And, of
course, it makes no provision whatever for easy use of the many
graphics and sound capabilities made available by the new dedicated
video and sound support chips.

On the other hand, its faithfulness to the original Commodore BASIC
allows a large body of software to be translated for the 64 with
little change (in most cases, the PET Emulator program from Commodore
will allow you to run PET programs with no changes).  Programming aids
and tricks developed for the PET and VIC will, for the most part,
carry over quite nicely to the 64.  Although there is no official
source code listing of the ROM available from Commodore, this version
of BASIC has been around long enough that it has been thoroughly
disassembled, dissected, and documented by PET users.

The labels used here correspond to those used by Jim Butterfield in
his PET memory maps, which are well-known among PET BASIC users.  They
should, therefore, provide some assistance in locating equivalent
routines on the two machines.  A good description of the workings of
PET BASIC can be found in Programming the PET/CBM by Raeto West.

It is beyond the scope of this book to detail the inner workings of
each routine in the BASIC interpreter.  However, the following summary
of routines and their functions should aid the user who is interested
in calling BASIC routines from his or her own program, or in modifying
the BASIC.

Please keep in mind that the entry and exit points listed for routines
that perform a particular function are to be used as guideposts, and
not absolutes.  In fact, BASIC enters many of these routines from
slightly different places to accomplish different tasks.  Some
subroutines are called by so many commands that it is hard to say
which they belong to.  You will even find that some whole commands are
part of other commands.  Where it is important for you to know the
details of a particular routine, you will need to obtain a disassembly
of that section and look at the machine language program itself.

It should be noted that when BASIC is not neede,d it can be switched
out and the RAM underneath can be accessed by the VIC-II chip and used
for screen graphics.  See location 56576 ($DD00) for more information."
"In the context of the C64, What is the purpose of the memory location at address $ECE7?","address              $ECE7
Text for Keyboard Buffer When SHIFT/RUN is Pressed

When the SHIFT and RUN keys are pressed, the ASCII text stored here is
forced into the keyboard buffer.  That text is LOAD, carriage return,
RUN, carriage return."
"In the context of the C64, What is the purpose of the memory location at address $EA1C?","address              $EA1C
Store to Screen

This routine stores the character in the .A register to the screen
address pointed to by 209 ($D1), and stores the color in the .X
register to the address pointed to by 243 ($F3)."
"In the context of the C64, What is the purpose of the memory location at address $0400-$07E7?","address     $400-$7E7
Video Matrix: 25 Lines by 40 Columns

The video matrix is where thext screen characters are stored in RAM.
Normally, the VIC-II chip will treat each byte of memory here as a
screen display code and will display the text character that
corresponds to that byte of code.  The first byte of memory here will
be displayed in the top-left corner of the screen, and subsequent
bytes will be displayed in the columns to the right and the rows below
that character.

It is possible to make text or graphics characters appear on the
screen by POKEing their screen codes directly into this area of RAM.
For example, the letter A has a screen code value of 1.  Therefore,
POKE 1024,1 should make the letter A appear in the top-left corner of
the screen.

However, you should be aware that the most current version of the
Operating System initializes the color RAM which is used for the
foreground color of text characters to the same value as the
background color every time that the screen is cleared.  The result is
that although the POKE will put a blue A on the screen, you won't be
able to see it because it is the same color blue as the background.
This can be remedied by POKEing a different value into color RAM
(which starts at 55296 ($D800)).

A POKE 1024,1:POKE 1024+54272,1 will put a white A in the upper-left
corner of the screen.  The loop

FOR I=0 TO 255:POKE 1024+I,I:POKE 1024+54272+I,1:NEXT

will display all of the characters in white at the top of the screen.
Another solution to the color RAM problem is to fool the Operating
System into initializing the color RAM for you.  If you change the
background color to the desired foreground color before you clear the
screen, color RAM will be set to that color.  Then, all you have to do
is change the background color back to what it was.  This example will
show how it's done:

10 POKE 53281,2:REM BACKGROUND IS RED
20 PRINT CHR$(147):REM CLEAR SCREEN
30 POKE 53281,1:REM BACKGROUND IS WHITE
40 POKE 1024,1:REM RED 'A' APPEARS IN TOP LEFT CORNER"
"In the context of the C64, What is the purpose of the memory location at address $EE85?","address              $EE85
Set the Serial Clock Line Low (Active)

This subroutine clears the serial bus clock pulse output bit (Bit 4 of
CIA #2 Data Port A at 56576 ($DD00))."
"In the context of the C64, What is the purpose of the memory location at address $F6FB?","address              $F6FB
Set Kernal I/O Error Messages

This subroutine is used to handle I/O errors from Kernal I?O routines.
It calls CLRCHN to restore default I/O devices.  If Bit 6 of the flag
at 157 ($9D) is set, it prints I/O ERROR followed by the error number,
and then sets the Carry flag to indicate an error, with the error
number in the Accumulator.  The Kernal error messages are not used by
BASIC, but may be used by machine language monitors and other
applications."
"In the context of the C64, What is the purpose of the memory location at address $EF97?","address              $EF97
Put a Byte of Received Data into RS-232 Receive Buffer

This routine checks for a Receive Buffer Overrun, stores the byte just
received in the RS-232 receive buffer, and checks for Parity Error,
Framing Error, or Break Detected Error.  It then sets up to receive
the next byte.

614"
"In the context of the C64, What is the purpose of the memory location at address $BD?","address          $BD            ROPRTY
RS-232 Output Parity/Cassette Temporary Storage

This location is used by the RS-232 routines as an output parity work
byte, and by the tape as temporary storage for the current character
being read or sent."
"In the context of the C64, What is the purpose of the memory location at address $2A3?","address           $2A3
Save Area for CIA #1 Interrupt Control Register During Cassette Read"
"In the context of the C64, What is the purpose of the memory location at address $302-$303?","address      $302-$303      IMAIN
Vector to the Main BASIC Program Loop

This vector points to the address of the main BASIC program loop at
42115 ($A483).  This is the routine that is operating when you are in
the direct mode (READY).  It executes statements, or stores them as
program lines."
"In the context of the C64, What is the purpose of the memory location at address $F30F?","address              $F30F
Find the File in the Logical File Table

This subroutine is used by many Kernal routines to find the position
of the logical file in the logical file table at 601 ($259)."
"In the context of the C64, What is the purpose of the memory location at address $95?","address           $95            BSOUR
Buffered Character for Serial Bus

This is the character waiting to be sent.  A 255 ($FF) indicates that
no character is waiting for serial output."
"In the context of the C64, What is the purpose of the memory location at address $330-$331?","address       $330-$331      ILOAD
Vector to Kernal LOAD Routine (Currently at 62622 ($F49E))"
"In the context of the C64, What is the purpose of the memory location at address $9B?","address           $9B            PRTY
Tape Character Parity

This location is used to help detect when bits of information have
been lost during transmission of tape data."
"In the context of the C64, What is the purpose of the memory location at address $A?","address            $A             VERCK
Flag: LOAD or VERIFY

BASIC uses one Kernal routine to perform either the LOAD or VERIFY
function, depending on whether the Accumulator (.A) is set to 0 or 1
upon entry to the routine.  BASIC sets the value of VERCK to 0 for a
LOAD, or 1 for a VERIFY.  Its contents are passed to the Kernal LOAD
routine, which in turn stores it in location 147 ($93)."
"In the context of the C64, What is the purpose of the memory location at address $BCCC?","address         $BCCC          INT
Perform INT

This routine removes the fractional part of a floating point number by
calling the routine above to change it to an integer, and then
changing the integer back to floating point format."
"In the context of the C64, What is the purpose of the memory location at address $BDDD?","address         $BDDD          FOUT
Convert Contents of FAC1 to ASCII String

This routine converts a floating point number to a string of ASCII
digits, and sets a pointer to the string in .A and .Y."
"In the context of the C64, What is the purpose of the memory location at address $D01B?","address              $D01B          SPBGPR
Sprite to Foreground Display Priority Register

Bit 0:  Select display priority of Sprite 0 to foreground (0=sprite
        appears in front of foreground)
Bit 1:  Select display priority of Sprite 1 to foreground (0=sprite
        appears in front of foreground)
Bit 2:  Select display priority of Sprite 2 to foreground (0=sprite
        appears in front of foreground)
Bit 3:  Select display priority of Sprite 3 to foreground (0=sprite
        appears in front of foreground)
Bit 4:  Select display priority of Sprite 4 to foreground (0=sprite
        appears in front of foreground)
Bit 5:  Select display priority of Sprite 5 to foreground (0=sprite
        appears in front of foreground)
Bit 6:  Select display priority of Sprite 6 to foreground (0=sprite
        appears in front of foreground)
Bit 7:  Select display priority of Sprite 7 to foreground (0=sprite
        appears in front of foreground)

If a sprite is positioned to appear at a spot on the screen that is
already occupied by text or bitmap graphics, a conflict arises.  The
contents of this register determines which one will be displayed in
such a situation.  If the bit that corresponds to a particular sprite
is set to 0, the sprite will be displayed in front of the foreground
graphics data.  If that bit is set to 1, the foreground data will be
displayed in front of the sprite.  The default value that this
register is set to at power-on is 0, so all sprites start out with
priority over foreground graphics.

Note that for the purpose of priority, the 01 bit-pair of multicolor
graphics modes is considered to display a background color, and
therefore will be shown behind sprite graphics even if the foreground
graphics data takes priority.  Also, between the sprites themselves
there is a fixed priority.  Each sprite has priority over all
higher-number sprites, so that Sprite 0 is displayed in front of all
the others.

The use of priority can aid in creating three-dimensional effects, by
allowing some objects on the screen to pass in front of or behind
other objects."
"In the context of the C64, What is the purpose of the memory location at address $D029?","address              $D029          SP2COL
Sprite 2 Color Register (the default color value is 3, cyan)"
"In the context of the C64, What is the purpose of the memory location at address $BF7B?","address         $BF7B          FPWRT
Performs Exponentation (Power Calculation Called for by UPARROW)

This routine raises the value in FAC2 to the power in FAC1 and leaves
the result in FAC1."
"In the context of the C64, What is the purpose of the memory location at address $D01A?","address              $D01A          SP3COL
Sprite 3 Color Register (the default color value is 4, purple)"
"In the context of the C64, What is the purpose of the memory location at address $BFB4?","address         $BFB4          NEGOP
Perform NOT and >

This negates the Floating Point Accumulator by exclusive ORing the
sign byte with a constant of 255 ($FF).  Zero is left unchanged.  The
results of this command follow rom the formula NOT X=-(X+1).
Therefore, if you NOT a tatement that is true (-1), you get 0 (false)."
"In the context of the C64, What is the purpose of the memory location at address $BF11?","address         $BF11          FHALF
The Constant Value 1/2 in Five-Byte Floating Point Notation

This constant is used for rounding and SQR."
"In the context of the C64, What is the purpose of the memory location at address $D01C?","address              $D01C          SPMC
Sprite Multicolor Registers

Bit 0:  Select multicolor mode for Sprite 0 (1=multicolor, 0=hi-res)
Bit 1:  Select multicolor mode for Sprite 1 (1=multicolor, 0=hi-res)
Bit 2:  Select multicolor mode for Sprite 2 (1=multicolor, 0=hi-res)
Bit 3:  Select multicolor mode for Sprite 3 (1=multicolor, 0=hi-res)
Bit 4:  Select multicolor mode for Sprite 4 (1=multicolor, 0=hi-res)
Bit 5:  Select multicolor mode for Sprite 5 (1=multicolor, 0=hi-res)
Bit 6:  Select multicolor mode for Sprite 6 (1=multicolor, 0=hi-res)
Bit 7:  Select multicolor mode for Sprite 7 (1=multicolor, 0=hi-res)

Sprite multicolor mode is very similar to text and bitmap multicolor
modes (see Bit 4 of 53270, $D016).  Normally, the color of each dot of
the sprite is controlled by a single bit of sprite shape data.  When
thi mode is enabled for a sprite, by setting the corresponding bit of
this register to 1, the bits of sprite shape data are grouped together
in pairs, with each pair of bits controlling a double-wide dot of the
sprite display.  By sacrificing some of the horizontal resolution (the
sprite, although the same size, is now only 12 dots wide), you gain
the use of two additional colors.  The four possible combinations of
these bit-pairs display dot colors from the following sources:

00 Background Color Register 0 (transparent)
01 Sprite Multicolor Register 0 (53285, $D025)
10 Sprite Color Registers (53287-94, $D027-E)
11 Sprite Multicolor Register 1 (53286, $D026)

Like multicolor text characters, multicolor sprites all share two
color registers.  While each sprite can display three foreground
colors, only one of these colors in unique to that sprite.  The number
of unique colors may be increated by combining more than one sprite
into a single character."
"In the context of the C64, What is the purpose of the memory location at address $BCF3?","address         $BCF3          FIN
Convert an ASCII String to a Floating Point Number FAC1

This routine is called by VAL to evaluate and convert an ASCII string
to a floating point number."
"In the context of the C64, What is the purpose of the memory location at address $9?","address             $9             TRMPOS
Column position of the Cursor before the Last TAB or SPC

TRMPOS is used by TAB and SPC.  The cursor column position prior to
the TAB or SPC is moved here from 211 ($D3), and is used to calculate
where the cursor ends up after one of these functions is invoked.
Note that the value contained here shows the position of the cursor on
a logical line.  Since one logical line can be up to two physical
lines long, the value stored here can range from 0 to 79."
"In the context of the C64, What is the purpose of the memory location at address $9A?","address           $9A            DFLTO
Default Output (CMD) Device (Set to 3 for the Screen)

The default value of this location is 3, which designates the screen
as the current output device.  That value can be changed by the Kernal
routine CHKOUT (62032, $F250), which uses this location to store the
device number of the device whose file it defines as an output
channel.

BASIC calls CHKOUT whenever the command PRINT# or CMD is executed, but
clears the channel after the PRINT# operation has been completed."
"In the context of the C64, What is the purpose of the memory location at address $94?","address          $94            C3PO
Flag: Serial Bus--Output Character Was Buffered

This location is used by the serial output routines to indicate that a
character has been placed in the output buffer and is waiting to be
sent."
"In the context of the C64, What is the purpose of the memory location at address $32E-$32F?","address       $32E-$32F      USRCMD
Vector to User-Defined Command (Currently Points to BRK at 65126
($FE66))

This appears to be a holdover from PET days, when the built-in machine
language monitor would JuMP through the USRCMD vector when it
encountered a command that it did not understand, allowing the user to
add new commands to the monitor.

Although this vector is initialized to point to the routine called by
STOP/ RESTORE and the BRK interrupt, and is updated by the Kernal
VECTOR routine (64794, $FD1A), it does not seem to have the function
of aiding in the addition of new commands."
"In the context of the C64, What is the purpose of the memory location at address $304-$305?","address      $304-$305      ICRNCH
Vector to the Routine That Crunches the ASCII Text of Keywords into
Tokens

This vector points to the address of the CRUNCH routine at 42364
($A57C)."
"In the context of the C64, What is the purpose of the memory location at address $F31F?","address              $F31F
Set Current Logical File, Current Device, and Current Seconday Address

This subroutine is used to update the Kernal variables at 184-186
($B8-$BA) which holds the current logical file number, current device
number, and current secondary address number."
"In the context of the C64, What is the purpose of the memory location at address $BE?","address           $BE            FSBLK
Cassette Read/Write Block Count

Used by the tape routines to count the number of copies of a data
block remaining to be read or written."
"In the context of the C64, What is the purpose of the memory location at address $EFE1?","address     09         $EFE1
CHKOUT for the RS-232 device

The Kernal CHKOUT routine calls this subroutine to define the RS-232
device's logical file as an output channel.  Before this can be done,
the logical file must first be OPENed."
"In the context of the C64, What is the purpose of the memory location at address $2A4?","address           $2A4
Save Area for CIA #1 Control Register A During Cassette Read"
"In the context of the C64, What is the purpose of the memory location at address $F72C?","address              $F72C
Get Next Tape File Header from Cassette

This routine reads in tape blocks until it finds a file header block.
It then prints out the FOUND message along with the first 16
characters of the filename."
"In the context of the C64, What is the purpose of the memory location at address $EE13?","address              $EE13          ACPTR
Receive a Byte of Data from a Device on the Serial Bus

This is a documented Kernal routine whose entry point in the jump
table is 65445 ($FFA5).  When called, it will get a byte of data from
the current TALKer on the serial bus and store it in the Accumulator.
In order to receive the data, the device must have previously been
sent a command to TALK and a secondary address if it needs one."
"In the context of the C64, What is the purpose of the memory location at address $EA24?","address              $EA24
Synchronize Color RAM Pointer to Screen Line Pointer

This subroutine sets the pointer at 243 ($F3) to the address of the
beginning of the line of Color RAM which corresponds to the current
line of screen RAM (whose pointer is at 209 ($D1))."
"In the context of the C64, What is the purpose of the memory location at address $7F8-$7FF?","address     $7F8-$7FF
Sprite Shape Data Pointers

The last eight bytes of the video matrix (whether it is here at the
default location, or has been relocated elsewhere) are used as
pointers to the data blocks used to define the sprite shapes.

Each sprite is 3 bytes wide (24 bits) by 21 lines high.  It therefore
requires 63 bytes for its shape definition, but it actually uses 64
bytes in order to arrive at an even 256 shape blocks in the 16K area
of RAM which the VIC-II chip addresses.

Each pointer holds the current data block being used to define the
shape of one sprite.  The block numver used to define the shape of
Sprite 0 is held in location 2040 ($7F8), the Sprite 1 shape block is
designated by location 2041 ($7F9), etc.  The value in the pointer
times 64 equals the starting location of the sprite shape data table.
For example, a value of 11 in location 2040 indicates that the shape
data for Sprite 0 starts at address 704 (11*64), and continues for 63
more bytes to 767.

For additional information on sprite graphics, see the entries for
individual VIC-II chip sprite graphics locations, and the summary at
the beginning of the VIC-II chip section, at 53248 ($D000)."
"In the context of the C64, What is the purpose of the memory location at address $A000-$A001?","address  $A000-$A001
Cold Start Vector

This vector points to the address of the routine used to initialize
BASIC.  After the Operating System finishes its power-on activities,
it enters the BASIC program through this vector.  The most visible
effect of the BASIC initialization routine is that the screen is
cleared, and the words:

     **** COMMODORE 64 BASIC V2 ****

are printed along with the BYTES FREE message.  For details of the
steps taken during the initialization of BASIC, see the entry for
58260 ($E394), the current cold start entry point."
"In the context of the C64, What is the purpose of the memory location at address $ECF0?","address              $ECF0
Low Byte Table of Screen Line Addresses

This table holds the low byte of the screen address for lines 0-24.
The high byte is derived from combining a value from the screen line
link table at 217 ($D9) with the pointer to screen memory at 648
($288)."
"In the context of the C64, What is the purpose of the memory location at address $A81D?","address         $A81D          RESTOR
Perform RESTORE

The RESTORE command simply resetes the DATA pointer at 65-66 ($41-$42)
from the start of BASIC pointer at 43-44 ($2B-$2V)."
"In the context of the C64, What is the purpose of the memory location at address $E87C?","address              $E87C
Move Cursor to Next Line

This subroutine moves the cursor down to the next line if possible, or
scrolls the screen if the cursor is on the last line."
"In the context of the C64, What is the purpose of the memory location at address $1000-$1FFF?","address     $1000-$1FFF
Character ROM Image for VIC-II Chip When Using Memory Bank 0 (Default)

Though the VIC-II chip shares memory with the 6510 processor chip, it
does not always see that memory in exactly the same way as the main
microprocessor.

Although the 6510 accesses RAM at these locations, when the VIC-II is
banked to use the first 16K of RAM (which is the default condition),
it sees the character ROM here (the 6510 cannot access this ROM unless
it is switched into its memory at 49152 ($C000)).  This solves the
riddle of how the VIC-II chip can use the character ROM at 49152
($C000) for character shape data and RAM at 1024 ($400), when it can
only address memory within a 16K range.  It also means that the RAM at
4096-8191 cannot be used for screen display memory or user-defined
character dot data, and sprite data blocks 64-127 are not accessible.

You can verify this by turning on bitmap graphics with the screen
memory set to display addresses from 0 to 8192.  You will see that the
bottom portion of the screen shows all of the text character shapes
stored in the ROM.  For more information on the format of text
character data storage, see the description of the Character ROM at
49152 ($C000)."
"In the context of the C64, What is the purpose of the memory location at address $EA13?","address              $EA13
Set Cursor Blink Timing and Color Memory Address for Print to Screen

This subroutine sets the cursor blink countdown and sets the pointer
to Color RAM.  It then falls through to the next routine."
"In the context of the C64, What is the purpose of the memory location at address $ECB9?","address              $ECB9
Video Chip Register Default Table

This table contains the default values that are stored in the 47
VIC-II chip registers.  It is interesting to note that this table
appears to be incomplete.  While Sprite Color Registers 0-6 are
initialized to values of 1-7, Sprite Color Register 7 is initialized
to 76--the ASCII value of the letter L which begins on the next table."
"In the context of the C64, What is the purpose of the memory location at address $A004-$A00B?","address  $A004-$A00B
ASCII Text characters CBMBASIC

The ASCII characters for the letters CBMBASIC are located here.
Possibly an identifier, this text is not referenced elsewhere in the
program."
"In the context of the C64, What is the purpose of the memory location at address $29B?","address          $29B           RIDBE
RS-232: Index to End of Receive Buffer

This index points to the ending byte within the 256-byte RS-232
receive buffer, and is used to add data to that buffer."
"In the context of the C64, What is the purpose of the memory location at address $F333?","address              $F333          CLRCHN
Restore Current Input and Output Devices to the Default Devices

This is a documented Kernal Routine which can be entered at location
65484 ($FFCC) in the jump table.

The routine jumps through a RAM vector at 802 ($322).  It sets the
current input device to the keyboard, and the current output device to
the screen.  Also, if the current input device was formerly a serial
device, the routine sends it an UNTALK command on the serial bus, and
if a serial device was formerly the current output device, the routine
sends it an UNLISTEN command."
"In the context of the C64, What is the purpose of the memory location at address $300-$301?","address       $300-$301      IERROR
Vector to the Print BASIC Error Message Routine

This vector points to the address of the ERROR routine at 58251
($E38B)."
"In the context of the C64, What is the purpose of the memory location at address $2A2?","address           $2A2
Indicator of CIA #1 Control Register B Activity During Cassette I/O"
"In the context of the C64, What is the purpose of the memory location at address $F04D?","address              $F04D
CHKIN for the RS-232 Device

The Kernal CHKIN routine calls this subroutine to define the RS-232
device's logical file as an input channel.  A prerequisite for this is
that the logical file first be OPENed."
"In the context of the C64, What is the purpose of the memory location at address $98?","address           $98            LDTND
Number of Open I/O Files/Index to the End of File Tables

The number of currently open I/O files is stored here.  The maximum
number that can be open at one time is ten.  The number stored here is
used as the index to the end of the tables that hold the file numbers,
device numbers, and secondary address numbers (see locations 601-631
($259-$277) for more information about these tables).

CLOSE decreases this number and removes entries from the tables
referred to above, while OPEN increases it and adds the appropriate
information to the end of the tables.  The Kernal routine CLALL closes
all files by setting this number to 0, which effectively empties the
table."
"In the context of the C64, What is the purpose of the memory location at address $92?","address           $92            SVXT
Timing Constant for Tape Reads

This location is used as an adjustable timing constant for tape reads,
which can be changed to allow for the slight speed variation between
tapes."
"In the context of the C64, What is the purpose of the memory location at address $70?","address           $70            FACOV
Low Order Mantissa Byte of Floating Point Accumulator #1 (For
Rounding)

If the mantissa of the floating point number has more significant
figures than can be held in four bytes, the least significant figures
are placed here.  They are used to extend the accuracy of intermediate
mathematical operations and to round to the final figure."
"In the context of the C64, What is the purpose of the memory location at address $D406?","address              $D406          SUREL1
Voice 1 Sustain/Release Control Register

Bits 0-3:  Select release cycle duration (0-15)
Bits 4-7:  Select sustain volume level (0-15)

Bits 4-7 select the volume level at which the note is sustained.
Following the decay cycle, the volume of the output of voice 1 will
remain at the selected sustain level as long as the gate bit of the
Control Register is set to 1.  The sustain values range from 0, which
chooses no volume, to 15, which sets the output of voice 1 equal to
the peak volume achieved during the attack cycle.

Bits 0-3 determine the length of the release cycle.  This phase, in
which the volume fades from the sustain level to near zero volume,
begins when the gate bit of the Control Register is set to 0 (while
leaving the waveform setting that was previously chosen).  The
duration of this decline in volume corresponds to the number (0-15)
selected in the same way as for the decay value:

0 = 6 milliseconds           8 = 300 milliseconds
1 = 24 milliseconds          9 = 750 milliseconds
2 = 48 milliseconds         10 = 1.5 seconds
3 = 72 milliseconds         11 = 2.4 seconds
4 = 114 milliseconds        12 = 3 seconds
5 = 168 milliseconds        13 = 9 seconds
6 = 204 milliseconds        14 = 15 seconds
7 = 240 milliseconds        15 = 24 seconds

Location Range: 54279-54292 ($D407-$D414)
Voice 2 and Voice 3 Controls

The various control registers for these two voices correspond almost
exactly to those of voice 1.  The one exception is that the sync and
ring-modulation bits of voice 2 operate on Oscillators 1 and 2, while
the same bits of the Control Register for voice 3 uses Oscillators 2
and 3."
"In the context of the C64, What is the purpose of the memory location at address $BFED?","address         $BFED          EXP
Perform EXP

This routine calculates the natural logarithm e (2.718281828...)
raised to the power in FAC1.  The result is left in FAC1.

This routine is split between the BASIC ROM wich ends at 49151 ($BFFF)
and the Kernal ROM which begins at 57344 ($E000).  Therefore, a JMP
$E000 instruction is tacked on to the end, which makes the BASIC
routines in the 64 Kernal ROM three bytes higher in memory than the
corresponding VIC-20 routines."
"In the context of the C64, What is the purpose of the memory location at address $D028?","address              $D028          SP1COL
Sprite 1 Color Register (the default color value is 2, red)"
"In the context of the C64, What is the purpose of the memory location at address 53274 ($D01A)?","address     3274         $D01A          IRQMASK
IRQ Mask Register

Bit 0:  Enable Raster Compare IRQ (1=interrupt enabled)
Bit 1:  Enable IRQ to occure when sprite collides with display of
  normal
        graphics data (1=interrupt enabled)
Bit 2:  Enable IRQ to occur when two sprites collide (1=interrupt
  enabled)
Bit 3:  Enable light pen to trigger an IRQ (1=interrupt enabled)
Bits 4-7:  Not used

This register is used to enable an IRQ request to occur when one of
the VIC-II chip interrupt conditions is met.  In order to understand
what that means, and how these interrupts can extend the range of
options available to a programmer, you must first understand what an
interrupt is.

An interrupt is a signal given to the microprocessor (the brains of
the computer) that tells it to stop executing its machine language
program (for example, BASIC), and to work on another program for a
short time, perhaps only a fraction of a second.  After finishing the
interrupt program, the computer goes back to executing the main
program, just as if there had never been a detour.

Bit 0.  This bit enables the Raster Compare IRQ.  The conditions for
this IRQ are met when the raster scan reaches the video line indicated
by the value written to the Raster Register at 53266 ($D012) and Bit 7
of 53265 ($D011).  Again, an explanation of the terminology is in
order.

In the normal TV display, a beam of electrons (raster) scans the
screen, starting in the top-left corner, and moving in a straight line
to the right, lighting up appropriate parts of the screen line on the
way.  When it comes to the right edge, the beam moves down a line, and
starts again from the left.  There are 262 such line that are scanned
by the 64 display, 200 of which form the visible screen area.  This
scan updates the complete screen display 60 times every second.

The VIC-II chip keeps track of which line is being scanned, and stores
the scan number in the Raster Register at 53266 and 53265 ($D012 and
$D011).  The Raster Register has two functions.  When read, it tells
what line is presently being scanned.  But when written to, it
designates a particular scan line as the place where a raster
interrupt will occur.

At the exact moment that the raster beam line number equals the number
written to the register, Bit 0 of the status register will be set to
1, showing that the conditions for a Raster Compare Interrupt have
been fulfulled.  If the raster interrupt is enabled then,
simultaneously, the interrupt program will be executed.  This allows
the user to reset any of the VIC-II registers at any point in the
display, and thus change character sets, background color, or graphics
mode for only a part of the screen display.

The interrupt routine will first check if the desired condition is the
source of the interrupt (see above entry) and then make the changes to
the screen display.  Once you have written this interrupt routine, you
must take the following steps to install it.

1.  Set the interrupt disable flag in the status register with an SEI
instruction.  This will disable all interrupts and prevent th system
from crashing while you are changing the interrupt vectors.

2.  Enable the raster interrupt.  This is done by setting Bit 0 of the
VIC- II chip interrupt enable register at location 53274 ($D01A) to 1.

3.  Indicate the scan line on which you want the interrupt to occur by
writing to the raster registers.  Don't forget that this is a nine-bit
value, and you must set both the low byte (in location 53266 ($D012))
and the high bit (in the register at 53265 ($D011)) in order to insure
that the interrupt will start at the scan line you want it to, and not
256 lines earlier or later.

4.  Let the computer know where the machine language routine that you
want the interrupt to execute starts.  This is done by placing the
address in the interrupt vector at locations 788-789 ($314-$315).
This address is split into two parts, a low byte and a high byte, with
the low byte stored at 788.

To calculate the two values for a given address AD, you may use the
formula HIBYTE=INT(AD/156) and LOWBYTE=AD-(HIBYTE*256).  The value
LOWBYTE would go into location 788, and the value HIBYTE would go into
location 789.

5.  Reenable interrupts with a CLI instruction, which clears the
interrupt disable flag on the status register.

When the computer is first turned on, the interrupt vector is set to
point to the normal hardware timer interrupt routine, the one that
advances the jiffy clock and reads the keyboard.  Since this interrupt
routine uses the same vector as the raster interrupt routine, it is
best to turn off the hardware timer interrupt by putting a value of
127 in location 56333 ($DC0D).

If you want the keyboard and jiffy clock to function normally while
your interrupt is enabled, you must preserve the contents of locations
788 and 789 before you change them to point to your new routine.  Then
you must have your interrupt routine jump to the old interrupt routine
exactly once per screen refresh (every 1/60 second).

Another thing that you should keep in mind is that at least two raster
interrupts are required if you want to change only a part of the
screen.  Not only must the interrupt routine change the display, but
it must also set up another raster interrput that will change it back.

The sample program below uses a raster-scan interrupt to divide the
display into three sections.  The first 80 scan lines are in
high-resolution bitmap mode, the next 40 are regular text, and the
last 80 are in multicolor bitmap mode.  The screen will split this way
as soon as a SYS to the routine that turns on the interrupt occurs.
The display will stay split even after the program ends.  Only if you
hit the STOP and RESTORE keys together will the display return to
normal.

The interrupt uses a table of values that are POKEd into four key
locations during each of the three interrupts, as well as values to
determine at what scan lines the interrupt will occur.  The locations
affected are Control Register 1 (53265, $D011), Control Register 2
(53270, $D016), the Memory Control Register (53272, $D018), and
Background Color 0 (53281, $D021).  The data for the interrupt routine
is contained in lines 49152-49276.  Each of these line numbers
corresponds to the locations where the first data byte in the
statement is POKEd into memory.

If you look at lines 49264-49276 of the BASIC program, you will see
REMark statements that explain which VIC-II registers are affected by
the DATA statements in each line.  The number in these DATA
startements appear in the reverse order in which they are put into the
VIC register.  For example, line 49273 holds the data that will go
into Control Register 2.  The last number, 8, is the one that will be
placed into Control Register 2 while the top part of the screen is
displayed.  The first number, 24, is placed into Control Register 2
during the bottom part of the screen display, and changes that portion
of the display to multicolor mode.

The only tricky part in determining which data byte affects which
interrupt comes in line 49264, which holds the data that determines
the scan line at which each interrupt will occur.  Each DATA statement
entry reflects the scan line at which the next interrupt will occur.
The first item in line 49264 is 49.  Even though this is the entry for
the third interrupt, the next to be generates is the first interrupt,
which occurs at the top of the screen.  Likewise, the last data item
of 129 is used during the first interrupt to start the next interrupt
at scan line 129.

Try experimenting with these values to see what results you come up
with.  For example, if you change the number 170 to 210, you will
increase the text area by five lines (40 scan lines).

By changing the values in the data tables, you can alter the effect of
each interrupt.  Change the 20 in line 49276 to 22, and you will get
lowercase text in the middle of the screen.  Change the first 8 in
line 49273 to 24, and you'll get multicolor text in the center window.
Each of these table items may be used exactly like you would use the
corresponding register, in order to change background color, to obtain
text or bitmap graphics, regular or multicolor modes, screen blanking
or extended background color mode.

It is even possible to change the table values during a program, by
POKEing the new value into the memory location where those table
values are stored.  In that way, you can, for example, change the
background color of any of the screen parts while the program is
running.

5 FOR I=0 TO 7:BI(I)=2^I:NEXT
10 FOR I=49152 TO 49278:READ A:POKE I,A:NEXT:SYS12*4096
20 PRINT CHR$(147):FOR I=0 TO 8:PRINT:NEXT
30 PRINT'THE TOP AREA IS HIGH-RES BIT MAP MODE'
40 PRINT:PRINT'THE MIDDLE AREA IS ORDINARY TEXT '
50 PRINT:PRINT'THE BOTTOM AREA IS MULTI-COLOR BIT MAP'
60 FORG=1384 TO 1423:POKE G,6:NEXT
70 FORG=1024 TO 1383:POKEG,114:POKE G+640,234:NEXT
80 A$='':FOR I=1 TO 128:A$=A$+'@':NEXT:FOR I=32 TO 63 STEP 2
90 POKE 648,I:PRINT CHR$(19)CHR$(153);A$;A$;A$;A$:NEXT:POKE 648,4
100 BASE=2*4096:BK=49267
110 H=40:C=0:FORX=0TO319:GOSUB150:NEXT
120 H=160:C=0:FORX=0TO319STEP2:GOSUB150:NEXT:C=40
125 FORX=1TO319STEP2:GOSUB150:NEXT
130 C=80:FOR X=0 TO 319 STEP2:W=0:GOSUB150:W=1:GOSUB150:NEXT
140 GOTO 140
150 Y=INT(H+20*SIN(X/10+C)):BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504)
160 POKE BY,PEEK(BY) OR (BI(ABS(7-(XAND7)-W))):RETURN
49152 DATA 120, 169, 127, 141, 13, 220
49158 DATA 169, 1, 141, 26, 208, 169
49164 DATA 3, 133, 251, 173, 112, 192
49170 DATA 141, 18, 208, 169, 24, 141
49176 DATA 17, 208, 173, 20, 3, 141
49182 DATA 110, 192, 173, 21, 3, 141
49188 DATA 111, 192, 169, 50, 141, 20
49194 DATA 3, 169, 192, 141, 21, 3
49200 DATA 88, 96, 173, 25, 208, 141
49206 DATA 25, 208, 41, 1, 240, 43
49212 DATA 190, 251, 16, 4, 169, 2
49218 DATA 133, 251, 166, 251, 189, 115
49224 DATA 192, 141, 33, 208, 189, 118
49230 DATA 192, 141, 17, 208, 189, 121
49236 DATA 192, 141, 22, 208, 189, 124
49242 DATA 192, 141, 24, 208, 189, 112
49248 DATA 192, 141, 18, 208, 138, 240
49254 DATA 6, 104, 168, 104, 170, 104
49260 DATA 64, 76, 49, 234
49264 DATA 49, 170, 129 :REM SCAN LINES
49267 DATA 0, 6, 0:REM BACKGROUND COLOR
49270 DATA 59, 27,59:REM CONTROL REG. 1
49273 DATA 24, 8, 8:REM CONTROL REG. 2
49276 DATA 24, 20, 24:REM MEMORY CONTROLRUN

Besides enabling the creation of mixed graphics-modes screens, the
Raster Compare Interrupt is also useful for creating scrolling zones,
so that some parts of the screen can be fine-scrolled while the rest
remains stationary.

Bit 1 enables the light pen interrupt.  This interrupt can occur when
the light of the raster beam strikes the light-sensitive device in the
pen's tip, causing it to close the fire button switch on joystick
Controller Port #1.

The light pen interrupt affords a method of signaling to a program
that the pen is being held to the screen, and that its position can be
read.  Some light pens provide a push-button switch which grounds one
of the other lines on the joystick port.  This switch can be pressed
by the user as an additional signal that the pen is properly
positioned.  Its location can then be read in the light pen position
registers (53267-8, $D013-4).

Bit 2 enables the sprite-foreground collision interrupt.  This
interrupt can occur if one of the srpte character's dots is touching
one of the dots from the foreground display of either text character
or bitmap graphics.

Bit 3 enables the sprite-sprite collision interrupt, which can occur
if one of the sprite character's dots is touching one of the dots of
another sprite character.

These two interrupts are useful for games, where such collisions often
require that some action be taken immediately.  Once the interrupt
signals that a collision has occurred, the interrupt routine can check
the Sprite- Foreground Collision Register at 53279 ($D01F), or the
Sprite-Sprite Collision Register at 53278 ($D01E), to see which sprite
or sprites are involved in the collision.  See the entry for those
locations for more details on collisions."
"In the context of the C64, What is the purpose of the memory location at address $BF3A?","address         $BF3A          FDCEND
Table of Constants for TI$ Conversion

This table contains the floating point representation of the powers of
-60 multiplied by 1 or 10.  These constants are used for converting
TI$ to ASCII."
"In the context of the C64, What is the purpose of the memory location at address $D015?","address              $D015          SPENA
Sprite Enable Register

Bit 0:  Enable Sprite 0 (1=sprite is on, 0=sprite is off)
Bit 1:  Enable Sprite 1 (1=sprite is on, 0=sprite is off)
Bit 2:  Enable Sprite 2 (1=sprite is on, 0=sprite is off)
Bit 3:  Enable Sprite 3 (1=sprite is on, 0=sprite is off)
Bit 4:  Enable Sprite 4 (1=sprite is on, 0=sprite is off)
Bit 5:  Enable Sprite 5 (1=sprite is on, 0=sprite is off)
Bit 6:  Enable Sprite 6 (1=sprite is on, 0=sprite is off)
Bit 7:  Enable Sprite 7 (1=sprite is on, 0=sprite is off)

In order for any sprite to be displayed, the corresponding bit in this
register must be set to 1 (the default for this location is 0).  Of
course, just setting this bit along will not guarantee that a sprite
will be shown on the screen.  The Sprite Data Pointer must indicate a
data area that holds some values other than 0.  The Sprite Color
Register must also contain a value other than that of the background
color.  In addition, the Sprite Horizontal and Vertical Position
Registers must be set for positions that lie within the visible screen
range in order for a sprite to appear on screen."
"In the context of the C64, What is the purpose of the memory location at address $D016?","address              $D016          SCROLX
Horizontal Fine Scrolling and Control Register

Bits 0-2:  Fine scroll display horizontally by X dot positions (0-7)
Bit 3:  Select a 38-column or 40-column text display (1=40 columns,
  0=38 columns)
Bit 4:  Enable multicolor text or multicolor bitmap mode (1=multicolor on,
  0=multicolor off)
Bit 5:  Video chip reset (0=normal operations, 1=video completely off)
Bits 6-7:  Unused

This is one of the two important multifunction control registers on
the VIC-II chip.  On power-up, it is set to a default value of 8,
which means that the VIC chip Reset line is set for a normal display,
Multicolor Mode is disabled, a 40-column text display is selected, and
no horizontal fine-scroll offset is used.

Bits 0-2.  The first three bits of this chip control vertical fine
scrolling of the screen display.  This feature allows you to smoothly
move the entire text display back and forth, enabling the display area
to act as a window, scrolling over a larger text or character graphics
display.

Since each text character is eight dots wide, moving each character
over one whole character position (known as coarse scrolling) is a
relatively big jump, and the motion looks jerky.  By placing a number
from 1 to 7 into these three bits, you can move the whole screen
display from one to seven dot spaces to the right.

Stepping through values 1 to 7 allows you to smoothly make the
transition from having a character appear at one screen column to
having it appear at the next one over.  To demonstrate this, type in
the following program, LIST, and RUN it.

10 FOR I=1 TO 50:FOR J=0 TO 7
20 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I
30 FOR I=1 TO 50:FOR J=7 TO 0 STEP-1
40 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I

As you can see, after the display has moved over seven dots, it starts
over at its original position.  In order to continue with the scroll,
you must do a coarse scroll every time the value of the scroll bits
goes from 7 to 0, or from 0 to 7.  This is accomplished by moving each
byte of display data on each line over one position, overwriting the
last character, and introducing a new byte of data on the opposite end
of the screen line to replace it.

Obviously, only a machine language program can move all of these bytes
quickly enough to maintain the effect of smooth motion.  The following
BASIC program, however, will give you an idea of what the combination
of fine and coarse scrolling looks like.

10 POKE 53281,0:PRINT CHR$(5);CHR$(147):FOR I=1 TO 5:PRINT CHR$(17):NEXT
20 FOR I=1 TO 30
30 PRINT TAB(I-1)'{UP}{10 SPACES}{UP}'
40 WAIT53265,128:POKE53270,PEEK(53270)AND248:PRINTTAB(I)'AWAY WE GO'
50 FOR J=1 TO 7
60 POKE 53270,(PEEK(53270)AND248)+J
70 FORK=1TO30-I
80 NEXT K,J,I:RUN

Changing the value of the three horizontal scroll bits will affect the
entire screen display.  If you wish to scroll only a portion of the
screen, you will have to use raster interrupts (see 53274 ($D01A)
below) to establish a scroll zone, change the value of these scroll
bits only when that zone is being displayed, and change it back to 0
afterward.

Bit 3.  Bit 3 of this register allows you to cover up the first and
last columns of the screen display with the border.  Since the viewers
cannot see the characters there, they will not be able to see you
insert a new character on the end of the line when you do coarse
scrolling (see explanation of Bits 0-2 above).

Setting this bit to 1 enables the normal 40-column display, while
resetting it to 0 changes the display to 38 columns.  This is a purely
cosmetic aid, and it is not necessary to change the screen to the
smaller size to use the scrolling feature.

Bit 4.  This bit selects multicolor graphics.  The effect of setting
this bit to 1 depends on whether or not the bitmap graphics mode is
also enabled.

If you are not in bitmap mode, and you select multicolor text
character mode by setting this bit to 1, characters with a color
nybble whose value is less than 8 are displyed normally.  There will
be one background color and one foreground color.  But each dot of a
character with a color nybble whose value is over 7 can have any one
of four different colors.

The two colors in the Background Control Registers 1 and 2 (53282-3,
$D022-3) are available in addition to the colors supplied by the Color
RAM.  The price of these extra colors is a reduction in horizontal
resolution.  Instead of each bit controlling one dot, in multicolor
mode a pair of bits control the color of a larger dot.  A pattern of
11 will light it with the color from the lower three bits of color
RAM.  Patterns of 01 and 10 will select the colors from Background
Color Registers 1 and 2, respectively, for the double-width dot.

You can see the effect that setting this bit has by typing in the
following BASIC command line:

POKE 53270,PEEK(53280)OR16:PRINT CHR$(149)'THIS IS MULTICOLOR MODE'

It is obvious from this example that the normal set of text characters
was not made to be used in multicolor mode.  In order to take
advantage of this mode, you will need to design custom four-color
characters.  For more information, see the alternate entry for 53248
($D000), the Character Generator ROM.

If the multicolor and bitmap enable bits are both set to 1, the result
is a multicolor bitmap mode.  As in multicolor text mode, pairs of
graphics data bits are used to set each dot in a 4 by 8 matrix to one
of four colors.  This results in a reduction of the horizontal
resolution to 160 double-wide dots across.  But while text multicolor
mode allows only one of the four colors to be set individually for
each 4 by 8 dot area, bitmap multicolor mode allows up to three
different colors to be individually selected in each 4 by 8 dot area.
The source of the dot color for each bit-pair combination is shown
below:

00 Background Color Register 0 (53281, $D021)
01 Upper four bits of Video Matrix
10 Lower four bits of Video Matrix
11 Color RAM nybble (area starts at 55296 ($D800))

The fact that bit-pairs are used in this mode changes the strategy for
plotting somewhat.  In order to find the byte BY in which the desired
bit-pair resides, you must multiply the horizontal position X, which
has a value of 0- 159, by 2, and then use the same formula as for
hi-res bitmap mode.

Given that the horizontal position (0-159) of the dot is stored in the
variable X, its vertical position is in the variable Y, and the base
address of the bitmap area ia in the variable BASE, you can find the
desired byte with the formula:

BY=BASE+(Y AND 248)*40+(Y AND 7)+(2*X AND 504)

Setting the desired bit-pair will depend on what color you chose.
First, you must set up an array of bit masks.

CA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64

To turn on the desired dot, select a color CO from 0 to 3
(representing the color selected by the corresponding bit pattern) and
execute the following statement:

BI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR (CO*CA(BI))

The following program will demonstrate this technique:

10 CA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64:REM ARRAY FOR BIT PAIRS
20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
30 POKE53265,PEEK(53265)OR32:POKE53270,PEEK(53270)OR16:REM MULTI-COLOR BIT MAP
40 A$='':FOR I=1 TO 37:A$=A$+'C':NEXT:PRINT CHR$(19);
50 FOR I=1 TO 27:PRINT A$;:NEXT:POKE 2023,PEEK(2022): REM SET COLOR MAP
60 A$='':FOR I=1 TO 128:A$=A$+'@':NEXT:FOR I=32 TO 63 STEP 2
70 POKE648,I:PRINTCHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLR HI-RES SCREEN
80 FOR CO=1TO3:FOR Y=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM
90 X=INT(10*CO+15*SIN(CO*45+Y/10)): REM SINE WAVE SHAPE
100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X*2 AND 504): REM FIND HI-RES BYTE
110 BI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR(CO*CA(BI))
120 NEXT Y,CO
130 GOTO 130: REM LET IT STAY ON SCREEN

Bit 5:  Bit 5 controls the VIC-II chip Reset line.  Setting this bit
to 1 will completely stop the video chip from operating.  On older
64s, the screen will go black.  It should always be set to 0 to insure
normal operation of the chip.

Bits 6 and 7.  These bits are not used.

53271         $D017          YXPAND
Sprite Vertical Expansion Register

Bit 0:  Expand Sprite 0 vertically (1=double height, 0=normal height)
Bit 1:  Expand Sprite 1 vertically (1=double height, 0=normal height)
Bit 2:  Expand Sprite 2 vertically (1=double height, 0=normal height)
Bit 3:  Expand Sprite 3 vertically (1=double height, 0=normal height)
Bit 4:  Expand Sprite 4 vertically (1=double height, 0=normal height)
Bit 5:  Expand Sprite 5 vertically (1=double height, 0=normal height)
Bit 6:  Expand Sprite 6 vertically (1=double height, 0=normal height)
Bit 7:  Expand Sprite 7 vertically (1=double height, 0=normal height)

This register can be used to double the height of any sprite.  When
the bit in this register that corresponds to a particular sprite is
set to 1, each dot of the 24 by 21 sprite dot matrix will become two
raster scan lines high instead of one."
"In the context of the C64, What is the purpose of the memory location at address $D018?","address              $D018          VMCSB
VIC-II Chip Memory Control Register

Bit 0:  Unused
Bits 1-3:  Text character dot-data base address within VIC-II address
  space
Bits 4-7:  Video matrix base address within VIC-II address space

This register affects virtually all graphics operations.  It
determines the vase address of two very important data areas, the
Video Matrix, and the Character Dot-Data area.

Bits 1-3.  These bits are used to set the location of the Character
Dot-Data area.  This area is where the data is stored (for more
information on character shape data, see the alternate entry for
location 53248 ($D000), the Character Generator ROM).

Bits 1-3 can represent any even number from 0 to 14.  That numer
stands for the even 1K offset of the character data area from the
beginning of VIC-II memory.  For example, if these bits are all set to
0, it means that the character memory occupies the first 2K of VIC-II
memory.  If they equal 2, the data area starts 2*1K (2*1024) or 2048
bytes from the beginning of VIC memory.

The default value of this nybble is 4.  This sets the address of the
Character Dot-Data area to 4096 ($1000), which is the starting address
of where the VIC-II chip addresses the Character ROM.  The normal
character set which contains uppercase and graphics occupies the first
2K of that ROM.  The alternate character set which contains both
upper- and lowercase letters use the second 2K.  Therefore, to shift
to the alternate character set, you must change the value of this
nybble to 6, with a POKE 53272,PEEK(53272)OR2.  To change it back,
POKE 53272,PEEK(53272)AND253.

In bitmap mode, the lower nybble controls the location of the bitmap
screen data.  Since this data area can start only at an offset of 0 or
8K from the beginning of VIC-II memory, only Bit 3 of the Memory
Control Register is significant in bitmap mode.  If Bit 3 holds a 0,
the offset is 0, and if it holds a 1, the offset is 8192 (8K).

Bits 4-7.  This nybble determines the starting address of the Video
Matrix area.  This is the 1024-byte area of memory which contains the
screen codes for the text characters that are displayed on the screen.
In addition, the last eight bytes of this area are used as pointers
which designate which 64- byte block of VIC-II memory will be used as
shape data for each sprite.

These four bits can represent numbers from 0 to 15.  These numbers
stand for the offset (in 1K increments) from the beginning of VIC-II
memory to the Video Matrix.

For example, the default bit pattern is 0001.  This indicates that the
Video Matrix is offset by 1K from the beginning of VIC-II memory, the
normal starting place for screen memory.  Remember, though, the bit
value of this number will be 16 times what the bit pattern indicates,
because we are dealing with Bits 4-7.  Therefore, the 0001 in the
upper nybble has a value of 16.

Using this register, we can move the start of screen memory to any 1K
boundary within the 16K VIC-II memory area.  Just changing this
register, however, is not enough if you want to use the BASIC line
editor.  The editor looks to location 648 ($288) to determine where to
print screen characters.

If you just change the location of the Video Matrix without changing
the value in 648, BASIC will continue to print characters in the
memory area starting at 1024, even though that area is no longer being
displayed.  The result is that you will not be able to see anything
that you type in on the keyboard.  To fix this, you must POKE 648 with
the page number of the starting address of screen memory (page
number=location/256).  Remember, the actual starting address of screen
memory depends not only on the offset from the beginning of VIC-II
memory in the register, but also on which bank of 16K is used for
VIC-II memory.

For example, if the screen area starts 1024 bytes from the beginning
of VIC- II memory, and the video chip is using Bank 2 (32768-49151),
the actual starting address of screen memory is 32768+1024=33792
($8400).  For examples of how to change the video memory area, and of
how to relocate the screen, see the entro for 56576 ($DD00).

53273         $D019          VICIRQ
VIC Interrupt Flag Register

Bit 0:  Flag:  Is the Raster Compare a possible source of an IRQ?
        (1=yes)
Bit 1:  Flag:  Is a collision between a sprite and the normal graphics
        display a possible source of an IRQ?  (1=yes)
Bit 2:  Flag:  Is a collision between two sprites a possible source of
        an IRQ?  (1=yes)
Bit 3:  Flag:  Is the light pen trigger a possible source of an IRQ?
        (1=yes)
Bits 4-6:  Not used
Bit 7:  Flag:  Is there any VIC-II chip IRQ source which could cause
        an IRQ?  (1=yes)

The VIC-II chip is capable of generating a maskable request (IRQ) when
certain conditions relating to the video display are fulfilled.
Briefly, the conditions that can cause a VIC-II chip IRQ are:

1.  The line number of the current screen line being scanned by the
raster is the same as the line number value written to the Raster
Register (53266, $D012).

2.  A sprite is positioned at the same location where normal graphics
data are being displayed.

3.  Two sprites are positioned so that they are touching.

4.  The light sensor on the light pen has been struck by the raster
beam, causing the fire button switch on joystick Control Port #1 to
close (pressing the joystick fire button can have the same effect).

When one of these conditions is met, the corresponding bit in this
status register is set to 1 and latched.  That means that as long as
the corresponding enable bit in the VIC IRQ Mask register is set to 1,
and IRQ requested will be generated, and any subsequent fulfillment of
the same condition will be ignored until the latch is cleared.

This allows you to preserve multiple interrupt requests if more than
one of the interrupt conditions is met at a time.  In order to keep an
IRQ source from generating another request after it has been serviced,
and to enable subsequent interrupt conditions to be detected, the
interrupt service routine must write a 1 to the corresponding bit.
This will clear the latch for that bit.  The default value written to
this register is 15, which clears all interrupts.

There is only 1 IRQ vector that points to the address of the routine
that will be executed when an IRQ interrupt occurs.  The same routine
will therefore be executed regardless of the source of the interrupt.
This status register provides a method for that routine to check what
the source of the IRQ was, so that the routine can take appropriate
action.  First, the routine can check Bit 7.  Anytime that any of the
other bits in the status register is set to 1, Bit 7 will also be set.
Therefore, if that bit holds a 1, you know that the VIC-II chip
requested an IRQ (the two CIA chips which are the other sources of IRQ
interrupts can be checked in a similar manner).  Once it has been
determined that the VIC chip is responsible for the IRQ, the
individual bits can be tested to see which of the IRQ conditions have
been met.

For more information, and a sample VIC IRQ program, see the following
entry.

5"
"In the context of the C64, What is the purpose of the memory location at address $BF1C?","address         $BF1C          FOUTBL
Powers of Minus Ten Constants Table

This table contains the powers of -10 expressed as four-byte floating
point numbers (that is, -1; +10; -100; +1000; -10,000; +100,000;
-1,000,000; +10,000,000; and -100,000,000)."
"In the context of the C64, What is the purpose of the memory location at address $BFBF?","address         $BFBF          EXPCON
Table of Constants for EXP and LOG in Five-Byte Floating Point Format

These tables are used to calculate 2 to the N power."
"In the context of the C64, What is the purpose of the memory location at address $D027?","address              $D027          SP0COL
Sprite 0 Color Register (the default color value is 1, white)"
"In the context of the C64, What is the purpose of the memory location at address $D405?","address              $D405          ATDCY1
Voice 1 Attack/Decay Register

Bits 0-3:  Select decay cycle duration (0-15)
Bits 4-7:  Select attack cycle duration (0-15)

Bits 4-7 control the duration of the attack cycle.  This is the period
of time over which the volume will rise from 0 to its peak amplitude.
There are 16 durations which may be selected.  The way in which the
number placed here corresponds to the elapsed time of this cycle is as
follows:

0 = 2 milliseconds           8 = 100 milliseconds
1 = 8 milliseconds           9 = 250 milliseconds
2 = 16 milliseconds         10 = 500 milliseconds
3 = 24 milliseconds         11 = 800 milliseconds
4 = 38 milliseconds         12 = 1 second
5 = 56 milliseconds         13 = 3 seconds
6 = 68 milliseconds         14 = 5 seconds
7 = 80 milliseconds         15 = 8 seconds

Bits 0-3 control the length of the decay phase, in which the volume of
the note declines from the peak reached in the attack phase to the
sustain level.  The number selected corresponds to the length of this
phase as shown below:

0 = 6 milliseconds           8 = 300 milliseconds
1 = 24 milliseconds          9 = 750 milliseconds
2 = 48 milliseconds         10 = 1.5 seconds
3 = 72 milliseconds         11 = 2.4 seconds
4 = 114 milliseconds        12 = 3 seconds
5 = 168 milliseconds        13 = 9 seconds
6 = 204 milliseconds        14 = 15 seconds
7 = 240 milliseconds        15 = 24 seconds

Since the two functions share one register, you must multiply the
attack value by 16 and add it to the decay value in order to come up
with the number to be placed in the register:

REGISTER VALUE=(ATTACK*16)+DECAY"
"In the context of the C64, What is the purpose of the memory location at address $71-$72?","address       $71-$72        FBUFPT
Series Evaluation Pointer

This location points to the address of a temporary table of values
built in the free RAM area for the evaluation of formulas.  It is also
used for such various purposes as a TI$ work area, string setup
pointer, and work space for the evaluation of the size of an array.

Although this is labeled a pointer to the tape buffer in the
Programmer's Reference Guide, disassembly of the BASIC ROM reveals no
reference to this location for that purpose (see 178 ($B2) for pointer
to tape buffer)."
"In the context of the C64, What is the purpose of the memory location at address $93?","address           $93            VERCK
Flag for Load Routine: 0=LOAD, 1=VERIFY

The same Kernal routine can perform either a LOAD or VERIFY, depending
on the value stored in the Accumulator (.A) on entry to the routine.
This location is used to determine which operation to perform."
"In the context of the C64, What is the purpose of the memory location at address $99?","address           $99            DFLTN
Default Input Device (Set to 0 for Keyboard)

The default value of this location is 0, which designates the keyboard
as the current input device.  That value can be changed by the Kernal
routine CHKIN (61966, $F20E), which uses this location to store the
device number of the device whose file it defines as an input channel.

BASIC calls CHKIN whenever the command INPUT# or GET# is executed, but
clears the channel after the input operation has been completed."
"In the context of the C64, What is the purpose of the memory location at address $2A1?","address          $2A1           ENABL
RS-232 Interrupts Enabled

This location holds the active NMI interrupt flag byte from CIA #2
Interrupt Control Register (56589, $DD0D).  The bit values for this
flag are as follows:

Bit 4: 1 (bit value of 16) = System is Waiting for Receiver Edge
Bit 1: 1 (bit value of 2)  = System is Receiving Data
Bit 0: 1 (bit value of 1)  = System is Transmitting Data"
"In the context of the C64, What is the purpose of the memory location at address $F014?","address              $F014
CHROUT for the RS-232 Device

The Kernal CHROUT routine calls this subroutine to output a character
to the RS-232 device.  After the logical file has been OPENed and set
for output using CHKOUT, the CHROUT routine is used to actually send a
byte of data."
"In the context of the C64, What is the purpose of the memory location at address $F32F?","address              $F32F          CLALL
Close All Logical I/O Files

CLALL is a documented Kernal routine whose entry point in the jump
table is 65511 ($FFE7).

The routine jumps through a RAM vector at 812 ($32C).  It closes all
open files, by resetting the index into open files at 152 ($98) to
zero.  It then falls through to the next routine, which restores the
default I/O devices."
"In the context of the C64, What is the purpose of the memory location at address $2A7-$2FF?","address       $2A7-$2FF
Unused

The programmer may use this area for machine language subroutines, or
for graphics data storage.

If the VIC-II ship is using the bottom 16K for graphics and memory
(the default setting when the system is turned on), this is one of the
few free areas available for storing sprite or character data.
Locaitons 704-767 could be used for sprite data block number 11,
without interfering with BASIC program text or variables.

Location Range: 768-779 ($300-$30B)
BASIC Indirect Vector Table

Several important BASIC routines are vectored through RAM.  This means
that the first instruction executed by the routine is an indirect jump
to a location pointed to by one of the vectors in this table.

On power up, the system sets these vectors to point to the next
instruction past the original JuMP instruction.  The routine then
continues with that instruction as if the jump never took place.  For
example, the BASIC error message routine starts at 42039 ($A437) with
the instruction JMP ($300).  The indirect vector at 768 ($300) points
to 42042 ($A43A), which is the instruction immediately following JMP
($300).

Although this may seem like a fancy way of accomplishing nothing,
using these indirect vectors serves two important purposes.  First, it
allows you to use these important BASIC routines without knowing their
addresses in the BASIC ROM.

For example, the routine to LIST the ASCII text of the single-byte
BASIC program token that is currently in the Accumulator (.A) is
located at one address in the VIC, and another in the 64.  On future
Commodore computers it may be found at still another location.  Yet as
long as the routine is vectored in RAM at 774 ($306), the statement
QP=PEEK(774)+256*PEEK(775) would find the address of that routine on
any of the machines.  Thus, entering such routines through RAM vectors
rather than a direct jump into the ROMs helps to keep your programs
compatible with different machines.

The other important effect of having these vectors in RAM is that you
can alter them.  In that way, you can redirect these important BASIC
routines to execute your own preprocessing routines first.

If you wanted to add commands to BASIC, for example, how would you go
about it?  First, you would need to change the BASIC routines that
convert ASCII program text to tokenized program format, so that when a
line of program text was entered, the new keyword would be stored as a
token.

Next, you would need to change the routine that executes tokens, so
that when the interpreter comes to your new keyword token, it will
take the proper action.

You would also have to change the routine that converts tokens back to
ASCII text, so that your program would LIST the token out correctly.
And you might want to alter the routine that prints error messages, to
add new messages for your keyword.

As you will see, vectors to all of these routines can be found in the
following indirect vector table.  Changing these vectors is a much
more elegant and efficient solution than the old wedge technique
discussed at location 115 ($73)"
"In the context of the C64, What is the purpose of the memory location at address $299-$29A?","address       $299-$29A      BAUDOF
Time Required to Send a Bit

This location holds the prescaler value used by CIA #2 timers A and B.

These timers cause an NMI interrupt to drive the RS-232 receive and
transmit routines CLOCK/PRESCALER times per second each, where CLOCK
is the system 02 frequency of 1,022,730 Hz (985,250 if you are using
the European PAL television standard rather than the American NTSC
standard), and PRESCALER is the value stored at 56580-1 ($DD04-5) and
56582-3 ($DD06-7), in low-byte, high-byte order.  You can use the
following formula to figure the correct prescaler value for a
particular RS-232 baud rate:

PRESCALER=((CLOCK/BAUDRATE)/2)-100

The American (NTSC standard) prescaler values for the standard RS-232
baud rates which the control register at 659 ($293) makes available
are stored in a table at 65218 ($FEC2), starting with the two-byte
value used for 50 baud.  The European (PAL standard) version of that
table is located at 58604 ($E4EC).

Location Range: 667-670 ($29B-$29E)
Byte Indices to the Beginning and End of Receive and Transmit Buffers

The two 256-byte First In, First Out (FIFO) buffers for RS-232 data
reception and transmission are dynamic wraparound buffers.  This means
that the starting point and the ending point of the buffer can change
over time, and either point can be anywhere withing the buffer.  If,
for example, the starting point is at byte 100, the buffer will fill
towards byte 255, at which point it will wrap around to byte 0 again.
To maintain this system, the following four locations are used as
indices to the starting and the ending point of each buffer."
"In the context of the C64, What is the purpose of the memory location at address $EC78?","address              $EC78
Control Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the Control keyboard,
one for each key which is struck while the CTRL key is pressed.  The
table is in keycode order (see the keycode table in Appendix H for the
correspondence of keycode to key).  A 65th byte with the value of 255
($FF) marks the end of the table (this corresponds to a keypress value
of 64, no key pressed).

The only keys generally struck in combination with the CTRL key are
the ones that change the colors on the top row of the keyboard, but
this doesn't necessarily mean that the other CTRL key combinations
don't do anything.  On the contrary, looking at the values in this
table, you can see that any of the first 32 values in the PETASCII
table can be produced by some combination of the CTRL key and another
key.  CTRL-@ produces a CHR$(0).  CTRL-A through CTRL-Z produce
CHR$(1) through CHR$(26).  Ctrl-: is the same as CHR$(27), CTRL-Lira
(that's the slashed-L British pound sign) produces CHR$(28), CTRL-;
equals CHR$(29), CTRL-up arrow produces CHR$(30), and CTRL-= produces
CHR$(31).

Any of these combinations produce the same effect as the CHR$(X)
statement.  For examble, CTRL-; moves the cursor over to the right,
CTRL-N switches to lowercase, CTRL-R turns on reverse video, and
CTRL-E changes the printing to white."
"In the context of the C64, What is the purpose of the memory location at address $A002-$A003?","address  $A002-$A003
Warm Start Vector

The warm start vector points to the address of the routines used to
reset BASIC after the STOP/RESTORE key combination is pressed.  This
is the same address to which the BRK instruction is vectored.  When
BASIC is entered through this vector, the program in memory is not
disturbed.  For more information, see the entry for 58235 ($E37B), the
current warm start entry point."
"In the context of the C64, What is the purpose of the memory location at address $800-$9FFF?","address    $800-$9FFF
BASIC Program Text

This is the area where the actual BASIC program text is stored.  The
text of a BASIC program consists of linked lines of program tokens.
Each line contains the following:

1.  A two-byte pointer to the address of the next program line (in
standard low-byte, high-byte order).  After the last program line, a
link pointer consisting of two zeros marks the end of the program.

2.  A two-byte line number (also in low-byte, high-byte order).

3.  The program commands.  Each keyword is stored as a one-byte
character whose value is equal to or greater than 128.  Print, for
example, is stored as the number 151.  Other elements of the BASIC
command, such as the variable names, string literals ('HELLO'), and
numbers, are stored using their ASCII equivalents.

4.  A 0 character, which acts as a line terminator.  In order for
BASIC to work correctly, the first character of the BASIC text area
must be 0.

A quick review of the BASIC pointers starting at 43 ($2B) reveals that
the layout of the BASIC program area (going from lower memory
addresses to higher) is as follows:

BASIC Program Text
Non-Array Variables and String Descriptors
Array Variables
Free Area (Reported by FRE(0))
String Text Area (Strings build from top of memory down into free area)
BASIC ROM

It is interesting to note that the NEW command does not zero out the
text area but rather replaces the first link address in the BASIC
program with two zeros, indicating the end of the program.  Therefore,
you can recover a program from a NEW by replacing the first link
adress, finding the address of the two zeros that actually mark the
end of the program, and setting the pointers at 45, 47, and 49 (which
all point to the end of a BASIC program before the program is RUN) to
the byte following these zeros."
"In the context of the C64, What is the purpose of the memory location at address $E9FF?","address              $E9FF
Clear Screen Line

This subroutine writes space characters to an entire line of screen
memory, and clears the corresponding line of color memory to color in
Background Color Register 0 (53281, $D021)."
"In the context of the C64, What is the purpose of the memory location at address $E716?","address              $E716
Output to the Screen

This is the main entry point for the part of CHROUT that handles
output to the screen device.  It takes an ASCII character number, and
tests if the character is printable.  If it is, it prints it (taking
into consideration the reverse flag, if any inserts are left, etc.).
If it is a nonprinting character, the routine performs the appropriate
cursor movement, color change, screen clearing, or whatever else might
be indicated."
"In the context of the C64, What is the importance of delaying the reading of the POT register in the C64 and C128 when using a mouse driver, and how can it be ensured?","SID Register Cautions

In  the  C64 & C128,  the  SID  POT  lines  are connected to both
joystick  ports.  A 4066 analog switch is used  to switch the POT
lines  between  the  two  ports based on one of the keyboard scan
lines.  This  means that the normal keyscan interrupt temporarily
affects the values returned in the POT registers.  Therefore,  in
order  to  perform  reliable  conversions,  the POT lines must be
connected  to  the mouse for a period >1.6 millisecond before the
value in the POT register is valid.

The best way to insure this is to wedge the mouse driver software
into the IRQ handler prior  to the polled keyscan.  This more-or-
less assures that the keyscan lines have been sufficiently stable
before the POT register is read by the mouse drivers."
"In the context of the C64, What is the BASIC program code for a 1351 mouse driver on a Commodore 64?","BASIC PROGRAM FOR 1351 MOUSE AND C64


start tok64 data64.prg
 100 GOSUB 140:GOSUB 330
 110 V=13*4096:POKE V+21,1:POKE V+39,1:POKEV+0,100:POKE V+1,100:\
     POKE V+16,0
 120 POKE 2040,56:SYS 12*4096+256
 130 END
 140 FOR X=0 TO 129:READ A$:GOSUB 430:POKE 49408+X,Y:NEXT X:RETURN
 150 DATA AD,15,03,C9,C1,F0,19,08
 160 DATA 78,AD,14,03,8D,00,C0,AD
 170 DATA 15,03,8D,01,C0,A9,21,8D
 180 DATA 14,03,A9,C1,8D,15,03,28
 190 DATA 60,D8,AD,19,D4,AC,02,C0
 200 DATA 20,58,C1,8C,02,C0,18,6D
 210 DATA 00,D0,8D,00,D0,8A,69,00
 220 DATA 29,01,4D,10,D0,8D,10,D0
 230 DATA AD,1A,D4,AC,03,C0,20,58
 240 DATA C1,8C,03,C0,38,49,FF,6D
 250 DATA 01,D0,8D,01,D0,6C,00,C0
 260 DATA 8C,05,C0,8D,04,C0,A2,00
 270 DATA 38,ED,05,C0,29,7F,C9,40
 280 DATA B0,07,4A,F0,12,AC,04,C0
 290 DATA 60,09,C0,C9,FF,F0,08,38
 300 DATA 6A,A2,FF,AC,04,C0,60,A9
 310 DATA 00,60
 320 REM ------------------------
 330 FOR X=0 TO 63:READ A$:GOSUB 430:POKE 3584+X,Y:NEXT X:RETURN
 340 DATA F8,00,00,90,00,00,B8,00
 350 DATA 00,DC,00,00,8E,00,00,07
 360 DATA 00,00,02,00,00,00,00,00
 370 DATA 00,00,00,00,00,00,00,00
 380 DATA 00,00,00,00,00,00,00,00
 390 DATA 00,00,00,00,00,00,00,00
 400 DATA 00,00,00,00,00,00,00,00
 410 DATA 00,00,00,00,00,00,00,00
 420 REM ------------------------
 430 Y=1:Y1=0
 440 IF LEFT$(A$,1)<>MID$('0123456789abcdef',Y,1) THEN Y=Y+1:\
     GOTO 440
 450 Y1=(Y-1)*16:Y=1
 460 IF RIGHT$(A$,1)<>MID$('0123456789abcdef',Y,1) THEN Y=Y+1:\
     GOTO 460
 470 Y=Y1+Y-1:RETURN"
"In the context of the C64, What is the operational mode of a mouse that tracks movement internally and transmits position data to the SID POTX and POTY registers every 512 microseconds without requiring software intervention?","Proportional Mode

In proportional mode the mouse operates as follows:
1) Mouse  movement  is  tracked internally within the mouse.  The
   position of the mouse MOD 64  is  transmitted to the SID  POTX
   and  POTY  registers  every  512  microsecond  and requires no
   software intervention.
   The  POTX  register  is  used  to read X position of the mouse
   and the POTY register is used to read Y position of the mouse.
   The register contents are as follows:

                    +-------------------------------+
   Bit Position     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
                    +---+---+---+---+---+---+---+---+
   POT Register     | X | P5| P4| P3| P2| P1| P0| N |
                    +-------------------------------+
   where:
        X ......... is a don't care bit.
        P5-P0 ..... is the mouse position MOD 64.
        N ......... is a special (noise) bit (keep reading...).

2) The  left  mouse  button  is  mapped to what would be the fire
   button on a joystick.
3) The  right  mouse  button  is  mapped to what would be that UP
   direction on a joystick.

Software Interface

1) Because  the  left and right buttons appear as joystick lines,
   reading  them  from  software is a simple exercise in polling.
   Note that as with a joystick,  the buttons will interfere with
   the  keyboard  map,  and  software  should make some effort to
   distinguish between point short in the keyboard matrix  (i.e.,
   a  key  being  depressed),  and  a  whole  row or column being
   grounded (i.e., a joystick type of signal).
2) The  position information is not difficult to handle.  Ideally
   is  should be installed as part of the 60 Hz interrupt routine
   (preferably  at  the  beginning  --  see  the  section  on SID
   Register Cautions).
   This strategy is as follows:
   1) Read the mouse position MOD 64.
   2) Determine  if  the mouse has moved by comparing the current
      position with a saved copy of the previous position.
   3) If  the mouse has moved,  then modify your pointer position
      appropriately.
      You  should  note,  that even if the mouse is still,  it is
      possible for the POT register  to oscillate between $80 and
      $7F.  This  would result in the mouse position as jittering
      between two points.

In  order  to  ascertain  whether  the mouse has moved the software
should read the low order bit of the POT register.

All of this can be seen in the supplied mouse driver code."
"In the context of the C64, How does the mouse operate in joystick mode?","In joystick mode the mouse operates as follows:
1) If the mouse is moved, then the appropriate joystick lines are
   activated for a period of 20 ms. Thus moving the mouse is like
   pushing the joystick in the appropriate direction.
2) The  left  mouse  button  is  mapped to what would be the fire
   button on a joystick.
3) The  right  mouse button is mapped into the SID POTX register.
   If  the  button  is depressed  then the SID POTX register will
   contain a number <$80. If the button is not depressed then SID
   POTX will contain a number >=$80.
4) See the section on SID Register Cautions.

Software Interface

For  most  applications,  the  interface for joystick mode should
be  just  as  any joystick driver, and the right button should be
ignored."
"In the context of the C64, What are the features and modes of operation of the Commodore 1351 Mouse(TM)?","The  Commodore  1351  Mouse(TM)  is a controller designed for use
with  the  Commodore 64(R)  or  Commodore 128(TM)  computers.  It
features two buttons on the top, and a ball on the underside that
is rolled upon a flat surface to manipulate onscreen activity.

The  mouse  has  two  modes  of  operation  --  joystick mode and
proportional mode.

In  joystick  mode,  the  mouse  emulates  a  joystick and can be
used  with all joystick-compatible  software.  In this mode,  the
left  button  is  the fire button and the right button is usually
ignored.

In   proportional  mode,  the  mouse  uses  a  new  technique  to
communicate   mouse   movement  to  the  controlling  application
software.  That requires  the software to know the mouse is there
and  how to read it.  For example,  the GEOS(TM) operating system
can  use  many  different  input  drivers.  One  of  them  is the
Commodore  Mouse  driver,  which  can  be  used  with the 1351 in
proportional mode.

The  1351  provides a proportional mode  so that applications can
have a fast,  responsive pointer that moves easily on the screen.
Joystick mode acts as a fallback for those for those applications
that don't have installable device drivers. You can therefore use
the mouse as a joystick for older software, and take advantage of
the   benefits   provided   by   proportional   mode  with  newer
applications.

The mouse automatically powers up in proportional mode. To choose
joystick mode,  plug  the  mouse into either joystick port on the
side  of  the  computer  and  hold  down the right button  as the
computer is powered up."
"In the context of the C64, What are the steps to clean a computer mouse?","Mouse Cleaning

Since the ball of your mouse roll freely to accurately manipulate
the cursor  (or whatever) on the screen,  it's important that the
ball remains free of dirt or debris.  This is easily accomplished
by sliding out the plastic piece holding the ball in place.


Remove  the  ball  and  wipe  it off with a soft cloth, such as a
handkerchief.


To remove any dirt or dust  from the ball area,  just blow gently
into the opening.  Around the top of the opening, there are three
metal rollers. To clean these, take cotton-tipped swab, moistened
with head cleaning fluid or alcohol, and gently clean the surface
of each roller.  Replace the ball inside the controller  and snap
the plastic piece back on."
"In the context of the C64, What are the features and operating modes of the Commodore 1351 mouse for use with the C64/C128 product line?","The  Commodore 1351 mouse  for use with the C64/C128 product line
is a small two-button device  which is connected to either of the
joystick ports on the C64/C128.

The mouse supports two distinct operating modes:
1) Joystick mode.
2) Proportional mode.

Proportional  mode  is  usable  with  the  C64  or the C128,  and
requires  a  special  machine  language  driver  to yield optimum
performance.

Mode selection is determined when the mouse is powered up. If the
user  depresses the right mouse button when the device is powered
up, then the mouse will be in joystick mode.

If  the  user  does  not  depress the right mouse button when the
device is powered up, then the mouse will default to proportional
mode.

Joystick  mode allows you to utilize the mouse as a joystick when
using software which does not support proportional mode."
"In the context of the C64, What are some important tips for the proper care and use of a computer mouse?","Mouse Tips

Proper care and use of your mouse requires common sense.

Use your mouse on a clean, smooth surface.

Make  sure  you  have  adequate  desktop space to manipulate your
mouse, so you don't have to constantly pick up and reposition it.

Don't  hold  the mouse by its cord,  or let the body of the mouse
hang off the table."
"In the context of the C64, What is the assembly code for a Commodore 128 mouse driver for BASIC 7.0 applications?",";
;       C128 MOUSE DRIVER FOR BASIC 7.0 APPLICATIONS
;
IIRQ    = $0314
VIC     = $D000         ; VIC REGISTERS
SID     = $D400         ; SID REGISTERS
POTX    = SID+$19
POTY    = SID+$1A
;
ACTIVE  = $117E         ; IF ZERO, THEN MOVE SPRITE
;
XPOS    = VIC+$00       ; LOW ORDER X POSITION
YPOS    = VIC+$01       ; Y POSITION
XPOSMSB = VIC+$10       ; BIT 0 IS HIGH ORDER X POSITION
;
        *=$18F0
IIRQ2   *=*+2
OPOTX   *=*+1
OPOTY   *=*+1
NEWVALUE        *=*+1
OLDVALUE        *=*+1
;
        * = $1800
;
INSTALL LDA IIRQ+1
        CMP #>MIRQ
        BEQ L90
        PHP
        SEI
        LDA IIRQ
        STA IIRQ2
        LDA IIRQ+1
        STA IIRQ2+1

        LDA #<MIRQ
        STA IIRQ
        LDA #>MIRQ
        STA IIRQ+1
;
        PLP
L90     RTS
;
MIRQ    CLD             ; JUST IN CASE.....
        LDA ACTIVE      ; IF    BASIC IS MOVING SPRITE
        BNE L90         ;       LET BASIC HAVE IT ( WHY NOT ? )
        LDA POTX        ; GET DELTA VALUES FOR X
        LDY OPOTX
        JSR MOVCHK
        STY OPOTX
;
        CLC             ; MODIFY LOW ORDER X POSITION
        ADC XPOS
        STA XPOS
        TXA
        ADC #$00
        AND #%00000001
        EOR XPOSMSB
        STA XPOSMSB
;
        LDA POTY        ; GET DELTA VALUE FOR Y
        LDY OPOTY
        JSR MOVCHK
        STY OPOTY
;
        SEC             ; MODIFY Y POSITION ( DECREASE Y FOR
                        ;                     INCRESE IN POT )
        EOR #$FF
        ADC YPOS
        STA YPOS
;
        JMP (IIRQ2)     ; CONTINUE W/ IRQ OPERATION
;
; MOVCHK
;       ENTRY   Y    = OLD VALUE OF POT REGISTER
;               A    = CURRENT VALUE OF POT REGISTER
;       EXIT    Y    = VALUE TO USE FOR OLD VALUE
;               X, A = DELTA VALUE FOR POSITION
;
MOVCHK  STY OLDVALUE    ; SAVE OLD &  NEW VALUES
        STA NEWVALUE
        LDX #0          ; PRELOAD X W/ 0
;
        SEC             ; A <=  MOD64( NEW-OLD )
        SBC OLDVALUE
        AND #%01111111
        CMP #%01000000  ; IF      > 0
        BCS L50
        LSR A           ;         A <= A/2
        BEQ L80         ;         IF      <> 0
        LDY NEWVALUE    ;                 Y <= NEWVALUE
        RTS             ;                 RETURN
;
L50     ORA #%11000000  ; ELSE    OR IN HIGH ORDER BITS
        CMP #$FF        ;         IF      <> -1
        BEQ L80
        SEC             ;                 A <= A/2
        ROR A
        LDX #$FF        ;                 X <= -1
        LDY NEWVALUE    ;                 Y <= NEWVALUE
        RTS             ;                 RETURN
;
L80     LDA #0          ; A <= 0
        RTS             ; RETURN W/ Y = OLD VALUE
;"
"In the context of the C64, What is the assembly language code for a Commodore 64 mouse driver?","MACHINE LANGUAGE PROGRAMS FOR 1351 MOUSE AND C64
;       C64 MOUSE DRIVER FOR BASIC 2.0 APPLICATIONS
;
IIRQ    = $0314
VIC     = $D000         ; VIC REGISTERS
SID     = $D400         ; SID REGISTERS
POTX    = SID+$19
POTY    = SID+$1A
;
XPOS    = VIC+$00       ; LOW ORDER X POSITION
YPOS    = VIC+$01       ; Y POSITION
XPOSMSB = VIC+$10       ; BIT 0 IS HIGH ORDER X POSITION
;
        *=$C000
IIRQ2   *=*+2
OPOTX   *=*+1
OPOTY   *=*+1
NEWVALUE        *=*+1
OLDVALUE        *=*+1
;
        * = $C100
;
INSTALL LDA IIRQ+1
        CMP #>MIRQ
        BEQ L90
        PHP
        SEI
        LDA IIRQ
        STA IIRQ2
        LDA IIRQ+1
        STA IIRQ2+1

        LDA #<MIRQ
        STA IIRQ
        LDA #>MIRQ
        STA IIRQ+1
;
        PLP
L90     RTS
;
MIRQ    CLD             ; JUST IN CASE.....
        LDA POTX        ; GET DELTA VALUES FOR X
        LDY OPOTX
        JSR MOVCHK
        STY OPOTX
;
        CLC             ; MODIFY LOW ORDER X POSITION
        ADC XPOS
        STA XPOS
        TXA
        ADC #$00
        AND #%00000001
        EOR XPOSMSB
        STA XPOSMSB
;
        LDA POTY        ; GET DELTA VALUE FOR Y
        LDY OPOTY
        JSR MOVCHK
        STY OPOTY
;
        SEC             ; MODIFY Y POSITION ( DECREASE Y FOR
                        ;                     INCREASE IN POT )
        EOR #$FF
        ADC YPOS
        STA YPOS
;
        JMP (IIRQ2)     ; CONTINUE W/ IRQ OPERATION
;
; MOVCHK
;       ENTRY   Y    = OLD VALUE OF POT REGISTER
;               A    = CURRENT VALUE OF POT REGISTER
;       EXIT    Y    = VALUE TO USE FOR OLD VALUE
;               X, A = DELTA VALUE FOR POSITION
;
MOVCHK  STY OLDVALUE    ; SAVE OLD &  NEW VALUES
        STA NEWVALUE
        LDX #0          ; PRELOAD X W/ 0
;
        SEC             ; A <=  MOD64( NEW-OLD )
        SBC OLDVALUE
        AND #%01111111
        CMP #%01000000  ; IF      > 0
        BCS L50
        LSR A           ;         A <= A/2
        BEQ L80         ;         IF      <> 0
        LDY NEWVALUE    ;                 Y <= NEWVALUE
        RTS             ;                 RETURN
;
L50     ORA #%11000000  ; ELSE    OR IN HIGH ORDER BITS
        CMP #$FF        ;         IF      <> -1
        BEQ L80
        SEC             ;                 A <= A/2
        ROR A
        LDX #$FF        ;                 X <= -1
        LDY NEWVALUE    ;                 Y <= NEWVALUE
        RTS             ;                 RETURN
;
L80     LDA #0          ; A <= 0
        RTS             ; RETURN W/ Y = OLD VALUE
;"
"In the context of the C64, What is a humorous way to brag about the amount of RAM in a computer to an Apple user?","RAM Expansion
Wanna show off to that overinflated 48K Apple user next door. Try this on 'im.
sys 54295 ;BASIC4.0
Of course you know there can't possibly be that much, but how's he gonna know. Stay sharp though - he may know his Apple ROMs with equal impunity."
"In the context of the C64, What is the purpose and usage of the SYS command in Commodore BASIC, and how can it be used to report the current line number or convert hexadecimal to decimal?","Instant BASIC Monitor
You can execute this SYS directly, but it won't mean much. However, put on the end of some line in your program and itwill report what line that is. It's part of the error message routine - the part that reports the line number after a run is interrupted. For example: ?syntax error in 6010.
Immediately upon entering direct mode, the operating sys tem deposits an FF into the high order byte of the Current Line Number word, thus rendering that information mean ingless. During program execution, the current line being executed is copied here. Try this:
100 print 'line 100' 110 print 'some line ' : sys 53112:?
120sys53112
130 goto 100

For C64 it's SYS 48585 and the VIC 20 is 56777. As you can see, if the program is renumbered, the message in line 100 will need updating. The ROM call, however, is universal. You can skip the 'in' display by adding 7 to the address.
Taking this one baby step further, this routine could be used as a primitive hex to decimal converter. For example:
poke 55, 10: poke 54, 7: sys 53119
. . .would print the decimal equivalent of $0A07. (C64/ VIC20: use 58 and 57 for the POKE addresses, with the above SYS address + 7) This is ok when you can convert the low order and high order to decimal in your head. When numbers get like CF7D it's a little tougher. Perhaps some one with BASIC 4.0 (built-in MLM) will investigate a more sophisticated approach to the same end. (Dave Hook, you there? You did that once long ago, did you not?)"
"In the context of the C64, What are some creative ways to deter software pirates and protect your program from being cracked?","Pirate Peeves
Want to drive program pirates crazy. You must admit, if a burglar really wants in, he'll get in no matter how much protection you have. Program pirates are no different. The idea is to make them work for it. As they remove one lock, you check for it later in the program and throw them a couple of knuckle balls. Here's a couple of knuckle balls:
poke 175, 3
. . .switches the input device from the keyboard to the screen. ForVIC20/C64 use poke 153,3. Of course the pirate will remove this rather unsophisticated excuse for protec tion. So, you check for it. Then execute:
sys 57441
This turns off the keyboard completely except for carriage returns. It has no VIC20/C64 equivalent. The point is, if you make it appear as though the more they unprotect your software, the more foul it behaves, pretty soon they'll be replacing the protection they removed just so they can use it. The Transactor will be devoting an entire issue to soft ware protection and piracy in August 1984. Watch for it."
"In the context of the C64, What are some important considerations and guidelines for formatting and using a Commodore hard disk drive?","Hard Disk Formatting
If you have any plans to install a Commodore hard disk drive, chances are the first command you send to it will be a New or HEADER operation. Disk users will know that this formating procedure is necessary to prepare the unit for all future operations. But once you get it started, you might as well find something else to do for a while like learn to play piano or re-build the engine in your car. A Header opera tion on the hard disk can take as long as 1 hour 45 minutes because the ID you select is recorded on every sector header.
You need only do this once unless you wish to change the ID. A Header without the ID merely clears the BAM (Block Allocation Map) and the directory - the rest of the disk is left untouched. If you do decide a re-format is necessary, just remember it will take a while.
Two other hard disk notes: The unit should never be moved while the cylinder is spinning. It takes a minute or so for the cylinder to come to a complete stop after power-down. When moving it, keep the unit level - don't set it on end or its side. Hard disks should be kept on a good solid surface during operation. Even small vibrations can cause undue wear on the disk bearings. Avoid sheifs, tables with long legs or spots that may get bumped by passers-by.
Lastly, Commodore hard disks don't have a drive 0 and drive 1 - only drive 0. Some software packages assume you have a dual floppy and will attempt to access drive 1. Even BASIC tries to read drive 1 when you give a Catalog or Directory command with no drive specified. If you're experi encing any trouble, just slip in a ',D0' or '0:'."
"In the context of the C64, What are some handy methods and user-defined functions for working with inverse trigonometric functions and trigonometric functions in degrees?","INVERSE TRIGNOMETRIC FUNCTIONS
Here are a couple of handy methods of obtaining are sine and arc
cosine (remember, the result will be in radians).
ASNX = ATN (X/SQR(1-Xf2)
ACSX = ATN (SQR(1-Xf2)/X)
For those of you who are used to working in degrees, here are some
handy user defined functions:
DEFFNS(V) = SIN(V/(18O/tf))
DEFFNC(V) = COS(V/(180/rf))
DEFFNT(V) = TAN(V/(18O/rf))
These are three user defined functions which when called with
arguments and degrees will give the appropriate results. In these
examples V can be any variable but if all three are defined in
the same programme, you must use three different dummy variables.
EXAMPLE: PRINT FNS(3O)
Result of this will be .5. Notice that the argument for FNS, or
FN anything for that matter, can be either a variable or numeric
constant. Also, after a programme containing these definitions
has been run, these functions may be called using FN in the direct
mode, that is, from the keyboard directly without being in a
programme."
"In the context of the C64, What is the price and availability of the second cassette unit for the PET computer?","SECOND CASSETTE UNIT
The second cassette unit with lead and plug ready to go straight
onto the second cassette port on the rear of the PET, will be
available from the beginning of June at a cost $130.00 plus P.S.T."
"In the context of the C64, How can you use a bell built into your computer to alert you when a long disk operation is finished?","Disk De-Activity Indicator
If you're disk unit gets into some long operation, like the one mentioned above, you might not notice that it's finished until the next time you browse by. If you have a bell built into your computer, here is one way to make it useful:
print ds$ : poke 231, 100 : print '|
The POKE increases the chime time of the bell, and the 3 reverse G's invoke it 3 times. If you're within ear-shot, this should be enough to get your attention. Or you can put the bell in an endless loop that stops when you hit a key. Only one problem with this though - if you happen to step out or something, that insidious chiming is enough to drive some one bonkers if left exposed to it for too long. You might come home to find your new hard disk is now a chopping block in the kitchen!"
"In the context of the C64, How does the processor handle interrupts, including break or software interrupts, and what are the implications for user-modified code and I/O chip setup?","INTERRUPT STRUCTURE
Interrupts (including Break or Software Interrupts) are handled
by software polling.
When the processor recognizes an interrupt it vectors through
FFFE, FFFF in ROM to a routine that first inspects the processor
hardware (IRQ line low).
If it was caused by a Break instruction, a Jump Indirect is
executed through locations 02IB, C. If by a hardware interrupt then
a Jump Indirect is taken through locations 0219, A.
These locations being in RAM may be user-modified to point to
extra user code ahead of normal interrupt processing.
Note, however that the IRQ pointer is used by the cassette
routines and should be restored to standard values before the cassette
Save or Load functions are called.
Various sections of the I/O chips can be set up to cause inter
rupts through the IRQ line.
Example: POKE 59470,2 enables a negative edge on the
user port CAL line to cause an interrupt.
However, have your code set up to handle it when it happens!
Also note that each pass through the regular interrupt code
increments the time register."
"In the context of the C64, What are some advanced Commodore 64 hardware tips and modifications for service technicians and enthusiasts?","Some More C64 Hardware Tips
Tony Lamartina of Chicago has another, but it's more suited to service technicians or those with access to necessary equipment.
1. Remove metal cover from video RF area.
2. Connect scope lead between ground and pin 1 of IC31. 3. Adjust R27 for 1.5 volt DC level.
4. Connect scope lead between ground and pin 4 of DIN
plug.
5. Adjust R25 for midposition
6. Connect decade box between pin 4 of DIN plug and
right side of C78
7. Adjust resistance of decade box for 0.8 to 1 volt of
signal level on scope
8. Connect resistor of value determined by decade box
across pin 1 and pin 4 of DIN plug
9. Fine adjust R25 for best display of colour monitor.
Tony also suggests the following be checked on early re leases of the 64:
1. Loose RF box covers. Tighten the metal tabs and re-in stall.
2. Check for a missing heat sink on VR2-7805 voltage regulator. Install suitable heat sink.
3. If the unit displays 'sparkling' (interference across the CRT screen, random in nature) connect a 330 picoF capacitor from pin 20 (ground) to pin 30 (address 6) of the 6567 (VIC II) video chip. Make this connection outside the RF shielded box."
"In the context of the C64, What is the trick to merge two lines of BASIC code into one line on a Commodore PET/CBM or 80-column machine, and how can it be achieved using a POKE command?","Text In Drag
Back when there was only 40 Column PET/CBMs, The Transactor discussed a method of attaching the code from one line of BASIC onto the end of the line above it. For example, the following two lines need not be on two sepa rate lines:
100 for j = 1 to 10 110 next
The two lines would be LISTed on the screen. Then using the space bar to wrap around the top line onto the bottom line, the two lines would become one double line. Naturally it only worked for a range of 80 characters. The top line had to be less than 40 characters long and only the first 40 characters of the line below could be transfered. With the two screen lines linked together, the DELete key would beused to 'drag' the line below up onto the line above, squeezing out the line number plus those extra spaces in the process. Of course you'd have to insert a colon yourself and also delete line 110. Try it! (By the way, this doesn't work on the VIC 20/C64 - the screen editor has been changed and is now too smart for this trick to be pulled off)
When 80 Column machines came along there was no longer any need for a line wrap table in low RAM - all the lines were identical regardless of how much code was entered. So the situation above could still occur, but to add one line to another required re-typing.
(You must know what I'm leading up to. Yes, a POKE this time) By making the operating system 'think' that each line is longer than 80 characters, this same trick can be played on the 80 column screen editor. Slight of hand? No. More accurately, 'right of hand'. Location 213 is the right hand window margin. Normally it contains 79 for 80 column lines (0-79):
poke 213,159
. . .will make the editor think that each screen line is 160 characters long, however, you're still limited to 80 charac ters per program line.
Now, about the only way I could make this work was to start from the beginning of the first line and ' cursor right' all the way over to about column 75. Only then would DELete cooperate and drag the bottom line up. Using cursor left to 'go around the other way' created some other problems.
Once you're done you'll want to restore 213 to a 79. Otherwise you'll get some strangeness occurring. Try POKE 213, 255 and cursor down off the bottom of the screen. Weird, eh? Again, I don't know why. And if you think that's weird, try listing a program that will cause screen scrolling. You won't crash the machine, but you may have to clear the screen before entering any new direct commands. Try experimenting. I'm not sure, but it might even work for 3 screen lines (ie. POKE 213, 239)."
"In the context of the C64, What is the function of the COLOR CONTROL knob on a <1702 monitor?","1702 monitor COLOR CONTROL
Turn this knob to the left to pale colors, and to the right to
brighten colors.  The normal setting is at the center, which is the
click-stop position."
"In the context of the C64, What is the function of the knob on a 1702 monitor and how does it affect the picture?","1702 monitor BRIGHTNESS CONTROL
Turn this knob to the right to brighten the picture.  The normal
setting is at the center."
"In the context of the C64, What is the purpose of the TINT CONTROL knob on a 1702 monitor?","1702 monitor TINT CONTROL
Turn this knob to the left to add more red, and to the right to add
more green color.

The normal setting forthis knob is at the center, which is the click-
stop position.

When you're adjusting the color, concentrate on one or two colors,
such as brown and purple."
"In the context of the C64, How do you access and use the manual control buttons to adjust the picture on your 1702 monitor?","You can adjust your 1702 monitor's picture with the seven manual control
buttons located behind the panel beneath the monitor screen.  The
panel opens from the top; just flip open the cover by releasing it at
the top."
"In the context of the C64, What does the user manual of the Commodore 1702 color monitor instruct the user to do before using the monitor and what warnings does it provide?","Your new Commodore 1702 color monitor gives you a superior color
picture that enhances your computing experience.  This monitor is
simple to hook up to your computer and is easy to adjust.

Please read this brief manual carefully before you try to use your
monitor.  The manual shows you how to install and use the monitor
correctly.  It also explains how to use the picture control knobs,
which are like the control knobs on a color TV.

Be sure to heed any warnings in this manual, and do NOT remove the
back cover or otherwise attempt to service this monitor.  If you have
problems with your monitor that are not covered in this manual, see
your Commodore dealer or a qualified technician."
"In the context of the C64, What are the steps to connect a Commodore 1702 monitor to a personal computer?","CONNECTING THE 1702 MONITOR TO A COMPUTER
The monitor connection cable connects your monitor to a Commodore
personal computer.  Before you connect the cable, turn off the power
to both your personal computer and the monitor.

There are two different cables that you can use to connect the monitor
to your computer.

1. One kind of cable has three jacks that connect to the BACK of the
monitor.

2. The other cable has two jacks that connect to the FRONT of the
monitor.

The kind of cable you'll use depends on your computer.  To find out
which kind of cable you should use, look at the audio/video connector
on your computer (see your computer's user manual if you don't know
where this connector is).

1. If the audio/video connector has EIGHT little holes, use the
three-jack cable.

2. If the connector has FIVE little holes, use the two-jack cable.

To connect a three-jack cable to the rear panel of the monitor, follow
these instructions, which clarify the diagram:

1. Plug the eight PIN DIN connector (the larger end of the cable) into
the audio/video connector port on your computer.  Just push the cable
end in.

2. Plug the RCA pin plugs (the jacks) of the cable into the rear
terminals on the monitor.  The jacks and the terminals are color-
coded:

* the audio output jack (WHITE) plugs into the AUDIO IN terminal
(WHITE) on the monitor
* the luminance output jack (YELLOW) plugs into the LUMA terminal
(YELLOW)
* the chroma output jack (RED) plugs into the CHROMA terminal (RED)

3. Switch the SIGNAL SELECTOR to the REAR position."
"In the context of the C64, What are the steps to turn on your 1702 monitor and personal computer, and what should you expect to see on the monitor screen?","TURNING ON YOUR 1702 MONITOR
When you finish connecting your monitor according to the instructions,
follow these simple steps:

1. Turn on the monitor by pushing down the power switch. The POWER
INDICATOR LIGHT on the front of the monitor shows you when the power
is on.  Always turn on the monitor BEFORE you turn on the computer.

Later, when you're ready to turn the power off, just press the power
button again.  The button will pop back up and the power light will go
out.

2. Turn on your personal computer.  You can tell that both the monitor
and the computer are working correctly when the monitor displays a
message like this one, which appears when you're using a Commodore 64:

[ Graphic partially omitted: Black and white front view of monitor
showing characters, screen, and border. ]

 .-------------------------------------------------------.
 |                                                       |
 |   .-----------------------------------------------.   |
 |   |   .---------------------------------------.   |   |
 |   |   |                                       |   |   |
 |   |   | ****COMMODORE 64 BASIC V2****         |   |   |
 |   |   | 64K RAM SYSTEM 38911 BASIC BYTES FREE . . . . . . Character
 |   |   | READY.                                |   |   |
 |   |   | #                               . . . . . . . . . Screen
 |   |   |                                       |   |   |
 |   |   |                                       |   |   |
 |   |   |                                       | . . . . . Border
 |   |   |                                       |   |   |


Different computers display other opening messages.  If you don't know
what message to expect, see your computer's user manual."
"In the context of the C64, How do you connect a two-jack cable to the front of a 1702 monitor?","To connect a two-jack cable to the front of the 1702. monitor, follow these
steps:

1. Plug the five PIN DIN connector (the larger end of the cable) into
the audio/video connector port on your computer.  Just push the cable
in.

2. Plug the VIDEO IN and AUDIO IN jacks into the VIDEO INPUT and AUDIO
INPUT terminals on the front of the monitor under the screen.

3. Switch the SIGNAL SELECTOR to the FRONT position. The SIGNAL
SELECTOR is a switch on the REAR PANEL.  After you follow these simple
steps, your 1702is ready for useasa video monitor for your personal
computer."
"In the context of the C64, What precautions and guidelines should be taken when servicing or repairing a 1702 monitor?","1702 monitor SERVICE

15. Unplug the set from the wall outlet and refer servicing to
qualified service personnel under the following conditions:

A. When the power cord or plug is damaged or frayed.

B. If liquid has been spilled into the set.

C. If the set has been exposed to rain or water.

D. If the set does not operate normally by following the operating
instructions.  Adjust only those controls that are covered in the
operating instructions, as improper adjustment of other controls may
result in damage and will often require extensive work by a qualified
technician to restore the set to normal operation.

E. If the set has been dropped or the cabinet has been damaged.

F. When the set exhibits a distinct change in performance -- this
indicates a need for servicing.

G. If snapping or popping from the set is continuous or frequent while
the set is operating.  It is normal for some sets to make occasional
snapping or popping sounds, particularly when being turned on or off.


16. Do not attempt to service this set yourself, as opening or
removing covers may expose you to dangerous voltage or other hazards.
Refer all servicing to qualified service personnel.

17. When replacement parts are required, have the service technician
verify in writing that the replacements he uses have the same safety
characteristics as the original parts.  Use of manufacturer's
specified replacements can prevent fire, shock, or other hazards.

18. Upon completion of any service or repairs to the set, please ask
the service technician to perform the safety check described in the
manufacturers' service literature.

19. When a video monitor reaches the end of its useful life, improper
disposal could result in a picture tube implosion.  Ask a qualified
service technician to dispose of the set."
"In the context of the C64, What are the safety precautions and guidelines for using a 1702 monitor?","USE 1702 monitor 

. Always turn the set off if it is necessary to leave the room for
more than a short period of time.  Never leave a set on when leaving
the house.  A possible malfunction may result in a fire hazard.

. Caution children about dropping or pushing objects into the set's
cabinet openings.  Some internal parts carry hazardous voltages and
contact can result in a fire or electrical shock.

. Unplug the set from the wall outlet before cleaning the face of
the picture tube.  Use a slightly damp (not wet) cloth.  Do not use an
aerosol directly on the picture tube since it may overspray and cause
electrical shock.

. Never add accessories to a set that has not been designed for this
purpose.  Such additions may result in a shock hazard.

. For added protection of the set during a lightning storm or when
the set is to be left unattended for an extended period of time,
unplug it from the wall outlet.  This will prevent possible shock and
fire hazards due to lightning storms or power line surges.

. Do not bring magnetic devices such as magnets or motors near the
picture tube.  These things have a bad effect on the color purity of
the picture.

. Sometimes you may feel static electricity when you touch the
surface of the picture tube.  However, this is normal for any TV set
and is harmless to the human body."
"In the context of the C64, What is the function of the knob labeled VERTICAL POSITION CONTROL"" on a 1702 monitor?""","1702 monitor VERTICAL POSITION CONTROL
Turn this knob to stop vertical rolling of the picture."
"In the context of the C64, What is the function of the knob on a 1702 monitor?","1702 monitor VOLUME CONTROL
Turn this knob to the right to increase sound volume and to the left
to decrease volume."
"In the context of the C64, What are the safety precautions and guidelines for the installation and operation of a <1702 monitor?","1702 monitor INSTALLATION

1. Your set is equipped with a polarized AC line plug (one blade of
the plug is wider than the other).

This safety feature allows the plug to fit into the power outlet only
one way.  Should you be unable to insert the plug fully into the
outlet, try reversing the plug.  Should it still fail to fit, contact
your electrician.

2. Operate the set only from a power source as indicated on the set or
refer to the user's manual for this information.  If you are not sure
of the type of power supply to your home, consult your dealer or local
power company.

3. Overloaded AC outlets and extension cords are dangerous, and so are
frayed power cords and broken plugs.  They may result in a shock or
fire hazard.  Call your service technician for replacement.

4. Do not allow anything to rest or roll over the power cord, and do
not place the set where power cord is subject to traffic or abuse.
This may result in a shock or fire hazard.

5. Do not use this set near water -- for example, near a bathtub,
washbowl, kitchen sink, or laundry tub, in a wet basement, or near a
swimming pool, etc.

6. Sets are provided with ventilation openings in the cabinet to allow
heat generated during operation to be released.  If these openings are
blocked, heat built up within the set can cause failures which may
result in a fire hazard.  Therefore:

* Never block the bottom ventilation slots by placing it on a bed,
sofa, rug, etc.;
* Never place a set in a 'built-in' enclosure unless proper
ventilation is provided;
* Never cover the openings with cloth or other material;
* Never place the set near or over a radiator or heat register."
"In the context of the C64, What safety precautions should be taken when installing, using, and servicing a monitor to avoid electrical shock or fire hazards?","1702 monitor SAFETY PRECAUTIONS

Electrical energy can perform many useful functions.  This unit has
been engineered and manufactured to assure your personal safety.  But
improper use can result in potential electrical shock or fire hazards.
In order not to defeat the safeguards incorporated in this monitor,
observe the following basic rules for its installation, use and
servicing.  And also follow all warnings and instructions marked on
your video monitor."
"In the context of the C64, What is the function of the horizontal position control knob on a 1702 monitor?","1702 monitor HORIZONTAL POSITION CONTROL
Turn this knob to the right to move the center of the picture to the
right, and turn it to the left to move the center of the picture to
the left."
"In the context of the C64, What is the purpose of the CONTRAST CONTROL knob on a 1702 monitor?","1702 monitor CONTRAST CONTROL
Turn this knob to the right to increase contrast.  The normal setting
is at the center."
