text
"[INST]In the context of the C64, What is the purpose of the OPEN statement in BASIC?[/INST]The OPEN statement creates a 'channel' to talk to one of the devices."
"[INST]In the context of the C64, What devices can you send output to using the OPEN statement?[/INST]You can send output to devices like a cassette deck, printer, disk drive, or modem."
"[INST]In the context of the C64, What is the purpose of the PRINT# statement?[/INST]The PRINT# statement sends characters to the device specified by the OPEN statement."
"[INST]In the context of the C64, What is an example of using the OPEN and PRINT# statements?[/INST]The example shows opening a channel to a printer and printing a message."
"[INST]In the context of the C64, What is the importance of the OPEN statement?[/INST]The OPEN statement is important because it allows you to send output to devices other than the screen."
"[INST]In the context of the C64, Can the output buffer hold more than 255 characters?[/INST]No, the output buffer can hold 255 characters before a full buffer hold-off occurs."
"[INST]In the context of the C64, What happens when the output buffer is full?[/INST]The system will wait in the CHROUT routine until transmission is allowed or the RUN/STOP and RESTORE keys are used to recover the system through a WARM START."
"[INST]In the context of the C64, What is the purpose of the CHROUT routine?[/INST]The CHROUT routine is used to send data to an RS-232 channel."
"[INST]In the context of the C64, What is the difference between the CHROUT and CHKOUT routines?[/INST]The CHROUT routine is used to send data to an RS-232 channel, while the CHKOUT routine is used to handle the x-line handshake."
"[INST]In the context of the C64, Is there a carriage-return delay built into the output channel?[/INST]No, there is no carriage-return delay built into the output channel."
"[INST]In the context of the C64, What is the purpose of the x-line handshake?[/INST]The x-line handshake is used to implement a handshake routine that uses multiple lines for receiving and transmitting data."
"[INST]In the context of the C64, What is the EIA standard for RS-232-C interfaces?[/INST]The EIA standard for RS-232-C interfaces is August 1979."
"[INST]In the context of the C64, What is the role of the RTS, CTS, and DCD lines in the x-line handshake?[/INST]The RTS, CTS, and DCD lines are implemented with the Commodore 64 defined as the Data Terminal Device."
"[INST]In the context of the C64, Can a normal RS-232 printer correctly print without hold-off or internal buffering?[/INST]No, a normal RS-232 printer cannot correctly print without hold-off or internal buffering."
"[INST]In the context of the C64, What is the purpose of the CHKOUT routine?[/INST]The CHKOUT routine is used to handle the x-line handshake, which follows the EIA standard for RS-232-C interfaces."
"[INST]In the context of the C64, What is the purpose of peripheral equipment?[/INST]To make the Commodore 64 more capable of meeting user needs"
"[INST]In the context of the C64, What are some examples of peripheral equipment?[/INST]Datassette recorders, disk drives, printers, and modems"
"[INST]In the context of the C64, What makes Commodore peripherals 'intelligent'?[/INST]They don't take up valuable Random Access Memory space when in use"
"[INST]In the context of the C64, What is the advantage of Commodore peripherals not using RAM space?[/INST]You're free to use all 64K of memory in your Commodore 64"
"[INST]In the context of the C64, Will programs written on the Commodore 64 be compatible with future Commodore computers?[/INST]Yes, they will be upwardly compatible"
"[INST]In the context of the C64, What is the limitation of the Commodore OS?[/INST]It can't make programs compatible with computers made by other companies"
"[INST]In the context of the C64, What is the purpose of the Commodore CP/M cartridge?[/INST]To allow users to run CP/M software on their Commodore 64"
"[INST]In the context of the C64, What is CP/M?[/INST]A non-computer dependent operating system"
"[INST]In the context of the C64, How does CP/M use memory space?[/INST]It uses some of the memory space normally available for programming to run its own operating system"
"[INST]In the context of the C64, What are the disadvantages of using CP/M?[/INST]Programs will have to be shorter and screen editing capabilities can't be used"
"[INST]In the context of the C64, What are the advantages of using CP/M?[/INST]You can use software designed for CP/M and Z-80 microprocessors, and programs can be transported to other CP/M computers"
"[INST]In the context of the C64, What is the Z-80 microprocessor used for?[/INST]To run CP/M and allow programs to be transported to other CP/M computers"
"[INST]In the context of the C64, How does the Commodore CP/M cartridge install?[/INST]It plugs into the back of the Commodore 64 quickly and easily"
"[INST]In the context of the C64, What is the advantage of the Commodore CP/M cartridge installation?[/INST]It eliminates the hassle of installing a Z-80 card internally"
"[INST]In the context of the C64, Why is internal installation of a Z-80 card a hassle?[/INST]It requires care not to disturb the delicate circuitry that runs the rest of the computer"
"[INST]In the context of the C64, What is the benefit of using the Commodore CP/M cartridge?[/INST]It allows users to run CP/M software without internal installation of a Z-80 card"
"[INST]In the context of the C64, What is the purpose of the Operating System (OS)?[/INST]To make the computer functional"
"[INST]In the context of the C64, What is the advantage of the Commodore 64's OS?[/INST]It allows for upward compatibility with future Commodore computers"
"[INST]In the context of the C64, What is the limitation of the Commodore 64's OS?[/INST]It can't make programs compatible with computers made by other companies"
"[INST]In the context of the C64, What is the benefit of the Commodore 64's OS?[/INST]It allows for easy use of the computer"
"[INST]In the context of the C64, What is the purpose of the Commodore CP/M cartridge?[/INST]To allow users to take advantage of CP/M software"
"[INST]In the context of the C64, What is the advantage of the Z-80 microprocessor?[/INST]It allows for compatibility with CP/M software"
"[INST]In the context of the C64, What is the benefit of the Commodore CP/M cartridge?[/INST]It allows users to run CP/M software on their Commodore 64"
"[INST]In the context of the C64, What is the purpose of the Commodore CP/M cartridge?[/INST]To provide compatibility with CP/M software"
"[INST]In the context of the C64, What is the advantage of the Commodore CP/M cartridge?[/INST]It allows users to use software designed for CP/M and Z-80 microprocessors"
"[INST]In the context of the C64, What is the benefit of the Commodore CP/M cartridge?[/INST]It allows users to transport programs to other CP/M computers"
"[INST]In the context of the C64, What is the purpose of the Z-80 microprocessor?[/INST]To run CP/M and allow programs to be transported to other CP/M computers"
"[INST]In the context of the C64, What is the advantage of the Commodore CP/M cartridge?[/INST]It eliminates the need for internal installation of a Z-80 card"
"[INST]In the context of the C64, What is the benefit of the Commodore CP/M cartridge?[/INST]It allows users to use software designed for CP/M and Z-80 microprocessors"
"[INST]In the context of the C64, What is the purpose of the Commodore CP/M cartridge?[/INST]To allow users to take advantage of CP/M software on their Commodore 64"
"[INST]In the context of the C64, What is the advantage of the Commodore CP/M cartridge?[/INST]It allows users to run CP/M software without internal installation of a Z-80 card"
"[INST]In the context of the C64, what is the opcode for the TAX instruction?[/INST]The opcode for the TAX instruction is AA, which is used to transfer the contents of the accumulator to index X."
"[INST]In the context of the C64, what is the addressing mode for the TAX instruction?[/INST]The addressing mode for the TAX instruction is implied, which means that the instruction does not require any additional memory locations or registers to be specified."
"[INST]In the context of the C64, how many bytes does the TAX instruction occupy in memory?[/INST]The TAX instruction occupies only 1 byte in memory, making it a very compact and efficient instruction."
"[INST]In the context of the C64, how many cycles does the TAX instruction take to execute?[/INST]The TAX instruction takes 2 cycles to execute, which is relatively fast compared to other instructions that may take more cycles to complete."
"[INST]In the context of the C64, what is the purpose of the TAX instruction?[/INST]The purpose of the TAX instruction is to transfer the contents of the accumulator to index X, which allows the programmer to use the value in the accumulator as an index for accessing memory locations."
"[INST]In the context of the C64, can the TAX instruction be used with other addressing modes?[/INST]No, the TAX instruction can only be used with the implied addressing mode, which means that it does not require any additional memory locations or registers to be specified."
"[INST]In the context of the C64, in what situation would you use the TAX instruction?[/INST]You would use the TAX instruction when you need to use the value in the accumulator as an index to access a memory location, such as when implementing a loop or accessing an array."
"[INST]In the context of the C64, how does the TAX instruction affect the flags?[/INST]The TAX instruction does not affect the flags in any way, it simply transfers the contents of the accumulator to index X."
"[INST]In the context of the C64, is the TAX instruction a load instruction or a store instruction?[/INST]The TAX instruction is a load instruction, as it loads the value from the accumulator into index X."
"[INST]In the context of the C64, can the TAX instruction be used to transfer data between two registers?[/INST]No, the TAX instruction can only be used to transfer the contents of the accumulator to index X, it cannot be used to transfer data between two registers."
"[INST]In the context of the C64, what is the main function of the C64 operating system[/INST]The main function of the C64 operating system is to organize the memory in the machine for various tasks, it also handles the input from the keyboard and displays it on the screen, and performs many other functions, essentially acting as the 'intelligence and personality' of the Commodore 64."
"[INST]In the context of the C64, what happens when you turn on your Commodore 64[/INST]When you turn on your Commodore 64, the operating system takes control of your machine, performs its initial setup and configuration, and after completing its 'housework', it displays the READY. prompt, indicating that it is ready to accept commands and interact with the user."
"[INST]In the context of the C64, what is the significance of the READY. prompt[/INST]The READY. prompt is a message displayed by the C64 operating system after it has completed its initialization and setup, indicating that it is ready to accept commands and interact with the user, allowing the user to start using the computer."
"[INST]In the context of the C64, what is the role of the operating system in a computer[/INST]The operating system plays a crucial role in a computer, acting as the 'intelligence and personality' of the machine, it manages the computer's resources, handles input and output, and provides a platform for running applications and interacting with the user."
"[INST]In the context of the C64, how does the operating system handle user input[/INST]The operating system handles user input by reading the characters typed on the keyboard and displaying them on the screen, allowing the user to interact with the computer and issue commands."
"[INST]In the context of the C64, what is the relationship between the operating system and the computer[/INST]The operating system is the 'brain' of the computer, it is the software that controls and manages the computer's hardware, providing a platform for running applications and interacting with the user, and is essential for the computer to function."
"[INST]In the context of the C64, what is the purpose of the operating system's 'housework'[/INST]The operating system's 'housework' refers to the initial setup and configuration that it performs when the computer is turned on, this includes initializing the hardware, loading the operating system, and preparing the computer for use."
"[INST]In the context of the C64, what is the significance of the operating system in the Commodore 64[/INST]The operating system is the core of the Commodore 64, it provides the foundation for the computer's functionality, and is responsible for managing the computer's resources, handling input and output, and providing a platform for running applications and interacting with the user."
"[INST]In the context of the C64, how does the operating system manage the computer's resources[/INST]The operating system manages the computer's resources by allocating memory, managing I/O operations, and controlling access to the computer's hardware, ensuring that the computer's resources are used efficiently and effectively."
"[INST]In the context of the C64, what is the role of the operating system in managing the computer's hardware[/INST]The operating system plays a crucial role in managing the computer's hardware, it provides a layer of abstraction between the hardware and the user, allowing the user to interact with the computer without needing to know the details of the hardware."
"[INST]In the context of the C64, what is the resolution of the horizontal sprite position register?[/INST]The resolution of the horizontal sprite position register is 512 positions, which allows for precise control over the sprite's horizontal placement on the screen."
"[INST]In the context of the C64, what is the range of visible x locations for sprites?[/INST]The range of visible X locations for sprites is 23 to 347, which corresponds to the hexadecimal values $17 to $157."
"[INST]In the context of the C64, how are sprite positions determined?[/INST]Sprite positions are determined by the upper-left corner of the sprite array, which provides a reference point for the sprite's location on the screen."
"[INST]In the context of the C64, what is the range of visible y locations for sprites?[/INST]The range of visible Y locations for sprites is 50 to 249, which corresponds to the hexadecimal values $32 to $F9."
"[INST]In the context of the C64, what is the purpose of having a larger range of sprite positions than the visible screen area?[/INST]Having a larger range of sprite positions than the visible screen area allows sprites to be moved smoothly on and off the display screen, creating a more seamless and engaging visual experience."
"[INST]In the context of the C64, what registers are used to position sprites?[/INST]Sprites are positioned via their X and Y position registers, as shown in the register map."
"[INST]In the context of the C64, in what way can sprites be moved on the screen?[/INST]Sprites can be moved smoothly on and off the display screen, allowing for dynamic and interactive visual effects."
"[INST]In the context of the C64, what is the significance of the upper-left corner of the sprite array?[/INST]The upper-left corner of the sprite array serves as a reference point for determining the sprite's position on the screen."
"[INST]In the context of the C64, what is the benefit of having a high resolution for sprite positioning?[/INST]Having a high resolution for sprite positioning allows for precise control over the sprite's placement on the screen, enabling more detailed and nuanced visual effects."
"[INST]In the context of the C64, how do the visible X and Y locations for sprites relate to the overall screen area?[/INST]The visible X and Y locations for sprites are a subset of the overall screen area, allowing sprites to be positioned and moved within a specific region of the screen."
"[INST]In the context of the C64, what is the primary function of the 6510 microprocessor chip?[/INST]The 6510 is a low-cost microcomputer system capable of solving a broad range of small-systems and peripheral-control problems at minimum cost to the user."
"[INST]In the context of the C64, what is the location of the Output Register on the 6510 chip?[/INST]The Output Register is located at Address 0000."
"[INST]In the context of the C64, what is the purpose of the Three-State sixteen-bit Address Bus on the 6510 chip?[/INST]The Three-State sixteen-bit Address Bus allows Direct Memory Accessing (DMA) and multiprocessor systems sharing a common memory."
"[INST]In the context of the C64, what is the significance of the internal processor architecture of the 6510 chip?[/INST]The internal processor architecture is identical to the MOS Technology 6502 to provide software compatibility."
"[INST]In the context of the C64, what is the benefit of the 6510 chip's Eight-Bit Bi-Directional I/O Port?[/INST]The Eight-Bit Bi-Directional I/O Port is bit-by-bit programmable."
"[INST]In the context of the C64, what is the maximum addressable memory range of the 6510 chip?[/INST]The 6510 chip has an addressable memory range of up to 64K bytes."
"[INST]In the context of the C64, what is the advantage of the 6510 chip's pipeline architecture?[/INST]The pipeline architecture allows for efficient processing and improved performance."
"[INST]In the context of the C64, what is the significance of the 6510 chip's single +5-volt supply?[/INST]The single +5-volt supply makes the chip more power-efficient and easier to use."
"[INST]In the context of the C64, what is the benefit of the 6510 chip's interrupt capability?[/INST]The interrupt capability allows the chip to handle multiple tasks and prioritize interrupts efficiently."
"[INST]In the context of the C64, what is the significance of the 6510 chip's compatibility with the M6800 bus?[/INST]The compatibility with the M6800 bus allows the 6510 chip to be used with a wide range of systems and peripherals."
"[INST]In the context of the C64, What is the operation of the RTS instruction?[/INST]The RTS instruction returns from a subroutine."
"[INST]In the context of the C64, What is the opcode of the RTS instruction?[/INST]The opcode of the RTS instruction is 60."
"[INST]In the context of the C64, What is the number of bytes used by the RTS instruction?[/INST]The RTS instruction uses 1 byte."
"[INST]In the context of the C64, What is the number of cycles required to execute the RTS instruction?[/INST]The RTS instruction requires 6 cycles."
"[INST]In the context of the C64, What is the addressing mode of the RTS instruction?[/INST]The addressing mode of the RTS instruction is implied."
"[INST]In the context of the C64, What is the purpose of the RTS instruction?[/INST]The purpose of the RTS instruction is to return from a subroutine."
"[INST]In the context of the C64, What is the format of the RTS instruction?[/INST]The format of the RTS instruction is PC from S, PC + 1 -> PC."
"[INST]In the context of the C64, What is the cycle time of the RTS instruction?[/INST]The cycle time of the RTS instruction is not specified."
"[INST]In the context of the C64, JSR instruction is used for what purpose?[/INST]Jump to new location saving return address"
"[INST]In the context of the C64, JSR instruction is also known as what?[/INST]Jump to new location"
"[INST]In the context of the C64, JSR instruction is used in what type of operation?[/INST]PC + 2 to S"
"[INST]In the context of the C64, JSR instruction is used to save what?[/INST]return address"
"[INST]In the context of the C64, JSR instruction is used to jump to what?[/INST]new location"
"[INST]In the context of the C64, JSR instruction is used to save the return address in what?[/INST]PC + 1"
"[INST]In the context of the C64, JSR instruction is used to save the return address in what?[/INST]PCL"
"[INST]In the context of the C64, JSR instruction is used to save the return address in what?[/INST]PCH"
"[INST]In the context of the C64, JSR instruction is used to save the return address in what?[/INST]PC + 2"
"[INST]In the context of the C64, JSR instruction is used to save the return address in what?[/INST](PC + 1)"
"[INST]In the context of the C64, Is the input/output port an 8-bit register?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the input/output port in the Commodore 64?[/INST]Memory management"
"[INST]In the context of the C64, What is the range of RAM and ROM memory that the input/output port can control?[/INST]More than 64K"
"[INST]In the context of the C64, What is the memory location of the DATA DIRECTION REGISTER?[/INST]0"
"[INST]In the context of the C64, What is the memory location of the actual PORT?[/INST]1"
"[INST]In the context of the C64, What type of port is the input/output port?[/INST]Input/output"
"[INST]In the context of the C64, What is the size of the input/output port?[/INST]8-bit"
"[INST]In the context of the C64, What is the purpose of the input/output port in the Commodore 64?[/INST]Memory management"
"[INST]In the context of the C64, What is the range of memory that the input/output port can control?[/INST]More than 64K"
"[INST]In the context of the C64, What is the purpose of the input/output port?[/INST]Input/output operation"
"[INST]In the context of the C64, Can the harmonic content of a waveform be changed?[/INST]Yes, it can be changed by using a filter."
"[INST]In the context of the C64, What are the three types of filtering available in the SID chip?[/INST]High-pass, low-pass, and bandpass filters."
"[INST]In the context of the C64, What is the purpose of the cutoff frequency in a filter?[/INST]It is the reference point for the filter."
"[INST]In the context of the C64, What is the function of register 23 in the SID chip?[/INST]To turn ON the filter for voice 1."
"[INST]In the context of the C64, What is the purpose of the low-pass filter?[/INST]It passes frequencies below the cutoff and attenuates those above."
"[INST]In the context of the C64, What is the purpose of the bandpass filter?[/INST]It passes a narrow band of frequencies around the cutoff and attenuates all others."
"[INST]In the context of the C64, What is the purpose of the notch reject filter?[/INST]It passes frequencies away from the cutoff while attenuating at the cutoff frequency."
"[INST]In the context of the C64, How are the high- and low-pass filters combined to form a notch reject filter?[/INST]By passing frequencies away from the cutoff while attenuating at the cutoff frequency."
"[INST]In the context of the C64, What determines the type of filter used in the SID chip?[/INST]Register 24."
"[INST]In the context of the C64, What are the functions of the bits in register 24?[/INST]Bit 6 controls the high-pass filter, bit 5 is the bandpass filter, and bit 4 is the low-pass filter."
"[INST]In the context of the C64, How are the cutoff frequencies determined in the SID chip?[/INST]By registers 21 and 22."
"[INST]In the context of the C64, What determines the low 3 bits of the cutoff frequency?[/INST]Register 21."
"[INST]In the context of the C64, What determines the 8 bits of the high cutoff frequency?[/INST]Register 22."
"[INST]In the context of the C64, What is the range of values for the cutoff frequency?[/INST]0 through 255."
"[INST]In the context of the C64, What is the range of values for the low cutoff frequency?[/INST]0 through 7."
"[INST]In the context of the C64, What is the purpose of filtering in the SID chip?[/INST]To change the harmonic structure of a waveform."
"[INST]In the context of the C64, What effects can be produced by changing the filtering of a sound as it goes through the ADSR phases?[/INST]Interesting effects."
"[INST]In the context of the C64, What is the importance of careful use of filtering in the SID chip?[/INST]To get just the sound you want."
"[INST]In the context of the C64, What is the purpose of the ADSR phases in the SID chip?[/INST]To produce interesting effects."
"[INST]In the context of the C64, What is the purpose of the waveform in the SID chip?[/INST]To produce sound."
"[INST]In the context of the C64, What is the purpose of the SID chip?[/INST]To produce sound."
"[INST]In the context of the C64, What is the purpose of the RAMTAS routine?[/INST]Perform RAM test"
"[INST]In the context of the C64, What is the call address of the RAMTAS routine?[/INST]$FF87 (hex) 65415 (decimal)"
"[INST]In the context of the C64, What registers are used for communication in the RAMTAS routine?[/INST]A, X, Y"
"[INST]In the context of the C64, What is the stack requirement for the RAMTAS routine?[/INST]2"
"[INST]In the context of the C64, What registers are affected by the RAMTAS routine?[/INST]A, X, Y"
"[INST]In the context of the C64, What is the description of the RAMTAS routine?[/INST]This routine is used to test RAM and set the top and bottom of memory pointers accordingly. It also clears locations $0000 to $0101 and $0200 to $03FF. It also allocates the cassette buffer, and sets the screen base to $0400."
"[INST]In the context of the C64, What is the typical use of the RAMTAS routine?[/INST]Normally, this routine is called as part of the initialization process of a Commodore 64 program cartridge."
"[INST]In the context of the C64, What is cleared by the RAMTAS routine?[/INST]locations $0000 to $0101 and $0200 to $03FF"
"[INST]In the context of the C64, What is allocated by the RAMTAS routine?[/INST]the cassette buffer"
"[INST]In the context of the C64, What is set by the RAMTAS routine?[/INST]the screen base to $0400"
"[INST]In the context of the C64, What is the typical location of the RAMTAS routine?[/INST]part of the initialization process of a Commodore 64 program cartridge"
"[INST]In the context of the C64, What happens to X positions beyond 255?[/INST]To put a sprite beyond X position 255 on the far right side of the screen, you must first POKE V+ 16 as shown, THEN POKE a new X valve from 0 to 63, which will place the sprite in one of the X positions at the right side of the screen."
"[INST]In the context of the C64, What is the range of X positions?[/INST]X positions run from 0 to 255... and then START OVER from 0 to 255."
"[INST]In the context of the C64, How do you get back to positions 0-255?[/INST]To get back to positions 0-255, POKE V+16,0 and POKE in an X value from 0 to 255."
"[INST]In the context of the C64, What is the range of Y positions?[/INST]Y positions run from 0 to 255, including 0 to 49 off the TOP of the viewing area, 50 to 229 IN the,viewing area, and 230 to 255 off the BOTTOM of the viewing area."
"[INST]In the context of the C64, What is the range of Y positions off the top of the viewing area?[/INST]Y positions run from 0 to 49 off the TOP of the viewing area..."
"[INST]In the context of the C64, What is the range of Y positions in the viewing area?[/INST]Y positions run from 50 to 229 IN the,viewing area..."
"[INST]In the context of the C64, What is the range of Y positions off the bottom of the viewing area?[/INST]Y positions run from 230 to 255 off the BOTTOM of the viewing area..."
"[INST]In the context of the C64, How do you POKE in an X position value?[/INST]To get back to positions 0-255, POKE V+16,0 and POKE in an X value from 0 to 255."
"[INST]In the context of the C64, What is the purpose of the CIOUT routine?[/INST]Transmit a byte over the serial bus"
"[INST]In the context of the C64, What is the call address of the CIOUT routine?[/INST]$FFA8 (hex) 65448 (decimal)"
"[INST]In the context of the C64, What communication registers are used by the CIOUT routine?[/INST]A"
"[INST]In the context of the C64, What are the preparatory routines for the CIOUT routine?[/INST]LISTEN, [SECOND]"
"[INST]In the context of the C64, What are the error returns for the CIOUT routine?[/INST]See READST"
"[INST]In the context of the C64, What is the stack requirement for the CIOUT routine?[/INST]5"
"[INST]In the context of the C64, What registers are affected by the CIOUT routine?[/INST]nan"
"[INST]In the context of the C64, What is the description of the CIOUT routine?[/INST]This routine is used to send information to devices on the serial bus."
"[INST]In the context of the C64, What is the purpose of the LISTEN KERNAL routine?[/INST]Command a device on the serial bus to get ready to receive data"
"[INST]In the context of the C64, What is the purpose of the SECOND KERNAL routine?[/INST]Send a secondary address to a device on the serial bus"
"[INST]In the context of the C64, What is the purpose of the KERNAL UNLSN routine?[/INST]End the data transmission"
"[INST]In the context of the C64, Can the VIC-II chip access 16K of memory at a time?[/INST]Yes"
"[INST]In the context of the C64, What is the total amount of memory in the Commodore 64?[/INST]64K"
"[INST]In the context of the C64, What is the purpose of the BANK SELECT bits?[/INST]To access all sections of memory"
"[INST]In the context of the C64, What chip contains the BANK SELECT bits?[/INST]The 6526 COMPLEX INTERFACE ADAPTER CHIP #2 (CIA #2)"
"[INST]In the context of the C64, How are the BANK SELECT bits controlled?[/INST]Using POKE and PEEK BASIC statements, or using assmebly"
"[INST]In the context of the C64, What is the purpose of setting bits 0 and 1 of location 56578?[/INST]To make sure they are outputs"
"[INST]In the context of the C64, What is the effect of setting bits 0 and 1 of location 56576?[/INST]To change banks"
"[INST]In the context of the C64, What is the default bank setting when the Commodore 64 is powered on?[/INST]BANK 0 ($0000-$3FFF)"
"[INST]In the context of the C64, What is the purpose of being aware of the current bank the VIC-II chip is pointing at?[/INST]To know where character data patterns come from, where the screen is, where sprites come from, etc."
"[INST]In the context of the C64, What is the purpose of the interrupt status register?[/INST]The interrupt status register shows the current status of any interrupt source."
"[INST]In the context of the C64, What happens when two sprites hit each other?[/INST]The current status of bit 2 of the interrupt register will be a 1 when two sprites hit each other."
"[INST]In the context of the C64, What is the purpose of bit 7 in the interrupt status register?[/INST]Bit 7 is also set with a 1, whenever an interrupt occurs."
"[INST]In the context of the C64, What is the location of the interrupt status register in memory?[/INST]The interrupt status register is located at 53273 ($D019)"
"[INST]In the context of the C64, What happens when an interrupt bit is set?[/INST]Once an interrupt bit has been set, it's latched"" in and must be cleared by writing a 1 to that bit in the interrupt register when you're ready to handle it."""
"[INST]In the context of the C64, What is the purpose of the interrupt register in handling interrupts?[/INST]This allows selective interrupt handling, without having to store the other interrupt bits."
"[INST]In the context of the C64, What is the description of bit 0 in the interrupt status register?[/INST]IRST    0   Set when current raster count = stored raster count"
"[INST]In the context of the C64, What is the description of bit 1 in the interrupt status register?[/INST]IMDC    1   Set by SPRITE-DATA collision (1st one only, until reset)"
"[INST]In the context of the C64, What is the description of bit 2 in the interrupt status register?[/INST]IMMC    2   Set by SPRITE-SPRITE collision (1st one only, until reset)"
"[INST]In the context of the C64, What is the description of bit 3 in the interrupt status register?[/INST]ILP    3   Set by negative transition of light pen (1 per frame)"
"[INST]In the context of the C64, What is the description of bit 7 in the interrupt status register?[/INST]IRQ    7   Set by latch set and enabled"
"[INST]In the context of the C64, Once you've made a sprite, you want to be able to move it around the screen.[/INST]To do this, your Commodore 64 uses three positioning registers: SPRITE X POSITION REGISTER, SPRITE Y POSITION REGISTER, and MOST SIGNIFICANT BIT X POSITION REGISTER."
"[INST]In the context of the C64, Can you move a sprite around the screen?[/INST]Yes, you can, by using the SPRITE X POSITION REGISTER, SPRITE Y POSITION REGISTER, and MOST SIGNIFICANT BIT X POSITION REGISTER."
"[INST]In the context of the C64, What are the three positioning registers used to move a sprite?[/INST]The three positioning registers are SPRITE X POSITION REGISTER, SPRITE Y POSITION REGISTER, and MOST SIGNIFICANT BIT X POSITION REGISTER."
"[INST]In the context of the C64, How many possible X positions can you place a sprite?[/INST]You can place your sprite in 512 possible X positions."
"[INST]In the context of the C64, What is the purpose of the X and Y position registers?[/INST]The X and Y position registers work together, in pairs, as a team, to position your sprites very accurately."
"[INST]In the context of the C64, What is the memory map layout of the X and Y registers?[/INST]The locations of the X and Y registers appear in the memory map as follows: First is the X register for sprite 0, then the Y register for sprite 0. Next comes the X register for sprite 1, the Y register for sprite 1, and so on. After all 16 X and Y registers comes the most significant bit in the X position (X MSB) located in its own register."
"[INST]In the context of the C64, Can you position a sprite in 256 possible Y positions?[/INST]Yes, you can, because each sprite has a Y position register."
"[INST]In the context of the C64, How many possible Y positions can you place a sprite?[/INST]You can place your sprite in 256 possible Y positions."
"[INST]In the context of the C64, What is the purpose of the most significant bit in the X position register?[/INST]This bit lets you position your sprites very accurately."
"[INST]In the context of the C64, Can you position a sprite in 512 possible X positions?[/INST]Yes, you can, because each sprite has an X position register."
"[INST]In the context of the C64, what is the status register composed of[/INST]The status register is composed of eight flags, which are indicators that show whether a certain condition has occurred or not. These flags are essential in understanding the state of the processor and making informed decisions in programming."
"[INST]In the context of the C64, what is a flag in the context of the status register[/INST]A flag in the context of the status register is a single bit that indicates whether a specific condition has occurred or not. It is a binary indicator that can have a value of either 0 or 1, representing a true or false state."
"[INST]In the context of the C64, what is the purpose of the status register[/INST]The purpose of the status register is to provide information about the outcome of arithmetic and logical operations, allowing the programmer to make informed decisions and take appropriate actions based on the results."
"[INST]In the context of the C64, how many flags does the status register have[/INST]The status register has eight flags, each of which provides information about a specific condition or outcome."
"[INST]In the context of the C64, what kind of information do the flags in the status register provide[/INST]The flags in the status register provide information about the outcome of arithmetic and logical operations, such as whether a result is zero, negative, or has overflowed, among other things."
"[INST]In the context of the C64, what is the significance of the flags in the status register[/INST]The flags in the status register are significant because they provide critical information about the state of the processor and the outcome of operations, allowing the programmer to make informed decisions and write more efficient code."
"[INST]In the context of the C64, how do the flags in the status register relate to each other[/INST]The flags in the status register are interconnected, with each flag providing information that can be used in conjunction with other flags to make more informed decisions."
"[INST]In the context of the C64, what is the relationship between the status register and the processor state[/INST]The status register is closely tied to the processor state, providing information about the outcome of operations and allowing the programmer to adjust the program flow accordingly."
"[INST]In the context of the C64, can the status register be used to make decisions in a program[/INST]Yes, the status register can be used to make decisions in a program, allowing the programmer to branch to different parts of the code based on the outcome of operations."
"[INST]In the context of the C64, in what way does the status register facilitate conditional branching[/INST]The status register facilitates conditional branching by providing information about the outcome of operations, allowing the programmer to use conditional statements to direct the program flow."
"[INST]In the context of the C64, What is the type of clock required by the 6510?[/INST]A two-phase non-overlapping clock that runs at the Vcc voltage level."
"[INST]In the context of the C64, What is the capability of the Address Bus outputs?[/INST]Capable of driving one standard TTL load and 130 pf."
"[INST]In the context of the C64, What is the purpose of the Reset input?[/INST]To reset or start the microprocessor from a power down condition."
"[INST]In the context of the C64, What happens when the Reset input is held low?[/INST]Writing to or from the microprocessor is inhibited."
"[INST]In the context of the C64, How long does the system initialization take after a reset?[/INST]Six clock cycles."
"[INST]In the context of the C64, What is loaded into the program counter after a reset?[/INST]The memory vector locations FFFC and FFFD."
"[INST]In the context of the C64, What is the minimum voltage required for the power-up routine?[/INST]4.75 volts."
"[INST]In the context of the C64, How long must the Reset input be held low during power-up?[/INST]At least two clock cycles."
"[INST]In the context of the C64, What is the purpose of the Interrupt Request (/IRQ) input?[/INST]To request that an interrupt sequence begin within the microprocessor."
"[INST]In the context of the C64, What is the condition for the microprocessor to begin an interrupt sequence?[/INST]The interrupt mask bit in the Status Code Register is not set."
"[INST]In the context of the C64, What happens to the Program Counter and Processor Status Register during an interrupt?[/INST]They are stored in the stack."
"[INST]In the context of the C64, What is loaded into the program counter low at the end of an interrupt cycle?[/INST]Address FFFE."
"[INST]In the context of the C64, What is loaded into the program counter high at the end of an interrupt cycle?[/INST]Location FFFF."
"[INST]In the context of the C64, What is the purpose of the Address Enable Control (AEC) line?[/INST]To control the validity of the Address Bus."
"[INST]In the context of the C64, What happens to the Address Bus when the AEC line is low?[/INST]It is in a high-impedance state."
"[INST]In the context of the C64, What is the purpose of the I/O Port (P0-P7)?[/INST]To transfer data to or from peripheral devices."
"[INST]In the context of the C64, What is the location of the Output Register in RAM?[/INST]Address 0001."
"[INST]In the context of the C64, What is the location of the Data Direction Register?[/INST]Address 0000."
"[INST]In the context of the C64, What is the capability of the I/O Port outputs?[/INST]Capable of driving one standard TTL load and 130 pf."
"[INST]In the context of the C64, What is the purpose of the Read/Write (R/W) signal?[/INST]To control the direction of data transfers on the Data Bus."
"[INST]In the context of the C64, What is the state of the R/W signal when the microprocessor is writing?[/INST]Low."
"[INST]In the context of the C64, What is the state of the R/W signal when the microprocessor is reading?[/INST]High."
"[INST]In the context of the C64, What is the type of bus used for the Data Bus?[/INST]Bi-Directional bus."
"[INST]In the context of the C64, How many pins are used for the Data Bus?[/INST]Eight."
"[INST]In the context of the C64, What is the capability of the Data Bus outputs?[/INST]Capable of driving one standard TTL load and 130 pf."
"[INST]In the context of the C64, What is the purpose of the Clocks (01, 02)?[/INST]To provide a clock signal to the microprocessor."
"[INST]In the context of the C64, What is the voltage level of the Clocks?[/INST]Vcc voltage level."
"[INST]In the context of the C64, What is the type of load that the Address Bus outputs can drive?[/INST]One standard TTL load and 130 pf."
"[INST]In the context of the C64, What is the type of load that the Data Bus outputs can drive?[/INST]One standard TTL load and 130 pf."
"[INST]In the context of the C64, What is the type of load that the I/O Port outputs can drive?[/INST]One standard TTL load and 130 pf."
"[INST]In the context of the C64, what is the purpose of the CLALL function?[/INST]The purpose of the CLALL function is to close all open files, reset the pointers into the open file table, and automatically call the CLRCHN routine to reset the I/O channels."
"[INST]In the context of the C64, What is the call address of the CLALL function?[/INST]The call address of the CLALL function is $FFE7 in hexadecimal, which is equivalent to 65511 in decimal."
"[INST]In the context of the C64, What are the preparatory routines required for the CLALL function?[/INST]There are no preparatory routines required for the CLALL function."
"[INST]In the context of the C64, What are the error returns of the CLALL function?[/INST]There are no error returns for the CLALL function."
"[INST]In the context of the C64, What are the stack requirements for the CLALL function?[/INST]The stack requirements for the CLALL function are 11."
"[INST]In the context of the C64, What registers are affected by the CLALL function?[/INST]The registers affected by the CLALL function are A and X."
"[INST]In the context of the C64, How do you use the CLALL function?[/INST]To use the CLALL function, simply call the routine with a JSR instruction, for example: JSR CLALL."
"[INST]In the context of the C64, What is the effect of calling the CLALL function on open files?[/INST]Calling the CLALL function closes all open files and resets the pointers into the open file table."
"[INST]In the context of the C64, What happens to the I/O channels when the CLALL function is called?[/INST]When the CLALL function is called, the CLRCHN routine is automatically called to reset the I/O channels."
"[INST]In the context of the C64, Can you provide an example of how to use the CLALL function?[/INST]Here is an example of how to use the CLALL function: JSR CLALL ;CLOSE ALL FILES AND SELECT DEFAULT I/O CHANNELS JMP RUN ;BEGIN EXECUTION"
"[INST]In the context of the C64, What is the relationship between the CLALL function and the CLRCHN routine?[/INST]The CLALL function automatically calls the CLRCHN routine to reset the I/O channels when it is called."
"[INST]In the context of the C64, How is the display screen divided for sprite positioning?[/INST]The display screen is divided into a grid of X and Y coordinates, like a graph, where the X coordinate is the horizontal position across the screen and the Y coordinate is the vertical position up and down."
"[INST]In the context of the C64, What are the two settings required to position a sprite on the screen?[/INST]To position a sprite on the screen, you must POKE two settings: the X position and the Y position, which tell the computer where to display the upper left-hand corner of the sprite."
"[INST]In the context of the C64, How is a sprite displayed on the screen?[/INST]A sprite is displayed as a graphic image 24 pixels across and 21 pixels down, starting at the X-Y position you defined, based on the upper left corner of the entire sprite, even if you define the sprite using only a small part of the 24x21-pixel sprite area."
"[INST]In the context of the C64, What is the significance of the upper left-hand corner of a sprite?[/INST]The upper left-hand corner of a sprite is the reference point for positioning the sprite on the screen, and the sprite will be displayed based on this corner, even if you define the sprite using only a small part of the 24x21-pixel sprite area."
"[INST]In the context of the C64, How do you specify the position of a sprite on the screen?[/INST]You specify the position of a sprite on the screen by POKEing the X and Y settings for each sprite, remembering that every sprite has its own unique X POKE and Y POKE."
"[INST]In the context of the C64, What is the purpose of the X and Y coordinates in sprite positioning?[/INST]The X and Y coordinates specify the horizontal and vertical positions of the upper left-hand corner of the sprite on the screen, respectively."
"[INST]In the context of the C64, How many pixels make up a sprite on the C64?[/INST]A sprite on the C64 consists of 504 individual pixels, arranged in a 24x21 grid."
"[INST]In the context of the C64, What is the significance of the grey area in the X-Y positioning diagram?[/INST]The grey area in the diagram represents the television viewing area, while the white area represents positions that are off the viewing screen."
"[INST]In the context of the C64, How do you display a sprite in a given location on the screen?[/INST]To display a sprite in a given location on the screen, you must POKE the X and Y settings for each sprite, remembering that every sprite has its own unique X POKE and Y POKE."
"[INST]In the context of the C64, What is the relationship between the X-Y coordinates and the sprite's position on the screen?[/INST]The X-Y coordinates specify the position of the upper left-hand corner of the sprite on the screen, and the sprite will be displayed accordingly, based on these coordinates."
"[INST]In the context of the C64, how do you enable a sprite for display on the Commodore 64?[/INST]To enable a sprite for display on the Commodore 64, you need to set its corresponding enable bit (MnE) to '1' in register 21 ($15). This allows the sprite to be displayed on the screen, and sprite operations will occur involving the enabled sprite."
"[INST]In the context of the C64, what happens when the MnE bit is set to '0'?[/INST]When the MnE bit is set to '0', the sprite is disabled and no sprite operations will occur involving the disabled sprite. This means that the sprite will not be displayed on the screen and will not participate in any sprite-related operations."
"[INST]In the context of the C64, what is the purpose of the MnE bit in register 21?[/INST]The MnE bit in register 21 is used to selectively enable or disable a sprite for display on the Commodore 64. By setting the MnE bit to '1', you can enable a sprite, and by setting it to '0', you can disable it."
"[INST]In the context of the C64, where is the MnE bit located?[/INST]The MnE bit is located in register 21 ($15) on the Commodore 64. This register is used to control the display of sprites on the screen."
"[INST]In the context of the C64, what is the effect of setting the MnE bit to '1'?[/INST]Setting the MnE bit to '1' enables the sprite for display on the Commodore 64, allowing it to be displayed on the screen and participate in sprite-related operations."
"[INST]In the context of the C64, what is the default state of the MnE bit?[/INST]The default state of the MnE bit is not explicitly stated, but it can be assumed to be '0', disabling the sprite by default, until it is explicitly set to '1' to enable it."
"[INST]In the context of the C64, can you enable multiple sprites at once?[/INST]Yes, you can enable multiple sprites at once by setting the corresponding MnE bits to '1' in register 21 ($15) for each sprite you want to enable."
"[INST]In the context of the C64, what happens if you try to display a disabled sprite?[/INST]If you try to display a disabled sprite (i.e., the MnE bit is set to '0'), the sprite will not be displayed on the screen, and no sprite operations will occur involving the disabled sprite."
"[INST]In the context of the C64, how do you disable a sprite?[/INST]To disable a sprite, you need to set its corresponding MnE bit to '0' in register 21 ($15). This will prevent the sprite from being displayed on the screen and from participating in sprite-related operations."
"[INST]In the context of the C64, what is the relationship between the MnE bit and sprite operations?[/INST]The MnE bit controls whether a sprite is enabled or disabled for display and participation in sprite-related operations. If the MnE bit is set to '1', the sprite is enabled, and if it is set to '0', the sprite is disabled."
"[INST]In the context of the C64, Can the location of screen memory be changed easily?[/INST]Yes, by a POKE to control register 53272 ($D018 HEX)."
"[INST]In the context of the C64, What is the purpose of the control register 53272 ($D018 HEX)?[/INST]It is used to control which character set is used, so be careful to avoid disturbing that part of the control register."
"[INST]In the context of the C64, What is the UPPER 4 bits used for in the control register?[/INST]They control the location of screen memory."
"[INST]In the context of the C64, What is the statement used to move the screen?[/INST]POKE 53272,(PEEK(53272)AND15)OR A"
"[INST]In the context of the C64, What are the possible values of A in the statement?[/INST]A has one of the following values: 0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240"
"[INST]In the context of the C64, What is the default location of screen memory?[/INST]$0400 (1024)"
"[INST]In the context of the C64, What is the formula to calculate the page number?[/INST]POKE 648, page (where page = address/256, e.g., 1024/256= 4)"
"[INST]In the context of the C64, What is the purpose of the KERNAL'S screen editor?[/INST]It must be told where the screen is."
"[INST]In the context of the C64, What is the BANK ADDRESS of the VIC-II chip?[/INST]It must be added in."
"[INST]In the context of the C64, What is the range of possible values for A?[/INST]0 to 240"
"[INST]In the context of the C64, What is the purpose of the control register?[/INST]It is used to control which character set is used and the location of screen memory"
"[INST]In the context of the C64, What is the purpose of the screen memory?[/INST]It is used to display the screen"
"[INST]In the context of the C64, What is the purpose of the screen editor?[/INST]It is used to edit the screen"
"[INST]In the context of the C64, What is the purpose of the KERNAL?[/INST]It is used to manage the computer's memory and I/O operations"
"[INST]In the context of the C64, What is the purpose of the VIC-II chip?[/INST]It is used to control the computer's video output"
"[INST]In the context of the C64, What is the purpose of the screen?[/INST]It is used to display information to the user"
"[INST]In the context of the C64, What is the purpose of the screen editor?[/INST]It is used to edit the screen"
"[INST]In the context of the C64, What is the purpose of the KERNAL'S screen editor?[/INST]It is used to manage the screen"
"[INST]In the context of the C64, What is the location of the Interrupt Enable Register?[/INST]The Interrupt Enable Register is located at 53274 ($D01A)."
"[INST]In the context of the C64, What is the purpose of the Interrupt Enable Register?[/INST]Unless the corresponding bit in the interrupt enable register is set to a 1, no interrupt from that source will take place."
"[INST]In the context of the C64, What happens if the Interrupt Enable Register is not set to a 1?[/INST]No interrupt will take place."
"[INST]In the context of the C64, What is the requirement to enable an interrupt request?[/INST]The corresponding interrupt enable bit must be set to a 1."
"[INST]In the context of the C64, What is the benefit of using interrupts properly?[/INST]It lets you use split screen modes."
"[INST]In the context of the C64, What is an example of using interrupts properly?[/INST]For instance, you can have half of the screen bit mapped, half text."
"[INST]In the context of the C64, What is the purpose of the raster compare register?[/INST]To set the interrupt to occur at a specific point on the screen."
"[INST]In the context of the C64, What is the limitation of using BASIC for display interrupts?[/INST]BASIC isn't fast enough to do this very well."
"[INST]In the context of the C64, What is the recommended approach for using display interrupts?[/INST]You should work in machine language."
"[INST]In the context of the C64, What is the advantage of using display interrupts?[/INST]You can display more than 8 sprites at a time."
"[INST]In the context of the C64, Initialize the Commodore 64 screen editor[/INST]This routine sets up the KERNAL screen editor."
"[INST]In the context of the C64, What is the purpose of the CINT function?[/INST]Initialize screen editor & 6567 video chip"
"[INST]In the context of the C64, What is the call address of the CINT function?[/INST]$FF81 (hex) 65409 (decimal)"
"[INST]In the context of the C64, What registers are affected by the CINT function?[/INST]A, X, Y"
"[INST]In the context of the C64, What is the stack requirement for the CINT function?[/INST]4"
"[INST]In the context of the C64, What is the description of the CINT function?[/INST]This routine sets up the 6567 video controller chip in the Commodore 64 for normal operation."
"[INST]In the context of the C64, Read system clock routine[/INST]Read system clock"
"[INST]In the context of the C64, RDTIM function name[/INST]RDTIM"
"[INST]In the context of the C64, Call address of RDTIM[/INST]65502"
"[INST]In the context of the C64, Registers affected by RDTIM[/INST]A, X, Y"
"[INST]In the context of the C64, Description of RDTIM[/INST]This routine is used to read the system clock"
"[INST]In the context of the C64, Resolution of system clock[/INST]a 60th of a second"
"[INST]In the context of the C64, Bytes returned by RDTIM[/INST]Three"
"[INST]In the context of the C64, Registers containing clock bytes[/INST]Accumulator, X index register, Y index register"
"[INST]In the context of the C64, Example usage of RDTIM[/INST]JSR RDTIM, STY TIME, STX TIME+1, STA TIME+2"
"[INST]In the context of the C64, Stack requirements of RDTIM[/INST]2"
"[INST]In the context of the C64, What is the code for BLACK color?[/INST]0"
"[INST]In the context of the C64, What is the code for PURPLE color?[/INST]4"
"[INST]In the context of the C64, What is the code for ORANGE color?[/INST]8"
"[INST]In the context of the C64, What is the code for MED. GREY color?[/INST]12"
"[INST]In the context of the C64, What is the code for WHITE color?[/INST]1"
"[INST]In the context of the C64, What is the code for RED color?[/INST]2"
"[INST]In the context of the C64, What is the code for BLUE color?[/INST]6"
"[INST]In the context of the C64, What is the code for YELLOW color?[/INST]7"
"[INST]In the context of the C64, What does TYA do?[/INST]TYA Transfer index Y to accumulator"
"[INST]In the context of the C64, What is the number of bytes of TYA?[/INST]1"
"[INST]In the context of the C64, What is the number of cycles of TYA?[/INST]2"
"[INST]In the context of the C64, The stack pointer contains the location of the first empty place on the stack.[/INST]This register contains the location of the first empty place on the stack."
"[INST]In the context of the C64, What is the purpose of the stack pointer?[/INST]The stack is used for temporary storage by machine language programs, and by the computer."
"[INST]In the context of the C64, What is stored in the stack pointer?[/INST]The location of the first empty place on the stack."
"[INST]In the context of the C64, What is the stack used for?[/INST]The stack is used for temporary storage by machine language programs, and by the computer."
"[INST]In the context of the C64, What is the stack pointer used for?[/INST]The stack is used for temporary storage by machine language programs, and by the computer."
"[INST]In the context of the C64, What is the purpose of the stack?[/INST]The stack is used for temporary storage by machine language programs, and by the computer."
"[INST]In the context of the C64, What is stored in the stack?[/INST]The location of the first empty place on the stack."
"[INST]In the context of the C64, What is the stack pointer?[/INST]This register contains the location of the first empty place on the stack."
"[INST]In the context of the C64, What is the stack used for temporary storage?[/INST]The stack is used for temporary storage by machine language programs, and by the computer."
"[INST]In the context of the C64, JMP operation explained[/INST]The JMP operation is used to jump to a new location in the program."
"[INST]In the context of the C64, JMP operation syntax[/INST]The syntax for the JMP operation is (PC + 1) -> PCL."
"[INST]In the context of the C64, JMP operation modes[/INST]The JMP operation has two modes: Absolute and Indirect."
"[INST]In the context of the C64, Absolute JMP mode[/INST]In Absolute mode, the JMP operation uses the OP CODE 4C and requires 3 bytes and 3 cycles."
"[INST]In the context of the C64, Indirect JMP mode[/INST]In Indirect mode, the JMP operation uses the OP CODE 6C and requires 3 bytes and 5 cycles."
"[INST]In the context of the C64, JMP operation purpose[/INST]The purpose of the JMP operation is to jump to a new location in the program."
"[INST]In the context of the C64, JMP operation examples[/INST]Examples of the JMP operation include JMP Oper and JMP (Oper)."
"[INST]In the context of the C64, JMP operation usage[/INST]The JMP operation is used to transfer control to a new location in the program."
"[INST]In the context of the C64, JMP operation limitations[/INST]The JMP operation has limitations, such as requiring a specific OP CODE and number of bytes and cycles."
"[INST]In the context of the C64, JMP operation importance[/INST]The JMP operation is important in programming as it allows for control flow and program branching."
"[INST]In the context of the C64, RTI is used for what purpose?[/INST]Return from interrupt"
"[INST]In the context of the C64, RTI is an abbreviation for what?[/INST]Return from interrupt"
"[INST]In the context of the C64, What is the operation of RTI?[/INST]From Stack"
"[INST]In the context of the C64, What is the assembly language form of RTI?[/INST]RTI"
"[INST]In the context of the C64, What is the OP CODE of RTI?[/INST]4D"
"[INST]In the context of the C64, How many bytes does the RTI instruction occupy?[/INST]1"
"[INST]In the context of the C64, How many cycles does the RTI instruction take?[/INST]6"
"[INST]In the context of the C64, What is the addressing mode of RTI?[/INST]Implied"
"[INST]In the context of the C64, What is the operation of RTI in terms of addressing mode?[/INST]From Stack"
"[INST]In the context of the C64, What is the purpose of RTI in terms of interrupt handling?[/INST]Return from interrupt"
"[INST]In the context of the C64, What is the purpose of the SETNAM function?[/INST]The purpose of the SETNAM function is to set up the file name for the OPEN, SAVE, or LOAD routines, where the accumulator must be loaded with the length of the file name and the X and Y registers must be loaded with the address of the file name in standard 6502 low-byte/high-byte format."
"[INST]In the context of the C64, What is the call address of the SETNAM function?[/INST]The call address of the SETNAM function is $FFBD (hex) or 65469 (decimal)."
"[INST]In the context of the C64, What registers are used to communicate with the SETNAM function?[/INST]The SETNAM function uses the A, X, and Y registers for communication."
"[INST]In the context of the C64, How many bytes of stack space are required by the SETNAM function?[/INST]The SETNAM function requires 2 bytes of stack space."
"[INST]In the context of the C64, What happens if the accumulator is set to 0 when calling the SETNAM function?[/INST]If the accumulator is set to 0 when calling the SETNAM function, it represents a zero file length, and no file name is desired."
"[INST]In the context of the C64, What is the format of the address stored in the X and Y registers when calling the SETNAM function?[/INST]The address stored in the X and Y registers when calling the SETNAM function is in standard 6502 low-byte/high-byte format."
"[INST]In the context of the C64, How do you load the length of the file name when calling the SETNAM function?[/INST]You load the length of the file name by loading the accumulator with the length of the file name."
"[INST]In the context of the C64, What is an example of how to call the SETNAM function?[/INST]An example of how to call the SETNAM function is: LDA #NAME2-NAME; LDX #<NAME; LDY #>NAME; JSR SETNAM."
"[INST]In the context of the C64, What is the purpose of the X and Y registers when calling the SETNAM function?[/INST]The X and Y registers are used to store the address of the file name in standard 6502 low-byte/high-byte format when calling the SETNAM function."
"[INST]In the context of the C64, What is the significance of the address stored in the X and Y registers when calling the SETNAM function?[/INST]The address stored in the X and Y registers when calling the SETNAM function is the address of the file name, which can be any valid memory address in the system where a string of characters for the file name is stored."
"[INST]In the context of the C64, How do you set the file name to zero length when calling the SETNAM function?[/INST]You set the file name to zero length by setting the accumulator to 0, representing a zero file length, and the X and Y registers can be set to any memory address in that case."
"[INST]In the context of the C64, Where is the VIC-II control register located?[/INST]The VIC-II control register is located at memory location 53265 ($D011)."
"[INST]In the context of the C64, What does bit 4 of the VIC-II control register control?[/INST]Bit 4 of the VIC-II control register controls the screen blanking function, where a value of 1 turns the screen on and a value of 0 turns the screen off."
"[INST]In the context of the C64, What happens when bit 4 of the VIC-II control register is set to 0?[/INST]When bit 4 of the VIC-II control register is set to 0, the entire screen changes to the border color, effectively blanking the screen."
"[INST]In the context of the C64, What is the purpose of the following POKE command: POKE 53265,PEEK(53265)AND 239?[/INST]The purpose of the POKE command POKE 53265,PEEK(53265)AND 239 is to blank the screen by setting bit 4 of the VIC-II control register to 0, without losing any data, it just isn't displayed."
"[INST]In the context of the C64, What is the effect of turning off the screen on the processor?[/INST]Turning off the screen speeds up the processor slightly, which also speeds up program execution."
"[INST]In the context of the C64, How can you bring back the screen after it has been blanked?[/INST]You can bring back the screen by using the POKE command POKE 53265,PEEK(53265)OR 16, which sets bit 4 of the VIC-II control register back to 1."
"[INST]In the context of the C64, What is the difference between a value of 1 and 0 for bit 4 of the VIC-II control register?[/INST]A value of 1 for bit 4 of the VIC-II control register turns the screen on, while a value of 0 turns the screen off and changes the entire screen to the border color."
"[INST]In the context of the C64, What is the significance of memory location 53265 in the context of screen blanking?[/INST]Memory location 53265 is the location of the VIC-II control register, which controls the screen blanking function through bit 4."
"[INST]In the context of the C64, How does screen blanking affect program execution?[/INST]Screen blanking speeds up program execution by slightly speeding up the processor."
"[INST]In the context of the C64, What is the purpose of using the AND operator in the POKE command POKE 53265,PEEK(53265)AND 239?[/INST]The purpose of using the AND operator in the POKE command POKE 53265,PEEK(53265)AND 239 is to clear bit 4 of the VIC-II control register, effectively blanking the screen."
"[INST]In the context of the C64, what is the purpose of the MASK register in the 6526 interrupt control?[/INST]The MASK register provides convenient control of individual mask bits, allowing the user to selectively enable or disable interrupts from various sources. When writing to the MASK register, the user can set or clear individual mask bits by writing a 1 or 0 to the corresponding bit position, while leaving unaffected bits unchanged. This allows for fine-grained control over which interrupts are enabled and which are masked."
"[INST]In the context of the C64, how does the interrupt control register handle multiple interrupts?[/INST]The interrupt control register can handle multiple interrupts by setting the corresponding bit in the DATA register for each interrupt source. The IR bit (MSB) of the DATA register is set if any interrupt is enabled by the MASK register, and the /IRQ pin is brought low. This allows the processor to detect the presence of an interrupt and respond accordingly."
"[INST]In the context of the C64, what happens when an interrupt is cleared from the DATA register?[/INST]When an interrupt is cleared from the DATA register, the /IRQ line returns high, indicating that the interrupt has been serviced. The DATA register is cleared following a read of the register, which means that the interrupt information is lost unless it is preserved by the user."
"[INST]In the context of the C64, how does the 6526 handle polled interrupts?[/INST]The 6526 allows for polled interrupts by allowing the user to selectively mask individual interrupt sources. When an interrupt is masked, it does not generate an interrupt request, but the corresponding bit is still set in the DATA register. This allows the user to poll the DATA register to detect the presence of an interrupt, and then service the interrupt accordingly."
"[INST]In the context of the C64, what is the purpose of the SET/CLEAR bit in the MASK register?[/INST]The SET/CLEAR bit (bit 7) in the MASK register determines the behavior of the mask bits when writing to the register. If the SET/CLEAR bit is 0, writing a 1 to a mask bit clears it, while writing a 0 leaves it unaffected. If the SET/CLEAR bit is 1, writing a 1 to a mask bit sets it, while writing a 0 leaves it unaffected."
"[INST]In the context of the C64, how does the 6526 prioritize interrupts?[/INST]The 6526 does not have a built-in interrupt priority system. Instead, it relies on the user to prioritize interrupts by selectively masking and unmasking individual interrupt sources. This allows the user to customize the interrupt handling to suit the specific needs of their application."
"[INST]In the context of the C64, what is the function of the IR bit in the DATA register?[/INST]The IR bit (MSB) of the DATA register is set if any interrupt is enabled by the MASK register. This bit indicates the presence of an interrupt and is used to generate an interrupt request to the processor."
"[INST]In the context of the C64, how does the 6526 handle multi-chip systems?[/INST]In a multi-chip system, the IR bit can be polled to detect which chip has generated an interrupt request. This allows the user to determine which chip needs to be serviced and respond accordingly."
"[INST]In the context of the C64, what is the purpose of the DATA register in the 6526?[/INST]The DATA register provides a read-only interface to the interrupt status of the 6526. It contains a bit for each interrupt source, which is set when an interrupt occurs. The DATA register is cleared following a read, which means that the interrupt information is lost unless it is preserved by the user."
"[INST]In the context of the C64, can the 6526 generate multiple interrupt requests simultaneously?[/INST]Yes, the 6526 can generate multiple interrupt requests simultaneously. The DATA register contains a bit for each interrupt source, and multiple bits can be set simultaneously if multiple interrupts occur. The IR bit (MSB) of the DATA register is set if any interrupt is enabled by the MASK register, indicating the presence of an interrupt."
"[INST]In the context of the C64, What is the easiest method to add machine language programs to a BASIC program?[/INST]The easiest method is by using DATA statements, where the machine language routine is stored as a series of numeric values in a DATA statement, and then POKEing those values into memory at the start of the program."
"[INST]In the context of the C64, How do you add a machine language routine to a BASIC program using the DATA statement method?[/INST]You use a READ statement to read the values from the DATA statement, and then use a POKE statement to store those values in memory, typically at the start of the program."
"[INST]In the context of the C64, What are the drawbacks of using the DATA statement method to add machine language routines to a BASIC program?[/INST]The drawbacks include taking up more memory space, and the wait while the program is POKED in, making it better suited for smaller routines."
"[INST]In the context of the C64, What is an example of a BASIC program that uses the DATA statement method to add a machine language routine?[/INST]An example is: 10 RESTORE:FOR X=1 TO 9:READ A:POKE 12*4096+X,A:NEXT, which reads values from a DATA statement and POKEs them into memory."
"[INST]In the context of the C64, How do you store a machine language routine in a DATA statement?[/INST]You store the machine language routine as a series of numeric values in a DATA statement, where each value represents a byte of machine code."
"[INST]In the context of the C64, What is the purpose of the RESTORE statement in the example program?[/INST]The RESTORE statement is used to reset the DATA pointer to the beginning of the DATA statement, so that the READ statement can read the values in the correct order."
"[INST]In the context of the C64, Why is the DATA statement method better suited for smaller machine language routines?[/INST]The DATA statement method is better suited for smaller machine language routines because it takes up more memory space, and larger routines would use too much memory."
"[INST]In the context of the C64, How do you POKE the values from the DATA statement into memory?[/INST]You use a POKE statement to store the values from the DATA statement into memory, typically at the start of the program, using an address calculation like 12*4096+X."
"[INST]In the context of the C64, What is the advantage of using the DATA statement method to add machine language routines to a BASIC program?[/INST]The advantage is that it is easy to debug, and no special methods are needed to save the two parts of the program."
"[INST]In the context of the C64, Why is the DATA statement method a common method for adding machine language programs to a BASIC program?[/INST]The DATA statement method is a common method because it is easy to use, and does not require any special tools or techniques, making it accessible to beginners."
"[INST]In the context of the C64, RS232: what is the maximum number of characters that the Commodore 64 receiver buffer can hold?[/INST]The Commodore 64 receiver buffer will hold up to 255 characters before the buffer overflows."
"[INST]In the context of the C64, RS232: what happens if the buffer overflows?[/INST]If an overflow occurs, then all characters received during a full buffer condition, from that point on, are lost."
"[INST]In the context of the C64, RS232: what is the recommended way to receive RS-232 data at high speeds?[/INST]You will have to use machine language routines to handle this type of data burst."
"[INST]In the context of the C64, RS232: what is the difference between GET# and INPUT#?[/INST]GET# is recommended, while INPUT# is not recommended because it can cause the system to hang in a waiting condition."
"[INST]In the context of the C64, RS232: what happens if a GET# does not find any data in the buffer?[/INST]The character "" (a null) is returned."
"[INST]In the context of the C64, RS232: what is the purpose of the routine CHKIN?[/INST]The routine CHKIN handles the x-line handshake which follows the EIA standard for RS-232-C interfaces."
"[INST]In the context of the C64, RS232: what is the standard for RS-232-C interfaces?[/INST]The standard is defined as the Data Terminal device."
"[INST]In the context of the C64, RS232: what happens if the Clear To Send (CTS) or Data Set Ready (DSR) line(s) disappear during character INPUT#?[/INST]The system will hang in a RESTORE-only state."
"[INST]In the context of the C64, RS232: what is the recommended way to handle data bursts?[/INST]You will have to use machine language routines to handle this type of data burst."
"[INST]In the context of the C64, RS232: what is the maximum word length for RS-232-C interfaces?[/INST]The maximum word length is 8 bits."
"[INST]In the context of the C64, RS232: what happens if the word length is less than 8 bits?[/INST]All unused bit(s) will be assigned a value of zero."
"[INST]In the context of the C64, RS232: what is the purpose of the routine GETIN?[/INST]The routine GETIN is used to receive data from an RS-232 channel."
"[INST]In the context of the C64, RS232: what is the purpose of the routine CHRIN?[/INST]The routine CHRIN is used to receive data from an RS-232 channel."
"[INST]In the context of the C64, RS232: what is the recommended way to receive data from an RS-232 channel?[/INST]You should use the GET# routine."
"[INST]In the context of the C64, RS232: what happens if the buffer is not kept clear?[/INST]The buffer will overflow and all characters received during a full buffer condition, from that point on, are lost."
"[INST]In the context of the C64, Is the simplest form of output in BASIC the PRINT statement?[/INST]Yes"
"[INST]In the context of the C64, What is the main objective when printing on the screen?[/INST]To format the information so it's easy to read"
"[INST]In the context of the C64, What is the purpose of the cursor in the PRINT statement?[/INST]To change position"
"[INST]In the context of the C64, What is the character code number of the RETURN key?[/INST]13"
"[INST]In the context of the C64, What are the two functions in the BASIC language that work with the PRINT statement?[/INST]TAB and SPC"
"[INST]In the context of the C64, What does the semicolon (;) do in the PRINT statement?[/INST]Separates 2 items without any spaces in between"
"[INST]In the context of the C64, What does the comma (,) do in the PRINT statement?[/INST]Separates items into columns"
"[INST]In the context of the C64, What are the quote marks ("") used for in the PRINT statement?[/INST]To separate literal text from variables"
"[INST]In the context of the C64, What is the purpose of the RETURN code (CHR$ code of 13) in the PRINT statement?[/INST]Makes the cursor go to the next logical line on the screen"
"[INST]In the context of the C64, What determines where the <RETURN> key sends the cursor?[/INST]The logical line the cursor is on"
"[INST]In the context of the C64, What is the maximum length of a logical line?[/INST]2 screen lines long"
"[INST]In the context of the C64, What are some other ways to use the TV as an output device?[/INST]Graphics, VIC chip, and sound"
"[INST]In the context of the C64, What is the purpose of the PRINT statement?[/INST]To format the information on the screen"
"[INST]In the context of the C64, What is the purpose of the cursor in the PRINT statement?[/INST]To change position"
"[INST]In the context of the C64, What is the purpose of the RETURN key?[/INST]To make the cursor go to the next logical line on the screen"
"[INST]In the context of the C64, What is the purpose of the semicolon (;) in the PRINT statement?[/INST]To separate 2 items without any spaces in between"
"[INST]In the context of the C64, What is the purpose of the comma (,) in the PRINT statement?[/INST]To separate items into columns"
"[INST]In the context of the C64, What is the purpose of the quote marks ("") in the PRINT statement?[/INST]To separate literal text from variables"
"[INST]In the context of the C64, What is the purpose of the RETURN code (CHR$ code of 13) in the PRINT statement?[/INST]To make the cursor go to the next logical line on the screen"
"[INST]In the context of the C64, What is the purpose of the PRINT statement?[/INST]To format the information on the screen"
"[INST]In the context of the C64, What is the purpose of the cursor in the PRINT statement?[/INST]To change position"
"[INST]In the context of the C64, What is the purpose of the RETURN key?[/INST]To make the cursor go to the next logical line on the screen"
"[INST]In the context of the C64, What is the purpose of the semicolon (;) in the PRINT statement?[/INST]To separate 2 items without any spaces in between"
"[INST]In the context of the C64, What is the purpose of the comma (,) in the PRINT statement?[/INST]To separate items into columns"
"[INST]In the context of the C64, What is the purpose of the quote marks ("") in the PRINT statement?[/INST]To separate literal text from variables"
"[INST]In the context of the C64, Does the Commodore 64 have a built-in RS-232 interface?[/INST]The Commodore 64 has a built-in RS-232 interface for connection to any RS-232 modem, printer, or other device."
"[INST]In the context of the C64, What is required to connect a device to the Commodore 64?[/INST]All you need is a cable and a little bit of programming to connect a device to the Commodore 64."
"[INST]In the context of the C64, What is the voltage range of the Commodore 64's RS-232 interface?[/INST]The Commodore 64's RS-232 interface is set-up in the standard RS-232 format, but the voltages are TTL levels (0 to 5V) rather than the normal RS-232 -12 to 12 volt range."
"[INST]In the context of the C64, What is the purpose of the RS-232 interface software?[/INST]The RS-232 interface software can be accessed from BASIC or from the KERNAL for machine language programming."
"[INST]In the context of the C64, What are the BASIC commands used for RS-232 communication?[/INST]RS-232 on the BASIC level uses the normal BASIC commands: OPEN, CLOSE, CMD, INPUT#, GET#, PRINT#, and the reserved variable ST."
"[INST]In the context of the C64, What is the role of the 6526 CIA #2 device in the RS-232 interface?[/INST]The 6526 chip generates NMI (Non-Maskable Interrupt) requests for RS-232 processing, allowing background RS-232 processing to take place during BASIC and machine language programs."
"[INST]In the context of the C64, What are the built-in hold-offs in the KERNAL, cassette, and serial bus routines?[/INST]There are built-in hold-offs in the KERNAL, cassette, and serial bus routines to prevent the disruption of data storage or transmission by the NMIs that are generated by the RS-232 routines."
"[INST]In the context of the C64, Why can't data be received from RS-232 devices during cassette or serial bus activities?[/INST]Because these hold-offs are only local (assuming you're careful about your programming) no interference should result."
"[INST]In the context of the C64, What are the two buffers in the Commodore 64 RS-232 interface?[/INST]The Commodore 64 RS-232 KERNAL buffers consist of two first-in/first-out (FIFO) buffers, each 256 bytes long, at the top of memory."
"[INST]In the context of the C64, What happens when an RS-232 channel is opened?[/INST]The OPENing of an RS-232 channel automatically allocates 512 bytes of memory for the buffers."
"[INST]In the context of the C64, What happens if there is not enough free space beyond the end of your BASIC program?[/INST]If there is not enough free space beyond the end of your BASIC program no error message will be printed, and the end of your program will be destroyed."
"[INST]In the context of the C64, What happens when an RS-232 channel is closed?[/INST]These buffers are automatically removed by using the CLOSE command."
"[INST]In the context of the C64, What is the importance of being careful when programming RS-232 routines?[/INST]SO BE CAREFUL!"
"[INST]In the context of the C64, Is the RS-232 interface software accessible from BASIC?[/INST]Yes, the RS-232 interface software can be accessed from BASIC."
"[INST]In the context of the C64, Can the RS-232 interface software be accessed from the KERNAL?[/INST]Yes, the RS-232 interface software can be accessed from the KERNAL."
"[INST]In the context of the C64, What is the purpose of the RS-232 interface cartridge?[/INST]The RS-232 interface cartridge handles the necessary voltage conversions."
"[INST]In the context of the C64, What is the role of the KERNAL in the RS-232 interface?[/INST]The KERNAL byte and bit level handlers run under the control of the 6526 CIA #2 device timers and interrupts."
"[INST]In the context of the C64, What is the purpose of the RS-232 interface software in machine language programming?[/INST]The RS-232 interface software can be accessed from the KERNAL for machine language programming."
"[INST]In the context of the C64, What are the commands used for RS-232 communication in machine language programming?[/INST]The commands used for RS-232 communication in machine language programming are the same as those used in BASIC."
"[INST]In the context of the C64, What is the purpose of the RS-232 interface in the Commodore 64?[/INST]The RS-232 interface allows the Commodore 64 to connect to any RS-232 modem, printer, or other device."
"[INST]In the context of the C64, What is the role of the 6526 CIA #2 device in the RS-232 interface?[/INST]The 6526 chip generates NMI (Non-Maskable Interrupt) requests for RS-232 processing."
"[INST]In the context of the C64, What are the built-in hold-offs in the KERNAL, cassette, and serial bus routines?[/INST]There are built-in hold-offs in the KERNAL, cassette, and serial bus routines to prevent the disruption of data storage or transmission by the NMIs that are generated by the RS-232 routines."
"[INST]In the context of the C64, What happens when an RS-232 channel is opened?[/INST]The OPENing of an RS-232 channel automatically allocates 512 bytes of memory for the buffers."
"[INST]In the context of the C64, What happens if there is not enough free space beyond the end of your BASIC program?[/INST]If there is not enough free space beyond the end of your BASIC program no error message will be printed, and the end of your program will be destroyed."
"[INST]In the context of the C64, What happens when an RS-232 channel is closed?[/INST]These buffers are automatically removed by using the CLOSE command."
"[INST]In the context of the C64, Can you enter a program in HEX or SYMBOLIC codes with 64MON?[/INST]You can enter a program in either HEX or SYMBOLIC codes with 64MON."
"[INST]In the context of the C64, What is the advantage of using 64MON?[/INST]The advantages of this method include easier entry of the machine language routines, debugging aids, and a much faster means of saving and loading."
"[INST]In the context of the C64, What is the drawback of using 64MON?[/INST]The drawback to this method is that it generally requires the BASIC program to load the machine language routine from tape or disk when it is started."
"[INST]In the context of the C64, Can you save the portion of memory the program is in with 64MON?[/INST]Yes, you can save the portion of memory the program is in with 64MON."
"[INST]In the context of the C64, What is the purpose of 64MON?[/INST]This program allows you to enter a program in either HEX or SYMBOLIC codes, and save the portion of memory the program is in."
"[INST]In the context of the C64, Can you load a machine language routine from tape with 64MON?[/INST]Yes, you can load a machine language routine from tape with 64MON."
"[INST]In the context of the C64, What is the benefit of using 64MON for debugging?[/INST]The debugging aids are an advantage of using 64MON."
"[INST]In the context of the C64, Can you prepare a machine language routine with 64MON?[/INST]Yes, you can prepare a machine language routine with 64MON."
"[INST]In the context of the C64, Is 64MON a machine language section?[/INST]No, 64MON is not a machine language section, but it has a machine language section."
"[INST]In the context of the C64, Can you save and load with 64MON?[/INST]Yes, you can save and load with 64MON."
"[INST]In the context of the C64, Does the SETTMO routine set the timeout flag for the IEEE bus?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the SETTMO routine?[/INST]Set IEEE bus card timeout flag"
"[INST]In the context of the C64, What is the call address of the SETTMO routine?[/INST]$FFA2 (hex) 65442 (decimal)"
"[INST]In the context of the C64, What communication registers are affected by the SETTMO routine?[/INST]A"
"[INST]In the context of the C64, What is the stack requirement for the SETTMO routine?[/INST]2"
"[INST]In the context of the C64, Can the SETTMO routine be used with an IEEE add-on card only?[/INST]Yes"
"[INST]In the context of the C64, What happens if the device on the IEEE port does not respond to the DAV signal within 64 milliseconds?[/INST]The Commodore 64 will recognize an error condition and leave the handshake sequence"
"[INST]In the context of the C64, What is the effect of setting bit 7 of the accumulator to 0 when calling the SETTMO routine?[/INST]Timeouts are enabled"
"[INST]In the context of the C64, What is the effect of setting bit 7 of the accumulator to 1 when calling the SETTMO routine?[/INST]Timeouts are disabled"
"[INST]In the context of the C64, What is the purpose of the timeout feature in the Commodore 64?[/INST]To communicate that a disk file is not found on an attempt to OPEN a file only with an IEEE card"
"[INST]In the context of the C64, what is the opcode for STA in zero page addressing mode?[/INST]The opcode for STA in zero page addressing mode is 85, which requires 2 bytes and takes 3 cycles to execute."
"[INST]In the context of the C64, what is the difference between STA Oper and STA Oper,X in zero page addressing mode?[/INST]In zero page addressing mode, STA Oper uses the opcode 85 and takes 3 cycles, whereas STA Oper,X uses the opcode 95 and takes 4 cycles, with the X register being used as an offset to the zero page address."
"[INST]In the context of the C64, what is the opcode for STA in absolute addressing mode?[/INST]The opcode for STA in absolute addressing mode is 80, which requires 3 bytes and takes 4 cycles to execute."
"[INST]In the context of the C64, how does the STA instruction differ when using the Y register in absolute addressing mode?[/INST]When using the Y register in absolute addressing mode, the STA instruction uses the opcode 99, requires 3 bytes, and takes 5 cycles to execute, with the Y register being used as an offset to the absolute address."
"[INST]In the context of the C64, what is the opcode for STA in indirect,X addressing mode?[/INST]The opcode for STA in indirect,X addressing mode is 81, which requires 2 bytes and takes 6 cycles to execute, with the X register being used as an offset to the indirect address."
"[INST]In the context of the C64, what is the difference between STA (Oper,X) and STA (Oper),Y in indirect addressing mode?[/INST]In indirect addressing mode, STA (Oper,X) uses the opcode 81 and takes 6 cycles, whereas STA (Oper),Y uses the opcode 91 and also takes 6 cycles, with the X register being used as an offset to the indirect address in the former, and the Y register being used as an offset in the latter."
"[INST]In the context of the C64, what is the purpose of the STA instruction?[/INST]The STA instruction is used to store the value of the accumulator in a specified memory location, with the addressing mode determining the memory location being written to."
"[INST]In the context of the C64, can you provide an example of using STA in a program?[/INST]Here is an example of using STA in a program: `LDA #$05 ; load the value 5 into the accumulator STA $0200 ; store the accumulator value in memory location $0200`"
"[INST]In the context of the C64, what is the relationship between the STA instruction and the accumulator?[/INST]The STA instruction is used to store the value of the accumulator in a specified memory location, meaning that the accumulator's value is copied to the specified memory location."
"[INST]In the context of the C64, how does the STA instruction interact with the X and Y registers?[/INST]The STA instruction can use the X and Y registers as offsets to the specified memory location, allowing for more flexible and dynamic memory access, with the X register being used in indirect,X and zero page,X addressing modes, and the Y register being used in absolute,Y and indirect,Y addressing modes."
"[INST]In the context of the C64, what is the function of FC LO and FC HI registers in the C64's programmable Filter?[/INST]Together, FC LO and FC HI registers form an 11-bit number that linearly controls the Cutoff (or Center) Frequency of the programmable Filter, with an approximate range of 30 Hz to 12 KHz."
"[INST]In the context of the C64, what is the purpose of the RES/FILT register in the C64's programmable Filter?[/INST]The RES/FILT register controls the resonance of the filter, with bits 4-7 (RES0-RES3) determining the resonance level, and bits 0-3 determining which signals will be routed through the Filter, including Voice 1, Voice 2, Voice 3, and External audio input."
"[INST]In the context of the C64, what is the range of resonance settings in the C64's programmable Filter?[/INST]The resonance settings range from no resonance (0) to maximum resonance (15 or $F), with 16 linearly spaced settings."
"[INST]In the context of the C64, how does the FILT 1 bit in the RES/FILT register affect Voice 1 in the C64's programmable Filter?[/INST]When the FILT 1 bit is set to 0, Voice 1 appears directly at the audio output and the Filter has no effect on it, but when set to 1, Voice 1 is processed through the Filter and its harmonic content is altered according to the selected Filter parameters."
"[INST]In the context of the C64, what is the function of the FILTEX bit in the RES/FILT register in the C64's programmable Filter?[/INST]The FILTEX bit determines whether the External audio input (pin 26) is processed through the Filter, with a 0 setting bypassing the Filter and a 1 setting routing the External audio input through the Filter."
"[INST]In the context of the C64, what is the total number of bits used to control the Cutoff Frequency in the C64's programmable Filter?[/INST]The Cutoff Frequency is controlled by an 11-bit number formed by FC LO and FC HI registers."
"[INST]In the context of the C64, what is the highest possible Cutoff Frequency in the C64's programmable Filter?[/INST]The highest possible Cutoff Frequency is approximately 12 KHz."
"[INST]In the context of the C64, what happens to the harmonic content of Voice 1 when the FILT 1 bit is set to 1 in the RES/FILT register?[/INST]The harmonic content of Voice 1 is altered according to the selected Filter parameters when the FILT 1 bit is set to 1."
"[INST]In the context of the C64, what is the purpose of bits 0-3 in the RES/FILT register in the C64's programmable Filter?[/INST]Bits 0-3 in the RES/FILT register determine which signals will be routed through the Filter, including Voice 1, Voice 2, Voice 3, and External audio input."
"[INST]In the context of the C64, what is the lowest possible Cutoff Frequency in the C64's programmable Filter?[/INST]The lowest possible Cutoff Frequency is approximately 30 Hz."
"[INST]In the context of the C64, what is the purpose of the RES pin on the SID chip?[/INST]The RES pin on the SID chip is a TTL-level input that serves as the reset control for the SID. When this pin is brought low for at least ten 02 cycles, it resets all internal registers to zero and silences the audio output, effectively restarting the SID chip."
"[INST]In the context of the C64, what happens when the RES pin is brought low for at least ten 02 cycles?[/INST]When the RES pin is brought low for at least ten 02 cycles, all internal registers of the SID chip are reset to zero and the audio output is silenced, effectively resetting the SID chip to its initial state."
"[INST]In the context of the C64, how is the RES pin typically connected?[/INST]The RES pin is normally connected to the reset line of the microprocessor or a power-on-clear circuit, ensuring that the SID chip is properly reset during power-on or when the microprocessor is reset."
"[INST]In the context of the C64, what is the effect of resetting the SID chip?[/INST]Resetting the SID chip silences the audio output and resets all internal registers to zero, effectively restarting the SID chip and preparing it for new audio operations."
"[INST]In the context of the C64, what type of signal is required on the RES pin?[/INST]The RES pin requires a TTL-level input signal to function properly, which is a specific type of digital signal that is commonly used in electronic circuits."
"[INST]In the context of the C64, what is the purpose of resetting the SID chip?[/INST]Resetting the SID chip is necessary to ensure that it is properly initialized and ready to produce audio output, and to prevent any unwanted or residual audio signals from being produced."
"[INST]In the context of the C64, in what situations would the RES pin be used?[/INST]The RES pin would be used during power-on or when the microprocessor is reset, to ensure that the SID chip is properly reset and initialized."
"[INST]In the context of the C64, what is the duration of the low signal required on the RES pin?[/INST]The RES pin requires a low signal for at least ten 02 cycles to properly reset the SID chip."
"[INST]In the context of the C64, what is the effect of not resetting the SID chip?[/INST]If the SID chip is not properly reset, it may produce unwanted or residual audio signals, or may not function properly, leading to unpredictable behavior."
"[INST]In the context of the C64, why is the RES pin important for the SID chip?[/INST]The RES pin is important for the SID chip because it provides a way to properly reset and initialize the chip, ensuring that it functions correctly and produces the desired audio output."
"[INST]In the context of the C64, What is the limitation of horizontal resolution in sprite multi-color mode?[/INST]In sprite multi-color mode, the horizontal resolution is cut in half, resulting in 12 pairs of dots instead of 24 dots across the sprite."
"[INST]In the context of the C64, How many different colors can be used in each sprite in multi-color mode?[/INST]Up to 4 different colors can be used in each sprite in multi-color mode."
"[INST]In the context of the C64, What is a BIT PAIR in sprite multi-color mode?[/INST]A BIT PAIR is a pair of dots in a sprite, which is treated as a single dot when choosing colors for the dots in the sprite."
"[INST]In the context of the C64, What is the bit pair value to turn ON the transparent color in a sprite?[/INST]The bit pair value to turn ON the transparent color in a sprite is 00."
"[INST]In the context of the C64, What is the bit pair value to turn ON the SPRITE MULTI-COLOR REGISTER #0 in a sprite?[/INST]The bit pair value to turn ON the SPRITE MULTI-COLOR REGISTER #0 in a sprite is 01."
"[INST]In the context of the C64, What is the bit pair value to turn ON the SPRITE COLOR REGISTER in a sprite?[/INST]The bit pair value to turn ON the SPRITE COLOR REGISTER in a sprite is 10."
"[INST]In the context of the C64, What is the bit pair value to turn ON the SPRITE MULTI-COLOR REGISTER #1 in a sprite?[/INST]The bit pair value to turn ON the SPRITE MULTI-COLOR REGISTER #1 in a sprite is 11."
"[INST]In the context of the C64, What is the significance of the value 10 in sprite multi-color mode?[/INST]The value 10 represents the sprite foreground color in sprite multi-color mode."
"[INST]In the context of the C64, What is the significance of the value 11 in sprite multi-color mode?[/INST]The value 11 represents the character foreground color in sprite multi-color mode."
"[INST]In the context of the C64, How do you think the sprite multi-color mode affects the overall graphics quality of a C64 game?[/INST]The sprite multi-color mode allows for more colorful and detailed sprites, but at the cost of reduced horizontal resolution, which may affect the overall graphics quality of a C64 game."
"[INST]In the context of the C64, Operation of LDA instruction[/INST]The LDA instruction is used to load the accumulator with a value from memory."
"[INST]In the context of the C64, LDA instruction format[/INST]The LDA instruction has several formats, including immediate, zero page, zero page X, absolute, absolute X, absolute Y, indirect X, and indirect Y."
"[INST]In the context of the C64, LDA instruction opcode[/INST]The opcode for the LDA instruction is A9, A5, B5, AD, BD, B9, A1, and B1."
"[INST]In the context of the C64, LDA instruction cycles[/INST]The number of cycles required to execute the LDA instruction varies depending on the addressing mode, ranging from 2 to 6 cycles."
"[INST]In the context of the C64, LDA instruction bytes[/INST]The number of bytes required to execute the LDA instruction varies depending on the addressing mode, ranging from 2 to 3 bytes."
"[INST]In the context of the C64, LDA instruction addressing modes[/INST]The LDA instruction has several addressing modes, including immediate, zero page, zero page X, absolute, absolute X, absolute Y, indirect X, and indirect Y."
"[INST]In the context of the C64, LDA instruction indirect addressing[/INST]The LDA instruction can use indirect addressing modes, including (indirect,X) and (indirect),Y."
"[INST]In the context of the C64, LDA instruction page boundary crossing[/INST]The LDA instruction can cross page boundaries, resulting in an additional cycle being added to the instruction's execution time."
"[INST]In the context of the C64, LDA instruction zero page addressing[/INST]The LDA instruction can use zero page addressing, which allows for faster access to memory locations."
"[INST]In the context of the C64, LDA instruction absolute addressing[/INST]The LDA instruction can use absolute addressing, which allows for direct access to memory locations."
"[INST]In the context of the C64, SBC stands for?[/INST]Subtract memory from accumulator with borrow"
"[INST]In the context of the C64, Subtract memory from accumulator with borrow?[/INST]SBC"
"[INST]In the context of the C64, What is the operation of SBC instruction?[/INST]A - M - C -> A"
"[INST]In the context of the C64, What is the note about C in SBC instruction?[/INST]C = Borrow"
"[INST]In the context of the C64, What is the purpose of SBC instruction?[/INST]Subtract memory from accumulator with borrow"
"[INST]In the context of the C64, What is the number of bytes for SBC #Oper in Immediate mode?[/INST]2"
"[INST]In the context of the C64, What is the number of cycles for SBC Oper in Zero Page mode?[/INST]3"
"[INST]In the context of the C64, What is the number of bytes for SBC Oper,X in Zero Page,X mode?[/INST]2"
"[INST]In the context of the C64, What is the number of cycles for SBC Oper,X in Zero Page,X mode?[/INST]4"
"[INST]In the context of the C64, What is the number of bytes for SBC Oper in Absolute mode?[/INST]3"
"[INST]In the context of the C64, What is the number of cycles for SBC Oper in Absolute mode?[/INST]4"
"[INST]In the context of the C64, what is the function of PW LO/PW HI registers in the C64?[/INST]These registers form a 12-bit number that linearly controls the Pulse Width (duty cycle) of the Pulse waveform on Oscillator 1, with a resolution that allows for smooth sweeping without discernable stepping."
"[INST]In the context of the C64, how is the pulse width determined in the C64?[/INST]The pulse width is determined by the equation PWout = (PWn/40.95) %, where PWn is the 12-bit number in the Pulse Width registers."
"[INST]In the context of the C64, what happens when the Pulse Width registers are set to 0 or 4095 ($FF)?[/INST]A value of 0 or 4095 ($FF) in the Pulse Width registers will produce a constant DC output."
"[INST]In the context of the C64, what happens when the Pulse Width registers are set to 2048 ($800)?[/INST]A value of 2048 ($800) in the Pulse Width registers will produce a square wave."
"[INST]In the context of the C64, what is the condition for the Pulse Width registers to have an audible effect?[/INST]The Pulse waveform on Oscillator 1 must be selected in order for the Pulse Width registers to have any audible effect."
"[INST]In the context of the C64, in what format is the 12-bit number stored in the Pulse Width registers?[/INST]The 12-bit number is stored in the Pulse Width registers with bits 4-7 of PW HI not used."
"[INST]In the context of the C64, what is the range of values that can be stored in the Pulse Width registers?[/INST]The Pulse Width registers can store values ranging from 0 to 4095 ($FF), which corresponds to a 12-bit number."
"[INST]In the context of the C64, how does the pulse width resolution affect the output waveform?[/INST]The pulse width resolution allows the width to be smoothly swept with no discernable stepping, resulting in a smooth output waveform."
"[INST]In the context of the C64, in what way do the Pulse Width registers control the Pulse waveform on Oscillator 1?[/INST]The Pulse Width registers control the Pulse waveform on Oscillator 1 by linearly controlling the Pulse Width (duty cycle) of the waveform."
"[INST]In the context of the C64, what is the relationship between the Pulse Width registers and the Oscillator 1 waveform?[/INST]The Pulse Width registers directly control the Pulse Width (duty cycle) of the Pulse waveform on Oscillator 1, allowing for precise control over the waveform's characteristics."
"[INST]In the context of the C64, What is the fundamental frequency of a note?[/INST]The fundamental frequency defines the overall pitch of the note."
"[INST]In the context of the C64, What are harmonics in the context of sound waves?[/INST]Harmonics are sine waves having frequencies which are integer multiples of the fundamental frequency."
"[INST]In the context of the C64, What is the relationship between the fundamental frequency and the harmonics?[/INST]The harmonics are integer multiples of the fundamental frequency."
"[INST]In the context of the C64, What is the timbre of a note determined by?[/INST]The amounts of each harmonic present in a note give it its timbre."
"[INST]In the context of the C64, What is the harmonic structure of an acoustic instrument like a guitar or violin?[/INST]An acoustic instrument has a very complicated harmonic structure."
"[INST]In the context of the C64, What is the difference between a triangular wave and a sine wave?[/INST]A triangular wave contains only odd harmonics, while a sine wave oscillates at the fundamental frequency."
"[INST]In the context of the C64, What is the relationship between the harmonic number and the amplitude of a harmonic in a triangular wave?[/INST]The amount of each harmonic present is proportional to the reciprocal of the square of the harmonic number."
"[INST]In the context of the C64, What is the difference between a sawtooth wave and a triangular wave?[/INST]A sawtooth wave contains all the harmonics, while a triangular wave contains only odd harmonics."
"[INST]In the context of the C64, What is the relationship between the harmonic number and the amplitude of a harmonic in a sawtooth wave?[/INST]The amount of each harmonic present is proportional to the reciprocal of the harmonic number."
"[INST]In the context of the C64, What is the difference between a square wave and a rectangular wave?[/INST]A square wave contains odd harmonics, while a rectangular wave has varying harmonic content."
"[INST]In the context of the C64, What is the effect of changing the pulse width on a rectangular wave?[/INST]The timbre of the sound of a rectangular wave can be varied tremendously by changing the pulse width."
"[INST]In the context of the C64, What is the purpose of filtering in sound quality?[/INST]Filtering can be used to refine the sound and achieve the desired sound quality."
"[INST]In the context of the C64, What is the relationship between the waveform and the sound quality?[/INST]The waveform used can affect the sound quality and timbre of the sound."
"[INST]In the context of the C64, What is the role of harmonics in sound waves?[/INST]Harmonics are sine waves having frequencies which are integer multiples of the fundamental frequency."
"[INST]In the context of the C64, What is the difference between a fundamental frequency and a harmonic frequency?[/INST]The fundamental frequency defines the overall pitch of the note, while harmonic frequencies are integer multiples of the fundamental frequency."
"[INST]In the context of the C64, What is the relationship between the harmonic structure and the timbre of a note?[/INST]The harmonic structure gives a note its timbre."
"[INST]In the context of the C64, What is the purpose of choosing the right waveform?[/INST]Choosing the right waveform can help achieve the desired sound quality."
"[INST]In the context of the C64, What is the effect of filtering on the sound quality?[/INST]Filtering can refine the sound and achieve the desired sound quality."
"[INST]In the context of the C64, What is the role of the fundamental frequency in sound waves?[/INST]The fundamental frequency defines the overall pitch of the note."
"[INST]In the context of the C64, What is the relationship between the harmonic structure and the sound quality?[/INST]The harmonic structure affects the sound quality and timbre of a note."
"[INST]In the context of the C64, What is the difference between a sine wave and a triangular wave?[/INST]A sine wave oscillates at the fundamental frequency, while a triangular wave contains only odd harmonics."
"[INST]In the context of the C64, What is the purpose of adding filtering to a sound?[/INST]Filtering can refine the sound and achieve the desired sound quality."
"[INST]In the context of the C64, What is the relationship between the waveform and the sound quality?[/INST]The waveform used can affect the sound quality and timbre of the sound."
"[INST]In the context of the C64, What is the role of harmonics in the sound quality?[/INST]Harmonics are sine waves having frequencies which are integer multiples of the fundamental frequency."
"[INST]In the context of the C64, What is the difference between a sawtooth wave and a square wave?[/INST]A sawtooth wave contains all the harmonics, while a square wave contains odd harmonics."
"[INST]In the context of the C64, What is the purpose of choosing the right waveform?[/INST]Choosing the right waveform can help achieve the desired sound quality."
"[INST]In the context of the C64, What is the effect of changing the pulse width on a rectangular wave?[/INST]The timbre of the sound of a rectangular wave can be varied tremendously by changing the pulse width."
"[INST]In the context of the C64, What is the role of filtering in sound quality?[/INST]Filtering can refine the sound and achieve the desired sound quality."
"[INST]In the context of the C64, What is the relationship between the harmonic structure and the timbre of a note?[/INST]The harmonic structure gives a note its timbre."
"[INST]In the context of the C64, What is the purpose of adding filtering to a sound?[/INST]Filtering can refine the sound and achieve the desired sound quality."
"[INST]In the context of the C64, What is the relationship between the waveform and the sound quality?[/INST]The waveform used can affect the sound quality and timbre of the sound."
"[INST]In the context of the C64, What is the role of harmonics in the sound quality?[/INST]Harmonics are sine waves having frequencies which are integer multiples of the fundamental frequency."
"[INST]In the context of the C64, Is the status register a collection of flags?[/INST]Yes, it is a collection of eight flags."
"[INST]In the context of the C64, What does each flag indicate?[/INST]Each flag indicates whether something has or has not occurred."
"[INST]In the context of the C64, What is the purpose of the flags?[/INST]The purpose of the flags is to indicate whether something has or has not occurred."
"[INST]In the context of the C64, What is the total number of flags in the status register?[/INST]There are eight flags in the status register."
"[INST]In the context of the C64, What is the term for something that indicates whether something has or has not occurred?[/INST]The term is 'flag'."
"[INST]In the context of the C64, What is the status register used for?[/INST]The status register is used to indicate whether something has or has not occurred."
"[INST]In the context of the C64, What is the function of each flag in the status register?[/INST]The function of each flag is to indicate whether something has or has not occurred."
"[INST]In the context of the C64, What is the total number of flags in the status register?[/INST]There are eight flags in the status register."
"[INST]In the context of the C64, What is the purpose of the status register?[/INST]The purpose of the status register is to indicate whether something has or has not occurred."
"[INST]In the context of the C64, What does the status register consist of?[/INST]The status register consists of eight flags."
"[INST]In the context of the C64, Output a character to an already opened channel.[/INST]This routine outputs a character to an already opened channel."
"[INST]In the context of the C64, What is the purpose of the CHROUT routine?[/INST]Output a character"
"[INST]In the context of the C64, What is the call address of the CHROUT routine?[/INST]$FFD2 (hex) 65490 (decimal)"
"[INST]In the context of the C64, What registers are affected by the CHROUT routine?[/INST]Registers affected: A"
"[INST]In the context of the C64, What is the minimum stack requirement for the CHROUT routine?[/INST]8+"
"[INST]In the context of the C64, What is the default output device if the call is omitted?[/INST]the screen"
"[INST]In the context of the C64, What is the data byte to be output loaded into?[/INST]the accumulator"
"[INST]In the context of the C64, What is the routine that must be used to set up the output channel?[/INST]KERNAL OPEN and CHKOUT"
"[INST]In the context of the C64, What is the routine that must be used to close all open output channels?[/INST]KERNAL CLRCHN"
"[INST]In the context of the C64, What is the potential issue when using the CHROUT routine to send data to a specific serial device?[/INST]data will be sent to all open output channels on the bus"
"[INST]In the context of the C64, What are the steps to use the CHROUT routine?[/INST]0) Use the CHKOUT KERNAL routine if needed, 1) Load the data to be output into the accumulator, 2) Call this routine"
"[INST]In the context of the C64, what is the purpose of the raster register?[/INST]The raster register is a dual-function register that returns the lower 8 bits of the current raster position when read, and can be written to latch a value for an internal raster compare, triggering a raster interrupt when the current raster matches the written value."
"[INST]In the context of the C64, what is the location of the MSB-RC8 bit in the raster register?[/INST]The MSB-RC8 bit is located in register 17 ($11), which is separate from the lower 8 bits of the raster position in register 18 ($12)."
"[INST]In the context of the C64, what is the purpose of interrogating the raster register?[/INST]Interrogating the raster register allows for implementing display changes outside the visible area, thereby preventing display flicker."
"[INST]In the context of the C64, what is the visible display window in terms of raster lines?[/INST]The visible display window is from raster 51 through raster 251 ($033-$0FB)."
"[INST]In the context of the C64, what happens when the current raster matches the written value in the raster register?[/INST]When the current raster matches the written value, the raster interrupt latch is set."
"[INST]In the context of the C64, what is the effect of writing to the raster bits in the raster register?[/INST]Writing to the raster bits, including RC8, latches the value for an internal raster compare, which triggers a raster interrupt when the current raster matches the written value."
"[INST]In the context of the C64, what is the address of the raster register?[/INST]The address of the raster register is $12 (18 decimal)."
"[INST]In the context of the C64, what is the significance of register 17 ($11) in relation to the raster register?[/INST]Register 17 ($11) contains the MSB-RC8 bit, which is part of the raster position and is separate from the lower 8 bits in the raster register."
"[INST]In the context of the C64, how can display flicker be prevented when making display changes?[/INST]Display flicker can be prevented by interrogating the raster register to implement display changes outside the visible area."
"[INST]In the context of the C64, what is the purpose of the internal raster compare in the raster register?[/INST]The internal raster compare in the raster register is used to trigger a raster interrupt when the current raster matches the written value, allowing for precise timing of display changes."
"[INST]In the context of the C64, Purpose of PLOT function[/INST]Set cursor location"
"[INST]In the context of the C64, Call address of PLOT function[/INST]$FFF0 (hex) 65520 (decimal)"
"[INST]In the context of the C64, Registers affected by PLOT function[/INST]A, X, Y"
"[INST]In the context of the C64, Preparatory routines for PLOT function[/INST]nan"
"[INST]In the context of the C64, Error returns for PLOT function[/INST]nan"
"[INST]In the context of the C64, Stack requirements for PLOT function[/INST]2"
"[INST]In the context of the C64, Description of PLOT function[/INST]A call to this routine with the accumulator carry flag set loads the current position of the cursor on the screen (in X,Y coordinates) into the Y and X registers."
"[INST]In the context of the C64, How to read cursor location using PLOT function[/INST]1) Set the carry flag. 2) Call this routine. 3) Get the X and Y position from the Y and X registers, respectively."
"[INST]In the context of the C64, How to set cursor location using PLOT function[/INST]1) Clear carry flag. 2) Set the Y and X registers to the desired cursor location. 3) Call this routine."
"[INST]In the context of the C64, Example of using PLOT function to move cursor[/INST];MOVE THE CURSOR TO ROW 10, COLUMN 5 (5,10) LDX #10 LDY #5 CLC JSR PLOT"
"[INST]In the context of the C64, How many different dot positions can be individually programmed onto a TV screen in the Y direction?[/INST]200"
"[INST]In the context of the C64, What is the maximum number that the sprite Y position registers can handle?[/INST]255"
"[INST]In the context of the C64, Can the sprite Y position registers handle moving a sprite up and down?[/INST]yes"
"[INST]In the context of the C64, How many values are needed to smoothly move a sprite on and off the screen?[/INST]more than 200"
"[INST]In the context of the C64, What is the first on-screen value from the top of the screen in the Y direction for an unexpanded sprite?[/INST]30"
"[INST]In the context of the C64, What is the first Y value in which a sprite is fully on the screen?[/INST]50"
"[INST]In the context of the C64, What is the last Y value in which an unexpanded sprite is fully on the screen?[/INST]229"
"[INST]In the context of the C64, What is the last Y value in which an expanded sprite is fully on the screen?[/INST]208"
"[INST]In the context of the C64, What is the first Y value in which a sprite is fully off the screen?[/INST]250"
"[INST]In the context of the C64, Is the initial position of a sprite calculated from the top left corner?[/INST]yes"
"[INST]In the context of the C64, How many possible locations are on the Commodore 64 screen?[/INST]There are 1000 possible locations on the Commodore 64 screen."
"[INST]In the context of the C64, What is the starting location of the screen memory?[/INST]The screen starts at location 1024 ($0400 in HEXadecimal notation) but note that it can be changed programmatically."
"[INST]In the context of the C64, What is the width of each location in screen memory?[/INST]Each of these locations is 8 bits wide."
"[INST]In the context of the C64, How many colors can the Commodore 64 use?[/INST]There are 16 possible colors that the Commodore 64 can use."
"[INST]In the context of the C64, What determines which character to display at each screen location?[/INST]Each of the 1000 locations in screen memory contains a code number which tells the VIC-II chip which character to display at that screen location."
"[INST]In the context of the C64, What controls the various graphics modes?[/INST]The 47 CONTROL registers in the VIC-II chip select the various graphics modes."
"[INST]In the context of the C64, Where is the VIC-II chip located?[/INST]The VIC-II chip is located starting at 53248 ($D000 in HEX) through 53294 ($D02E in HEX)."
"[INST]In the context of the C64, what is a movable object block in the context of Commodore 64 graphics?[/INST]A movable object block, also referred to as a sprite, is a special type of character that can be displayed at any one position on the screen without the block constraints inherent in character and bit map mode."
"[INST]In the context of the C64, what is the maximum number of unique sprites that can be displayed simultaneously on a Commodore 64?[/INST]Up to 8 unique sprites can be displayed simultaneously, each defined by 63 bytes in memory which are displayed as a 24*21 dot array."
"[INST]In the context of the C64, what is the memory requirement for defining a sprite on a Commodore 64?[/INST]Each sprite is defined by 63 bytes in memory which are displayed as a 24*21 dot array."
"[INST]In the context of the C64, what is the dot array size of a sprite on a Commodore 64?[/INST]A sprite is displayed as a 24*21 dot array."
"[INST]In the context of the C64, what are some of the special features that make sprites suitable for video graphics and game applications on a Commodore 64?[/INST]Sprites have a number of special features that make them especially suited for video graphics and game applications."
"[INST]In the context of the C64, how are sprites stored in memory on a Commodore 64?[/INST]Sprites are stored in memory as a sequence of 63 bytes, with each byte representing a row of the sprite's 24*21 dot array."
"[INST]In the context of the C64, what is the layout of a sprite's memory block on a Commodore 64?[/INST]The memory block of a sprite is laid out as a sequence of 63 bytes, with each byte representing a row of the sprite's 24*21 dot array, as shown in the diagram: BYTE 00, BYTE 01, BYTE 02, ..., BYTE 62."
"[INST]In the context of the C64, can sprites be used in character and bit map modes on a Commodore 64?[/INST]No, sprites are not subject to the block constraints inherent in character and bit map modes, making them more flexible and powerful for graphics and game applications."
"[INST]In the context of the C64, what is the significance of the 63 bytes that define a sprite on a Commodore 64?[/INST]The 63 bytes that define a sprite are used to store the graphical data that makes up the sprite's 24*21 dot array, allowing for detailed and complex graphics to be displayed on the screen."
"[INST]In the context of the C64, in what ways are sprites more flexible than characters and bit maps on a Commodore 64?[/INST]Sprites are more flexible than characters and bit maps because they can be displayed at any one position on the screen without the block constraints inherent in character and bit map modes."
"[INST]In the context of the C64, what is the purpose of the PEEK and POKE commands in CBM BASIC language?[/INST]The PEEK and POKE commands in CBM BASIC language are used for changing memory locations, commonly used for graphics on the screen and for sound effects. They allow the programmer to access and modify specific memory locations by specifying their addresses."
"[INST]In the context of the C64, in the context of the Commodore 64, what is an address?[/INST]In the context of the Commodore 64, an address refers to a unique number that identifies a specific memory location. It's like a street address, where each memory location has its own number, allowing the programmer to access and manipulate it."
"[INST]In the context of the C64, what is the analogy used to describe memory locations in the Commodore 64?[/INST]The analogy used to describe memory locations in the Commodore 64 is a street of buildings, where each building represents a memory location, and the number on each door is the address of that location."
"[INST]In the context of the C64, what is the purpose of specifying an address when using PEEK and POKE commands?[/INST]The purpose of specifying an address when using PEEK and POKE commands is to identify the specific memory location that the programmer wants to access or modify, allowing for precise control over the computer's memory."
"[INST]In the context of the C64, what is the relationship between memory locations and addresses in the Commodore 64?[/INST]In the Commodore 64, each memory location has its own unique address, which serves as an identifier for that location. This allows the programmer to access and manipulate specific memory locations using their addresses."
"[INST]In the context of the C64, how do PEEK and POKE commands interact with memory locations in the Commodore 64?[/INST]PEEK and POKE commands interact with memory locations in the Commodore 64 by allowing the programmer to read from or write to specific memory locations, using their addresses to access and modify their contents."
"[INST]In the context of the C64, what is the significance of memory addresses in programming the Commodore 64?[/INST]Memory addresses are significant in programming the Commodore 64 because they provide a way to access and manipulate specific memory locations, allowing the programmer to control the computer's behavior and perform specific tasks."
"[INST]In the context of the C64, in what way do PEEK and POKE commands provide control over memory locations?[/INST]PEEK and POKE commands provide control over memory locations by allowing the programmer to read from or write to specific memory locations, giving them precise control over the computer's memory and enabling them to perform specific tasks."
"[INST]In the context of the C64, what is the role of addresses in the context of PEEK and POKE commands?[/INST]In the context of PEEK and POKE commands, addresses play the role of identifiers for specific memory locations, allowing the programmer to target and manipulate specific locations in the computer's memory."
"[INST]In the context of the C64, how do addresses enable the programmer to access specific memory locations?[/INST]Addresses enable the programmer to access specific memory locations by providing a unique identifier for each location, allowing the programmer to use PEEK and POKE commands to read from or write to specific locations in the computer's memory."
"[INST]In the context of the C64, what is the four-part envelope generator used in electronic music?[/INST]The four-part ADSR (ATTACK, DECAY, SUSTAIN, RELEASE) envelope generator has been proven in electronic music to provide the optimum trade-off between flexibility and ease of amplitude control."
"[INST]In the context of the C64, what is the violin an example of?[/INST]The violin is a good example of a sustained instrument."
"[INST]In the context of the C64, how does the violinist control the volume of the violin?[/INST]The violinist controls the volume by bowing the instrument."
"[INST]In the context of the C64, what happens to the volume of the violin after it reaches a peak?[/INST]The volume drops to an intermediate level."
"[INST]In the context of the C64, can the tone of the violin be held at the intermediate SUSTAIN level?[/INST]Yes, the tone can be held at the intermediate SUSTAIN level for as long as desired."
"[INST]In the context of the C64, what happens to the tone of the violin when GATE is cleared?[/INST]The tone will not begin to die away until GATE is cleared."
"[INST]In the context of the C64, can the basic envelope of the violin be used for other instruments?[/INST]Yes, with minor alterations, this basic envelope can be used for brass and woodwinds as well as strings."
"[INST]In the context of the C64, what is the characteristic of the percussion envelope?[/INST]The percussion envelope is characterized by a nearly instantaneous attack, immediately followed by a decay to zero volume."
"[INST]In the context of the C64, can percussion instruments be sustained at a constant amplitude?[/INST]No, percussion instruments cannot be sustained at a constant amplitude."
"[INST]In the context of the C64, what happens to the sound of a drum after it is struck?[/INST]The sound reaches full volume and decays rapidly regardless of how it was struck."
"[INST]In the context of the C64, what happens to the tone of percussion instruments after the peak is reached?[/INST]The tone immediately begins to decay to zero amplitude after the peak is reached, regardless of when GATE is cleared."
"[INST]In the context of the C64, what is the amplitude envelope of pianos and harpsichords like?[/INST]The amplitude envelope of pianos and harpsichords is somewhat more complicated, but can be generated quite easily with the ADSR."
"[INST]In the context of the C64, what happens to the amplitude of pianos and harpsichords when a key is first struck?[/INST]The amplitude reaches full volume when a key is first struck."
"[INST]In the context of the C64, what happens to the amplitude of pianos and harpsichords when a key remains depressed?[/INST]The amplitude immediately begins to die away slowly as long as the key remains depressed."
"[INST]In the context of the C64, what happens to the amplitude of pianos and harpsichords when a key is released?[/INST]If the key is released before the sound has fully died away, the amplitude will immediately drop to zero."
"[INST]In the context of the C64, what is the amplitude envelope of the organ like?[/INST]When a key is pressed, the tone immediately reaches full volume and remains there."
"[INST]In the context of the C64, what happens to the amplitude of the organ when a key is released?[/INST]When the key is released, the tone drops immediately to zero volume."
"[INST]In the context of the C64, what is the real power of SID?[/INST]The real power of SID lies in the ability to create original sounds rather than simulations of acoustic instruments."
"[INST]In the context of the C64, what is an example of an original sound that can be created with SID?[/INST]A good example would be the 'backwards' envelope, which is characterized by a slow attack and rapid decay which sounds very much like an instrument that has been recorded on tape then played backwards."
"[INST]In the context of the C64, what can be created by applying the amplitude envelope of one instrument to the harmonic structure of another?[/INST]Many unique sounds can be created by applying the amplitude envelope of one instrument to the harmonic structure of another."
"[INST]In the context of the C64, what is necessary to achieve the desired sound?[/INST]Experimentation with various envelope rates and harmonic contents will be necessary in order to achieve the desired sound."
"[INST]In the context of the C64, What is the purpose of the ENV 3 register?[/INST]The ENV 3 register allows the microprocessor to read the output of the Voice 3 Envelope Generator, which can be used to create harmonic envelopes, WAH-WAH, and similar effects by adding the output to the Filter Frequency."
"[INST]In the context of the C64, What is required for the ENV 3 register to produce any output?[/INST]The Voice 3 Envelope Generator must be Gated in order to produce any output from the ENV 3 register."
"[INST]In the context of the C64, How does the ENV 3 register differ from the OSC 3 register?[/INST]The OSC 3 register always reflects the changing output of the oscillator and is not affected in any way by the Envelope Generator, whereas the ENV 3 register is affected by the Envelope Generator and requires it to be Gated."
"[INST]In the context of the C64, What type of effects can be created by adding the output of the ENV 3 register to the frequency control registers of an oscillator?[/INST]'Phaser' sounds can be created by adding the output of the ENV 3 register to the frequency control registers of an oscillator."
"[INST]In the context of the C64, What is the relationship between the ENV 3 register and the Voice 3 Envelope Generator?[/INST]The ENV 3 register allows the microprocessor to read the output of the Voice 3 Envelope Generator, which can be used to create various effects."
"[INST]In the context of the C64, How does the ENV 3 register interact with the Filter Frequency?[/INST]The output of the ENV 3 register can be added to the Filter Frequency to produce harmonic envelopes, WAH-WAH, and similar effects."
"[INST]In the context of the C64, What is the role of the Envelope Generator in relation to the ENV 3 register?[/INST]The Envelope Generator must be Gated in order to produce any output from the ENV 3 register, and the output of the ENV 3 register is dependent on the Envelope Generator."
"[INST]In the context of the C64, What is the difference in behavior between the ENV 3 register and the OSC 3 register when the Envelope Generator is Gated?[/INST]The ENV 3 register will produce output when the Envelope Generator is Gated, whereas the OSC 3 register is not affected by the Envelope Generator and will always reflect the changing output of the oscillator."
"[INST]In the context of the C64, How can the ENV 3 register be used to create WAH-WAH effects?[/INST]The output of the ENV 3 register can be added to the Filter Frequency to produce WAH-WAH effects."
"[INST]In the context of the C64, What is the purpose of gating the Voice 3 Envelope Generator in relation to the ENV 3 register?[/INST]Gating the Voice 3 Envelope Generator allows the ENV 3 register to produce output, which can be used to create various effects."
"[INST]In the context of the C64, What is the first action taken by the KERNAL on power-up?[/INST]The KERNAL resets the stack pointer and clears decimal mode on power-up."
"[INST]In the context of the C64, What happens if an autostart ROM cartridge is present at location $8000 HEX?[/INST]If an autostart ROM cartridge is present, normal initialization is suspended, and control is transferred to the cartridge code."
"[INST]In the context of the C64, What devices are initialized by the KERNAL during power-up?[/INST]The KERNAL initializes all INPUT/OUTPUT devices, including the serial bus, 6526 CIA chips, 60-Hz timer, SID chip, and cassette motor."
"[INST]In the context of the C64, What is the purpose of the RAM test performed by the KERNAL?[/INST]The RAM test is a nondestructive test that sets the top and bottom of memory pointers, initializes page zero, and sets up the tape buffer."
"[INST]In the context of the C64, What is the starting location of the RAM test performed by the KERNAL?[/INST]The RAM test starts at location $0300 and works upward to find the first non-RAM location."
"[INST]In the context of the C64, What is the default value of the bottom of memory set by the KERNAL?[/INST]The bottom of memory is always set to $0800."
"[INST]In the context of the C64, What is the purpose of the indirect jump table established by the KERNAL?[/INST]The indirect jump table in low memory is established to facilitate indirect jumps to routines in the KERNAL."
"[INST]In the context of the C64, What is the final action taken by the KERNAL during power-up?[/INST]The final action taken by the KERNAL is to use the indirect at $A000 to start BASIC."
"[INST]In the context of the C64, How does the KERNAL handle the screen during power-up?[/INST]The KERNAL clears the screen and resets all screen editor variables during power-up."
"[INST]In the context of the C64, What is the purpose of initializing the BASIC memory map during power-up?[/INST]Initializing the BASIC memory map during power-up prepares the system for running BASIC programs."
"[INST]In the context of the C64, what is the function of the CLC instruction in 6502 assembly language?[/INST]The CLC instruction is used to clear the carry flag in the 6502 processor, which is a crucial flag that affects the outcome of arithmetic and logical operations. By clearing the carry flag, the CLC instruction ensures that the flag is reset to 0, allowing for accurate calculations and preventing any unwanted carry-over from previous operations."
"[INST]In the context of the C64, what is the addressing mode used by the CLC instruction?[/INST]The CLC instruction uses the implied addressing mode, which means that the instruction operates on the accumulator or a specific register without the need to specify an operand or memory location."
"[INST]In the context of the C64, what is the opcode for the CLC instruction?[/INST]The opcode for the CLC instruction is 18 in hexadecimal notation, which is a unique identifier for this instruction in the 6502 assembly language."
"[INST]In the context of the C64, how many bytes does the CLC instruction occupy in memory?[/INST]The CLC instruction occupies only 1 byte in memory, making it a very compact and efficient instruction that can be used in tight memory spaces."
"[INST]In the context of the C64, how many cycles does the CLC instruction take to execute?[/INST]The CLC instruction takes 2 cycles to execute, which is a relatively fast instruction that can be used in time-critical sections of code."
"[INST]In the context of the C64, what is the purpose of clearing the carry flag using the CLC instruction?[/INST]The purpose of clearing the carry flag using the CLC instruction is to ensure that the carry flag is reset to 0, allowing for accurate arithmetic and logical operations to take place without any unwanted carry-over from previous operations."
"[INST]In the context of the C64, in what situations would you use the CLC instruction in a program?[/INST]The CLC instruction would typically be used in situations where the carry flag needs to be reset to 0, such as after a mathematical operation or before a conditional branch instruction, to ensure accurate calculations and prevent unwanted side effects."
"[INST]In the context of the C64, how does the CLC instruction affect the status register?[/INST]The CLC instruction affects the status register by clearing the carry flag (C flag), which is one of the flags that make up the status register in the 6502 processor."
"[INST]In the context of the C64, can the CLC instruction be used to set the carry flag?[/INST]No, the CLC instruction cannot be used to set the carry flag; instead, it is used to clear the carry flag, and the SEC instruction is used to set the carry flag."
"[INST]In the context of the C64, what is the difference between the CLC and SEC instructions?[/INST]The CLC instruction clears the carry flag, whereas the SEC instruction sets the carry flag; these two instructions are used in different situations to control the carry flag and ensure accurate arithmetic and logical operations."
"[INST]In the context of the C64, what is the opcode for the RTI instruction in 6502 assembly language?[/INST]The opcode for the RTI instruction in 6502 assembly language is 4D."
"[INST]In the context of the C64, what is the addressing mode for the RTI instruction?[/INST]The addressing mode for the RTI instruction is implied."
"[INST]In the context of the C64, what is the number of bytes used by the RTI instruction?[/INST]The number of bytes used by the RTI instruction is 1."
"[INST]In the context of the C64, what is the number of cycles required by the RTI instruction?[/INST]The number of cycles required by the RTI instruction is 6."
"[INST]In the context of the C64, what is the purpose of the RTI instruction in 6502 assembly language?[/INST]The RTI instruction is used to return from an interrupt in 6502 assembly language."
"[INST]In the context of the C64, what is the assembly language form of the RTI instruction?[/INST]The assembly language form of the RTI instruction is simply 'RTI'."
"[INST]In the context of the C64, in what situations would you use the RTI instruction?[/INST]The RTI instruction would be used in situations where an interrupt has occurred and the program needs to return to its normal execution."
"[INST]In the context of the C64, what is the difference between the RTI instruction and the RTS instruction?[/INST]The RTI instruction is used to return from an interrupt, whereas the RTS instruction is used to return from a subroutine."
"[INST]In the context of the C64, can the RTI instruction be used to return from a subroutine?[/INST]No, the RTI instruction should not be used to return from a subroutine, instead the RTS instruction should be used."
"[INST]In the context of the C64, what happens if the RTI instruction is used incorrectly?[/INST]If the RTI instruction is used incorrectly, it can cause the program to malfunction or crash."
"[INST]In the context of the C64, what is the opcode for ROL in accumulator mode[/INST]The opcode for ROL in accumulator mode is 2A, which is used to rotate the accumulator one bit to the left."
"[INST]In the context of the C64, what is the addressing mode for ROL Oper,X[/INST]The addressing mode for ROL Oper,X is Zero Page,X, which means the operand is located in zero page and indexed by the X register."
"[INST]In the context of the C64, what is the number of bytes for ROL Oper in zero page mode[/INST]The number of bytes for ROL Oper in zero page mode is 2 bytes, which includes the opcode and the operand."
"[INST]In the context of the C64, what is the number of cycles for ROL A[/INST]The number of cycles for ROL A is 2 cycles, which is the time it takes to execute the instruction."
"[INST]In the context of the C64, what is the difference between ROL Oper and ROL Oper,X[/INST]The difference between ROL Oper and ROL Oper,X is that ROL Oper,X uses the X register as an index to access the operand, whereas ROL Oper does not."
"[INST]In the context of the C64, what is the opcode for ROL in absolute mode[/INST]The opcode for ROL in absolute mode is 2E, which is used to rotate the operand one bit to the left."
"[INST]In the context of the C64, what is the addressing mode for ROL A[/INST]The addressing mode for ROL A is accumulator, which means the operand is the accumulator itself."
"[INST]In the context of the C64, what is the number of bytes for ROL Oper in absolute mode[/INST]The number of bytes for ROL Oper in absolute mode is 3 bytes, which includes the opcode and the 2-byte operand."
"[INST]In the context of the C64, what is the number of cycles for ROL Oper,X[/INST]The number of cycles for ROL Oper,X is 6 cycles, which is the time it takes to execute the instruction."
"[INST]In the context of the C64, what is the purpose of the ROL instruction[/INST]The purpose of the ROL instruction is to rotate the bits of the operand one position to the left, which can be used for various purposes such as shifting and rotating data."
"[INST]In the context of the C64, Color TV sets are limited in their ability to place certain colors next to each other on the same line.[/INST]This limitation is due to the technical capabilities of the TV set."
"[INST]In the context of the C64, Which color combinations produce blurred images?[/INST]Certain combinations of screen and character colors produce blurred images."
"[INST]In the context of the C64, What is the main limitation of color TV sets?[/INST]Color TV sets are limited in their ability to place certain colors next to each other on the same line."
"[INST]In the context of the C64, What are the graphics abilities of the Commodore 64 based on?[/INST]The 6567 Video Interface Chip (VIC-II chip)"
"[INST]In the context of the C64, What are the different graphics modes provided by the VIC-II chip?[/INST]40 column by 25 line text display, 320 by 200 dot high resolution display, and SPRITES"
"[INST]In the context of the C64, Can multiple graphics modes be mixed on the same screen?[/INST]Yes, it can be done using some tricks"
"[INST]In the context of the C64, What are the three categories of graphics display modes in the VIC-II chip?[/INST]A) CHARACTER DISPLAY MODES, B) BIT MAP MODES, C) SPRITES"
"[INST]In the context of the C64, What are the two types of character display modes?[/INST]Standard Character Mode and Multi-Color Character Mode"
"[INST]In the context of the C64, What are the two types of bit map modes?[/INST]Standard Bit Map Mode and Multi-Color Bit Map Mode"
"[INST]In the context of the C64, What are the two types of sprites?[/INST]Standard Sprites and Multi-Color Sprites"
"[INST]In the context of the C64, Position of a sprite is calculated from what corner of the 24 dot by 21 dot area?[/INST]The TOP LEFT corner"
"[INST]In the context of the C64, What is the minimum number of dots required to make up a sprite?[/INST]One"
"[INST]In the context of the C64, Is the position of a sprite dependent on the number of dots used?[/INST]No"
"[INST]In the context of the C64, Can a sprite be designed in the middle of the screen with only one dot?[/INST]Yes"
"[INST]In the context of the C64, What is the starting point for calculating the exact positioning of a sprite?[/INST]The top left corner location"
"[INST]In the context of the C64, Is the positioning of a sprite affected by the number of dots used?[/INST]No"
"[INST]In the context of the C64, Can a sprite be designed in the 24 dot by 21 dot area?[/INST]Yes"
"[INST]In the context of the C64, Is the positioning of a sprite dependent on the screen size?[/INST]No"
"[INST]In the context of the C64, Can a sprite be designed in the middle of the screen?[/INST]Yes"
"[INST]In the context of the C64, What is the exact positioning of a sprite calculated from?[/INST]The top left corner location"
"[INST]In the context of the C64, What is the purpose of the OPEN function?[/INST]To open a logical file"
"[INST]In the context of the C64, What is the call address of the OPEN function?[/INST]$FFC0 (hex) 65472 (decimal)"
"[INST]In the context of the C64, What communication registers are used by the OPEN function?[/INST]nan"
"[INST]In the context of the C64, What preparatory routines are required before using the OPEN function?[/INST]SETLFS, SETNAM"
"[INST]In the context of the C64, What error returns can occur when using the OPEN function?[/INST]1,2,4,5,6,240, READST"
"[INST]In the context of the C64, What registers are affected by the OPEN function?[/INST]A, X, Y"
"[INST]In the context of the C64, What is the description of the OPEN function?[/INST]This routine is used to OPEN a logical file. Once the logical file is set up, it can be used for input/output operations."
"[INST]In the context of the C64, How many steps are required to use the OPEN function?[/INST]3"
"[INST]In the context of the C64, What are the steps to use the OPEN function?[/INST]Use the SETLFS routine, Use the SETNAM routine, Call this routine"
"[INST]In the context of the C64, Get a character from the input channel[/INST]This routine gets a byte of data from a channel already set up as the input channel by the KERNAL routine CHKIN."
"[INST]In the context of the C64, What is the purpose of the CHRIN routine?[/INST]Get a character from the input channel"
"[INST]In the context of the C64, What is the call address of the CHRIN routine?[/INST]$FFCF (hex) 65487 (decimal)"
"[INST]In the context of the C64, What registers are affected by the CHRIN routine?[/INST]A, X"
"[INST]In the context of the C64, What is the stack requirement for the CHRIN routine?[/INST]7+"
"[INST]In the context of the C64, What is the error return value for the CHRIN routine?[/INST]0 (See READST)"
"[INST]In the context of the C64, What is the description of the CHRIN routine?[/INST]This routine gets a byte of data from a channel already set up as the input channel by the KERNAL routine CHKIN."
"[INST]In the context of the C64, How does the CHRIN routine handle input from the keyboard?[/INST]The cursor is turned on, and blinks until a carriage return is typed on the keyboard."
"[INST]In the context of the C64, What is the purpose of the CHKIN routine?[/INST]Set up a channel as the input channel"
"[INST]In the context of the C64, What is the purpose of the OPEN routine?[/INST]Set up a channel as the input channel"
"[INST]In the context of the C64, what is the purpose of registers 27 and 28 in the SID chip?[/INST]Registers 27 and 28 provide digitized outputs from oscillator three and envelope generator three, allowing for dynamic changes to the SID chip's parameters during a note or sound, enabling the creation of interesting and fun effects."
"[INST]In the context of the C64, how does the sawtooth waveform of oscillator 3 affect register 27?[/INST]When the sawtooth waveform of oscillator 3 is chosen, register 27 presents a series of numbers incremented from 0 to 255 at a rate determined by the frequency of oscillator 3."
"[INST]In the context of the C64, what happens when the triangle waveform is selected for oscillator 3?[/INST]When the triangle waveform is selected, the output of register 27 increments from 0 up to 255, then decrements back down to 0."
"[INST]In the context of the C64, how does the pulse waveform of oscillator 3 affect register 27?[/INST]When the pulse waveform is chosen, the output of register 27 jumps back-and-forth between 0 and 255."
"[INST]In the context of the C64, what is the effect of choosing the noise waveform for oscillator 3 on register 27?[/INST]When the noise waveform is chosen, register 27 produces a series of random numbers."
"[INST]In the context of the C64, how can you turn off the audio output of voice 3?[/INST]Setting bit 7 of register 24 turns the audio output of voice 3 off."
"[INST]In the context of the C64, what is the relationship between register 27 and the envelope generator?[/INST]Register 27 always reflects the changing output of the oscillator and is not affected in any way by the envelope (ADSR) generator."
"[INST]In the context of the C64, what is the purpose of register 25?[/INST]Register 25 gives you access to the output of the envelope generator of oscillator 3, functioning similarly to the output of oscillator 3."
"[INST]In the context of the C64, how can you achieve vibrato using oscillator 3?[/INST]Vibrato can be achieved by adding the output of oscillator 3 to the frequency of another oscillator, as illustrated in Example Program 6."
"[INST]In the context of the C64, what is the requirement for producing output from register 25?[/INST]The oscillator must be turned on to produce any output from register 25."
"[INST]In the context of the C64, what is the purpose of the program counter[/INST]The program counter contains the address of the current machine language instruction being executed."
"[INST]In the context of the C64, What stops the program counter from changing[/INST]The program counter could only be stopped by halting the microprocessor in some way."
"[INST]In the context of the C64, What is the program counter always executing[/INST]The program counter is always executing the current machine language instruction."
"[INST]In the context of the C64, What is the program counter always containing[/INST]The program counter always contains the address of the current machine language instruction."
"[INST]In the context of the C64, What is the program counter always changing to[/INST]The program counter is always changing to the address of the next machine language instruction."
"[INST]In the context of the C64, What is the program counter always containing in[/INST]The program counter is always containing the address of the current machine language instruction in the Commodore 64."
"[INST]In the context of the C64, The volume of a musical tone changes from the moment you first hear it, all the way through until it dies out and you can't hear it anymore.[/INST]The volume of a musical tone changes from the moment you first hear it, all the way through until it dies out and you can't hear it anymore."
"[INST]In the context of the C64, What happens to the volume of a musical tone when it is first struck?[/INST]It rises from zero volume to its peak volume."
"[INST]In the context of the C64, What is the rate at which the volume of a musical tone rises when it is first struck?[/INST]The rate at which this happens is called the ATTACK."
"[INST]In the context of the C64, What happens to the volume of a musical tone after it reaches its peak?[/INST]It fails from the peak to some middle-ranged volume."
"[INST]In the context of the C64, What is the rate at which the volume of a musical tone falls after it reaches its peak?[/INST]The rate at which the fall of the note occurs is called the DECAY."
"[INST]In the context of the C64, What is the mid-ranged volume of a musical tone?[/INST]The mid-ranged volume itself is called the SUSTAIN level."
"[INST]In the context of the C64, What happens to the volume of a musical tone when it stops playing?[/INST]It fails from the SUSTAIN level to zero volume."
"[INST]In the context of the C64, What is the rate at which the volume of a musical tone fails when it stops playing?[/INST]The rate at which it fails is called the RELEASE."
"[INST]In the context of the C64, What are the parameters that give certain qualities and restrictions to a note?[/INST]The bounds are called parameters."
"[INST]In the context of the C64, What is the collective name for the parameters ATTACK, DECAY, SUSTAIN, and RELEASE?[/INST]The parameters ATTACK/DECAY/SUSTAIN/RELEASE and collectively called ADSR."
"[INST]In the context of the C64, SEC does what?[/INST]The SEC instruction sets the carry flag."
"[INST]In the context of the C64, SEC OP CODE?[/INST]The OP code of the SEC instruction is 38."
"[INST]In the context of the C64, SEC: No. Bytes[/INST]The number of bytes required to execute the SEC instruction is 1."
"[INST]In the context of the C64, SEC: No. Cycles[/INST]The number of cycles required to execute the SEC instruction is 2."
"[INST]In the context of the C64, SEC: Addressing Mode[/INST]The addressing mode of the SEC instruction is implied."
"[INST]In the context of the C64, SEC: Instruction Description[/INST]The SEC instruction sets the carry flag."
"[INST]In the context of the C64, SEC: Carry Flag[/INST]The SEC instruction sets the carry flag."
"[INST]In the context of the C64, SEC: Flag Setting[/INST]The SEC instruction sets the carry flag."
"[INST]In the context of the C64, SEC: Flag Operation[/INST]The SEC instruction sets the carry flag."
"[INST]In the context of the C64, what is the operation of LDX instruction[/INST]Load index X with memory"
"[INST]In the context of the C64, what is the addressing mode of LDX #Oper[/INST]Immediate"
"[INST]In the context of the C64, what is the OP CODE of LDX #Oper[/INST]A2"
"[INST]In the context of the C64, how many bytes does LDX #Oper take[/INST]2"
"[INST]In the context of the C64, how many cycles does LDX #Oper take[/INST]2"
"[INST]In the context of the C64, what is the addressing mode of LDX Oper[/INST]Zero Page"
"[INST]In the context of the C64, what is the OP CODE of LDX Oper[/INST]A6"
"[INST]In the context of the C64, how many bytes does LDX Oper take[/INST]2"
"[INST]In the context of the C64, how many cycles does LDX Oper take[/INST]3"
"[INST]In the context of the C64, what is the addressing mode of LDX Oper,Y[/INST]Zero Page,Y"
"[INST]In the context of the C64, what is the OP CODE of LDX Oper,Y[/INST]B6"
"[INST]In the context of the C64, how many bytes does LDX Oper,Y take[/INST]2"
"[INST]In the context of the C64, how many cycles does LDX Oper,Y take[/INST]4"
"[INST]In the context of the C64, what is the function of the dynamic ram refresh controller in the 6566/6567 devices?[/INST]The dynamic ram refresh controller is built into the 6566/6567 devices and is responsible for refreshing the dynamic RAM. It refreshes five 8-bit row addresses every raster line, guaranteeing a maximum delay of 2.02 ms between the refresh of any single row address in a 128 refresh scheme."
"[INST]In the context of the C64, what is the maximum delay between the refresh of any single row address in a 256 address refresh scheme?[/INST]The maximum delay between the refresh of any single row address in a 256 address refresh scheme is 3.66 ms."
"[INST]In the context of the C64, when does the refresh of dynamic ram occur in the system clock?[/INST]The refresh of dynamic ram occurs during Phase 1 of the system clock, making it transparent to the system."
"[INST]In the context of the C64, what signals are generated by the 6567 for every Phase 2 and video data access?[/INST]The 6567 generates both /RAS and /CAS signals for every Phase 2 and video data access, including refresh, eliminating the need for external clock generation."
"[INST]In the context of the C64, in what phase of the system clock does the refresh of dynamic ram occur?[/INST]The refresh of dynamic ram occurs during Phase 1 of the system clock."
"[INST]In the context of the C64, what is the purpose of the /RAS and /CAS signals generated by the 6567?[/INST]The /RAS and /CAS signals generated by the 6567 are connected directly to the dynamic rams and are used to control the refresh of the dynamic RAM."
"[INST]In the context of the C64, how often are the five 8-bit row addresses refreshed in the dynamic ram refresh controller?[/INST]The five 8-bit row addresses are refreshed every raster line in the dynamic ram refresh controller."
"[INST]In the context of the C64, what is the benefit of the dynamic ram refresh controller being built into the 6566/6567 devices?[/INST]The benefit of the dynamic ram refresh controller being built into the 6566/6567 devices is that it eliminates the need for external clock generation, making the system more efficient."
"[INST]In the context of the C64, is the refresh of dynamic ram transparent to the system?[/INST]Yes, the refresh of dynamic ram is totally transparent to the system because it occurs during Phase 1 of the system clock."
"[INST]In the context of the C64, what is the role of the 6567 in the dynamic ram refresh process?[/INST]The 6567 generates the necessary signals (/RAS and /CAS) to control the refresh of the dynamic RAM, making it an essential component of the dynamic ram refresh process."
"[INST]In the context of the C64, If the STOP key pressed during a UDTIM call?[/INST]If the <STOP> key on the keyboard was pressed during a UDTIM call, this call returns the Z flag set."
"[INST]In the context of the C64, What is the call address of the STOP function?[/INST]$FFE1 (hex) 65505 (decimal)"
"[INST]In the context of the C64, What registers are affected by the STOP function?[/INST]Registers affected: A, X"
"[INST]In the context of the C64, What is the purpose of the STOP function?[/INST]Check if <STOP> key is pressed"
"[INST]In the context of the C64, What happens if the STOP key is not pressed during a UDTIM call?[/INST]The accumulator will contain a byte representing the lost row of the keyboard scan."
"[INST]In the context of the C64, What is the default behavior if the STOP key is pressed during a UDTIM call?[/INST]The channels will be reset to default values."
"[INST]In the context of the C64, What is the condition to check for the STOP key press?[/INST]Test for the zero flag."
"[INST]In the context of the C64, What is the sequence of steps to use the STOP function?[/INST]0) UDTIM should be called before this routine. 1) Call this routine. 2) Test for the zero flag."
"[INST]In the context of the C64, What is the effect of pressing the STOP key during a UDTIM call on the accumulator?[/INST]The accumulator will contain a byte representing the lost row of the keyboard scan."
"[INST]In the context of the C64, What is the purpose of the UDTIM call before using the STOP function?[/INST]UDTIM should be called before this routine."
"[INST]In the context of the C64, what are the three basic abilities of computers[/INST]Computers have three basic abilities: they can calculate, make decisions, and communicate, which are fundamental to their operation and enable them to perform a wide range of tasks."
"[INST]In the context of the C64, what is the easiest ability to program in computers[/INST]Calculation is probably the easiest to program, as most of the rules of mathematics are familiar to us, making it a straightforward process to implement mathematical operations in a program."
"[INST]In the context of the C64, what is the second ability of computers[/INST]Decision making is the second ability of computers, which involves applying the rules of logic to make choices or take actions based on given conditions or inputs."
"[INST]In the context of the C64, why is communication the most complex ability of computers[/INST]Communication is the most complex ability of computers because it involves the least exacting set of rules, requiring flexibility to convey information in various ways, and ensuring that the information is presented in a way that can be understood by the receiver."
"[INST]In the context of the C64, what is the only real rule of communication in computers[/INST]The only real rule of communication in computers is that whatever sends information must present the information so that it can be understood by the receiver, which is a fundamental principle of effective communication."
"[INST]In the context of the C64, what is the advantage of the flexibility in computer communication[/INST]The flexibility in computer communication allows for virtually anything to be communicated in many possible ways, making it a powerful tool for conveying information."
"[INST]In the context of the C64, how do computers make decisions[/INST]Computers make decisions by applying the rules of logic to given conditions or inputs, which enables them to take actions or make choices based on the input they receive."
"[INST]In the context of the C64, what is the relationship between calculation and mathematics in computers[/INST]Calculation in computers is based on the rules of mathematics, which are familiar to us, making it a fundamental aspect of computer operation."
"[INST]In the context of the C64, what is the significance of the rules of logic in computer decision making[/INST]The rules of logic are essential in computer decision making, as they provide the framework for making choices or taking actions based on given conditions or inputs."
"[INST]In the context of the C64, why is understanding the rules of communication important in computer science[/INST]Understanding the rules of communication is important in computer science because it enables the effective transmission and reception of information, which is critical to the operation of computers and their ability to perform tasks."
"[INST]In the context of the C64, what is the maximum number of RS-232 channels that can be open at any time[/INST]Only one RS-232 channel should be open at any time; a second OPEN statement will cause the buffer pointers to be reset."
"[INST]In the context of the C64, what happens to characters in the transmit buffer when a second OPEN statement is executed[/INST]Any characters in either the transmit buffer or the receive buffer will be lost."
"[INST]In the context of the C64, how many characters can be sent in the filename field[/INST]Up to 4 characters can be sent in the filename field."
"[INST]In the context of the C64, what are the first two characters in the filename field[/INST]The first two are the control and command register characters;"
"[INST]In the context of the C64, what are the last two characters in the filename field[/INST]the other two are reserved for future system options."
"[INST]In the context of the C64, what options can be selected through the filename field[/INST]Baud rate, parity, and other options can be selected through this feature."
"[INST]In the context of the C64, is error-checking done on the control word to detect a non-implemented baud rate[/INST]No error-checking is done on the control word to detect a non-implemented baud rate."
"[INST]In the context of the C64, what happens when an illegal control word is used[/INST]Any illegal control word will cause the system output to operate at a very slow rate (below 50 baud)."
"[INST]In the context of the C64, what is the BASIC syntax for opening an RS-232 channel[/INST]OPEN lfn,2,0,\<control register><command register><opt baud low><opt baud high>\"""""
"[INST]In the context of the C64, what is the range of logical file numbers (lfn) that can be used[/INST]lfn-The logical file number (lfn) then can be any number from 1 through 255."
"[INST]In the context of the C64, what happens if a logical file number greater than 127 is chosen[/INST]if you choose a logical file number that is greater than 127, then a line feed will follow all carriage returns."
"[INST]In the context of the C64, what is the purpose of the control register[/INST]Is a single byte character (see Figure 6-1, Control Register Map) required to specify the baud rates."
"[INST]In the context of the C64, how are the baud rates specified in the control register[/INST]If the lower 4 bits of the baud rate is equal to zero (0), the <opt baud low><opt baud high> characters give you a rate based on the following:"
"[INST]In the context of the C64, what is the formula for calculating the baud rate[/INST]<opt baud low>=<system frequency/rate/2-100-<opt baud high>*256 <opt baud high>=INT((system frequency/rate/2-100)/256"
"[INST]In the context of the C64, what is the system frequency for NTSC TV standard[/INST]system frequency = 1.02273E6 NTSC (North American TV standard)"
"[INST]In the context of the C64, what is the system frequency for PAL TV standard[/INST]system frequency = 0.98525E6 PAL (U.K. and most European TV standard)"
"[INST]In the context of the C64, what is the purpose of the command register[/INST]Is a single byte character (see Figure 6-2, Command Register Map) that defines other terminal parameters."
"[INST]In the context of the C64, is the command register required[/INST]This character is NOT required."
"[INST]In the context of the C64, what is the KERNAL entry for opening an RS-232 channel[/INST]OPEN ($FFC0) (See KERNAL specifications for more information on entry conditions and instructions.)"
"[INST]In the context of the C64, why should the RS-232 OPEN command be performed before creating variables or arrays[/INST]In a BASIC program, the RS-232 OPEN command should be performed before creating any variables or arrays because an automatic CLR is performed when an RS-232 channel is OPENed"
"[INST]In the context of the C64, what happens if 512 bytes of space are not available at the time of the OPEN statement[/INST]your program will be destroyed if 512 bytes of space are not available at the time of the OPEN statement."
"[INST]In the context of the C64, what happens when an RS-232 channel is OPENed[/INST]an automatic CLR is performed when an RS-232 channel is OPENed (This is due to the allocation of 512 bytes at the top of memory.)"
"[INST]In the context of the C64, why should the RS-232 OPEN command be performed before creating variables or arrays[/INST]because an automatic CLR is performed when an RS-232 channel is OPENed (This is due to the allocation of 512 bytes at the top of memory.)"
"[INST]In the context of the C64, what is the consequence of not having 512 bytes of space available at the time of the OPEN statement[/INST]your program will be destroyed if 512 bytes of space are not available at the time of the OPEN statement."
"[INST]In the context of the C64, what is the purpose of the OPEN command[/INST]to open an RS-232 channel"
"[INST]In the context of the C64, what is the syntax for specifying the baud rate[/INST]<opt baud low>=<system frequency/rate/2-100-<opt baud high>*256 <opt baud high>=INT((system frequency/rate/2-100)/256"
"[INST]In the context of the C64, what is the purpose of the control register and command register[/INST]to specify the baud rates and other terminal parameters"
"[INST]In the context of the C64, what is the range of baud rates that can be specified[/INST]any baud rate can be specified using the control register and command register"
"[INST]In the context of the C64, what happens if an illegal control word is used[/INST]the system output will operate at a very slow rate (below 50 baud)"
"[INST]In the context of the C64, By what method can machine language programs be added to a BASIC program?[/INST]DATA STATEMENTS"
"[INST]In the context of the C64, How many methods are there to add machine language programs to a BASIC program?[/INST]3"
"[INST]In the context of the C64, What is the easiest method to add machine language routines?[/INST]DATA STATEMENTS"
"[INST]In the context of the C64, What is the drawback of using DATA STATEMENTS method?[/INST]taking up more memory space"
"[INST]In the context of the C64, What is the advantage of using DATA STATEMENTS method?[/INST]fairly easy to debug"
"[INST]In the context of the C64, What is the drawback of using DATA STATEMENTS method?[/INST]the wait while the program is POKED in"
"[INST]In the context of the C64, What is the best use of DATA STATEMENTS method?[/INST]for smaller routines"
"[INST]In the context of the C64, what are the three positioning registers used to move a sprite around the screen on a Commodore 64?[/INST]The three positioning registers used to move a sprite around the screen on a Commodore 64 are the SPRITE X POSITION REGISTER, the SPRITE Y POSITION REGISTER, and the MOST SIGNIFICANT BIT X POSITION REGISTER. These registers work together to allow for precise positioning of sprites, enabling placement in 512 possible X positions and 256 possible Y positions."
"[INST]In the context of the C64, how do the X and Y position registers work together to position a sprite?[/INST]The X and Y position registers work together in pairs as a team to position a sprite. The X register for a sprite determines the sprite's horizontal position, while the Y register determines the sprite's vertical position. The combination of the two registers allows for precise positioning of the sprite on the screen."
"[INST]In the context of the C64, in what order do the X and Y registers appear in the memory map?[/INST]The X and Y registers appear in the memory map in the following order: the X register for sprite 0, then the Y register for sprite 0, followed by the X register for sprite 1, the Y register for sprite 1, and so on, until all 16 X and Y registers are accounted for."
"[INST]In the context of the C64, what is the purpose of the most significant bit in the X position register?[/INST]The most significant bit in the X position register (X MSB) is used to extend the range of the X position register, allowing for more precise positioning of sprites. It is located in its own register and is used in conjunction with the X position register to determine the sprite's horizontal position."
"[INST]In the context of the C64, how many possible X positions can a sprite be placed in on a Commodore 64?[/INST]A sprite can be placed in 512 possible X positions on a Commodore 64, thanks to the combination of the X position register and the most significant bit in the X position register."
"[INST]In the context of the C64, how many possible Y positions can a sprite be placed in on a Commodore 64?[/INST]A sprite can be placed in 256 possible Y positions on a Commodore 64, as determined by the Y position register."
"[INST]In the context of the C64, what is the advantage of having separate X and Y position registers for each sprite?[/INST]The advantage of having separate X and Y position registers for each sprite is that it allows for precise and independent control over the horizontal and vertical positioning of each sprite, enabling complex and dynamic sprite movements."
"[INST]In the context of the C64, in what way do the X and Y position registers work together to enable accurate sprite positioning?[/INST]The X and Y position registers work together to enable accurate sprite positioning by providing a precise and independent control over the horizontal and vertical positioning of each sprite, allowing for precise placement and movement of sprites on the screen."
"[INST]In the context of the C64, what is the significance of the X MSB register in sprite positioning?[/INST]The X MSB (most significant bit) register is significant in sprite positioning because it extends the range of the X position register, allowing for more precise positioning of sprites and enabling placement in 512 possible X positions."
"[INST]In the context of the C64, how do the X and Y registers enable precise sprite movement?[/INST]The X and Y registers enable precise sprite movement by providing a precise and independent control over the horizontal and vertical positioning of each sprite, allowing for smooth and accurate movement of sprites on the screen."
"[INST]In the context of the C64, Where are the paddle values read from?[/INST]The paddle values are read via the SID registers 54297 ($D419) and 54298 ($D41A)."
"[INST]In the context of the C64, What is the issue with reading paddles from BASIC alone?[/INST]PADDLES ARE NOT RELIABLE WHEN READ FROM BASIC ALONE!!!!"
"[INST]In the context of the C64, What is the recommended way to use paddles from BASIC or machine code?[/INST]The best way to use paddles, from BASIC or machine code, is to use the following machine language routine..."
"[INST]In the context of the C64, What is the purpose of the `pdlrd` routine?[/INST]The `pdlrd` routine is a four paddle read routine that can also be used for two paddles or analog joysticks."
"[INST]In the context of the C64, What is the function of the `buffer` variable in the `pdlrd` routine?[/INST]The `buffer` variable is used to save the current value of the CIA Data Direction Register (DDRA)."
"[INST]In the context of the C64, What is the purpose of the `sei` instruction in the `pdlrd` routine?[/INST]The `sei` instruction is used to disable interrupts while the paddles are being read."
"[INST]In the context of the C64, How does the `pdlrd` routine wait for a short period of time?[/INST]The `pdlrd` routine waits for a short period of time using a loop that decrements the Y register until it reaches zero."
"[INST]In the context of the C64, What is the purpose of the `sta sid+25` and `sta sid+26` instructions?[/INST]The `sta sid+25` and `sta sid+26` instructions are used to read the X and Y values of the paddle, respectively."
"[INST]In the context of the C64, How does the `pdlrd` routine handle the fire buttons of the paddles?[/INST]The `pdlrd` routine reads the fire buttons of the paddles by reading the value of the `porta` register and storing it in the `btna` and `btnb` variables."
"[INST]In the context of the C64, What is the purpose of the `cli` instruction at the end of the `pdlrd` routine?[/INST]The `cli` instruction is used to re-enable interrupts after the paddles have been read."
"[INST]In the context of the C64, Is the printer an output device?[/INST]Yes, it is similar to the screen."
"[INST]In the context of the C64, What is the main concern when sending output to the printer?[/INST]To create a format that is easy on the eyes."
"[INST]In the context of the C64, What are the tools available for formatting output to the printer?[/INST]Reversed, double-width, capital and lower case letters, as well as dot-programmable graphics."
"[INST]In the context of the C64, Does the SPC function work the same way on the printer as it does on the screen?[/INST]Yes, it works in the same way."
"[INST]In the context of the C64, Why does the TAB function not work correctly on the printer?[/INST]Because it calculates the current position on the line based on the cursor's position on the screen, not on the paper."
"[INST]In the context of the C64, What is the purpose of the OPEN statement for the printer?[/INST]It creates the channel for communication and specifies which character set will be used."
"[INST]In the context of the C64, What are the examples of OPEN statements for the printer?[/INST]OPEN 1,4: REM UPPER CASE/GRAPHICS and OPEN 1,4,7: REM UPPER AND LOWER CASE"
"[INST]In the context of the C64, Can individual lines be printed in the opposite character set when working with one character set?[/INST]Yes, they can."
"[INST]In the context of the C64, What is the character that switches the characters to the upper and lower case set when in upper case with graphics?[/INST]CHR$(17)"
"[INST]In the context of the C64, What is the character that allows upper case and graphics characters to be printed when in upper and lower case?[/INST]CHR$(145)"
"[INST]In the context of the C64, What are the special functions in the printer controlled through character codes?[/INST]All these codes are simply printed just like any other character."
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 10?[/INST]Line feed"
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 13?[/INST]RETURN (automatic line feed on CBM printers)"
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 14?[/INST]Begin double-width character mode"
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 15?[/INST]End double-width character mode"
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 18?[/INST]Begin reverse character mode"
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 146?[/INST]End reverse character mode"
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 17?[/INST]Switch to upper/lower case character set"
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 145?[/INST]Switch to upper case/graphics character set"
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 16?[/INST]Tab to position in next 2 characters"
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 27?[/INST]Move to specified dot position"
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 8?[/INST]Begin dot-programmable graphic mode"
"[INST]In the context of the C64, What is the purpose of the CHR$ CODE 26?[/INST]Repeat graphics data"
"[INST]In the context of the C64, what is another important principle in machine language?[/INST]the ability to test and detect certain conditions"
"[INST]In the context of the C64, what is the purpose of the 'IF... THEN, IF... GOTO' structure in CBM BASIC?[/INST]to test and detect certain conditions"
"[INST]In the context of the C64, what flag is set when an instruction has caused a zero result?[/INST]the zero result flag"
"[INST]In the context of the C64, what instruction sets the zero result flag?[/INST]LDA #$00"
"[INST]In the context of the C64, what does the BEQ instruction mean?[/INST]Branch if result EQual to zero"
"[INST]In the context of the C64, what is the opposite of the BEQ instruction?[/INST]BNE, which means Branch on result Not Equal to zero"
"[INST]In the context of the C64, what is the purpose of the index registers?[/INST]to modify their contents"
"[INST]In the context of the C64, what does the INX instruction do?[/INST]INcrements the X index register"
"[INST]In the context of the C64, what happens when the X register is incremented from $FF?[/INST]it wraps around back to zero"
"[INST]In the context of the C64, what is the opposite of the INX instruction?[/INST]DEX, which DEcrements the X index register"
"[INST]In the context of the C64, what happens when the X index register is zero and DEX is executed?[/INST]it wraps around to $FF"
"[INST]In the context of the C64, what are CPX and CPY used for?[/INST]to compare the index registers with specific values or memory locations"
"[INST]In the context of the C64, what instruction is used to compare the X register with a specific value?[/INST]CPX"
"[INST]In the context of the C64, what is the purpose of the compare and branch instructions?[/INST]to play a major part in any machine language program"
"[INST]In the context of the C64, what is the operand specified in a branch instruction when using 64MON?[/INST]the address of the part of the program that the branch goes to"
"[INST]In the context of the C64, what is the range of a branch instruction in 64MON?[/INST]from 128 bytes backward to 127 bytes forward"
"[INST]In the context of the C64, what is the total range of a branch instruction in 64MON?[/INST]255 bytes"
"[INST]In the context of the C64, what happens if a branch instruction is out of range in 64MON?[/INST]it refuses to assemble that particular instruction"
"[INST]In the context of the C64, what is the advantage of using an assembler like 64MON?[/INST]it calculates the correct offset for branch instructions"
"[INST]In the context of the C64, what is the purpose of the status register?[/INST]to store flags affected by different instructions"
"[INST]In the context of the C64, what is the zero result flag also known as?[/INST]Z"
"[INST]In the context of the C64, what is the opposite of the BEQ instruction in terms of the zero result flag?[/INST]BNE, which branches if Z is not set"
"[INST]In the context of the C64, what is the purpose of the branch instructions?[/INST]to branch to another part of the program based on certain conditions"
"[INST]In the context of the C64, what is the advantage of using branch instructions?[/INST]they allow for more complex program flow"
"[INST]In the context of the C64, what is the difference between a branch instruction and a jump instruction?[/INST]branch instructions examine the status register, while jump instructions do not"
"[INST]In the context of the C64, what is the purpose of the INY and DEY instructions?[/INST]to increment and decrement the Y index register"
"[INST]In the context of the C64, what is the purpose of the CPY instruction?[/INST]to compare the Y register with a specific value"
"[INST]In the context of the C64, what is the advantage of using the compare and branch instructions together?[/INST]they allow for more complex conditional statements"
"[INST]In the context of the C64, Where are the characters stored in a Commodore 64?[/INST]In ROM"
"[INST]In the context of the C64, What can be changed to point to different sections of memory?[/INST]The memory location that tells the VIC-II chip where to find the characters"
"[INST]In the context of the C64, What is required to program your own character sets?[/INST]The character memory pointer must be changed to point to RAM"
"[INST]In the context of the C64, What happens when you use your own character set?[/INST]The standard Commodore 64 characters are unavailable"
"[INST]In the context of the C64, What must be copied into your own character memory in RAM?[/INST]Any letters, numbers, or standard Commodore 64 graphics you intend to use"
"[INST]In the context of the C64, What takes memory space away from your BASIC program?[/INST]Your character set"
"[INST]In the context of the C64, Why must you be careful when using your own character set?[/INST]To protect the character set from being overwritten by your BASIC program"
"[INST]In the context of the C64, What locations should not be used to start your character set with BASIC?[/INST]Locations 0 and 2048"
"[INST]In the context of the C64, Why can't location 2048 be used to start your character set?[/INST]Because that is where your BASIC program starts"
"[INST]In the context of the C64, What is the best place to put your character set for use with BASIC?[/INST]Starting at location 12288 ($3000 in HEX)"
"[INST]In the context of the C64, How do you set the character memory pointer to 12288?[/INST]By POKEing the low 4 bits of location 53272 with 12"
"[INST]In the context of the C64, What is the benefit of using your own character set?[/INST]You can customize your characters for any need"
"[INST]In the context of the C64, What is the result of not copying standard characters into your own character memory?[/INST]You will not have access to them"
"[INST]In the context of the C64, What is the consequence of not protecting your character set?[/INST]It can be overwritten by your BASIC program"
"[INST]In the context of the C64, What is the advantage of using RAM for your character set?[/INST]You can program your own character sets"
"[INST]In the context of the C64, What is the importance of considering memory space when using your own character set?[/INST]To avoid taking too much memory space away from your BASIC program"
"[INST]In the context of the C64, What is the flexibility of using your own character set?[/INST]You can pick and choose which characters to include and don't have to keep them in order"
"[INST]In the context of the C64, Where is the Sprite-Background priority register located?[/INST]The Sprite-Background priority register is located at memory address 53275 ($D01B)."
"[INST]In the context of the C64, What determines the priority of a sprite over the background?[/INST]The priority of a sprite over the background is determined by the corresponding bit in the Sprite-Background priority register, where 0 indicates higher priority and 1 indicates lower priority."
"[INST]In the context of the C64, How does a sprite's priority affect its display on the screen?[/INST]If a sprite has a higher priority than the background, it appears in front of the background data on the screen, and if it has a lower priority, it appears behind the background data."
"[INST]In the context of the C64, What happens when a sprite's priority bit is set to 0?[/INST]When a sprite's priority bit is set to 0, it has a higher priority than the background, and it appears in front of the background data on the screen."
"[INST]In the context of the C64, What happens when a sprite's priority bit is set to 1?[/INST]When a sprite's priority bit is set to 1, it has a lower priority than the background, and it appears behind the background data on the screen."
"[INST]In the context of the C64, How do you control the priority of sprites over the background?[/INST]The priority of sprites over the background is controlled by the Sprite-Background priority register, where each sprite has a corresponding bit that determines its priority."
"[INST]In the context of the C64, What is the significance of the Sprite-Background priority register?[/INST]The Sprite-Background priority register is significant because it allows for control over the display of sprites and background data on the screen, enabling the creation of complex graphics and visual effects."
"[INST]In the context of the C64, In what way does the Sprite-Background priority register affect the display of sprites?[/INST]The Sprite-Background priority register affects the display of sprites by determining their priority over the background data, allowing for sprites to appear in front of or behind the background."
"[INST]In the context of the C64, What is the relationship between a sprite's priority and its display on the screen?[/INST]A sprite's priority, as determined by its corresponding bit in the Sprite-Background priority register, determines its display on the screen, with higher priority sprites appearing in front of the background and lower priority sprites appearing behind the background."
"[INST]In the context of the C64, How does the Sprite-Background priority register enable complex graphics?[/INST]The Sprite-Background priority register enables complex graphics by allowing for the creation of layered graphics, where sprites can appear in front of or behind the background, creating a sense of depth and visual interest."
"[INST]In the context of the C64, what is the benefit of using the KERNAL routines?[/INST]it is an unnecessary duplication of effort to write these routines over and over again, so easy access to the operating system helps speed machine language programming."
"[INST]In the context of the C64, what is the KERNAL?[/INST]the KERNAL is a jump table, a collection of JMP instructions to many operating system routines."
"[INST]In the context of the C64, what must you do before calling a KERNAL routine?[/INST]you must make all of the preparations that the routine demands."
"[INST]In the context of the C64, how do you call a KERNAL routine?[/INST]you must call the routine by means of the JSR instruction."
"[INST]In the context of the C64, what instruction must KERNAL routines end with?[/INST]KERNAL routines must end with an RTS instruction."
"[INST]In the context of the C64, what happens when a KERNAL routine has finished its task?[/INST]control is returned to your program at the instruction after the JSR."
"[INST]In the context of the C64, what may KERNAL routines return?[/INST]many of the KERNAL routines return error codes in the status word or the accumulator."
"[INST]In the context of the C64, why is it important to handle error returns properly?[/INST]good programming practice and the success of your machine language programs demand that you handle this properly."
"[INST]In the context of the C64, what are the three simple steps to using the KERNAL?[/INST]set up, call the routine, and error handling."
"[INST]In the context of the C64, what is the purpose of the FUNCTION NAME in describing KERNAL routines?[/INST]it is the name of the KERNAL routine."
"[INST]In the context of the C64, what is the purpose of the CALL ADDRESS in describing KERNAL routines?[/INST]it is the call address of the KERNAL routine, given in hexadecimal."
"[INST]In the context of the C64, what is the purpose of the COMMUNICATION REGISTERS in describing KERNAL routines?[/INST]registers listed under this heading are used to pass parameters to and from the KERNAL routines."
"[INST]In the context of the C64, what is the purpose of the PREPARATORY ROUTINES in describing KERNAL routines?[/INST]certain KERNAL routines require that data be set up before they can operate, the routines needed are listed here."
"[INST]In the context of the C64, what is the purpose of the ERROR RETURNS in describing KERNAL routines?[/INST]a return from a KERNAL routine with the CARRY set indicates that an error was encountered in processing, the accumulator will contain the number of the error."
"[INST]In the context of the C64, what is the purpose of the STACK REQUIREMENTS in describing KERNAL routines?[/INST]it is the actual number of stack bytes used by the KERNAL routine."
"[INST]In the context of the C64, what is the purpose of the REGISTERS AFFECTED in describing KERNAL routines?[/INST]all registers used by the KERNAL routine are listed here."
"[INST]In the context of the C64, what is the purpose of the DESCRIPTION in describing KERNAL routines?[/INST]a short tutorial on the function of the KERNAL routine is given here."
"[INST]In the context of the C64, why is it important to use the KERNAL routines?[/INST]it helps speed machine language programming."
"[INST]In the context of the C64, what is the result of not handling error returns properly?[/INST]the rest of your program might 'bomb'."
"[INST]In the context of the C64, what is the purpose of the JSR instruction?[/INST]it is used to call a KERNAL routine."
"[INST]In the context of the C64, what is the purpose of the RTS instruction?[/INST]it is used to end a KERNAL routine."
"[INST]In the context of the C64, what is the benefit of using the operating system routines?[/INST]it helps speed machine language programming."
"[INST]In the context of the C64, what is the purpose of the accumulator in KERNAL routines?[/INST]it is used to pass parameters to and from the KERNAL routines."
"[INST]In the context of the C64, what is the purpose of the status word in KERNAL routines?[/INST]it is used to return error codes."
"[INST]In the context of the C64, what is the purpose of the stack in KERNAL routines?[/INST]it is used to store data temporarily."
"[INST]In the context of the C64, what is the purpose of the registers in KERNAL routines?[/INST]they are used to pass parameters to and from the KERNAL routines."
"[INST]In the context of the C64, what is the purpose of the error codes in KERNAL routines?[/INST]they indicate that an error was encountered in processing."
"[INST]In the context of the C64, what is the purpose of the CARRY flag in KERNAL routines?[/INST]it is set if an error was encountered in processing."
"[INST]In the context of the C64, what is the purpose of the DECIMAL address in describing KERNAL routines?[/INST]it is the call address of the KERNAL routine, given in decimal."
"[INST]In the context of the C64, Is the accumulator the most important register in the microprocessor?[/INST]Yes"
"[INST]In the context of the C64, What can you do with the accumulator?[/INST]Copy the contents of a memory location into the accumulator, copy the contents of the accumulator into a memory location, modify the contents of the accumulator or some other register directly, without affecting any memory"
"[INST]In the context of the C64, What instructions allow you to copy the contents of a memory location into the accumulator?[/INST]Various machine language instructions"
"[INST]In the context of the C64, What instructions allow you to copy the contents of the accumulator into a memory location?[/INST]Various machine language instructions"
"[INST]In the context of the C64, What can you do with the accumulator without affecting any memory?[/INST]Modify the contents of the accumulator or some other register directly"
"[INST]In the context of the C64, What is the only register that has instructions for performing math?[/INST]The accumulator"
"[INST]In the context of the C64, What is the most important register in the microprocessor?[/INST]The accumulator"
"[INST]In the context of the C64, What can you do with the accumulator in terms of math?[/INST]Perform math"
"[INST]In the context of the C64, What are the instructions for performing math?[/INST]Instructions for the accumulator"
"[INST]In the context of the C64, What is the accumulator used for?[/INST]To perform math and other operations"
"[INST]In the context of the C64, what is the ORA operation used for[/INST]The ORA operation is used for performing a bitwise OR operation on the accumulator with the contents of a memory location."
"[INST]In the context of the C64, what is the ORA operation used for in assembly language[/INST]The ORA operation is used in assembly language to perform a bitwise OR operation on the accumulator with the contents of a memory location."
"[INST]In the context of the C64, what is the ORA operation used for in computer programming[/INST]The ORA operation is used in computer programming to perform a bitwise OR operation on the accumulator with the contents of a memory location."
"[INST]In the context of the C64, what is the ORA operation used for in programming languages[/INST]The ORA operation is used in programming languages to perform a bitwise OR operation on the accumulator with the contents of a memory location."
"[INST]In the context of the C64, what is the ORA operation used for in programming[/INST]The ORA operation is used in programming to perform a bitwise OR operation on the accumulator with the contents of a memory location."
"[INST]In the context of the C64, what is the ORA operation used for in computer science[/INST]The ORA operation is used in computer science to perform a bitwise OR operation on the accumulator with the contents of a memory location."
"[INST]In the context of the C64, what is the ORA operation used for in programming languages[/INST]The ORA operation is used in programming languages to perform a bitwise OR operation on the accumulator with the contents of a memory location."
"[INST]In the context of the C64, what is the ORA operation used for in computer programming[/INST]The ORA operation is used in computer programming to perform a bitwise OR operation on the accumulator with the contents of a memory location."
"[INST]In the context of the C64, what is the ORA operation used for in assembly language programming[/INST]The ORA operation is used in assembly language programming to perform a bitwise OR operation on the accumulator with the contents of a memory location."
"[INST]In the context of the C64, what is the ORA operation used for in programming languages[/INST]The ORA operation is used in programming languages to perform a bitwise OR operation on the accumulator with the contents of a memory location."
"[INST]In the context of the C64, What is the purpose of ROR instruction?[/INST]Rotate one bit right (memory or accumulator)"
"[INST]In the context of the C64, What are the addressing modes for ROR instruction?[/INST]Accumulator, Zero Page, Zero Page,X, Absolute, Absolute,X"
"[INST]In the context of the C64, What is the number of bytes for ROR instruction in Accumulator mode?[/INST]1"
"[INST]In the context of the C64, What is the number of cycles for ROR instruction in Accumulator mode?[/INST]2"
"[INST]In the context of the C64, What is the number of bytes for ROR instruction in Zero Page mode?[/INST]2"
"[INST]In the context of the C64, What is the number of cycles for ROR instruction in Zero Page mode?[/INST]5"
"[INST]In the context of the C64, What is the number of bytes for ROR instruction in Zero Page,X mode?[/INST]2"
"[INST]In the context of the C64, What is the number of cycles for ROR instruction in Zero Page,X mode?[/INST]6"
"[INST]In the context of the C64, What is the number of bytes for ROR instruction in Absolute mode?[/INST]3"
"[INST]In the context of the C64, What is the number of cycles for ROR instruction in Absolute mode?[/INST]6"
"[INST]In the context of the C64, What is the number of bytes for ROR instruction in Absolute,X mode?[/INST]3"
"[INST]In the context of the C64, What is the number of cycles for ROR instruction in Absolute,X mode?[/INST]7"
"[INST]In the context of the C64, Unexpanded sprites are visible in which column mode?[/INST]40 column, by 25 row mode"
"[INST]In the context of the C64, What is the minimum X value for unexpanded sprites?[/INST]1"
"[INST]In the context of the C64, What is the maximum Y value for unexpanded sprites in 40 column mode?[/INST]249"
"[INST]In the context of the C64, What is the range of X values for expanded sprites in 38 column mode?[/INST]496 >= X <= 334"
"[INST]In the context of the C64, What is the minimum Y value for expanded sprites in 24 row mode?[/INST]13"
"[INST]In the context of the C64, What is the maximum X value for unexpanded sprites in 40 column mode?[/INST]343"
"[INST]In the context of the C64, What is the range of Y values for unexpanded sprites in 24 row mode?[/INST]34 <= Y <= 245"
"[INST]In the context of the C64, What is the minimum X value for expanded sprites in 40 column mode?[/INST]489"
"[INST]In the context of the C64, What is the maximum Y value for unexpanded sprites in 38 column mode?[/INST]249"
"[INST]In the context of the C64, What is the range of X values for unexpanded sprites in 38 column mode?[/INST]8 <= X <= 334"
"[INST]In the context of the C64, what is the capability of the VIC-II chip in regards to sprites?[/INST]The VIC-II chip has the ability to expand a sprite in the vertical direction, the horizontal direction, or both at once, making each dot in the sprite twice as wide or twice as tall, effectively making the sprite bigger."
"[INST]In the context of the C64, how does expanding a sprite affect its resolution?[/INST]Expanding a sprite does not actually increase its resolution, it just makes the sprite appear larger, with each dot being twice as wide or twice as tall."
"[INST]In the context of the C64, what happens to each dot in a sprite when it is expanded?[/INST]When a sprite is expanded, each dot in the sprite becomes twice as wide or twice as tall, making the sprite appear larger."
"[INST]In the context of the C64, in what ways can a sprite be expanded using the VIC-II chip?[/INST]A sprite can be expanded in the vertical direction, the horizontal direction, or both at once using the VIC-II chip."
"[INST]In the context of the C64, what is the effect of expanding a sprite on its size?[/INST]Expanding a sprite makes it appear larger, with each dot being twice as wide or twice as tall, but the resolution remains the same."
"[INST]In the context of the C64, can a sprite be expanded in multiple directions at once?[/INST]Yes, a sprite can be expanded in both the vertical and horizontal directions at the same time using the VIC-II chip."
"[INST]In the context of the C64, how does the VIC-II chip handle sprite expansion?[/INST]The VIC-II chip can expand a sprite in the vertical direction, the horizontal direction, or both at once, making each dot in the sprite twice as wide or twice as tall."
"[INST]In the context of the C64, is the resolution of a sprite affected when it is expanded?[/INST]No, the resolution of a sprite remains the same when it is expanded, it just appears larger."
"[INST]In the context of the C64, what is the result of expanding a sprite in the vertical direction?[/INST]Expanding a sprite in the vertical direction makes each dot in the sprite twice as tall, making the sprite appear larger."
"[INST]In the context of the C64, in what way does expanding a sprite affect its appearance?[/INST]Expanding a sprite makes it appear larger, with each dot being twice as wide or twice as tall, giving it a bigger appearance."
"[INST]In the context of the C64, Where is the Operating System contained?[/INST]in Read Only Memory (ROM) chips"
"[INST]In the context of the C64, What are the three separate program modules that make up the Operating System?[/INST]The BASIC Interpreter, The KERNAL, and The Screen Editor"
"[INST]In the context of the C64, What is the purpose of the BASIC Interpreter?[/INST]to analyse BASIC statement syntax and perform required calculations and/or data manipulation"
"[INST]In the context of the C64, How big is the vocabulary of the BASIC Interpreter?[/INST]65 keywords"
"[INST]In the context of the C64, What are the special characters used in the BASIC Interpreter?[/INST]upper and lower case alphabet, digits 0-9, punctuation characters, and special symbols"
"[INST]In the context of the C64, What does the KERNAL handle in the system?[/INST]interrupt level processing"
"[INST]In the context of the C64, What does the Screen Editor control?[/INST]output to the video screen and editing of BASIC program text"
"[INST]In the context of the C64, What does the Screen Editor intercept?[/INST]keyboard input"
"[INST]In the context of the C64, What does the Screen Editor decide about keyboard input?[/INST]whether to act upon characters immediately or pass them on to the BASIC Interpreter"
"[INST]In the context of the C64, Bit 4 of the VIC-II control register controls what function?[/INST]screen blanking function"
"[INST]In the context of the C64, What happens to the screen when bit 4 is set to 1?[/INST]the screen is normal"
"[INST]In the context of the C64, What happens to the screen when bit 4 is set to 0?[/INST]the entire screen changes to border color"
"[INST]In the context of the C64, What is the location of the control register?[/INST]53265"
"[INST]In the context of the C64, What is the hexadecimal value of the control register location?[/INST]$D011"
"[INST]In the context of the C64, What happens to the processor when the screen is turned off?[/INST]it speeds up"
"[INST]In the context of the C64, What is the POKE command to blank the screen?[/INST]POKE 53265,PEEK(53265)AND 239"
"[INST]In the context of the C64, What is the POKE command to bring back the screen?[/INST]POKE 53265,PEEK(53265)OR 16"
"[INST]In the context of the C64, What is the purpose of turning off the screen?[/INST]to speed up the processor"
"[INST]In the context of the C64, What happens to program running when the screen is turned off?[/INST]it is sped up"
"[INST]In the context of the C64, how do you blank the display screen on a commodore 64[/INST]By setting the DEN bit in register 17 ($11) to a '0', the entire screen will be filled with the exterior color as set in register 32 ($20), allowing for full processor utilization of the system bus, but note that sprite data will still be accessed if the sprites are not also disabled."
"[INST]In the context of the C64, what happens when the DEN bit is set to '0' in register 17[/INST]The display screen is blanked, and the entire screen will be filled with the exterior color as set in register 32 ($20), allowing for full processor utilization of the system bus, but note that sprite data will still be accessed if the sprites are not also disabled."
"[INST]In the context of the C64, what is the purpose of the DEN bit in register 17[/INST]The DEN bit in register 17 is used to blank the display screen, when set to '0', and to enable normal video display when set to '1'."
"[INST]In the context of the C64, what is the effect of blanking the screen on system bus utilization[/INST]When the screen is blanked, only transparent (Phase 1) memory accesses are required, permitting full processor utilization of the system bus."
"[INST]In the context of the C64, what happens to sprite data when the screen is blanked[/INST]Sprite data will still be accessed if the sprites are not also disabled, even when the screen is blanked."
"[INST]In the context of the C64, what is the register that controls the exterior color when the screen is blanked[/INST]Register 32 ($20) controls the exterior color that fills the screen when it is blanked."
"[INST]In the context of the C64, what is the normal state of the DEN bit in register 17[/INST]The DEN bit in register 17 is normally set to '1' to enable normal video display."
"[INST]In the context of the C64, what is the effect of setting the DEN bit to '1' in register 17[/INST]Setting the DEN bit to '1' in register 17 enables normal video display."
"[INST]In the context of the C64, what is the purpose of register 32 ($20)[/INST]Register 32 ($20) sets the exterior color that fills the screen when it is blanked."
"[INST]In the context of the C64, how do you enable normal video display on a commodore 64[/INST]By setting the DEN bit in register 17 ($11) to a '1', normal video display is enabled."
"[INST]In the context of the C64, What is the purpose of the CLALL function?[/INST]Close all files"
"[INST]In the context of the C64, What is the call address of the CLALL function?[/INST]$FFE7 (hex) 65511 (decimal)"
"[INST]In the context of the C64, What communication registers are used by the CLALL function?[/INST]nan"
"[INST]In the context of the C64, What preparatory routines are used by the CLALL function?[/INST]nan"
"[INST]In the context of the C64, What is the error return value of the CLALL function?[/INST]nan"
"[INST]In the context of the C64, What is the stack requirement of the CLALL function?[/INST]11"
"[INST]In the context of the C64, What registers are affected by the CLALL function?[/INST]A, X"
"[INST]In the context of the C64, What is the description of the CLALL function?[/INST]This routine closes all open files."
"[INST]In the context of the C64, What is the effect of calling the CLRCHN routine?[/INST]reset the I/O channels"
"[INST]In the context of the C64, How do you use the CLALL function?[/INST]Call this routine"
"[INST]In the context of the C64, What is an example of using the CLALL function?[/INST]JSR CLALL   ;CLOSE ALL FILES AND SELECT DEFAULT I/O CHANNELS"
"[INST]In the context of the C64, What is the purpose of the LISTEN function?[/INST]Command a device on the serial bus to listen"
"[INST]In the context of the C64, What is the call address of the LISTEN function?[/INST]$FFB1 (hex) 65457 (decimal)"
"[INST]In the context of the C64, What communication registers are affected by the LISTEN function?[/INST]A"
"[INST]In the context of the C64, What is the purpose of the preparatory routines in the LISTEN function?[/INST]nan"
"[INST]In the context of the C64, What is the error return for the LISTEN function?[/INST]See READST"
"[INST]In the context of the C64, What is the stack requirement for the LISTEN function?[/INST]nan"
"[INST]In the context of the C64, What registers are affected by the LISTEN function?[/INST]A"
"[INST]In the context of the C64, What is the description of the LISTEN function?[/INST]This routine will command a device on the serial bus to receive data"
"[INST]In the context of the C64, How do you load the accumulator with the number of the device to command to LISTEN?[/INST]Load the accumulator with the number of the device to command to LISTEN"
"[INST]In the context of the C64, What is the example of how to use the LISTEN function?[/INST];COMMAND DEVICE #8 TO LISTEN LDA #8 JSR LISTEN"
"[INST]In the context of the C64, Where is the raster register located in the VIC-II chip?[/INST]The raster register is located at address 53266 ($D012) in the VIC-II chip."
"[INST]In the context of the C64, What is the purpose of the raster register?[/INST]The raster register is a dual-purpose register that returns the lower 8 bits of the current raster position when read, and allows setting up timing changes in the display to eliminate screen flicker when written to."
"[INST]In the context of the C64, How do you determine the most significant bit of the raster position?[/INST]The most significant bit of the raster position is found in register location 53265 ($D011)."
"[INST]In the context of the C64, When should changes be made to the display to avoid screen flicker?[/INST]Changes to the display should be made when the raster is not in the visible display area, which is when the dot positions fall between 51 and 251."
"[INST]In the context of the C64, What happens when a value is written to the raster register?[/INST]When a value is written to the raster register, it is saved for use with the raster compare function, and when the actual raster value becomes the same as the written value, a bit in the VIC-II chip interrupt register 53273 ($D019) is turned ON by setting it to 1."
"[INST]In the context of the C64, What is the purpose of the raster compare function?[/INST]The raster compare function compares the actual raster value with the value written to the raster register, and triggers an interrupt when they match."
"[INST]In the context of the C64, How do you enable an interrupt (IRQ) to occur when the raster value matches the written value?[/INST]To enable an interrupt, the proper interrupt bit must be enabled (turned on) in the VIC-II chip interrupt register 53273 ($D019)."
"[INST]In the context of the C64, What is the significance of the value 51-251 in relation to the raster register?[/INST]The values 51-251 represent the dot positions when the raster is not in the visible display area, making it a safe time to make changes to the display without causing screen flicker."
"[INST]In the context of the C64, What is the address of the VIC-II chip interrupt register?[/INST]The address of the VIC-II chip interrupt register is 53273 ($D019)."
"[INST]In the context of the C64, How does the raster register help in eliminating screen flicker?[/INST]The raster register helps in eliminating screen flicker by allowing timing changes to be made to the display when the raster is not in the visible display area, thereby reducing screen flicker."
"[INST]In the context of the C64, what are the registers of the 6566/6567 that can be accessed similar to any other peripheral device?[/INST]The 6566/6567 registers can be accessed similar to any other peripheral device through the processor interface signals, which provides a standardized way of communicating with the processor."
"[INST]In the context of the C64, how do the 6566/6567 registers interact with the processor?[/INST]The 6566/6567 registers interact with the processor through the processor interface signals, allowing the processor to access and control the registers in a standardized way, enabling efficient communication and data transfer."
"[INST]In the context of the C64, what is the significance of the processor interface signals in the 6566/6567?[/INST]The processor interface signals play a crucial role in the 6566/6567, as they provide a standardized way for the processor to access and control the registers, enabling efficient communication and data transfer between the processor and the 6566/6567."
"[INST]In the context of the C64, how does the 6566/6567 access the processor interface signals?[/INST]The 6566/6567 accesses the processor interface signals through a standardized interface, which allows the processor to access and control the registers, enabling efficient communication and data transfer between the processor and the 6566/6567."
"[INST]In the context of the C64, what is the purpose of the processor interface signals in the 6566/6567?[/INST]The purpose of the processor interface signals in the 6566/6567 is to provide a standardized way for the processor to access and control the registers, enabling efficient communication and data transfer between the processor and the 6566/6567."
"[INST]In the context of the C64, how do the processor interface signals enable communication between the processor and the 6566/6567?[/INST]The processor interface signals enable communication between the processor and the 6566/6567 by providing a standardized way for the processor to access and control the registers, allowing for efficient data transfer and control."
"[INST]In the context of the C64, what is the role of the processor interface signals in the 6566/6567?[/INST]The role of the processor interface signals in the 6566/6567 is to provide a standardized way for the processor to access and control the registers, enabling efficient communication and data transfer between the processor and the 6566/6567."
"[INST]In the context of the C64, how does the 6566/6567 use the processor interface signals to communicate with the processor?[/INST]The 6566/6567 uses the processor interface signals to communicate with the processor by providing a standardized way for the processor to access and control the registers, enabling efficient communication and data transfer between the processor and the 6566/6567."
"[INST]In the context of the C64, what is the significance of the standardized interface in the 6566/6567?[/INST]The significance of the standardized interface in the 6566/6567 is that it provides a common language for the processor and the 6566/6567 to communicate, enabling efficient data transfer and control between the two."
"[INST]In the context of the C64, how does the processor interface signals enable data transfer between the processor and the 6566/6567?[/INST]The processor interface signals enable data transfer between the processor and the 6566/6567 by providing a standardized way for the processor to access and control the registers, allowing for efficient data transfer and control."
"[INST]In the context of the C64, what is the opcode for the SEC instruction?[/INST]The opcode for the SEC instruction is 38, which sets the carry flag. This instruction is used to set the carry flag in the processor status register, indicating that a borrow or carry has occurred in a previous arithmetic operation."
"[INST]In the context of the C64, what is the addressing mode of the SEC instruction?[/INST]The addressing mode of the SEC instruction is implied, meaning that it does not require a memory address or operand. The SEC instruction operates directly on the processor status register, setting the carry flag without referencing a specific memory location."
"[INST]In the context of the C64, how many bytes does the SEC instruction occupy in memory?[/INST]The SEC instruction occupies 1 byte in memory, making it a compact and efficient instruction for setting the carry flag."
"[INST]In the context of the C64, how many cycles does the SEC instruction take to execute?[/INST]The SEC instruction takes 2 cycles to execute, making it a relatively fast instruction for setting the carry flag."
"[INST]In the context of the C64, what is the purpose of the SEC instruction?[/INST]The purpose of the SEC instruction is to set the carry flag in the processor status register, indicating that a borrow or carry has occurred in a previous arithmetic operation. This instruction is often used in arithmetic and logical operations to maintain accurate results."
"[INST]In the context of the C64, can the SEC instruction be used with an operand?[/INST]No, the SEC instruction cannot be used with an operand. The SEC instruction operates directly on the processor status register, setting the carry flag without referencing a specific memory location or operand."
"[INST]In the context of the C64, what is the assembly language form of the SEC instruction?[/INST]The assembly language form of the SEC instruction is simply 'SEC', with no operands or addressing modes required."
"[INST]In the context of the C64, in what situations would you use the SEC instruction?[/INST]The SEC instruction would typically be used in situations where a borrow or carry has occurred in a previous arithmetic operation, such as in multi-byte arithmetic or when performing arithmetic operations that involve carry or borrow flags."
"[INST]In the context of the C64, how does the SEC instruction affect the processor status register?[/INST]The SEC instruction sets the carry flag in the processor status register, indicating that a borrow or carry has occurred in a previous arithmetic operation. This can affect the outcome of subsequent arithmetic and logical operations."
"[INST]In the context of the C64, is the SEC instruction specific to the C64?[/INST]While the SEC instruction is available on the C64, it is not specific to the C64 and is a standard instruction available on many 8-bit microprocessors, including the 6510 and 8500."
"[INST]In the context of the C64, What is the purpose of the LOAD routine?[/INST]Load RAM from device"
"[INST]In the context of the C64, What is the call address of the LOAD routine?[/INST]$FFD5 (hex) 65493 (decimal)"
"[INST]In the context of the C64, What registers are affected by the LOAD routine?[/INST]A, X, Y"
"[INST]In the context of the C64, What are the preparatory routines for the LOAD routine?[/INST]SETLFS, SETNAM"
"[INST]In the context of the C64, What are the possible error returns for the LOAD routine?[/INST]0,4,5,8,9, READST"
"[INST]In the context of the C64, What is the purpose of setting the accumulator to 0 or 1?[/INST]For a LOAD operation or a verify operation"
"[INST]In the context of the C64, What happens if the input device is opened with a secondary address of 0?[/INST]The header information from the device is ignored"
"[INST]In the context of the C64, What happens if the input device is addressed with a secondary address of 1?[/INST]The data is loaded into memory starting at the location specified by the header"
"[INST]In the context of the C64, What routines must be called before using the LOAD routine?[/INST]KERNAL SETLFS, and SETNAM routines"
"[INST]In the context of the C64, What devices cannot be used for loading data?[/INST]Keyboard (0), RS-232 (2), or the screen (3)"
"[INST]In the context of the C64, Load the accumulator with the number of the logical file to be closed.[/INST]Load the accumulator with the number of the logical file to be closed."
"[INST]In the context of the C64, Call this routine after loading the accumulator with the logical file number.[/INST]Call this routine after loading the accumulator with the logical file number."
"[INST]In the context of the C64, What is the purpose of the CLOSE routine?[/INST]Close a logical file."
"[INST]In the context of the C64, What is the call address of the CLOSE routine?[/INST]$FFC3 (hex) 65475 (decimal)"
"[INST]In the context of the C64, What registers are affected by the CLOSE routine?[/INST]A, X, Y"
"[INST]In the context of the C64, What is the minimum stack requirement for the CLOSE routine?[/INST]2+"
"[INST]In the context of the C64, What is the error return value for the CLOSE routine?[/INST]0,240 (See READST)"
"[INST]In the context of the C64, What is the preparatory routine for the CLOSE routine?[/INST]nan"
"[INST]In the context of the C64, What is the communication register for the CLOSE routine?[/INST]A"
"[INST]In the context of the C64, What is the description of the CLOSE routine?[/INST]This routine is used to close a logical file after all I/O operations have been completed on that file."
"[INST]In the context of the C64, Where is the raster register located in the VIC-II chip?[/INST]The raster register is found in the VIC-II chip at location 53266 ($D012)."
"[INST]In the context of the C64, What is the purpose of the raster register when reading it?[/INST]It returns the lower 8 bits of the current raster position."
"[INST]In the context of the C64, What is the most significant bit of the raster position located at?[/INST]Register location 53265 ($D011)."
"[INST]In the context of the C64, What is the purpose of the raster register in setting up timing changes?[/INST]To get rid of screen flicker."
"[INST]In the context of the C64, When should the changes on the screen be made?[/INST]When the raster is not in the visible display area, which is when your dot positions fall between 51 and 251."
"[INST]In the context of the C64, What happens when the raster register is written to?[/INST]The number written to is saved for use with the raster compare function."
"[INST]In the context of the C64, What happens when the actual raster value becomes the same as the number written to the raster register?[/INST]A bit in the VIC-II chip interrupt register 53273 ($D019) is turned ON by setting it to 1."
"[INST]In the context of the C64, What happens if the proper interrupt bit is enabled?[/INST]An interrupt (IRQ) will occur."
"[INST]In the context of the C64, What is the purpose of the raster compare function?[/INST]To compare the actual raster value with the number written to the raster register."
"[INST]In the context of the C64, What is the purpose of the VIC-II chip interrupt register?[/INST]To handle interrupts."
"[INST]In the context of the C64, What is the purpose of the raster register in the VIC-II chip?[/INST]To set up timing changes in your display to get rid of screen flicker."
"[INST]In the context of the C64, Can sprites cross each other's paths?[/INST]Yes, sprites have the ability to cross each other's paths."
"[INST]In the context of the C64, What is the highest priority sprite number?[/INST]Sprite 0 has the highest priority."
"[INST]In the context of the C64, Can sprites be positioned in front of or behind other objects on the screen?[/INST]Yes, sprites can be positioned in front of or behind other objects on the screen."
"[INST]In the context of the C64, What determines the priority of sprites?[/INST]Sprite priority is fixed and determined by the sprite number."
"[INST]In the context of the C64, Can sprites have 'holes' in them?[/INST]Yes, sprites can have 'holes' in them."
"[INST]In the context of the C64, What happens when a sprite with higher priority has 'holes' in it?[/INST]The sprite with the lower priority will show through."
"[INST]In the context of the C64, What is the effect of assigning lower sprite numbers?[/INST]Sprites assigned lower sprite numbers will appear in the foreground."
"[INST]In the context of the C64, What is the effect of assigning higher sprite numbers?[/INST]Sprites assigned higher sprite numbers will appear in the background."
"[INST]In the context of the C64, Can a sprite with higher priority show through a sprite with lower priority?[/INST]Yes, a sprite with higher priority can show through a sprite with lower priority."
"[INST]In the context of the C64, What is the 'window' effect in sprite display?[/INST]The 'window' effect is when a sprite with higher priority shows through a sprite with lower priority."
"[INST]In the context of the C64, what is the function of the data direction register in the 6526 i/o ports[/INST]The Data Direction Register (DDR) determines whether a bit in the Peripheral Data Register (PR) is an input or an output. If a bit in the DDR is set to a one, the corresponding bit in the PR is an output; if a DDR bit is set to a zero, the corresponding PR bit is defined as an input."
"[INST]In the context of the C64, what happens when a bit in the data direction register is set to a one[/INST]When a bit in the Data Direction Register (DDR) is set to a one, the corresponding bit in the Peripheral Data Register (PR) is defined as an output, allowing data to be written to the port pin."
"[INST]In the context of the C64, what is the purpose of the peripheral data register in the 6526 i/o ports[/INST]The Peripheral Data Register (PR) reflects the information present on the actual port pins (PA0-PA7, PB0-PB7) for both input and output bits, allowing data to be read from or written to the port pins."
"[INST]In the context of the C64, what is the difference between a bit set to a one and a bit set to a zero in the data direction register[/INST]A bit set to a one in the Data Direction Register (DDR) defines the corresponding bit in the Peripheral Data Register (PR) as an output, while a bit set to a zero defines the corresponding PR bit as an input."
"[INST]In the context of the C64, what type of compatibility do the ports a and b provide[/INST]Ports A and B provide both CMOS and TTL compatibility, thanks to the passive pull-up devices as well as active pull-ups."
"[INST]In the context of the C64, what is the load drive capability of ports a and b[/INST]Both ports A and B have two TTL load drive capability."
"[INST]In the context of the C64, what additional function do pb6 and pb7 provide[/INST]In addition to normal I/O operation, PB6 and PB7 also provide timer output functions."
"[INST]In the context of the C64, what is the purpose of the passive pull-up devices in ports a and b[/INST]The passive pull-up devices in Ports A and B provide CMOS and TTL compatibility."
"[INST]In the context of the C64, how do ports a and b reflect the information present on the actual port pins[/INST]Ports A and B reflect the information present on the actual port pins (PA0-PA7, PB0-PB7) for both input and output bits through the Peripheral Data Register (PR)."
"[INST]In the context of the C64, what is the relationship between the data direction register and the peripheral data register[/INST]The Data Direction Register (DDR) determines whether a bit in the Peripheral Data Register (PR) is an input or an output, and the PR reflects the information present on the actual port pins for both input and output bits."
"[INST]In the context of the C64, ROL instruction rotates one bit left in memory or accumulator[/INST]The ROL instruction rotates one bit left in memory or accumulator."
"[INST]In the context of the C64, ROL instruction has different addressing modes[/INST]The ROL instruction has different addressing modes such as Accumulator, Zero Page, Zero Page,X, Absolute, and Absolute,X."
"[INST]In the context of the C64, ROL instruction has different operation codes[/INST]The ROL instruction has different operation codes such as 2A, 26, 36, 2E, and 3E."
"[INST]In the context of the C64, ROL instruction has different number of bytes[/INST]The ROL instruction has different number of bytes such as 1, 2, and 3."
"[INST]In the context of the C64, ROL instruction has different number of cycles[/INST]The ROL instruction has different number of cycles such as 2, 5, 6, and 7."
"[INST]In the context of the C64, ROL instruction is used in assembly language[/INST]The ROL instruction is used in assembly language to rotate one bit left in memory or accumulator."
"[INST]In the context of the C64, ROL instruction is used in different addressing modes[/INST]The ROL instruction is used in different addressing modes such as Accumulator, Zero Page, Zero Page,X, Absolute, and Absolute,X."
"[INST]In the context of the C64, ROL instruction is used in different operation codes[/INST]The ROL instruction is used in different operation codes such as 2A, 26, 36, 2E, and 3E."
"[INST]In the context of the C64, ROL instruction is used in different number of bytes[/INST]The ROL instruction is used in different number of bytes such as 1, 2, and 3."
"[INST]In the context of the C64, ROL instruction is used in different number of cycles[/INST]The ROL instruction is used in different number of cycles such as 2, 5, 6, and 7."
"[INST]In the context of the C64, what is the purpose of the NOP instruction[/INST]The purpose of the NOP instruction is to perform a No Operation, which means that the instruction does not perform any actual operation."
"[INST]In the context of the C64, What is the number of cycles required to execute the NOP instruction[/INST]The NOP instruction requires 2 cycles to execute."
"[INST]In the context of the C64, What is the addressing mode used by the NOP instruction[/INST]The NOP instruction uses the Implied addressing mode."
"[INST]In the context of the C64, What is the assembly language form of the NOP instruction[/INST]The assembly language form of the NOP instruction is NOP."
"[INST]In the context of the C64, What is the number of bytes required to encode the NOP instruction[/INST]The NOP instruction requires 1 byte to encode."
"[INST]In the context of the C64, What is the opcode of the NOP instruction[/INST]The opcode of the NOP instruction is EA."
"[INST]In the context of the C64, What is the purpose of the NOP instruction in assembly language programming[/INST]The purpose of the NOP instruction in assembly language programming is to perform a No Operation, which means that the instruction does not perform any actual operation."
"[INST]In the context of the C64, What is the number of bytes required to encode the NOP instruction in assembly language programming[/INST]The NOP instruction in assembly language programming requires 1 byte to encode."
"[INST]In the context of the C64, What is the purpose of the NOP instruction in computer architecture[/INST]The purpose of the NOP instruction in computer architecture is to perform a No Operation, which means that the instruction does not perform any actual operation."
"[INST]In the context of the C64, What is the number of cycles required to execute the NOP instruction in computer architecture[/INST]The NOP instruction in computer architecture requires 2 cycles to execute."
"[INST]In the context of the C64, Where are the 6510 Registers stored?[/INST]0 & 1"
"[INST]In the context of the C64, What is the start of memory?[/INST]2"
"[INST]In the context of the C64, What is the purpose of the memory from 2-1023?[/INST]Memory used by the operating system."
"[INST]In the context of the C64, What is stored in the screen memory?[/INST]Screen memory."
"[INST]In the context of the C64, What are the SPRITE pointers used for?[/INST]SPRITE pointers."
"[INST]In the context of the C64, What is the purpose of the memory from 2048-40959?[/INST]This is YOUR memory. This is where your BASIC or machine language programs, or both, are stored."
"[INST]In the context of the C64, What is stored in the 8K CBM BASIC Interpreter?[/INST]8K CBM BASIC Interpreter."
"[INST]In the context of the C64, What is the purpose of the special programs RAM area?[/INST]Special programs RAM area."
"[INST]In the context of the C64, What is the purpose of the VIC-II?[/INST]VIC-II."
"[INST]In the context of the C64, What are the SID Registers used for?[/INST]SID Registers."
"[INST]In the context of the C64, What is stored in the Color RAM?[/INST]Color RAM."
"[INST]In the context of the C64, What are the I/O Registers used for?[/INST]I/O Registers."
"[INST]In the context of the C64, What is the purpose of the 8K CBM KERNAL Operating System?[/INST]8K CBM KERNAL Operating System."
"[INST]In the context of the C64, What is stored in the memory from 40960-49151?[/INST]8K CBM BASIC Interpreter."
"[INST]In the context of the C64, What is stored in the memory from 49152-53247?[/INST]Special programs RAM area."
"[INST]In the context of the C64, What is stored in the memory from 53248-53294?[/INST]VIC-II."
"[INST]In the context of the C64, What is stored in the memory from 54272-55295?[/INST]SID Registers."
"[INST]In the context of the C64, What is stored in the memory from 55296-56296?[/INST]Color RAM."
"[INST]In the context of the C64, What is stored in the memory from 56320-57343?[/INST]I/O Registers."
"[INST]In the context of the C64, What is stored in the memory from 57344-65535?[/INST]8K CBM KERNAL Operating System."
"[INST]In the context of the C64, what is the opcode for the STY instruction in zero page addressing mode?[/INST]The opcode for the STY instruction in zero page addressing mode is 84, which requires 2 bytes and 3 cycles to execute."
"[INST]In the context of the C64, what is the assembly language form for the STY instruction in zero page,X addressing mode?[/INST]The assembly language form for the STY instruction in zero page,X addressing mode is STY Oper,X, which has an opcode of 94, requires 2 bytes, and takes 4 cycles to execute."
"[INST]In the context of the C64, what is the difference in cycles between the STY instruction in zero page and absolute addressing modes?[/INST]The STY instruction in zero page addressing mode takes 3 cycles to execute, whereas in absolute addressing mode it takes 4 cycles, resulting in a difference of 1 cycle."
"[INST]In the context of the C64, what is the opcode for the STY instruction in absolute addressing mode?[/INST]The opcode for the STY instruction in absolute addressing mode is 8C, which requires 3 bytes and 4 cycles to execute."
"[INST]In the context of the C64, how many bytes are required to execute the STY instruction in zero page addressing mode?[/INST]The STY instruction in zero page addressing mode requires 2 bytes to execute."
"[INST]In the context of the C64, what is the purpose of the STY instruction?[/INST]The STY instruction is used to store the index Y in memory, which is an essential operation in many programming scenarios."
"[INST]In the context of the C64, in which addressing modes can the STY instruction be used?[/INST]The STY instruction can be used in zero page, zero page,X, and absolute addressing modes, each with its own opcode and execution characteristics."
"[INST]In the context of the C64, what is the assembly language form for the STY instruction in absolute addressing mode?[/INST]The assembly language form for the STY instruction in absolute addressing mode is STY Oper, which has an opcode of 8C, requires 3 bytes, and takes 4 cycles to execute."
"[INST]In the context of the C64, how many cycles does the STY instruction take to execute in zero page,X addressing mode?[/INST]The STY instruction in zero page,X addressing mode takes 4 cycles to execute."
"[INST]In the context of the C64, what is the opcode for the STY instruction in zero page,X addressing mode?[/INST]The opcode for the STY instruction in zero page,X addressing mode is 94, which requires 2 bytes and 4 cycles to execute."
"[INST]In the context of the C64, Can the SID chip's parameters be changed dynamically during a note or sound?[/INST]Yes, the SID chip's parameters can be changed dynamically during a note or sound to create many interesting and fun effects."
"[INST]In the context of the C64, What are the digitized outputs available for you in registers?[/INST]Digitized outputs from oscillator three and envelope generator three are available for you in registers 27 and 28, respectively."
"[INST]In the context of the C64, What is the relationship between the output of oscillator 3 and the waveform selected?[/INST]The output of oscillator 3 is directly related to the waveform selected."
"[INST]In the context of the C64, What happens to the output of oscillator 3 when the sawtooth waveform is chosen?[/INST]The output will present a series of numbers incremented (increased step by step) from 0 to 255 at a rate determined by the frequency of oscillator 3."
"[INST]In the context of the C64, What happens to the output of oscillator 3 when the triangle waveform is chosen?[/INST]The output will increment from 0 up to 255, then decrement (decrease step by step) back down to 0."
"[INST]In the context of the C64, What happens to the output of oscillator 3 when the pulse wave is chosen?[/INST]The output will jump back-and-forth between 0 and 255."
"[INST]In the context of the C64, What happens to the output of oscillator 3 when the noise waveform is chosen?[/INST]The output will give you a series of random numbers."
"[INST]In the context of the C64, What is the purpose of setting bit 7 of register 24?[/INST]Setting bit 7 of register 24 turns the audio output of voice 3 off."
"[INST]In the context of the C64, What is the function of register 25?[/INST]Register 25 gives you access to the output of the envelope generator of oscillator 3."
"[INST]In the context of the C64, How can vibrato be achieved?[/INST]Vibrato can be achieved by adding the output of oscillator 3 to the frequency of another oscillator."
"[INST]In the context of the C64, what is the purpose of the UNTLK function?[/INST]The purpose of the UNTLK function is to send an UNTALK command on the serial bus, which stops all devices previously set to TALK from sending data when this command is received."
"[INST]In the context of the C64, What is the call address of the UNTLK function?[/INST]The call address of the UNTLK function is $FFAB in hexadecimal, which is equivalent to 65451 in decimal."
"[INST]In the context of the C64, What are the communication registers used by the UNTLK function?[/INST]The UNTLK function does not use any communication registers."
"[INST]In the context of the C64, What are the preparatory routines required by the UNTLK function?[/INST]The UNTLK function does not require any preparatory routines."
"[INST]In the context of the C64, What are the error returns of the UNTLK function?[/INST]The error returns of the UNTLK function are the same as those of the READST routine."
"[INST]In the context of the C64, What is the stack requirement of the UNTLK function?[/INST]The UNTLK function requires 8 bytes of stack space."
"[INST]In the context of the C64, What registers are affected by the UNTLK function?[/INST]The UNTLK function affects the accumulator (A) register."
"[INST]In the context of the C64, How do you use the UNTLK function?[/INST]To use the UNTLK function, you simply need to call it using a JSR instruction, as shown in the example: JSR UNTLK>."
"[INST]In the context of the C64, What is the effect of the UNTLK function on devices set to TALK?[/INST]When the UNTLK function is called, all devices previously set to TALK will stop sending data."
"[INST]In the context of the C64, What is the purpose of sending an UNTALK command on the serial bus?[/INST]The purpose of sending an UNTALK command on the serial bus is to stop all devices previously set to TALK from sending data."
"[INST]In the context of the C64, how many bytes does each sprite take to define[/INST]each sprite takes 63 bytes to define, but an extra byte is needed as a placeholder at the end of each sprite, so each sprite takes up 64 bytes in total"
"[INST]In the context of the C64, what is the purpose of the sprite pointer[/INST]the sprite pointer controls where each sprite definition is located in memory, and each of the 8 sprites has a byte associated with it, located as the last 8 bytes of the 1K chunk of screen memory, normally starting at location 2040 ($07F8 in HEX)"
"[INST]In the context of the C64, where are the sprite pointers located in memory[/INST]the sprite pointers are located as the last 8 bytes of the 1K chunk of screen memory, normally starting at location 2040 ($07F8 in HEX), but if you move the screen, the location of your sprite pointers will also move"
"[INST]In the context of the C64, what is the range of values that a sprite pointer can hold[/INST]a sprite pointer can hold a number from 0 to 255, which points to the definition for that sprite"
"[INST]In the context of the C64, how much memory can a sprite pointer access[/INST]a sprite pointer can access anywhere in the 16K block of memory that the VIC-II chip can access, since 256*64=16K"
"[INST]In the context of the C64, why is it easy to calculate where in memory a sprite definition is[/INST]it's easy to calculate where in memory a sprite definition is because each sprite takes up 64 bytes, which is an even number and an even power in binary"
"[INST]In the context of the C64, what happens if you move the screen[/INST]if you move the screen, the location of your sprite pointers will also move"
"[INST]In the context of the C64, how many sprite pointers are there[/INST]there are 8 sprite pointers, one for each of the 8 sprites"
"[INST]In the context of the C64, what is the purpose of the extra byte at the end of each sprite[/INST]the extra byte at the end of each sprite is a placeholder"
"[INST]In the context of the C64, what is the significance of the 64 bytes per sprite[/INST]the 64 bytes per sprite makes it easy to calculate where in memory a sprite definition is, since 64 is an even number and an even power in binary"
"[INST]In the context of the C64, what is the opcode for absolute jmp instruction?[/INST]the opcode for absolute jmp instruction is 4C, which is used to jump to a new location in the program, and it takes 3 bytes and 3 cycles to execute"
"[INST]In the context of the C64, what is the addressing mode for jmp (oper) instruction?[/INST]the addressing mode for jmp (oper) instruction is indirect, which is denoted by jmp (oper) in assembly language form, and it has an opcode of 6C, taking 3 bytes and 5 cycles to execute"
"[INST]In the context of the C64, what is the purpose of jmp instruction?[/INST]the purpose of jmp instruction is to jump to a new location in the program, it is an unconditional jump instruction that transfers the program control to a new location specified by the operand"
"[INST]In the context of the C64, what is the difference between absolute and indirect jmp instructions?[/INST]the main difference between absolute and indirect jmp instructions is the way they specify the target address, absolute jmp instruction specifies the target address directly, whereas indirect jmp instruction specifies the address of a memory location that contains the target address"
"[INST]In the context of the C64, what is the cycle count for indirect jmp instruction?[/INST]the cycle count for indirect jmp instruction is 5 cycles, which is higher than the absolute jmp instruction due to the additional memory access required to fetch the target address"
"[INST]In the context of the C64, what is the opcode for indirect jmp instruction?[/INST]the opcode for indirect jmp instruction is 6C, which is used to jump to a new location in the program indirectly, by fetching the target address from a memory location"
"[INST]In the context of the C64, what is the byte count for absolute jmp instruction?[/INST]the byte count for absolute jmp instruction is 3 bytes, which includes the opcode and the target address"
"[INST]In the context of the C64, can jmp instruction be used to implement loops?[/INST]yes, jmp instruction can be used to implement loops, by jumping back to the beginning of the loop body, it can be used to create a loop that repeats a sequence of instructions"
"[INST]In the context of the C64, what is the assembly language form of absolute jmp instruction?[/INST]the assembly language form of absolute jmp instruction is jmp oper, where oper is the target address"
"[INST]In the context of the C64, what is the role of jmp instruction in program control flow?[/INST]the role of jmp instruction in program control flow is to transfer the program control to a new location, it is used to implement conditional and unconditional jumps, loops, and subroutines"
"[INST]In the context of the C64, what are the benefits of using sprites in game development on the C64[/INST]The use of sprites in game development on the C64 provides several benefits, including the ability to create arcade-style games with ease, and the possibility of writing high-quality games in BASIC, thanks to the hardware maintenance of sprites by the VIC-II chip."
"[INST]In the context of the C64, what is the maximum number of sprites supported by the VIC-II chip[/INST]The VIC-II chip supports up to 8 sprites, numbered from 0 to 7, each with its own definition location, position registers, color register, and enable and collision detection bits."
"[INST]In the context of the C64, what is the advantage of having sprites maintained by hardware[/INST]Having sprites maintained by hardware, as in the case of the VIC-II chip, allows for efficient and fast sprite management, freeing up system resources for other tasks and enabling the creation of complex and smooth animations."
"[INST]In the context of the C64, what is the significance of each sprite having its own definition location[/INST]Each sprite having its own definition location allows for flexibility and customization, enabling developers to define the appearance and behavior of each sprite independently, and to create a wide range of visual effects and animations."
"[INST]In the context of the C64, what is the purpose of the position registers in a sprite[/INST]The position registers in a sprite are used to store the x and y coordinates of the sprite on the screen, allowing for precise control over the sprite's movement and placement."
"[INST]In the context of the C64, what is the role of the color register in a sprite[/INST]The color register in a sprite determines the color of the sprite, enabling developers to customize the visual appearance of the sprite and to create a wide range of colorful and engaging graphics."
"[INST]In the context of the C64, what is the purpose of the enable bits in a sprite[/INST]The enable bits in a sprite are used to control the visibility of the sprite, allowing developers to dynamically show or hide sprites as needed, and to create complex and dynamic animations."
"[INST]In the context of the C64, what is the significance of collision detection in sprites[/INST]Collision detection in sprites enables developers to detect and respond to collisions between sprites, allowing for the creation of interactive and engaging game mechanics, such as collision-based scoring or level progression."
"[INST]In the context of the C64, how do sprites facilitate the creation of arcade-style games[/INST]Sprites facilitate the creation of arcade-style games by providing a built-in mechanism for creating and managing graphical objects, allowing developers to focus on game logic and design, and to create fast-paced and engaging gameplay experiences."
"[INST]In the context of the C64, what is the advantage of using BASIC to develop games on the C64[/INST]Using BASIC to develop games on the C64 provides an accessible and easy-to-use development environment, allowing developers to focus on game design and logic, and to create high-quality games quickly and efficiently."
"[INST]In the context of the C64, what is the opcode for the BCC instruction?[/INST]The opcode for the BCC instruction is 90."
"[INST]In the context of the C64, what is the addressing mode for the BCC instruction?[/INST]The addressing mode for the BCC instruction is Relative."
"[INST]In the context of the C64, what is the number of bytes for the BCC instruction?[/INST]The number of bytes for the BCC instruction is 2."
"[INST]In the context of the C64, what is the number of cycles for the BCC instruction when the branch occurs to the same page?[/INST]The number of cycles for the BCC instruction when the branch occurs to the same page is 2."
"[INST]In the context of the C64, what is the number of cycles for the BCC instruction when the branch occurs to a different page?[/INST]The number of cycles for the BCC instruction when the branch occurs to a different page is 4."
"[INST]In the context of the C64, what is the purpose of the BCC instruction?[/INST]The purpose of the BCC instruction is to branch on carry clear, which means the program will jump to a new location if the carry flag is clear."
"[INST]In the context of the C64, what is the syntax for the BCC instruction in assembly language?[/INST]The syntax for the BCC instruction in assembly language is BCC Oper, where Oper is the target address of the branch."
"[INST]In the context of the C64, how does the BCC instruction affect the program counter?[/INST]The BCC instruction affects the program counter by loading the target address into it, causing the program to jump to a new location."
"[INST]In the context of the C64, what is the relationship between the BCC instruction and the carry flag?[/INST]The BCC instruction is dependent on the carry flag, and only branches if the carry flag is clear."
"[INST]In the context of the C64, what are the implications of the BCC instruction on program flow?[/INST]The BCC instruction can significantly affect program flow, as it can cause the program to jump to a new location, potentially changing the course of execution."
"[INST]In the context of the C64, how do sprites interact with each other on the screen[/INST]Sprites have the ability to cross each other's paths, as well as cross in front of, or behind other objects on the screen, giving a truly three-dimensional effect for games."
"[INST]In the context of the C64, what determines the priority of sprites on the screen[/INST]Sprite to sprite priority is fixed, meaning that sprite 0 has the highest priority, sprite 1 has the next priority, and so on, until we get to sprite 7, which has the lowest priority."
"[INST]In the context of the C64, how do you control the order of sprites in a scene[/INST]When planning which sprites will appear to be in the foreground of the picture, they must be assigned lower sprite numbers than those sprites you want to put towards the back of the scene, and those sprites will be given higher sprite numbers."
"[INST]In the context of the C64, what happens when a sprite with higher priority has holes in it[/INST]If a sprite with higher priority has 'holes' in it (areas where the dots are not set to 1 and thus turned ON), the sprite with the lower priority will show through, creating a 'window' effect."
"[INST]In the context of the C64, how does the 'window' effect work with sprite and background data[/INST]The 'window' effect also happens with sprite and background data, where the background data will show through the 'holes' in the sprite."
"[INST]In the context of the C64, what is the significance of sprite 0 in terms of priority[/INST]Sprite 0 has the highest priority, meaning it will always be in front of other sprites."
"[INST]In the context of the C64, can sprites be made to appear behind other objects on the screen[/INST]Yes, by assigning a higher sprite number to the sprite, it will appear behind other objects on the screen."
"[INST]In the context of the C64, how do you create a layered effect with sprites[/INST]By assigning lower sprite numbers to sprites you want to appear in the foreground, and higher sprite numbers to sprites you want to appear in the background, you can create a layered effect."
"[INST]In the context of the C64, what happens when two sprites with different priorities overlap[/INST]When two sprites with different priorities overlap, the sprite with the higher priority will be in front of the sprite with the lower priority."
"[INST]In the context of the C64, can you use the 'window' effect to create complex scenes[/INST]Yes, by using the 'window' effect, you can create complex scenes with multiple layers and depth, giving a more realistic and engaging visual experience."
"[INST]In the context of the C64, What is the main difference between DIRECT mode and PROGRAM mode in Commodore 64 BASIC?[/INST]The main difference between DIRECT mode and PROGRAM mode in Commodore 64 BASIC is that in DIRECT mode, BASIC statements do not have line numbers and are executed immediately when the RETURN key is pressed, whereas in PROGRAM mode, BASIC statements must have line numbers and are executed when the program is run."
"[INST]In the context of the C64, What happens when you press the RETURN key in DIRECT mode?[/INST]When you press the RETURN key in DIRECT mode, the BASIC statement is executed immediately, allowing for interactive and immediate execution of BASIC commands."
"[INST]In the context of the C64, What is the purpose of the PROGRAM mode in Commodore 64 BASIC?[/INST]The purpose of the PROGRAM mode is to create and run programs, where each BASIC statement must have a line number, and the program can be executed as a whole when the RUN command is given."
"[INST]In the context of the C64, What is the character limit for a logical screen line in PROGRAM mode?[/INST]The character limit for a logical screen line in PROGRAM mode is 80 characters, which means that if a BASIC statement exceeds this limit, it must be continued on a new line with a new line number."
"[INST]In the context of the C64, Why is it important to type NEW and press RETURN before starting a new program?[/INST]Typing NEW and pressing RETURN before starting a new program is important because it clears the current program from memory, allowing you to start fresh and preventing any existing program from interfering with your new program."
"[INST]In the context of the C64, What is the significance of line numbers in PROGRAM mode?[/INST]Line numbers in PROGRAM mode are significant because they allow the BASIC interpreter to keep track of the order of execution of the program, and they enable the programmer to edit and debug the program more easily."
"[INST]In the context of the C64, How do you execute a program in PROGRAM mode?[/INST]To execute a program in PROGRAM mode, you simply type RUN and press RETURN, and the program will execute from the first line number to the last."
"[INST]In the context of the C64, What happens if you exceed the 80 character limit on a line in PROGRAM mode?[/INST]If you exceed the 80 character limit on a line in PROGRAM mode, you must continue the BASIC statement on a new line with a new line number, allowing you to break up long statements into more manageable pieces."
"[INST]In the context of the C64, What is the advantage of using DIRECT mode over PROGRAM mode?[/INST]The advantage of using DIRECT mode over PROGRAM mode is that it allows for interactive and immediate execution of BASIC commands, making it ideal for quick testing and experimentation."
"[INST]In the context of the C64, Can you have multiple BASIC statements on a single line in PROGRAM mode?[/INST]Yes, you can have multiple BASIC statements on a single line in PROGRAM mode, but you are limited by the 80 character limit, and you must separate each statement with a colon (:) or a semicolon (;)."
"[INST]In the context of the C64, What is the format of the OPEN statement parameters?[/INST]FORMAT: OPEN file#, device#, number, string"
"[INST]In the context of the C64, What is the purpose of the DEVICE column in the table?[/INST]File Name"
"[INST]In the context of the C64, What is the purpose of the NUMBER column in the table?[/INST]Control Registers"
"[INST]In the context of the C64, What is the purpose of the STRING column in the table?[/INST]Text Is PRINTed"
"[INST]In the context of the C64, What is the range of DEVICE# values?[/INST]8 to 11"
"[INST]In the context of the C64, What is the purpose of the MODEM device?[/INST]Control Registers"
"[INST]In the context of the C64, What is the purpose of the SCREEN device?[/INST]Text Is PRINTed"
"[INST]In the context of the C64, What is the purpose of the PRINTER device?[/INST]Text Is PRINTed"
"[INST]In the context of the C64, What is the purpose of the DISK device?[/INST]Drive #, File Name"
"[INST]In the context of the C64, What is the purpose of the CASSETTE device?[/INST]File Name"
"[INST]In the context of the C64, what is the purpose of the lda $dc00 instruction in the joystick read routine?[/INST]The lda $dc00 instruction is used to get input from port A only, which is necessary for reading the joystick and fire button input data."
"[INST]In the context of the C64, what is the significance of the ldy #0 and ldx #0 instructions in the joystick read routine?[/INST]The ldy #0 and ldx #0 instructions are used to initialize the Y and X registers to zero, which are later used to store the decoded joystick direction and fire button state."
"[INST]In the context of the C64, how does the routine determine the joystick direction?[/INST]The routine determines the joystick direction by shifting the bits of the accumulator and checking the carry flag. The joystick directions are determined as follows: bit3=right, bit2=left, bit1=backward, and bit0=forward."
"[INST]In the context of the C64, what is the purpose of the stx dx and sty dy instructions?[/INST]The stx dx and sty dy instructions are used to store the decoded joystick direction values in the dx and dy variables, which contain the 2's compliment direction numbers at the time of RTS."
"[INST]In the context of the C64, what is the significance of the carry flag at the time of RTS?[/INST]The carry flag at the time of RTS contains the fire button state. If C=1, then the button is not pressed, and if C=0, then the button is pressed."
"[INST]In the context of the C64, what is the purpose of the lsr a instruction in the joystick read routine?[/INST]The lsr a instruction is used to shift the bits of the accumulator, which is necessary for decoding the joystick direction and fire button state."
"[INST]In the context of the C64, how does the routine handle the joystick fire button input?[/INST]The routine handles the joystick fire button input by checking the bit4 of the accumulator, which corresponds to the fire button state."
"[INST]In the context of the C64, what is the purpose of the iny and inx instructions in the joystick read routine?[/INST]The iny and inx instructions are used to increment the Y and X registers, which are used to store the decoded joystick direction values."
"[INST]In the context of the C64, what is the significance of the dx and dy variables in the joystick read routine?[/INST]The dx and dy variables contain the 2's compliment direction numbers, where dx=1 corresponds to moving right, dx=-1 corresponds to moving left, dy=-1 corresponds to moving up the screen, and dy=0 corresponds to moving down the screen."
"[INST]In the context of the C64, what is the purpose of the rts instruction in the joystick read routine?[/INST]The rts instruction is used to return from the subroutine, and at the time of RTS, the dx and dy variables contain the decoded joystick direction values, and the carry flag contains the fire button state."
"[INST]In the context of the C64, What is the purpose of the CHKOUT function?[/INST]The purpose of the CHKOUT function is to open a channel for output, allowing data to be sent to a device such as a printer or serial device."
"[INST]In the context of the C64, What is the call address of the CHKOUT function?[/INST]The call address of the CHKOUT function is $FFC9 (hex) or 65481 (decimal)."
"[INST]In the context of the C64, What communication register is used by the CHKOUT function?[/INST]The CHKOUT function uses the X register as the communication register."
"[INST]In the context of the C64, What preparatory routine is required before calling the CHKOUT function?[/INST]The preparatory routine required before calling the CHKOUT function is the OPEN routine."
"[INST]In the context of the C64, What error returns can occur when calling the CHKOUT function?[/INST]The error returns that can occur when calling the CHKOUT function are 0, 3, 5, and 7, which correspond to errors such as file not open, device not present, and not an output file."
"[INST]In the context of the C64, How many stack requirements are needed to call the CHKOUT function?[/INST]The CHKOUT function requires 4+ stack requirements."
"[INST]In the context of the C64, What registers are affected by the CHKOUT function?[/INST]The CHKOUT function affects the A and X registers."
"[INST]In the context of the C64, Can the CHKOUT function be used to send data to the Commodore 64 screen?[/INST]No, the CHKOUT function is not needed to send data to the Commodore 64 screen, as the screen is the default output device."
"[INST]In the context of the C64, How do you specify a logical file number when calling the CHKOUT function?[/INST]You specify a logical file number by loading the X register with the logical file number used in the open statement, and then calling the CHKOUT function using the JSR instruction."
"[INST]In the context of the C64, What happens when the CHKOUT function is used to open a channel to a device on the serial bus?[/INST]When the CHKOUT function is used to open a channel to a device on the serial bus, it automatically sends the LISTEN address specified by the OPEN routine, and a secondary address if there was one."
"[INST]In the context of the C64, What is an example of how to use the CHKOUT function?[/INST]An example of how to use the CHKOUT function is to load the X register with the logical file number 3, and then call the CHKOUT function using the JSR instruction, as in the following code: LDX #3; JSR CHKOUT."
"[INST]In the context of the C64, what is the opcode for the BCS instruction?[/INST]The opcode for the BCS instruction is B0, which stands for Branch on Carry Set, and it is used to branch to a target location if the carry flag is set."
"[INST]In the context of the C64, What is the addressing mode used by the BCS instruction?[/INST]The addressing mode used by the BCS instruction is the Relative addressing mode, which means that the target address is specified relative to the current program counter."
"[INST]In the context of the C64, How many bytes does the BCS instruction occupy in memory?[/INST]The BCS instruction occupies 2 bytes in memory, which includes the opcode and the relative offset to the target location."
"[INST]In the context of the C64, How many cycles does the BCS instruction take to execute?[/INST]The BCS instruction takes 2 cycles to execute, but this can increase to 3 or 4 cycles if the branch occurs to the same page or the next page, respectively."
"[INST]In the context of the C64, What is the purpose of the BCS instruction?[/INST]The purpose of the BCS instruction is to branch to a target location if the carry flag is set, which is useful in conditional branching and loop control structures."
"[INST]In the context of the C64, What happens if the branch occurs to the same page?[/INST]If the branch occurs to the same page, an additional cycle is added to the execution time, making it 3 cycles in total."
"[INST]In the context of the C64, What happens if the branch occurs to the next page?[/INST]If the branch occurs to the next page, two additional cycles are added to the execution time, making it 4 cycles in total."
"[INST]In the context of the C64, Can you give an example of a situation where the BCS instruction would be used?[/INST]A common situation where the BCS instruction would be used is in a loop that continues until a certain condition is met, such as a counter reaching zero, and the carry flag is set to indicate the condition has been met."
"[INST]In the context of the C64, How does the BCS instruction interact with the carry flag?[/INST]The BCS instruction branches to the target location if the carry flag is set, which means that the instruction is dependent on the state of the carry flag to determine the flow of the program."
"[INST]In the context of the C64, What is the significance of the relative offset in the BCS instruction?[/INST]The relative offset in the BCS instruction specifies the target location to branch to, and it is calculated relative to the current program counter, allowing for efficient and flexible branching."
"[INST]In the context of the C64, Where is the best place to put machine language routines on the Commodore 64?[/INST]from $C000-$CFFF"
"[INST]In the context of the C64, What happens to the machine language routine if it's larger than 4K bytes?[/INST]it then becomes necessary to reserve an area at the top of memory"
"[INST]In the context of the C64, What is the top of memory normally?[/INST]$9FFF"
"[INST]In the context of the C64, How can the top of memory be changed?[/INST]through the KERNAL routine MEMTOP, or by the following BASIC statements"
"[INST]In the context of the C64, What is the purpose of the MEMTOP routine?[/INST]to change the top of memory"
"[INST]In the context of the C64, Where is the Receiver Buffer base location pointer stored?[/INST]The Receiver Buffer base location pointer is stored at $00F7, which is a two-byte pointer set up by the OPEN KERNAL routine, pointing to a 256-byte buffer."
"[INST]In the context of the C64, What is the purpose of the CLOSE KERNAL entry?[/INST]The CLOSE KERNAL entry is used to de-allocate the Receiver and Transmitter Buffers by writing a zero into the high order bytes ($00F8 and $00FA) of the buffer base location pointers."
"[INST]In the context of the C64, How can a machine language programmer allocate/de-allocate the buffers?[/INST]A machine language programmer can allocate/de-allocate the buffers by writing a non-zero value to the high order bytes ($00F8 and $00FA) of the buffer base location pointers, and de-allocate by writing a zero to the same locations."
"[INST]In the context of the C64, What is the importance of maintaining correct top of memory pointers?[/INST]Maintaining correct top of memory pointers is crucial, especially when running BASIC programs concurrently, to prevent memory conflicts and ensure smooth program execution."
"[INST]In the context of the C64, What is the size of the buffers allocated by the OPEN KERNAL routine?[/INST]The buffers allocated by the OPEN KERNAL routine are 256-byte buffers."
"[INST]In the context of the C64, What is the purpose of the ROBUF pointer?[/INST]The ROBUF pointer, stored at $00F9, is a two-byte pointer to the Transmitter Buffer base location, set up by the OPEN KERNAL routine."
"[INST]In the context of the C64, How can a machine language programmer use the buffer pointers?[/INST]A machine language programmer can use the buffer pointers to allocate/de-allocate the buffers for their own purposes, removing/creating only the buffer(s) required, while taking care to maintain correct top of memory pointers."
"[INST]In the context of the C64, What happens when a zero is written to the high order bytes of the buffer base location pointers?[/INST]When a zero is written to the high order bytes ($00F8 and $00FA) of the buffer base location pointers, the buffers are de-allocated."
"[INST]In the context of the C64, What is the role of the OPEN KERNAL routine in setting up the buffer pointers?[/INST]The OPEN KERNAL routine sets up the buffer pointers, REBUF and ROBUF, to point to different 256-byte buffers."
"[INST]In the context of the C64, What precautions should a machine language programmer take when allocating/de-allocating buffers?[/INST]A machine language programmer should take care to maintain correct top of memory pointers, especially when running BASIC programs concurrently, to prevent memory conflicts and ensure smooth program execution."
"[INST]In the context of the C64, What is the primary function of a modem?[/INST]translate character codes into audio pulses and vice-versa"
"[INST]In the context of the C64, What is the purpose of the OPEN statement in a modem?[/INST]sets up the parameters to match the speed and format of the other computer"
"[INST]In the context of the C64, What determines the baud rate, number of data bits, and number of stop bits in a modem?[/INST]the bit positions of the first character code"
"[INST]In the context of the C64, What is the optional second code in a modem used for?[/INST]specifies the parity and duplex of the transmission"
"[INST]In the context of the C64, What is the standard set of character codes used by most computers?[/INST]ASCII"
"[INST]In the context of the C64, Why is character translation necessary when communicating with other computers?[/INST]because Commodore 64 character codes are different from ASCII"
"[INST]In the context of the C64, What is the importance of knowing the receiving device when writing programs that communicate with other computers?[/INST]to ensure the receiving computer knows what to do with the characters"
"[INST]In the context of the C64, What is an example of a program that automatically types in account numbers and secret passwords?[/INST]a terminal program"
"[INST]In the context of the C64, Why is it important to carefully count the number of characters and RETURN characters in a program?[/INST]so the receiving computer knows what to do with them"
"[INST]In the context of the C64, What is the main difference between outputting to a modem and outputting to a screen?[/INST]the need for character translation"
"[INST]In the context of the C64, what is the starting address of the VIC chip register map?[/INST]$D000"
"[INST]In the context of the C64, what is the function of register 0?[/INST]SPRITE 0 X COMPONENT"
"[INST]In the context of the C64, what is the function of register 1?[/INST]SPRITE 0 Y COMPONENT"
"[INST]In the context of the C64, what is the function of register 2?[/INST]SPRITE 1 X COMPONENT"
"[INST]In the context of the C64, what is the function of register 3?[/INST]SPRITE 1 Y COMPONENT"
"[INST]In the context of the C64, what is the function of register 4?[/INST]SPRITE 2 X COMPONENT"
"[INST]In the context of the C64, what is the function of register 5?[/INST]SPRITE 2 Y COMPONENT"
"[INST]In the context of the C64, what is the function of register 6?[/INST]SPRITE 3 X COMPONENT"
"[INST]In the context of the C64, what is the function of register 7?[/INST]SPRITE 3 Y COMPONENT"
"[INST]In the context of the C64, what is the function of register 8?[/INST]SPRITE 4 X COMPONENT"
"[INST]In the context of the C64, what is the function of register 9?[/INST]SPRITE 4 Y COMPONENT"
"[INST]In the context of the C64, what is the function of register 10?[/INST]SPRITE 5 X COMPONENT"
"[INST]In the context of the C64, what is the function of register 11?[/INST]SPRITE 5 Y COMPONENT"
"[INST]In the context of the C64, what is the function of register 12?[/INST]SPRITE 6 X COMPONENT"
"[INST]In the context of the C64, what is the function of register 13?[/INST]SPRITE 6 Y COMPONENT"
"[INST]In the context of the C64, what is the function of register 14?[/INST]SPRITE 7 X COMPONENT"
"[INST]In the context of the C64, what is the function of register 15?[/INST]SPRITE 7 Y COMPONENT"
"[INST]In the context of the C64, what is the function of register 16?[/INST]MSB OF X COORDINATE"
"[INST]In the context of the C64, what is the function of register 17?[/INST]Y SCROLL MODE"
"[INST]In the context of the C64, what is the function of register 18?[/INST]RASTER CONTROL"
"[INST]In the context of the C64, what is the function of register 19?[/INST]LIGHT PEN X"
"[INST]In the context of the C64, what is the function of register 20?[/INST]LIGHT PEN Y"
"[INST]In the context of the C64, what is the function of register 21?[/INST]SPRITE ENABLE"
"[INST]In the context of the C64, what is the function of register 22?[/INST]X SCROLL MODE"
"[INST]In the context of the C64, what is the function of register 23?[/INST]SPRITE EXPAND Y"
"[INST]In the context of the C64, what is the function of register 24?[/INST]SCREEN AND CHARACTER MEMORY BASE ADDRESS"
"[INST]In the context of the C64, what is the function of register 25?[/INST]INTERRUPT REQUEST"
"[INST]In the context of the C64, what is the function of register 26?[/INST]IRQ MASKS"
"[INST]In the context of the C64, what is the function of register 27?[/INST]BACKGROUND-SPRITE PRIORITY"
"[INST]In the context of the C64, what is bit mapping in the context of Commodore 64 graphics?[/INST]Bit mapping is the method in which each possible dot (pixel) of resolution on the screen is assigned its own bit (location) in memory. If that memory bit is a one, the dot it is assigned to is on. If the bit is set to zero, the dot is off."
"[INST]In the context of the C64, what is the drawback of using high-resolution graphic design on Commodore 64?[/INST]High-resolution graphic design has a couple of drawbacks, one of which is that it takes lots of memory to bit map the entire screen, requiring one bit of memory for each pixel (or one byte for 8 pixels), resulting in 8000 bytes of memory needed to map the whole screen."
"[INST]In the context of the C64, how many pixels are on the Commodore 64 screen?[/INST]The resolution is 320 pixels (dots) by 200 pixels for the whole screen, giving you 64000 separate dots, each of which requires a bit in memory."
"[INST]In the context of the C64, why are high-resolution operations slow in BASIC?[/INST]High-resolution operations are made of many short, simple, repetitive routines, which are slow in BASIC, but exactly what machine language does best."
"[INST]In the context of the C64, how can you achieve high-resolution graphics in BASIC?[/INST]You can either write your programs entirely in machine language, or call machine language, high-resolution sub-routines from your BASIC program using the SYS command from BASIC, or use the VSP cartridge to add high-resolution commands to COMMODORE 64 BASIC."
"[INST]In the context of the C64, what is the advantage of using machine language for high-resolution graphics?[/INST]Machine language is ideal for high-resolution graphics because it can handle short, simple, repetitive routines quickly and efficiently, making it a better choice than BASIC for high-resolution operations."
"[INST]In the context of the C64, what is the purpose of the VSP cartridge?[/INST]The VSP cartridge is available to add high-resolution commands to COMMODORE 64 BASIC, allowing for easier development of high-resolution graphics in BASIC."
"[INST]In the context of the C64, how many characters are on each line of the Commodore 64 screen?[/INST]There are 25 characters in each line, with 40 lines on the screen."
"[INST]In the context of the C64, what is the resolution of the Commodore 64 screen in characters?[/INST]The resolution is 40 lines with 25 characters in each line."
"[INST]In the context of the C64, why are examples in this section given in BASIC?[/INST]The examples are given in BASIC to make them clear and easy to understand, even though machine language is often used for high-resolution graphics."
"[INST]In the context of the C64, what is the purpose of the GETIN function?[/INST]The purpose of the GETIN function is to get a character from the keyboard queue and return it as an ASCII value in the accumulator."
"[INST]In the context of the C64, what is the call address of the GETIN function?[/INST]The call address of the GETIN function is $FFE4 (hex) or 65508 (decimal)."
"[INST]In the context of the C64, what preparatory routines are required for the GETIN function?[/INST]The preparatory routines required for the GETIN function are CHKIN and OPEN."
"[INST]In the context of the C64, what happens if the keyboard queue is empty when calling the GETIN function?[/INST]If the keyboard queue is empty when calling the GETIN function, the value returned in the accumulator will be zero."
"[INST]In the context of the C64, how many characters can the keyboard buffer hold?[/INST]The keyboard buffer can hold up to ten characters."
"[INST]In the context of the C64, what happens to additional characters when the buffer is full?[/INST]When the buffer is full, additional characters are ignored until at least one character has been removed from the queue."
"[INST]In the context of the C64, how does the GETIN function handle RS-232 channels?[/INST]For RS-232 channels, the GETIN function only uses the A register and returns a single character, and the validity of the character should be checked using the READST routine."
"[INST]In the context of the C64, what is the purpose of the SCNKEY routine?[/INST]The SCNKEY routine is an interrupt-driven keyboard scan routine that automatically puts characters into the keyboard queue."
"[INST]In the context of the C64, how do you use the GETIN function in a program?[/INST]To use the GETIN function, you call it using a JSR instruction, check for a zero in the accumulator to check if the buffer is empty, and then process the data."
"[INST]In the context of the C64, what is the purpose of the BASIN routine?[/INST]The BASIN routine is used for channels such as serial, cassette, or screen, and is called instead of GETIN for these channels."
"[INST]In the context of the C64, what is sprite priority in the context of c64 graphics?[/INST]Sprite priority refers to the order in which sprites are displayed on the screen, with lower numbered sprites having priority over higher numbered sprites, meaning they will appear to move in front of or on top of sprites with lower priority."
"[INST]In the context of the C64, how do sprites with different priorities interact with each other on the screen?[/INST]When two sprites are in the same position, the sprite with higher priority will appear in front of the sprite with lower priority, potentially obscuring it or allowing it to show through from behind."
"[INST]In the context of the C64, what is the priority of sprite 0 compared to other sprites?[/INST]Sprite 0 has priority over all other sprites, meaning it will always appear in front of or on top of any other sprite."
"[INST]In the context of the C64, what happens when two sprites with different priorities overlap on the screen?[/INST]The sprite with higher priority will appear in front of the sprite with lower priority, potentially obscuring it or allowing it to show through from behind."
"[INST]In the context of the C64, how does the priority of sprite 7 compare to other sprites?[/INST]Sprite 7 has no priority in relation to the other sprites, meaning it will not necessarily appear in front of or behind any other sprite."
"[INST]In the context of the C64, what is the rule for determining sprite priority?[/INST]The rule is that lower numbered sprites have priority over higher numbered sprites, with sprite 0 having priority over all other sprites."
"[INST]In the context of the C64, can a sprite with lower priority appear in front of a sprite with higher priority?[/INST]No, a sprite with lower priority will always appear behind a sprite with higher priority, either being obscured or showing through from behind."
"[INST]In the context of the C64, what happens when sprite 1 and sprite 2 are in the same position on the screen?[/INST]Sprite 1 will appear in front of sprite 2, because sprite 1 has higher priority."
"[INST]In the context of the C64, how does the priority of sprites affect their display on the screen?[/INST]The priority of sprites determines the order in which they are displayed on the screen, with higher priority sprites appearing in front of lower priority sprites."
"[INST]In the context of the C64, in what order are sprites displayed on the screen based on their priority?[/INST]Sprites are displayed on the screen in order of their priority, with lower numbered sprites (higher priority) appearing in front of higher numbered sprites (lower priority)."
"[INST]In the context of the C64, What can you do with the X Index Register?[/INST]There are instructions for nearly all of the transformations you can make to the accumulator."
"[INST]In the context of the C64, What can you copy into the X register?[/INST]copy the contents of a memory location into the X register"
"[INST]In the context of the C64, What can you copy from the X register?[/INST]copy the contents of the X register into a memory location"
"[INST]In the context of the C64, What is the purpose of the CHKIN routine?[/INST]Open a channel for input"
"[INST]In the context of the C64, What is the call address of the CHKIN routine?[/INST]$FFC6 (hex) 65478 (decimal)"
"[INST]In the context of the C64, What registers are affected by the CHKIN routine?[/INST]A, X"
"[INST]In the context of the C64, What is the error return #3 for?[/INST]File not open"
"[INST]In the context of the C64, What is the error return #5 for?[/INST]Device not present"
"[INST]In the context of the C64, What is the error return #6 for?[/INST]File not an input file"
"[INST]In the context of the C64, What is the purpose of the OPEN routine in relation to the CHKIN routine?[/INST]To open a logical file"
"[INST]In the context of the C64, What is the purpose of loading the X register with the number of the logical file?[/INST]To specify the logical file to be used"
"[INST]In the context of the C64, What is the purpose of the JSR command in the CHKIN routine?[/INST]To call the CHKIN routine"
"[INST]In the context of the C64, What is the effect of using the CHKIN routine with a device on the serial bus?[/INST]It automatically sends the talk address and secondary address over the bus"
"[INST]In the context of the C64, What is the 'brain' of a microcomputer?[/INST]The central microprocessor is the 'brain' of a microcomputer."
"[INST]In the context of the C64, What is machine language?[/INST]Machine language is the ONLY programming language that your Commodore 64 understands."
"[INST]In the context of the C64, What is the native language of the machine?[/INST]Machine language is the NATIVE language of the machine."
"[INST]In the context of the C64, How does the Commodore 64 understand CBM BASIC instructions?[/INST]The Commodore 64 understands CBM BASIC instructions through an operating system."
"[INST]In the context of the C64, What is stored in a special type of memory?[/INST]A machine language program is stored in a special type of memory."
"[INST]In the context of the C64, What is the OPERATING SYSTEM of the Commodore 64?[/INST]The OPERATING SYSTEM of the Commodore 64 is a machine language program."
"[INST]In the context of the C64, What happens when the Commodore 64 is turned on?[/INST]The OPERATING SYSTEM (program) is automatically 'RUN' when the Commodore 64 is turned on."
"[INST]In the context of the C64, What is the purpose of the OPERATING SYSTEM?[/INST]The OPERATING SYSTEM is a machine language program that tells the Commodore 64 what to do when it's turned on."
"[INST]In the context of the C64, What is the difference between a program and the OPERATING SYSTEM?[/INST]A program can be changed or disappear when the Commodore 64 is turned off, unlike the OPERATING SYSTEM."
"[INST]In the context of the C64, What is PLA doing?[/INST]Pull accumulator"
"[INST]In the context of the C64, PLA operation is used in what addressing mode[/INST]Implied"
"[INST]In the context of the C64, What is the OP CODE for PLA operation[/INST]68"
"[INST]In the context of the C64, How many bytes does PLA operation use[/INST]1"
"[INST]In the context of the C64, How many cycles does PLA operation take[/INST]4"
"[INST]In the context of the C64, What is the purpose of PLA operation[/INST]Pull accumulator from stack"
"[INST]In the context of the C64, What is the assembly language form of PLA operation[/INST]PLA"
"[INST]In the context of the C64, What is the number of cycles PLA operation takes[/INST]4"
"[INST]In the context of the C64, What is the number of bytes PLA operation uses[/INST]1"
"[INST]In the context of the C64, What is the OP CODE for PLA operation in hexadecimal[/INST]0x44"
"[INST]In the context of the C64, What is the purpose of PLA operation in assembly language[/INST]Pull accumulator from stack"
"[INST]In the context of the C64, what is the operation of LDY instruction[/INST]Load index Y with memory"
"[INST]In the context of the C64, what is the addressing mode of LDY #Oper[/INST]Immediate"
"[INST]In the context of the C64, what is the assembly language form of LDY #Oper[/INST]LDY #Oper"
"[INST]In the context of the C64, what is the OP CODE of LDY #Oper[/INST]A0"
"[INST]In the context of the C64, how many bytes does LDY #Oper instruction occupy[/INST]2"
"[INST]In the context of the C64, how many cycles does LDY #Oper instruction take[/INST]2"
"[INST]In the context of the C64, what is the addressing mode of LDY Oper[/INST]Zero Page"
"[INST]In the context of the C64, what is the assembly language form of LDY Oper[/INST]LDY Oper"
"[INST]In the context of the C64, what is the OP CODE of LDY Oper[/INST]A4"
"[INST]In the context of the C64, how many bytes does LDY Oper instruction occupy[/INST]2"
"[INST]In the context of the C64, how many cycles does LDY Oper instruction take[/INST]3"
"[INST]In the context of the C64, what is the addressing mode of LDY Oper,X[/INST]Zero Page,X"
"[INST]In the context of the C64, what is the assembly language form of LDY Oper,X[/INST]LDY Oper,X"
"[INST]In the context of the C64, what is the OP CODE of LDY Oper,X[/INST]B4"
"[INST]In the context of the C64, how many bytes does LDY Oper,X instruction occupy[/INST]2"
"[INST]In the context of the C64, how many cycles does LDY Oper,X instruction take[/INST]4"
"[INST]In the context of the C64, what is the addressing mode of LDY Oper[/INST]Absolute"
"[INST]In the context of the C64, what is the assembly language form of LDY Oper[/INST]LDY Oper"
"[INST]In the context of the C64, what is the OP CODE of LDY Oper[/INST]AC"
"[INST]In the context of the C64, how many bytes does LDY Oper instruction occupy[/INST]3"
"[INST]In the context of the C64, how many cycles does LDY Oper instruction take[/INST]4"
"[INST]In the context of the C64, what is the addressing mode of LDY Oper,X[/INST]Absolute,X"
"[INST]In the context of the C64, what is the assembly language form of LDY Oper,X[/INST]LDY Oper,X"
"[INST]In the context of the C64, what is the OP CODE of LDY Oper,X[/INST]BC"
"[INST]In the context of the C64, how many bytes does LDY Oper,X instruction occupy[/INST]3"
"[INST]In the context of the C64, how many cycles does LDY Oper,X instruction take[/INST]4"
"[INST]In the context of the C64, Is there a specific register in the VIC-II chip control register where sprite to data collisions are detected?[/INST]The sprite to data collisions are detected in the sprite to data collision register at location 53279 ($D01F in HEX) of the VIC-II chip control register."
"[INST]In the context of the C64, What happens to the bits in the sprite to data collision register once they are read?[/INST]The bits in this register remain set until read (PEEKed). Once read, the register is automatically cleared."
"[INST]In the context of the C64, Is it a good idea to save the value in a variable until you are finished with it after reading the sprite to data collision register?[/INST]Yes, it is a good idea to save the value in a variable until you are finished with it."
"[INST]In the context of the C64, Is MULTI-COLOR data 01 considered transparent for collisions?[/INST]Yes, MULTI-COLOR data 01 is considered transparent for collisions, even though it shows up on the screen."
"[INST]In the context of the C64, What should you make in multi-color mode when setting up a background screen to avoid collisions?[/INST]Make everything that should not cause a collision 01 in multi-color mode."
"[INST]In the context of the C64, Can a sprite be involved in a collision if its bit in the sprite to data collision register is a 0?[/INST]No, if that bit is a 0, then that sprite is not involved in a collision."
"[INST]In the context of the C64, Is it possible for a sprite to be involved in a collision even if it shows up on the screen?[/INST]Yes, a sprite can be involved in a collision even if it shows up on the screen."
"[INST]In the context of the C64, What happens to the sprite to data collision register after it is read?[/INST]The register is automatically cleared after it is read."
"[INST]In the context of the C64, Is it necessary to read the sprite to data collision register to clear it?[/INST]No, the register is automatically cleared after it is read."
"[INST]In the context of the C64, Can a sprite be involved in a collision if its bit in the sprite to data collision register is a 1?[/INST]Yes, if that bit is a 1, then that sprite is involved in a collision."
"[INST]In the context of the C64, What character sets are available on the Commodore 64?[/INST]The Commodore 64 has two complete character sets that you can use either from the keyboard or in your programs."
"[INST]In the context of the C64, What happens when you hold down the <SHIFT> key while typing?[/INST]Holding down the <SHIFT> key while typing any character that doesn't have graphic symbols on the front of the key gives you the symbol on the top most part of the key."
"[INST]In the context of the C64, What is the purpose of the <C=> key?[/INST]The graphic symbols on the LEFT side of the front of the keys are displayed by pressing the <C=> key, while the symbols on the top most part of any key without graphics characters are selected when you hold down the <SHIFT> key while typing."
"[INST]In the context of the C64, What happens when you hold down the <C=> key while typing?[/INST]The graphic symbols on the LEFT side of the front of the keys are displayed by pressing the <C=> key, while the symbols on the top most part of any key without graphics characters are selected when you hold down the <SHIFT> key while typing."
"[INST]In the context of the C64, What is the effect of holding down the <SHIFT> key while typing any character?[/INST]Holding down the <SHIFT> key while typing any character that doesn't have graphic symbols on the front of the key gives you the symbol on the top most part of the key."
"[INST]In the context of the C64, What are the available characters in SET 1?[/INST]The upper case alphabet and the numbers 0-9 are available without pressing the <SHIFT> key."
"[INST]In the context of the C64, What are the available characters in SET 2?[/INST]The lower case alphabet and the numbers 0-9 are available without pressing the <SHIFT> key."
"[INST]In the context of the C64, How do you switch from one character set to the other?[/INST]To switch from one character set to the other press the <C=> and the <SHIFT> keys together."
"[INST]In the context of the C64, What happens when you hold down the <SHIFT> key while typing an uppercase letter?[/INST]The upper case alphabet is available when you hold down the <SHIFT> key while typing."
"[INST]In the context of the C64, What happens when you hold down the <C=> key while typing a lowercase letter?[/INST]The lower case alphabet is available without pressing the <SHIFT> key."
"[INST]In the context of the C64, Set the top of RAM?[/INST]This routine is used to set the top of RAM."
"[INST]In the context of the C64, What is the call address of MEMTOP?[/INST]$FF99 (hex) 65433 (decimal)"
"[INST]In the context of the C64, What registers are affected by MEMTOP?[/INST]X, Y"
"[INST]In the context of the C64, What is the purpose of MEMTOP?[/INST]Set the top of RAM"
"[INST]In the context of the C64, What happens when MEMTOP is called with the accumulator carry bit set?[/INST]the pointer to the top of RAM will be loaded into the X and Y registers"
"[INST]In the context of the C64, What happens when MEMTOP is called with the accumulator carry bit clear?[/INST]the contents of the X and Y registers are loaded in the top of memory pointer, changing the top of memory"
"[INST]In the context of the C64, What is the stack requirement for MEMTOP?[/INST]2"
"[INST]In the context of the C64, What are the communication registers for MEMTOP?[/INST]X, Y"
"[INST]In the context of the C64, What is the preparatory routine for MEMTOP?[/INST]nan"
"[INST]In the context of the C64, What are the error returns for MEMTOP?[/INST]nan"
"[INST]In the context of the C64, GetIN function purpose[/INST]Get a character"
"[INST]In the context of the C64, GetIN call address[/INST]$FFE4 (hex) 65508 (decimal)"
"[INST]In the context of the C64, Registers affected by GetIN[/INST]A (X, Y)"
"[INST]In the context of the C64, Preparatory routines for GetIN[/INST]CHKIN, OPEN"
"[INST]In the context of the C64, Error returns for GetIN[/INST]See READST"
"[INST]In the context of the C64, Stack requirements for GetIN[/INST]7+"
"[INST]In the context of the C64, Description of GetIN[/INST]Removes one character from the keyboard queue and returns it as an ASCII value"
"[INST]In the context of the C64, Characters in the keyboard buffer[/INST]Up to ten"
"[INST]In the context of the C64, Channel types supported by GetIN[/INST]Keyboard, RS-232, serial, cassette, screen"
"[INST]In the context of the C64, Routine to call for serial, cassette, or screen channels[/INST]BASIN"
"[INST]In the context of the C64, What is the purpose of the CLRCHN routine?[/INST]Clear I/O channels"
"[INST]In the context of the C64, What is the call address of the CLRCHN routine?[/INST]$FFCC (hex) 65484 (decimal)"
"[INST]In the context of the C64, What registers are affected by the CLRCHN routine?[/INST]A, X"
"[INST]In the context of the C64, What is the default input device?[/INST]0 (keyboard)"
"[INST]In the context of the C64, What is the default output device?[/INST]3 (the Commodore 64 screen)"
"[INST]In the context of the C64, What signal is sent to clear the input channel on the serial port?[/INST]UNTALK"
"[INST]In the context of the C64, What signal is sent to clear the output channel on the serial port?[/INST]UNLISTEN"
"[INST]In the context of the C64, What is the effect of not calling the CLRCHN routine?[/INST]Several devices can receive the same data from the Commodore 64 at the same time"
"[INST]In the context of the C64, What is the KERNAL CLALL routine?[/INST]A routine that automatically calls the CLRCHN routine"
"[INST]In the context of the C64, How to use the CLRCHN routine?[/INST]Call it using the JSR instruction"
"[INST]In the context of the C64, Set bottom of memory[/INST]This routine is used to set the bottom of the memory."
"[INST]In the context of the C64, What is the purpose of MEMBOT routine[/INST]This routine is used to set the bottom of the memory."
"[INST]In the context of the C64, What is the call address of MEMBOT routine[/INST]$FF9C (hex) 65436 (decimal)"
"[INST]In the context of the C64, What registers are affected by MEMBOT routine[/INST]Registers affected: X, Y"
"[INST]In the context of the C64, What is the initial value of the pointer to the lowest byte of RAM on the unexpanded Commodore 64[/INST]$0800 (2048 in decimal)"
"[INST]In the context of the C64, What happens when the accumulator carry bit is set when calling MEMBOT routine[/INST]a pointer to the lowest byte of RAM is returned in the X and Y registers"
"[INST]In the context of the C64, What happens when the accumulator carry bit is clear when calling MEMBOT routine[/INST]the values of the X and Y registers are transferred to the low and high bytes, respectively, of the pointer to the beginning of RAM"
"[INST]In the context of the C64, How to read the bottom of RAM[/INST]TO READ THE BOTTOM OF RAM 1) Set the carry. 2) Call this routine."
"[INST]In the context of the C64, How to set the bottom of memory[/INST]TO SET THE BOTTOM OF MEMORY 1) Clear the carry. 2) Call this routine."
"[INST]In the context of the C64, What is the example of moving the bottom of memory up 1 page[/INST];MOVE BOTTOM OF MEMORY UP 1 PAGE SEC ;READ MEMORY BOTTOM JSR MEMBOT INY CLC ;SET MEMORY BOTTOM TO NEW VALUE JSR MEMBOT"
"[INST]In the context of the C64, Positioning in the horizontal direction is more complicated because?[/INST]There are more than 256 positions, which is more than a byte."
"[INST]In the context of the C64, What is the maximum number of possible positions in the left/right direction?[/INST]512 possible positions."
"[INST]In the context of the C64, For a sprite,What is the range of visible positions on the screen?[/INST]Between 24 and 343."
"[INST]In the context of the C64, What happens if the X position of a sprite is greater than 255?[/INST]The bit in the X MOST SIGNIFICANT BIT POSITION register must be set to a 1."
"[INST]In the context of the C64, What happens if the X position of a sprite is less than 256?[/INST]The X MSB of that sprite must be 0."
"[INST]In the context of the C64, What do bits 0 to 7 of the X MSB register correspond to?[/INST]Sprites 0 to 7."
"[INST]In the context of the C64, What is the purpose of the X MSB register?[/INST]To control the X position of a sprite."
"[INST]In the context of the C64, What is the range of sprite positions?[/INST]From 0 to 511."
"[INST]In the context of the C64, What is the significance of the 9th bit?[/INST]It is used to control the X position."
"[INST]In the context of the C64, Sprite to sprite collisions are recognized by the computer in which register?[/INST]in the sprite to sprite collision register at location 53278 ($D01E in HEX)"
"[INST]In the context of the C64, Is the bit in the register set to 1 if a sprite is involved in a collision?[/INST]yes"
"[INST]In the context of the C64, What happens to the bits in the register once they are read?[/INST]they are automatically cleared"
"[INST]In the context of the C64, Why is it a good idea to save the value in a variable until you are finished with it?[/INST]because the register is automatically cleared once read"
"[INST]In the context of the C64, Can collisions take place even when the sprites are off screen?[/INST]yes"
"[INST]In the context of the C64, What is the purpose of the sprite to sprite collision register?[/INST]to recognize sprite to sprite collisions"
"[INST]In the context of the C64, Is the sprite to sprite collision register automatically cleared after being read?[/INST]yes"
"[INST]In the context of the C64, What happens to the bits in the register if they are not read?[/INST]they remain set"
"[INST]In the context of the C64, Can a sprite be involved in a collision even if it is off screen?[/INST]yes"
"[INST]In the context of the C64, What is the location of the sprite to sprite collision register in the VIC-II chip control register?[/INST]53278 ($D01E in HEX)"
"[INST]In the context of the C64, Is it necessary to read the sprite to sprite collision register to clear it?[/INST]no"
"[INST]In the context of the C64, how do i change the color of characters on a commodore 64[/INST]by using the <C=> key and the COLOR keys, characters can be changed to any color, including multi-color characters, for example, by typing the command POKE 53270,PEEK(53270)OR 16:PRINT'<CTRL+3>';, the word READY and anything else you type will be displayed in multi-color mode"
"[INST]In the context of the C64, what is the purpose of the POKE command in the given code snippet[/INST]the POKE command is used to modify the memory location 53270, which controls the text color, by performing a bitwise OR operation with the current value of that location and the decimal value 16, effectively setting the high-color bit, and thus enabling multi-color mode"
"[INST]In the context of the C64, what is the function of the PEEK command in the given code snippet[/INST]the PEEK command is used to read the current value of the memory location 53270, which stores the current text color, and returns its value, which is then used in the POKE command to modify it"
"[INST]In the context of the C64, what is the effect of the OR 16 operation in the given code snippet[/INST]the OR 16 operation performs a bitwise OR operation on the current value of the memory location 53270, setting the high-color bit, which enables multi-color mode, allowing characters to be displayed in multiple colors"
"[INST]In the context of the C64, what is the purpose of the PRINT '<CTRL+3>' statement[/INST]the PRINT '<CTRL+3>' statement is used to print the control code for red color, which is represented by the ASCII code 3, and is used to set the text color to red"
"[INST]In the context of the C64, how do i set the text color back to regular text[/INST]another color control can be used to set the text color back to regular text, which can be done by using a different POKE command or by using a different control code"
"[INST]In the context of the C64, what is the memory location that controls the text color on a commodore 64[/INST]the memory location that controls the text color on a commodore 64 is 53270"
"[INST]In the context of the C64, what is the decimal value that enables multi-color mode[/INST]the decimal value that enables multi-color mode is 16, which is used in the POKE command to set the high-color bit"
"[INST]In the context of the C64, what is the result of typing the command POKE 53270,PEEK(53270)OR 16:PRINT'<CTRL+3>';[/INST]the result of typing the command POKE 53270,PEEK(53270)OR 16:PRINT'<CTRL+3>'; is that the word READY and anything else you type will be displayed in multi-color mode"
"[INST]In the context of the C64, what is the purpose of the :REM statement in the given code snippet[/INST]the :REM statement is a remark statement, which is used to add a comment to the code, in this case, indicating that the code sets the text color to light red/multi-color red"
"[INST]In the context of the C64, What is the first mode of BASIC operation?[/INST]DIRECT Mode"
"[INST]In the context of the C64, What happens when you press the <RETURN> key in DIRECT mode?[/INST]BASIC statements are executed"
"[INST]In the context of the C64, What is the second mode of BASIC operation?[/INST]PROGRAM Mode"
"[INST]In the context of the C64, What is required for BASIC statements in PROGRAM mode?[/INST]line numbers in front of the statement"
"[INST]In the context of the C64, What is the limit on the number of characters on a logical screen line?[/INST]80 characters"
"[INST]In the context of the C64, What happens if you go over the 80 character limit?[/INST]you have to put the entire BASIC statement on a new line"
"[INST]In the context of the C64, What should you do before starting a new program?[/INST]type NEW and hit <RETURN>"
"[INST]In the context of the C64, What is important to remember when starting a new program?[/INST]to type NEW and hit <RETURN>"
"[INST]In the context of the C64, What is the purpose of the PROGRAM mode?[/INST]to run programs"
"[INST]In the context of the C64, What is the main difference between DIRECT and PROGRAM mode?[/INST]line numbers are required in PROGRAM mode"
"[INST]In the context of the C64, what is LSR doing?[/INST]LSR Shift right one bit (memory or accumulator)"
"[INST]In the context of the C64, What is the operation of PLP[/INST]PLP Pull processor status from stack"
"[INST]In the context of the C64, What is the addressing mode of PLP[/INST]Implied"
"[INST]In the context of the C64, What is the assembly language form of PLP[/INST]Assembly Language Form"
"[INST]In the context of the C64, What is the OP CODE of PLP[/INST]PLP"
"[INST]In the context of the C64, What is the number of bytes of PLP[/INST]1"
"[INST]In the context of the C64, What is the number of cycles of PLP[/INST]4"
"[INST]In the context of the C64, What is the purpose of PLP[/INST]Pull processor status from stack"
"[INST]In the context of the C64, What is the status pulled by PLP[/INST]processor status"
"[INST]In the context of the C64, What is the stack used for in PLP[/INST]From Stack"
"[INST]In the context of the C64, What is the operation of PLA[/INST]PLA"
"[INST]In the context of the C64, What is the purpose of the CHKOUT routine?[/INST]Open a channel for output"
"[INST]In the context of the C64, What is the call address of the CHKOUT routine?[/INST]$FFC9 (hex) 65481 (decimal)"
"[INST]In the context of the C64, What communication registers are affected by the CHKOUT routine?[/INST]X"
"[INST]In the context of the C64, What is the preparatory routine for the CHKOUT routine?[/INST](OPEN)"
"[INST]In the context of the C64, What are the possible error returns for the CHKOUT routine?[/INST]0,3,5,7 (See READST)"
"[INST]In the context of the C64, What is the minimum stack requirement for the CHKOUT routine?[/INST]4+"
"[INST]In the context of the C64, What registers are affected by the CHKOUT routine?[/INST]A, X"
"[INST]In the context of the C64, What is the purpose of calling the CHKOUT routine before sending data to an output device?[/INST]To open a channel for output"
"[INST]In the context of the C64, What happens if the device intended to be opened is not an output device?[/INST]An error will occur and the routine will be aborted"
"[INST]In the context of the C64, What is the purpose of the LISTEN address specified by the OPEN routine?[/INST]To automatically send the LISTEN address to the device on the serial bus"
"[INST]In the context of the C64, What is the main function of the OPERATING SYSTEM?[/INST]organizing all the memory in your machine for various tasks"
"[INST]In the context of the C64, What happens when you turn on your Commodore 64?[/INST]the OPERATING SYSTEM takes control of your machine"
"[INST]In the context of the C64, What does the OPERATING SYSTEM say after it finishes its housework?[/INST]READY"
"[INST]In the context of the C64, What can you do with the contents of the Y Index Register?[/INST]copy the contents of the Y register into a memory location"
"[INST]In the context of the C64, What is the purpose of the instructions for the Y Index Register?[/INST]There are instructions for nearly all of the transformations you can make to the accumulator, and the X register"
"[INST]In the context of the C64, What can you do with the Y Index Register and the X register?[/INST]There are instructions for nearly all of the transformations you can make"
"[INST]In the context of the C64, what is the purpose of the STOP function?[/INST]The purpose of the STOP function is to check if the STOP key is pressed, and it returns the Z flag set if the key was pressed during a UDTIM call, and resets the channels to default values, leaving other flags unchanged."
"[INST]In the context of the C64, What is the call address of the STOP function?[/INST]The call address of the STOP function is $FFE1 in hexadecimal, which is equivalent to 65505 in decimal."
"[INST]In the context of the C64, What registers are affected by the STOP function?[/INST]The STOP function affects two registers: A and X."
"[INST]In the context of the C64, What is the preparatory routine required for the STOP function?[/INST]There are no preparatory routines required for the STOP function."
"[INST]In the context of the C64, What is the error return of the STOP function?[/INST]There are no error returns for the STOP function."
"[INST]In the context of the C64, How do you use the STOP function?[/INST]To use the STOP function, you need to call UDTIM before calling STOP, then test for the zero flag to determine if the STOP key was pressed."
"[INST]In the context of the C64, What happens if the STOP key is not pressed?[/INST]If the STOP key is not pressed, the accumulator will contain a byte representing the lost row of the keyboard scan, allowing the user to check for certain other keys."
"[INST]In the context of the C64, What is the significance of the Z flag in the STOP function?[/INST]The Z flag is set if the STOP key was pressed during a UDTIM call, indicating that the STOP key was pressed."
"[INST]In the context of the C64, What is the relationship between the STOP function and the UDTIM function?[/INST]The STOP function should be called after UDTIM, as UDTIM scans for the STOP key and the STOP function checks if the key was pressed."
"[INST]In the context of the C64, How can you check if the STOP key was pressed using the STOP function?[/INST]You can check if the STOP key was pressed by testing for the zero flag after calling the STOP function, and if the flag is set, it means the STOP key was pressed."
"[INST]In the context of the C64, what is the purpose of the screen editor on the commodore 64?[/INST]The SCREEN EDITOR on the Commodore 64 allows users to move the cursor, delete, insert, and perform other editing functions, making it a convenient built-in feature of the operating system."
"[INST]In the context of the C64, what happens when a cbm basic command is executed?[/INST]When a CBM BASIC command is executed, a huge machine language program built into the Commodore 64, known as the BASIC INTERPRETER, runs the appropriate piece of machine language code, interpreting each command one by one."
"[INST]In the context of the C64, what is the role of the basic interpreter in the commodore 64?[/INST]The BASIC INTERPRETER is a huge machine language program that runs the appropriate piece of machine language code for each CBM BASIC command, interpreting each command one by one, unless it encounters a command it does not understand, resulting in a ?SYNTAX ERROR message."
"[INST]In the context of the C64, what is the result of the basic interpreter encountering an unknown command?[/INST]When the BASIC INTERPRETER encounters a command it does not understand, it displays the familiar ?SYNTAX ERROR message, indicating that the command is invalid or unrecognized."
"[INST]In the context of the C64, what is the relationship between cbm basic and the operating system on the commodore 64?[/INST]CBM BASIC is an integral part of the operating system on the Commodore 64, with all available commands recognized and executed by a huge machine language program built into the computer."
"[INST]In the context of the C64, what is the function of the operating system on the commodore 64?[/INST]The operating system on the Commodore 64 allows users to type on the keyboard and use the built-in SCREEN EDITOR, providing a convenient and user-friendly interface for interacting with the computer."
"[INST]In the context of the C64, how does the commodore 64 execute cbm basic commands?[/INST]The Commodore 64 executes CBM BASIC commands by using a huge machine language program, known as the BASIC INTERPRETER, which runs the appropriate piece of machine language code for each command."
"[INST]In the context of the C64, what is the purpose of the built-in machine language program on the commodore 64?[/INST]The built-in machine language program on the Commodore 64, known as the BASIC INTERPRETER, is responsible for executing CBM BASIC commands, providing a seamless and efficient way to interact with the computer."
"[INST]In the context of the C64, what is the significance of the ?syntax error message on the commodore 64?[/INST]The ?SYNTAX ERROR message on the Commodore 64 indicates that the BASIC INTERPRETER has encountered a command it does not understand, highlighting an error in the user's input or syntax."
"[INST]In the context of the C64, what is the relationship between the screen editor and the operating system on the commodore 64?[/INST]The SCREEN EDITOR is an integral part of the operating system on the Commodore 64, providing a convenient and user-friendly way to interact with the computer, and allowing users to move the cursor, delete, insert, and perform other editing functions."
"[INST]In the context of the C64, what is the purpose of the stack in the 6510 microprocessor[/INST]The stack is used by both the programmer and the microprocessor to temporarily remember things, and to remember, for example, an order of events."
"[INST]In the context of the C64, what happens when a GOSUB statement is encountered by the BASIC interpreter[/INST]The BASIC interpreter pushes its current position onto the stack before going to do the subroutine, and when a RETURN is executed, the interpreter pulls off the stack the information that tells it where it was before the subroutine call was made."
"[INST]In the context of the C64, in which memory page is the stack located[/INST]The stack is located in page one of memory."
"[INST]In the context of the C64, how long is the stack in bytes[/INST]The stack is 256 bytes long."
"[INST]In the context of the C64, in which direction is the stack organized in memory[/INST]The stack is organized backwards in memory."
"[INST]In the context of the C64, what is the function of the stack pointer[/INST]The stack pointer always points to the next available location in the stack."
"[INST]In the context of the C64, what happens to the stack pointer when something is pushed onto the stack[/INST]When something is pushed onto the stack, it is placed where the stack pointer points to, and the stack pointer is moved down to the next position (decremented)."
"[INST]In the context of the C64, what happens to the stack pointer when something is pulled off the stack[/INST]When something is pulled off the stack, the stack pointer is incremented, and the byte pointed to by the stack pointer is placed into the specified register."
"[INST]In the context of the C64, what is the implied mode in the context of instructions[/INST]The implied mode means that information is implied by an instruction itself, referring to what registers, flags, and memory the instruction is referring to."
"[INST]In the context of the C64, what is the function of the PHA instruction[/INST]The PHA instruction pushes the contents of the accumulator onto the stack."
"[INST]In the context of the C64, what is the function of the PLA instruction[/INST]The PLA instruction pulls a value off the stack and into the accumulator."
"[INST]In the context of the C64, what is the function of the PHP instruction[/INST]The PHP instruction pushes the status register onto the stack."
"[INST]In the context of the C64, what is the function of the PLP instruction[/INST]The PLP instruction pulls the status register from the stack."
"[INST]In the context of the C64, what is the starting address of the stack[/INST]The stack starts at address $01 00."
"[INST]In the context of the C64, what is the ending address of the stack[/INST]The stack ends at address $01 FF."
"[INST]In the context of the C64, what is the location of the first position in the stack[/INST]The first position in the stack is at $01 FF."
"[INST]In the context of the C64, what is the location of the last position in the stack[/INST]The last position in the stack is at $0100."
"[INST]In the context of the C64, what is the purpose of the RETURN statement in BASIC[/INST]The RETURN statement is used to return to the point in the program where the GOSUB statement was called."
"[INST]In the context of the C64, what is the purpose of the GOSUB statement in BASIC[/INST]The GOSUB statement is used to call a subroutine."
"[INST]In the context of the C64, what is the relationship between the stack and the stack pointer[/INST]The stack pointer always points to the next available location in the stack."
"[INST]In the context of the C64, what is the effect of pushing something onto the stack[/INST]When something is pushed onto the stack, the stack pointer is decremented."
"[INST]In the context of the C64, what is the effect of pulling something off the stack[/INST]When something is pulled off the stack, the stack pointer is incremented."
"[INST]In the context of the C64, what is the opcode for the SEI instruction?[/INST]The opcode for the SEI instruction is 78, which is used to set the interrupt disable status."
"[INST]In the context of the C64, what is the addressing mode for the SEI instruction?[/INST]The addressing mode for the SEI instruction is implied, which means that it does not require any additional memory addresses to be specified."
"[INST]In the context of the C64, how many bytes does the SEI instruction occupy in memory?[/INST]The SEI instruction occupies 1 byte in memory, making it a compact and efficient instruction."
"[INST]In the context of the C64, how many cycles does the SEI instruction take to execute?[/INST]The SEI instruction takes 2 cycles to execute, which is relatively fast compared to other instructions."
"[INST]In the context of the C64, what is the purpose of the SEI instruction?[/INST]The purpose of the SEI instruction is to set the interrupt disable status, which prevents interrupts from occurring during critical sections of code."
"[INST]In the context of the C64, can the SEI instruction be used in conjunction with other instructions?[/INST]Yes, the SEI instruction can be used in conjunction with other instructions to create complex logic and control flows in a program."
"[INST]In the context of the C64, in what situations would you use the SEI instruction?[/INST]You would use the SEI instruction in situations where you need to temporarily disable interrupts, such as during critical sections of code or when accessing shared resources."
"[INST]In the context of the C64, how does the SEI instruction affect the processor's interrupt handling?[/INST]The SEI instruction sets the interrupt disable status, which prevents the processor from responding to interrupts until the CLI instruction is executed."
"[INST]In the context of the C64, what is the relationship between the SEI and CLI instructions?[/INST]The SEI instruction sets the interrupt disable status, while the CLI instruction clears it, allowing interrupts to be processed again."
"[INST]In the context of the C64, is the SEI instruction commonly used in C64 programming?[/INST]Yes, the SEI instruction is commonly used in C64 programming to temporarily disable interrupts during critical sections of code or when accessing shared resources."
"[INST]In the context of the C64, what is the purpose of the $00A7 memory location in the RS-232 system interface?[/INST]The $00A7 memory location, also known as INBIT, is used as a temporary storage for the receiver input bit in the RS-232 system interface. This location plays a crucial role in the receiver's functionality, allowing for the efficient processing of incoming data."
"[INST]In the context of the C64, what is the function of the BITCI memory location in the RS-232 system interface?[/INST]The $00A8 memory location, also referred to as BITCI, is responsible for storing the receiver bit count in the RS-232 system interface. This location is essential for tracking the number of bits received, ensuring that data is processed correctly."
"[INST]In the context of the C64, what is the purpose of the RINONE memory location in the RS-232 system interface?[/INST]The $00A9 memory location, also known as RINONE, serves as a flag to check for the start bit in the receiver's functionality of the RS-232 system interface. This location is critical for detecting the start of incoming data transmission."
"[INST]In the context of the C64, what is the function of the RIDATA memory location in the RS-232 system interface?[/INST]The $00AA memory location, also referred to as RIDATA, acts as a receiver byte buffer and assembly location in the RS-232 system interface. This location is responsible for temporarily storing received data, allowing for efficient processing and assembly of incoming bytes."
"[INST]In the context of the C64, what is the purpose of the RIPRTY memory location in the RS-232 system interface?[/INST]The $00AB memory location, also known as RIPRTY, is used to store the receiver parity bit in the RS-232 system interface. This location is essential for error detection and correction in data transmission."
"[INST]In the context of the C64, what is the function of the BITTS memory location in the RS-232 system interface?[/INST]The $00B4 memory location, also referred to as BITTS, is responsible for storing the transmitter bit count out in the RS-232 system interface. This location is critical for tracking the number of bits transmitted, ensuring that data is sent correctly."
"[INST]In the context of the C64, what is the purpose of the NXTBIT memory location in the RS-232 system interface?[/INST]The $00B5 memory location, also known as NXTBIT, is used to store the transmitter's next bit to be sent in the RS-232 system interface. This location is essential for efficient data transmission, allowing the transmitter to prepare the next bit for sending."
"[INST]In the context of the C64, what is the function of the RODATA memory location in the RS-232 system interface?[/INST]The $00B6 memory location, also referred to as RODATA, acts as a transmitter byte buffer and disassembly location in the RS-232 system interface. This location is responsible for temporarily storing data to be transmitted, allowing for efficient disassembly and transmission of outgoing bytes."
"[INST]In the context of the C64, why can't the zero-page memory locations be used directly by the BASIC or KERNAL level programmer for RS-232 type operations?[/INST]The zero-page memory locations, although used internally by the RS-232 system interface, are not intended for direct use by the BASIC or KERNAL level programmer. Instead, the system RS-232 routines must be used to ensure proper and safe operation of the RS-232 interface."
"[INST]In the context of the C64, what is the importance of using the system RS-232 routines in the RS-232 system interface?[/INST]Using the system RS-232 routines is crucial in the RS-232 system interface, as they provide a safe and controlled way to interact with the RS-232 interface. This ensures that data transmission and reception are handled correctly, preventing potential errors and data corruption."
"[INST]In the context of the C64, What is the purpose of the light pen input?[/INST]The light pen input latches the current screen position into a pair of registers."
"[INST]In the context of the C64, What are the two registers that store the screen position?[/INST]The two registers are LPX and LPY."
"[INST]In the context of the C64, How many bits does the X position register contain?[/INST]The X position register contains 9 bits."
"[INST]In the context of the C64, What is the resolution of the X position?[/INST]The resolution of the X position is 2 horizontal dots."
"[INST]In the context of the C64, What is the purpose of the 8 MSB of the X position?[/INST]The 8 MSB of the X position define the X position at the time of transition."
"[INST]In the context of the C64, What is the purpose of the Y position register?[/INST]The Y position register latches in its register 20 ($14)."
"[INST]In the context of the C64, What is the resolution of the Y position?[/INST]The resolution of the Y position is single raster resolution within the visible display."
"[INST]In the context of the C64, How many times can the light pen latch be triggered in a frame?[/INST]The light pen latch can only be triggered once per frame."
"[INST]In the context of the C64, Why is it important to take several samples before turning the pen to the screen?[/INST]It is important to take several samples because subsequent triggers within the same frame will have no effect."
"[INST]In the context of the C64, What is the minimum number of samples required before turning the pen to the screen?[/INST]The minimum number of samples required is 3 or more."
"[INST]In the context of the C64, Can cassette tapes store a large amount of data?[/INST]Yes, the longer the tape, the more information it can store."
"[INST]In the context of the C64, What is the limitation of cassette tapes?[/INST]Tapes are limited in time, the more data on the tape, the longer the time it takes to find the information."
"[INST]In the context of the C64, What is the common practice when working with tape storage?[/INST]Reading the entire cassette data file into RAM, then processing it, and then re-writing all the data on the tape."
"[INST]In the context of the C64, Why is it necessary to minimize the time factor when working with tape storage?[/INST]Because the more data on the tape, the longer the time it takes to find the information."
"[INST]In the context of the C64, What is the advantage of using floppy disks over cassette tapes?[/INST]Floppy disks can read data at any position on the disk, without needing to read through all the other data."
"[INST]In the context of the C64, Why are floppy disks used for business applications?[/INST]Because they can write data over old data without disturbing the rest of the file."
"[INST]In the context of the C64, What is the difference between the PRINT and PRINT# statements?[/INST]The PRINT statement formats data for the screen, while the PRINT# statement formats data for cassette tapes."
"[INST]In the context of the C64, Why is formatting important when working with cassette tapes?[/INST]Because the formatting must be done with the INPUT# statement in mind, and the wrong formatting can waste space on the tape."
"[INST]In the context of the C64, What happens when the INPUT# statement tries to read strings without separators?[/INST]The statement will discover no data for the variables, and the first variable will contain all the variables, plus the spaces between them."
"[INST]In the context of the C64, What is the problem with using commas as separators in cassette tapes?[/INST]Commas are not recognized as separators on the tape, and the data items are not separated."
"[INST]In the context of the C64, Why is it important to use a proper separator in cassette tapes?[/INST]Because a proper separator is necessary to separate the data items, and without it, the data items are not separated."
"[INST]In the context of the C64, What is the purpose of the RETURN code in cassette tapes?[/INST]The RETURN code is used to mark the end of a line, and it is automatically put at the end of a PRINT or PRINT# statement."
"[INST]In the context of the C64, Why is it important to use a proper tape file format?[/INST]Because a proper tape file format is necessary to ensure that the data is stored correctly and can be read correctly."
"[INST]In the context of the C64, What is the difference between the GET# and INPUT# statements?[/INST]The GET# statement reads data from the tape one character at a time, while the INPUT# statement reads data from the tape as a string."
"[INST]In the context of the C64, Why is it important to use the CHR$(0) code when reading data from cassette tapes?[/INST]Because the CHR$(0) code is received as an empty string, and using it helps to avoid error messages."
"[INST]In the context of the C64, What is the purpose of the line GET# 1, A$: A= ASC(A$) in programs?[/INST]The line is used to examine tape data, but it can cause error messages if the tape data is empty."
"[INST]In the context of the C64, Why is it important to modify the line GET# 1, A$: A= ASC(A$) to GET#1, A$: A=ASC(A$+CHR$(0))?[/INST]Because the modification helps to avoid error messages by adding the CHR$(0) code to the end of the string."
"[INST]In the context of the C64, what is the primary function of the VIC-II chip in regards to collision detection[/INST]The VIC-II chip is capable of detecting collisions between sprites, as well as between sprites and background data, which is a unique and powerful feature that allows for more complex and interactive graphics in Commodore 64 games and applications."
"[INST]In the context of the C64, what triggers a collision detection in the VIC-II chip[/INST]A collision is triggered when a non-zero part of a sprite overlaps a non-zero portion of another sprite or characters on the screen, allowing the programmer to respond to these events and create more dynamic and engaging gameplay experiences."
"[INST]In the context of the C64, can sprites collide with background data on the Commodore 64[/INST]Yes, the VIC-II chip is capable of detecting collisions between sprites and background data, which allows for more complex and interactive graphics and gameplay mechanics."
"[INST]In the context of the C64, what is required for a collision to occur between two sprites[/INST]A collision occurs when a non-zero part of one sprite overlaps a non-zero portion of another sprite, allowing the programmer to detect and respond to these events in their code."
"[INST]In the context of the C64, can the VIC-II chip detect collisions between multiple sprites[/INST]Yes, the VIC-II chip can detect collisions between multiple sprites, allowing for more complex and dynamic gameplay mechanics and graphics."
"[INST]In the context of the C64, what is the significance of non-zero parts of sprites in collision detection[/INST]The non-zero parts of sprites are the areas that are visible on the screen, and it is these areas that are used to detect collisions with other sprites or background data, allowing the programmer to create more realistic and interactive gameplay experiences."
"[INST]In the context of the C64, how does the VIC-II chip handle collisions between sprites and background data[/INST]The VIC-II chip can detect collisions between sprites and background data, allowing the programmer to respond to these events and create more dynamic and interactive gameplay mechanics."
"[INST]In the context of the C64, what is the benefit of using collision detection in Commodore 64 games[/INST]The use of collision detection in Commodore 64 games allows for more realistic and interactive gameplay experiences, and enables the creation of more complex and engaging gameplay mechanics."
"[INST]In the context of the C64, can the VIC-II chip detect collisions between sprites and characters on the screen[/INST]Yes, the VIC-II chip can detect collisions between sprites and characters on the screen, allowing the programmer to respond to these events and create more dynamic and interactive gameplay experiences."
"[INST]In the context of the C64, what is the role of the VIC-II chip in detecting collisions between sprites[/INST]The VIC-II chip plays a crucial role in detecting collisions between sprites, allowing the programmer to respond to these events and create more dynamic and interactive gameplay mechanics and graphics."
"[INST]In the context of the C64, Are zero-page memory locations used locally?[/INST]Yes, they are used locally and are only given as a guide to understand the associated routines."
"[INST]In the context of the C64, What is the purpose of the zero-page locations?[/INST]They are used to understand the associated routines."
"[INST]In the context of the C64, Can the zero-page locations be used directly by the BASIC or KERNAL level programmer?[/INST]No, they cannot be used directly by the BASIC or KERNAL level programmer to do RS-232 type things."
"[INST]In the context of the C64, What are the zero-page locations used for?[/INST]They are used locally and are only given as a guide to understand the associated routines."
"[INST]In the context of the C64, Are the zero-page locations used for RS-232 type things?[/INST]No, the system RS-232 routines must be used."
"[INST]In the context of the C64, What is the significance of the zero-page locations?[/INST]They are used locally and are only given as a guide to understand the associated routines."
"[INST]In the context of the C64, Can the zero-page locations be used to do RS-232 type things?[/INST]No, the system RS-232 routines must be used."
"[INST]In the context of the C64, What is the purpose of the $00A7 location?[/INST]It is used as Receiver input bit temp storage."
"[INST]In the context of the C64, What is the purpose of the $00B6 location?[/INST]It is used as Transmitter byte buffer/disassembly location."
"[INST]In the context of the C64, What is the purpose of the $00AA location?[/INST]It is used as Receiver byte buffer/assembly location."
"[INST]In the context of the C64, At which memory locations can the input/output port register be found?[/INST]The input/output port register can be found at memory locations 0, which corresponds to the DATA DIRECTION REGISTER, and 1, which corresponds to the actual PORT."
"[INST]In the context of the C64, What is the primary function of the input/output port register on the Commodore 64?[/INST]The primary function of the input/output port register on the Commodore 64 is for memory management, allowing the chip to control more than 64K of RAM and ROM memory."
"[INST]In the context of the C64, What is the bit size of the input/output port?[/INST]The input/output port is an 8-bit input/output port."
"[INST]In the context of the C64, In what context is the input/output port register used on the Commodore 64?[/INST]The input/output port register is used in the context of memory management on the Commodore 64, allowing the chip to control more than 64K of RAM and ROM memory."
"[INST]In the context of the C64, Where can the details of the input/output port registers be found?[/INST]The details of the input/output port registers can be found in the explanations of the principles needed to understand them."
"[INST]In the context of the C64, What is the relationship between the input/output port register and memory management on the Commodore 64?[/INST]The input/output port register is used to control more than 64K of RAM and ROM memory on the Commodore 64, making it an essential component of memory management."
"[INST]In the context of the C64, How many bits are available in the input/output port?[/INST]There are 8 bits available in the input/output port."
"[INST]In the context of the C64, What is the purpose of the DATA DIRECTION REGISTER in the input/output port?[/INST]The DATA DIRECTION REGISTER is used to set the direction of data flow in the input/output port, determining whether the port is used for input or output operations."
"[INST]In the context of the C64, What is the significance of memory locations 0 and 1 in the context of the input/output port?[/INST]Memory locations 0 and 1 are significant in the context of the input/output port because they correspond to the DATA DIRECTION REGISTER and the actual PORT, respectively."
"[INST]In the context of the C64, Can the input/output port register be used for purposes other than memory management on the Commodore 64?[/INST]The input/output port register is primarily used for memory management on the Commodore 64, and its use for other purposes is not explicitly stated."
"[INST]In the context of the C64, POKE 55296,2[/INST]To change the color of a character located at the upper left-hand corner of the screen to red."
"[INST]In the context of the C64, Change color of character[/INST]To change the color of a character located at the upper left-hand corner of the screen to red."
"[INST]In the context of the C64, What is the value to change a character's color to red[/INST]2"
"[INST]In the context of the C64, What is the value to change a character's color to black[/INST]0"
"[INST]In the context of the C64, What is the value to change a character's color to purple[/INST]4"
"[INST]In the context of the C64, What is the value to change a character's color to orange[/INST]8"
"[INST]In the context of the C64, What is the value to change a character's color to gray[/INST]12"
"[INST]In the context of the C64, What is the value to change a character's color to light green[/INST]13"
"[INST]In the context of the C64, What is the value to change a character's color to light blue[/INST]14"
"[INST]In the context of the C64, What is the value to change a character's color to brown[/INST]9"
"[INST]In the context of the C64, What is the value to change a character's color to yellow[/INST]7"
"[INST]In the context of the C64, How do sprite priorities determine which sprites appear in front of or behind each other on the screen?[/INST]The built-in sprite priorities determine which sprites have priority over others when they overlap on the screen, with lower-numbered sprites having priority over higher-numbered sprites, following a 'first come, first served' rule."
"[INST]In the context of the C64, What is the rule that determines which sprite appears in front of another when they overlap on the screen?[/INST]The rule is 'first come, first served', meaning that lower-numbered sprites automatically have priority over higher-numbered sprites."
"[INST]In the context of the C64, How does the priority of sprite 0 differ from that of other sprites?[/INST]Sprite 0 always supersedes all other sprites because it's the lowest-numbered sprite, giving it priority over all other sprites."
"[INST]In the context of the C64, What is the priority of sprite 7 compared to other sprites?[/INST]Sprite 7 has less priority than any of the other sprites and will always appear to be displayed 'behind' any other sprites that overlap its position."
"[INST]In the context of the C64, How can you illustrate how priorities work in a program?[/INST]By changing lines 50, 60, and 70 in a program to POKEV,24:POKEV+1,50:POKEV+16,0, POKEV+2,34:POKEV+3,60, and POKEV+4,44:POKEV+5,70, you can see a white sprite on top of a yellow sprite on top of an orange sprite, demonstrating how priorities work."
"[INST]In the context of the C64, What is the advantage of understanding sprite priorities in animation?[/INST]Understanding sprite priorities allows you to move sprites and take advantage of these priorities in your animation, creating a more realistic and engaging visual effect."
"[INST]In the context of the C64, How do sprite priorities affect the display of overlapping sprites?[/INST]When two or more sprites overlap on the screen, the sprite with the higher priority will appear in front of the sprite with the lower priority, creating a 3D illusion."
"[INST]In the context of the C64, What determines the priority of a sprite in a program?[/INST]The priority of a sprite is determined by its sprite number, with lower-numbered sprites having priority over higher-numbered sprites."
"[INST]In the context of the C64, How can you use sprite priorities to create a 3D illusion on the screen?[/INST]By carefully arranging the priority of sprites, you can create a 3D illusion by making certain sprites appear in front of or behind others, creating a sense of depth on the screen."
"[INST]In the context of the C64, What is the significance of the 'first come, first served' rule in sprite priorities?[/INST]The 'first come, first served' rule ensures that lower-numbered sprites have priority over higher-numbered sprites, allowing for a predictable and consistent behavior in sprite overlap situations."
"[INST]In the context of the C64, what is the opcode for the load accumulator instruction?[/INST]The opcode for the load accumulator instruction is $A9, which loads a byte into the accumulator. This instruction is used to initialize the accumulator with a value, and it is often used at the beginning of a program to set the initial value of the accumulator."
"[INST]In the context of the C64, what is the execution time for the jmp instruction?[/INST]The execution time for the jmp instruction is 3 cycles. This instruction is used to jump to a specific location in memory, and it is often used to implement loops and conditional statements."
"[INST]In the context of the C64, what is the memory requirement for the sta instruction?[/INST]The memory requirement for the sta instruction is 2 bytes. This instruction is used to store the value of the accumulator in a memory location, and it is often used to store data in memory."
"[INST]In the context of the C64, what is the opcode for the store accumulator instruction?[/INST]The opcode for the store accumulator instruction is $85, which stores the value of the accumulator in a memory location. This instruction is used to store data in memory, and it is often used to implement data storage and retrieval."
"[INST]In the context of the C64, what is the execution time for the lda instruction?[/INST]The execution time for the lda instruction is 2 cycles. This instruction is used to load a byte into the accumulator, and it is often used to initialize the accumulator with a value."
"[INST]In the context of the C64, what is the memory requirement for the jmp instruction?[/INST]The memory requirement for the jmp instruction is 2 bytes. This instruction is used to jump to a specific location in memory, and it is often used to implement loops and conditional statements."
"[INST]In the context of the C64, what is the opcode for the jump instruction?[/INST]The opcode for the jump instruction is $4C, which jumps to a specific location in memory. This instruction is used to implement loops and conditional statements, and it is often used to control the flow of a program."
"[INST]In the context of the C64, what is the execution time for the sta instruction?[/INST]The execution time for the sta instruction is 3 cycles. This instruction is used to store the value of the accumulator in a memory location, and it is often used to store data in memory."
"[INST]In the context of the C64, what is the memory requirement for the lda instruction?[/INST]The memory requirement for the lda instruction is 2 bytes. This instruction is used to load a byte into the accumulator, and it is often used to initialize the accumulator with a value."
"[INST]In the context of the C64, what is the opcode for the and accumulator instruction?[/INST]The opcode for the and accumulator instruction is $25, which performs a bitwise AND operation between the accumulator and a memory location. This instruction is used to perform bitwise operations, and it is often used to implement conditional statements."
"[INST]In the context of the C64, Multi-color mode provides how many colors within each character?[/INST]up to four colors"
"[INST]In the context of the C64, What is the bit in register 22 that selects multi-color mode?[/INST]MCM bit"
"[INST]In the context of the C64, What happens when the MSB of the color nybble is a '0' in multi-color mode?[/INST]the character will be displayed as described in standard character mode"
"[INST]In the context of the C64, What happens when the MSB of the color nybble is a '1' in multi-color mode?[/INST]the character bits are interpreted in the multi-color mode"
"[INST]In the context of the C64, What are the two modes that can be inter-mixed?[/INST]standard character mode and multi-color mode"
"[INST]In the context of the C64, What is the maximum number of colors available in standard character mode?[/INST]8 colors"
"[INST]In the context of the C64, What is the size of each dot in multi-color mode compared to standard mode?[/INST]twice the horizontal size"
"[INST]In the context of the C64, What is the maximum number of colors that can be displayed in each character region in multi-color mode?[/INST]4 different colors"
"[INST]In the context of the C64, What are the two types of colors that can be specified in multi-color mode?[/INST]foreground and background"
"[INST]In the context of the C64, What is the purpose of the 3 LSB of the color nybble in multi-color mode?[/INST]to specify the color"
"[INST]In the context of the C64, What is the size of the character matrix in multi-color mode?[/INST]4*8 matrix"
"[INST]In the context of the C64, what is the only register that can be used as an index in indirect indexed mode?[/INST]The Y register is the only register that can be used as an index in indirect indexed mode, which allows for flexible memory access and manipulation."
"[INST]In the context of the C64, in indirect indexed mode, where can the actual address be located?[/INST]The actual address can only be in zero page, which is a 256-byte region of memory that is quickly accessible by the CPU."
"[INST]In the context of the C64, what is the significance of the zero page address specified in the instruction in indirect indexed mode?[/INST]The zero page address specified in the instruction contains the low byte of the actual address, and the next byte to it contains the high-order byte, which together form the complete memory address."
"[INST]In the context of the C64, how is the actual address calculated in indirect indexed mode?[/INST]The actual address is calculated by combining the low-order byte from the zero page address, the high-order byte from the next byte, and the value of the Y register, which serves as an index to offset the base address."
"[INST]In the context of the C64, in the example, what are the contents of locations $02 and $03?[/INST]The contents of location $02 are $45, and the contents of location $03 are $1E, which together form the actual address $1E45, to which the Y register is added to access the desired memory location."
"[INST]In the context of the C64, what is the purpose of the instruction LDA ($02),Y in the example code?[/INST]The instruction LDA ($02),Y loads the accumulator with the value stored at the memory location calculated by adding the value of the Y register to the base address stored in locations $02 and $03, which is $1E45 in this case."
"[INST]In the context of the C64, how does the analogy of delivering a letter to a post office illustrate indirect indexed mode?[/INST]The analogy illustrates how the CPU uses the zero page address as a 'post office' to retrieve the actual address, which is then offset by the value of the Y register, similar to how the letter is delivered to a specific house number past a base address on a street."
"[INST]In the context of the C64, what is the significance of the instruction LDY #$05 in the example code?[/INST]The instruction LDY #$05 sets the value of the Y register to $05, which is used as an index to offset the base address stored in locations $02 and $03, allowing the CPU to access a specific memory location."
"[INST]In the context of the C64, in indirect indexed mode, what is the role of the zero page address specified in the instruction?[/INST]The zero page address specified in the instruction serves as a 'pointer' to the actual address, which is stored in two consecutive bytes, with the low-order byte stored at the specified address and the high-order byte stored at the next address."
"[INST]In the context of the C64, what is the advantage of using indirect indexed mode in programming?[/INST]The advantage of using indirect indexed mode is that it allows for flexible and efficient memory access and manipulation, enabling the CPU to access a wide range of memory locations using a single instruction, which can improve the performance and efficiency of the program."
"[INST]In the context of the C64, How much RAM does the Commodore 64 have?[/INST]64K bytes"
"[INST]In the context of the C64, How much ROM does the Commodore 64 have?[/INST]20K bytes"
"[INST]In the context of the C64, What is the purpose of the 6510 processor chip's input/output port?[/INST]To control whether RAM or ROM or I/O will appear in certain portions of the system's memory"
"[INST]In the context of the C64, What is the address of the 6510 input/output port?[/INST]Location 1"
"[INST]In the context of the C64, What is the address of the data direction register for the 6510 input/output port?[/INST]Location 0"
"[INST]In the context of the C64, What is the function of the LORAM control line?[/INST]To control RAM/ROM at $A000-$BFFF"
"[INST]In the context of the C64, What is the function of the HIRAM control line?[/INST]To control RAM/ROM at $E000-$FFFF"
"[INST]In the context of the C64, What is the function of the CHAREN control line?[/INST]To control I/O/ROM at $D000-$DFFF"
"[INST]In the context of the C64, What is the purpose of the cassette write line?[/INST]To write data to the cassette"
"[INST]In the context of the C64, What is the purpose of the cassette switch sense?[/INST]To sense the play button"
"[INST]In the context of the C64, What is the purpose of the cassette motor control?[/INST]To control the cassette motor"
"[INST]In the context of the C64, What is the value of the data direction register?[/INST]47 decimal"
"[INST]In the context of the C64, How does the Commodore 64 set the data direction register?[/INST]Automatically"
"[INST]In the context of the C64, What happens when LORAM is programmed LOW?[/INST]The BASIC ROM disappears from the memory map and is replaced by 8K bytes of RAM"
"[INST]In the context of the C64, What happens when HIRAM is programmed LOW?[/INST]The KERNAL ROM disappears from the memory map and is replaced by 8K bytes of RAM"
"[INST]In the context of the C64, What happens when CHAREN is set to 0?[/INST]The character ROM appears in the processor address space, and the I/O devices are not accessible"
"[INST]In the context of the C64, What happens when CHAREN is set to 1?[/INST]The I/O devices appear in the microprocessor address space, and the character ROM is not accessible"
"[INST]In the context of the C64, What is the purpose of the programmable characters feature?[/INST]To download the character set from ROM to RAM"
"[INST]In the context of the C64, What happens when you write to a ROM location?[/INST]Data is stored in the RAM 'under' the ROM"
"[INST]In the context of the C64, What happens when you read from a ROM location?[/INST]The contents of the ROM are returned, not the 'hidden' RAM"
"[INST]In the context of the C64, How much memory is occupied by the character generator ROM?[/INST]4K bytes"
"[INST]In the context of the C64, What is the address range of the character generator ROM?[/INST]$D000-$DFFF"
"[INST]In the context of the C64, What is the address range of the RAM that appears when LORAM is LOW?[/INST]$A000-$BFFF"
"[INST]In the context of the C64, What is the address range of the RAM that appears when HIRAM is LOW?[/INST]$E000-$FFFF"
"[INST]In the context of the C64, What is the purpose of the 6510 processor chip's control lines?[/INST]To control memory configurations"
"[INST]In the context of the C64, How many bits are in the data direction register?[/INST]6"
"[INST]In the context of the C64, What is the purpose of the input/output devices?[/INST]To access peripheral devices"
"[INST]In the context of the C64, What is the purpose of the KERNAL ROM?[/INST]To provide operating system functionality"
"[INST]In the context of the C64, What is the purpose of the BASIC ROM?[/INST]To provide a programming language"
"[INST]In the context of the C64, Screen blanking is achieved by setting which register bit to 0?[/INST]DEN bit in register 17"
"[INST]In the context of the C64, What happens to the screen when it is blanked?[/INST]The entire screen will be filled with the exterior color"
"[INST]In the context of the C64, What is the purpose of blanking the screen?[/INST]To permit full processor utilization of the system bus"
"[INST]In the context of the C64, What type of memory accesses are required when the screen is blanked?[/INST]Transparent (Phase 1) memory accesses"
"[INST]In the context of the C64, What happens to sprite data when the screen is blanked?[/INST]Sprite data will be accessed if the sprites are not also disabled"
"[INST]In the context of the C64, What is the default state of the DEN bit?[/INST]The DEN bit must be set to 1"" for normal video display"""
"[INST]In the context of the C64, What happens to the system bus when the screen is blanked?[/INST]The system bus is utilized fully"
"[INST]In the context of the C64, What is the effect of setting the DEN bit to 0?[/INST]The screen is blanked"
"[INST]In the context of the C64, What is the purpose of setting the DEN bit to 1?[/INST]For normal video display"
"[INST]In the context of the C64, What happens to the exterior color when the screen is blanked?[/INST]The exterior color is displayed on the entire screen"
"[INST]In the context of the C64, what is the purpose of the interrupt register in the C64?[/INST]The interrupt register is used to show the status of the four sources of interrupt, which are set to '1' when an interrupt source has generated an interrupt request, allowing the system to handle and prioritize interrupts efficiently."
"[INST]In the context of the C64, what are the four sources of interrupt in the C64?[/INST]The four sources of interrupt in the C64 are: IRST (Raster count interrupt), IMDC (Sprite-DATA collision interrupt), IMMC (Sprite-Sprite collision interrupt), and ILP (Light Pen interrupt)."
"[INST]In the context of the C64, how is the interrupt latch in the interrupt register set?[/INST]The interrupt latch in the interrupt register is set to '1' when an interrupt source has generated an interrupt request, and can only be cleared by writing a '1' to the desired latch in the interrupt register."
"[INST]In the context of the C64, what is the purpose of the interrupt enable bit in register 26 ($1A)?[/INST]The interrupt enable bit in register 26 ($1A) must be set to '1' to enable an interrupt request to set the /IRQ output to '0', allowing the interrupt to be handled by the system."
"[INST]In the context of the C64, what is the effect of writing a '1' to the desired latch in the interrupt register?[/INST]Writing a '1' to the desired latch in the interrupt register clears the latch, allowing the system to selectively handle video interrupts without requiring software to 'remember' active interrupts."
"[INST]In the context of the C64, what is the significance of the /IRQ output in the interrupt system?[/INST]The /IRQ output is set to '0' when an interrupt request is enabled and the corresponding interrupt latch is set, indicating to the system that an interrupt needs to be handled."
"[INST]In the context of the C64, how does the system handle multiple interrupt sources?[/INST]The system handles multiple interrupt sources by using the interrupt register to prioritize and handle interrupts efficiently, allowing the system to selectively handle video interrupts without requiring software to 'remember' active interrupts."
"[INST]In the context of the C64, what is the purpose of the raster count interrupt (IRST)?[/INST]The raster count interrupt (IRST) is set when the raster count equals the stored raster count, allowing the system to synchronize with the video display."
"[INST]In the context of the C64, what is the purpose of the sprite-DATA collision interrupt (IMDC)?[/INST]The sprite-DATA collision interrupt (IMDC) is set by the sprite-DATA collision register (first collision only), allowing the system to detect and handle sprite collisions."
"[INST]In the context of the C64, what is the purpose of the light pen interrupt (ILP)?[/INST]The light pen interrupt (ILP) is set by the negative transition of the LP input (once per frame), allowing the system to detect and handle light pen events."
"[INST]In the context of the C64, What is the range of possible values for X?[/INST]0 to 255, counting from left to right."
"[INST]In the context of the C64, What happens when you POKE a value between 0 and 23 for X?[/INST]The sprite is placed out of the viewing area off the left side of the screen."
"[INST]In the context of the C64, What is the command to POKE sprite I at the farthest left X position in the viewing area?[/INST]POKE V+2,24."
"[INST]In the context of the C64, What is the purpose of the 'RIGHT X' row in the chart?[/INST]To get beyond the 255th position across the screen."
"[INST]In the context of the C64, How do you access the right side of the screen and start X numbering over again?[/INST]By POKEing V+16 and a number depending on the sprite."
"[INST]In the context of the C64, What is the range of possible values for Y?[/INST]0 to 255, counting from top to bottom."
"[INST]In the context of the C64, What happens when you POKE a value between 0 and 49 for Y?[/INST]The sprite is placed out of the viewing area off the top of the screen."
"[INST]In the context of the C64, What happens when you POKE a value between 230 and 255 for Y?[/INST]The sprite is placed out of the viewing area off the bottom of the screen."
"[INST]In the context of the C64, What is the purpose of the program provided in the text?[/INST]To demonstrate X-Y positioning using sprite 1."
"[INST]In the context of the C64, What does the command POKE V+3,229 do?[/INST]Moves the sprite to the bottom left corner of the screen."
"[INST]In the context of the C64, What is the RIGHT X LIMIT of the sprite?[/INST]255."
"[INST]In the context of the C64, What must be done to access positions beyond the 255th position?[/INST]The most significant bit in register 16 must be SET."
"[INST]In the context of the C64, What is the command to set the most significant bit of the X position for sprite 1?[/INST]POKE V+16,2."
"[INST]In the context of the C64, What does the command POKE V+2,0 do?[/INST]Displays the sprite at the new position zero, which is now reset to the 256th pixel."
"[INST]In the context of the C64, How do you get back to the left side of the screen?[/INST]By resetting the most significant bit of the X position counter to 0."
"[INST]In the context of the C64, What is the command to reset the most significant bit of the X position counter to 0?[/INST]POKE V+16, PEEK(V+16)AND 253."
"[INST]In the context of the C64, How do you POKE the X position for any sprite?[/INST]With a number from 0 to 255."
"[INST]In the context of the C64, What is the purpose of the additional POKE (V+16)?[/INST]To set the most significant bit of the X position and start counting from 0 again at the 256th pixel across the screen."
"[INST]In the context of the C64, What is the command to place sprite 0 at the 257th pixel across the screen?[/INST]POKE V+16,PEEK(V+16)OR 1 and POKE V,1."
"[INST]In the context of the C64, How do you get back to the left side X positions?[/INST]By turning off the control setting by typing POKE V+16,PEEK(V+16)AND 254."
"[INST]In the context of the C64, What happens when you POKE a value between 50 and 229 for Y?[/INST]The sprite is placed in the viewing area."
"[INST]In the context of the C64, What is the purpose of the X-Y POKE chart?[/INST]To provide settings for POKEing X and Y positions."
"[INST]In the context of the C64, How do you POKE the Y position for a sprite?[/INST]With a number from 0 to 255, counting from top to bottom."
"[INST]In the context of the C64, What is the command to POKE sprite I at a specific X position?[/INST]POKE V+2,X, where X is the desired position."
"[INST]In the context of the C64, What is the command to POKE sprite I at a specific Y position?[/INST]POKE V+3,Y, where Y is the desired position."
"[INST]In the context of the C64, What happens when you POKE a value beyond 255 for X?[/INST]You must use an additional POKE (V+16) to access the right side of the screen."
"[INST]In the context of the C64, What is the range of additional X positions available on the right side of the screen?[/INST]65, renumbered from 0 to 65."
"[INST]In the context of the C64, What is the maximum value you can POKE for the right side X value?[/INST]255, which takes you off the right edge of the viewing screen."
"[INST]In the context of the C64, what is the purpose of the IOINIT function?[/INST]The purpose of the IOINIT function is to initialize all input/output devices and routines, typically called as part of the initialization procedure of a Commodore 64 program cartridge."
"[INST]In the context of the C64, what is the call address of the IOINIT function in hexadecimal?[/INST]The call address of the IOINIT function in hexadecimal is $FF84."
"[INST]In the context of the C64, what is the decimal equivalent of the IOINIT function call address?[/INST]The decimal equivalent of the IOINIT function call address is 65412."
"[INST]In the context of the C64, what preparatory routines are required to be executed before calling the IOINIT function?[/INST]There are no preparatory routines required to be executed before calling the IOINIT function."
"[INST]In the context of the C64, which registers are affected by the IOINIT function?[/INST]The IOINIT function affects the A, X, and Y registers."
"[INST]In the context of the C64, what is the stack requirement for the IOINIT function?[/INST]The IOINIT function does not have any stack requirements."
"[INST]In the context of the C64, what is the purpose of calling the IOINIT function in a Commodore 64 program cartridge?[/INST]The purpose of calling the IOINIT function in a Commodore 64 program cartridge is to initialize all input/output devices and routines as part of the initialization procedure."
"[INST]In the context of the C64, how do you call the IOINIT function in assembly language?[/INST]You can call the IOINIT function in assembly language using the JSR instruction, for example: JSR IOINIT>."
"[INST]In the context of the C64, what type of return values can the IOINIT function return in case of an error?[/INST]The IOINIT function can return error values, but the specific type of return values is not specified."
"[INST]In the context of the C64, why is it important to call the IOINIT function in a Commodore 64 program?[/INST]It is important to call the IOINIT function in a Commodore 64 program to ensure that all input/output devices and routines are properly initialized, which is essential for the program to function correctly."
"[INST]In the context of the C64, EOR operation[/INST]The EOR operation is used to perform an Exclusive-OR operation between the accumulator and the memory location."
"[INST]In the context of the C64, EOR instruction[/INST]The EOR instruction is used to perform an Exclusive-OR operation between the accumulator and the memory location."
"[INST]In the context of the C64, Assembly language form[/INST]The assembly language form of the EOR instruction is EOR #Oper."
"[INST]In the context of the C64, OP CODE[/INST]The OP CODE of the EOR instruction is 49."
"[INST]In the context of the C64, Number of bytes[/INST]The number of bytes required to execute the EOR instruction is 2."
"[INST]In the context of the C64, Number of cycles[/INST]The number of cycles required to execute the EOR instruction is 2."
"[INST]In the context of the C64, Addressing mode[/INST]The addressing mode of the EOR instruction is Immediate."
"[INST]In the context of the C64, Assembly language form of EOR[/INST]The assembly language form of the EOR instruction is EOR #Oper."
"[INST]In the context of the C64, Number of cycles for EOR[/INST]The number of cycles required to execute the EOR instruction is 2."
"[INST]In the context of the C64, Where is the sprite to data collision register located in the VIC-II chip?[/INST]The sprite to data collision register is located at location 53279 ($D01F in HEX) of the VIC-II chip control register."
"[INST]In the context of the C64, What happens to the bits in the sprite to data collision register when a collision is detected?[/INST]When a collision is detected, the corresponding bit in the sprite to data collision register is set to 1, indicating that the sprite is involved in a collision."
"[INST]In the context of the C64, What happens to the bits in the sprite to data collision register when they are read?[/INST]When the bits in the sprite to data collision register are read (PEEKed), they are automatically cleared, so it is a good idea to save the value in a variable until you are finished with it."
"[INST]In the context of the C64, Why is it important to save the value of the sprite to data collision register?[/INST]It is important to save the value of the sprite to data collision register because the register is automatically cleared when read, and you may need to use the value later in your program."
"[INST]In the context of the C64, How can you avoid unwanted collisions in multi-color mode?[/INST]In multi-color mode, you can avoid unwanted collisions by making everything that should not cause a collision have a data value of 01, which is considered transparent for collisions."
"[INST]In the context of the C64, What is the significance of data value 01 in multi-color mode?[/INST]In multi-color mode, data value 01 is considered transparent for collisions, even though it shows up on the screen."
"[INST]In the context of the C64, How can you detect sprite to data collisions in your program?[/INST]You can detect sprite to data collisions by checking the sprite to data collision register at location 53279 ($D01F in HEX) of the VIC-II chip control register."
"[INST]In the context of the C64, What happens when a sprite is involved in a collision?[/INST]When a sprite is involved in a collision, the corresponding bit in the sprite to data collision register is set to 1."
"[INST]In the context of the C64, Why is it a good idea to make everything that should not cause a collision have a data value of 01 in multi-color mode?[/INST]It is a good idea to make everything that should not cause a collision have a data value of 01 in multi-color mode because this value is considered transparent for collisions, and will not trigger a collision detection."
"[INST]In the context of the C64, How can you use the sprite to data collision register in your program?[/INST]You can use the sprite to data collision register to detect collisions between sprites and data, and respond accordingly in your program, such as by changing the sprite's position or behavior."
"[INST]In the context of the C64, What is the operation of BPL branch instruction?[/INST]Branch on result plus"
"[INST]In the context of the C64, What is the addressing mode of BPL instruction?[/INST]Relative"
"[INST]In the context of the C64, What is the assembly language form of BPL instruction?[/INST]BPL Oper"
"[INST]In the context of the C64, What is the OP CODE of BPL instruction?[/INST]10"
"[INST]In the context of the C64, How many bytes does the BPL instruction occupy?[/INST]2"
"[INST]In the context of the C64, How many cycles does the BPL instruction take?[/INST]2*"
"[INST]In the context of the C64, What is the condition for adding 1 to the branch count?[/INST]branch occurs to same page"
"[INST]In the context of the C64, What is the condition for adding 2 to the branch count?[/INST]branch occurs to different page"
"[INST]In the context of the C64, What is the significance of the asterisk (*) in the BPL instruction?[/INST]Add 1 or 2 to the branch count"
"[INST]In the context of the C64, What is the effect of the BPL instruction on the program flow?[/INST]Branch to a new location"
"[INST]In the context of the C64, Multi-color bit map mode allows you to display how many different colors in each 8 by 8 section of bit map?[/INST]up to four"
"[INST]In the context of the C64, Multi-color bit map mode uses how much memory for the bit map?[/INST]an 8K section"
"[INST]In the context of the C64, What are the three ways to select colors for multi-color bit map mode?[/INST](1) the background color register 0, (2) the video matrix, and (3) color memory"
"[INST]In the context of the C64, What is the purpose of setting bit 5 of 53265 and bit 4 at location 53270 to a 1?[/INST]to turn ON multi-color bit mapped mode"
"[INST]In the context of the C64, What is the purpose of setting bit 5 of 53265 and bit 4 at location 53270 to a 0?[/INST]to turn OFF multi-color bit mapped mode"
"[INST]In the context of the C64, What is the correspondence between the 8K section of memory and the display?[/INST]one to one"
"[INST]In the context of the C64, How wide are the horizontal dots in multi-color bit mapped mode?[/INST]two bits"
"[INST]In the context of the C64, What is the maximum number of colors that can be displayed in each 2 bits?[/INST]4"
"[INST]In the context of the C64, What is the purpose of the POKE 53265,PEEK(53265)OR 32 command?[/INST]to turn ON multi-color bit mapped mode"
"[INST]In the context of the C64, What is the purpose of the POKE 53265,PEEK(53265)AND 223 command?[/INST]to turn OFF multi-color bit mapped mode"
"[INST]In the context of the C64, what is the purpose of the OSC 3/RANDOM register?[/INST]The OSC 3/RANDOM register allows the microprocessor to read the upper 8 output bits of Oscillator 3, which can be used as a random number generator for games, a modulation generator, and for various timing and sequencing applications."
"[INST]In the context of the C64, what happens when the Sawtooth waveform of Oscillator 3 is selected?[/INST]When the Sawtooth waveform of Oscillator 3 is selected, the OSC 3/RANDOM register will present a series of numbers incrementing from 0 to 255 ($FF) at a rate determined by the frequency of Oscillator 3."
"[INST]In the context of the C64, what is the effect of selecting the Triangle waveform on the OSC 3/RANDOM register?[/INST]When the Triangle waveform is selected, the output of the OSC 3/RANDOM register will increment from 0 up to 255, then decrement down to 0."
"[INST]In the context of the C64, how can the OSC 3/RANDOM register be used to create dynamic effects?[/INST]The numbers generated by the OSC 3/RANDOM register can be added, via software, to the Oscillator or Filter Frequency registers or the Pulse Width registers in real-time, allowing for the creation of many dynamic effects such as siren-like sounds, synthesizer 'Sample and Hold' effects, and vibrato."
"[INST]In the context of the C64, what is the purpose of setting Oscillator 3 to a frequency around 7 Hz?[/INST]Setting Oscillator 3 to a frequency around 7 Hz allows for the creation of vibrato effects by adding the OSC 3 Triangle output (with proper scaling) to the Frequency control of another oscillator."
"[INST]In the context of the C64, what is the effect of adding the OSC 3 Sawtooth output to the frequency control of another oscillator?[/INST]Adding the OSC 3 Sawtooth output to the frequency control of another oscillator can create siren-like sounds."
"[INST]In the context of the C64, what is the effect of adding the OSC 3 Noise output to the Filter Frequency control registers?[/INST]Adding the OSC 3 Noise output to the Filter Frequency control registers can produce synthesizer 'Sample and Hold' effects."
"[INST]In the context of the C64, why should the audio output of Voice 3 be eliminated when using Oscillator 3 for modulation?[/INST]The audio output of Voice 3 should be eliminated (3 OFF = 1) when using Oscillator 3 for modulation to prevent unwanted audio output."
"[INST]In the context of the C64, what is the range of effects that can be generated by altering the frequency of Oscillator 3 and scaling the OSC 3 output?[/INST]An unlimited range of effects can be generated by altering the frequency of Oscillator 3 and scaling the OSC 3 output."
"[INST]In the context of the C64, what is the chief function of the OSC 3/RANDOM register?[/INST]The chief function of the OSC 3/RANDOM register is probably that of a modulation generator, allowing for the creation of various dynamic effects."
"[INST]In the context of the C64, FC LO and FC HI registers form an 11-bit number which linearly controls the Cutoff Frequency of the programmable Filter.[/INST]The approximate Cutoff Frequency ranges from 30 Hz to 12 KHz."
"[INST]In the context of the C64, Resonance is a peaking effect which emphasizes frequency components at the Cutoff Frequency of the Filter.[/INST]causing a sharper sound."
"[INST]In the context of the C64, Bits 4-7 of RES/FILT register control the resonance of the filter.[/INST]There are 16 resonance settings ranging linearly from no resonance (0) to maximum resonance (15 or $F)."
"[INST]In the context of the C64, Bits 0-3 of RES/FILT register determine which signals will be routed through the Filter.[/INST]FILT 1 (Bit 0), FILT 2 (Bit 1), FILT 3 (Bit 2), and FILTEX (Bit 3) control the routing of signals."
"[INST]In the context of the C64, Voice 1 will be processed through the Filter when FILT 1 is set to a one.[/INST]the harmonic content of Voice 1 will be altered according to the selected Filter parameters."
"[INST]In the context of the C64, External audio input (pin 26) will be processed through the Filter when FILTEX is set to a one.[/INST]the harmonic content of External audio input will be altered according to the selected Filter parameters."
"[INST]In the context of the C64, FC LO and FC HI registers are used to form an 11-bit number.[/INST]which linearly controls the Cutoff Frequency of the programmable Filter."
"[INST]In the context of the C64, Resonance settings range from no resonance to maximum resonance.[/INST]There are 16 resonance settings ranging linearly from no resonance (0) to maximum resonance (15 or $F)."
"[INST]In the context of the C64, Bits 4-7 of RES/FILT register control the resonance of the filter.[/INST]There are 16 resonance settings ranging linearly from no resonance (0) to maximum resonance (15 or $F)."
"[INST]In the context of the C64, FC LO and FC HI registers are used to form an 11-bit number which linearly controls the Cutoff Frequency of the programmable Filter.[/INST]The approximate Cutoff Frequency ranges from 30 Hz to 12 KHz."
"[INST]In the context of the C64, Is the R/W input used to determine the direction of data transfer?[/INST]The read/write input, R/W, is used to determine the direction of data transfer on the data bus, in conjunction with /CS."
"[INST]In the context of the C64, What happens when R/W is high?[/INST]data is transferred from the selected register to the data bus output."
"[INST]In the context of the C64, What happens when R/W is low?[/INST]data presented on the data bus pins is loaded into the selected register."
"[INST]In the context of the C64, What is the purpose of the R/W input?[/INST]The read/write input, R/W, is used to determine the direction of data transfer on the data bus, in conjunction with /CS."
"[INST]In the context of the C64, Is data transferred from the register to the data bus when R/W is high?[/INST]Yes"
"[INST]In the context of the C64, Is data loaded into the register from the data bus when R/W is low?[/INST]Yes"
"[INST]In the context of the C64, What happens to the data on the data bus when R/W is high?[/INST]data is transferred from the selected register to the data bus output."
"[INST]In the context of the C64, What happens to the data on the data bus when R/W is low?[/INST]data presented on the data bus pins is loaded into the selected register."
"[INST]In the context of the C64, Is the R/W input used in conjunction with /CS?[/INST]Yes"
"[INST]In the context of the C64, Is the R/W input used to determine the direction of data transfer?[/INST]Yes"
"[INST]In the context of the C64, what is the opcode for the CLV instruction?[/INST]The opcode for the CLV instruction is B8, which is used to clear the overflow flag in the processor status register."
"[INST]In the context of the C64, what is the addressing mode for the CLV instruction?[/INST]The addressing mode for the CLV instruction is implied, meaning that the instruction does not require a memory operand."
"[INST]In the context of the C64, how many bytes does the CLV instruction occupy in memory?[/INST]The CLV instruction occupies 1 byte in memory."
"[INST]In the context of the C64, how many cycles does the CLV instruction take to execute?[/INST]The CLV instruction takes 2 cycles to execute."
"[INST]In the context of the C64, what is the purpose of the CLV instruction?[/INST]The purpose of the CLV instruction is to clear the overflow flag in the processor status register, which is used to indicate an overflow condition in arithmetic operations."
"[INST]In the context of the C64, can the CLV instruction be used to set the overflow flag?[/INST]No, the CLV instruction is used to clear the overflow flag, not set it."
"[INST]In the context of the C64, in what situations would you use the CLV instruction?[/INST]You would use the CLV instruction when you need to clear the overflow flag after an arithmetic operation, such as when you need to reset the flag after a calculation that may have caused an overflow."
"[INST]In the context of the C64, how does the CLV instruction affect the processor status register?[/INST]The CLV instruction clears the overflow flag in the processor status register, which is used to indicate an overflow condition in arithmetic operations."
"[INST]In the context of the C64, what is the difference between the CLV instruction and the CLC instruction?[/INST]The CLV instruction clears the overflow flag, while the CLC instruction clears the carry flag, which is used to indicate a carry or borrow in arithmetic operations."
"[INST]In the context of the C64, is the CLV instruction commonly used in assembly language programming?[/INST]The CLV instruction is not as commonly used as other instructions, but it is still an important instruction in certain situations, such as when working with arithmetic operations that may cause an overflow."
"[INST]In the context of the C64, What is the maximum number of characters that the Commodore 64 receiver buffer can hold?[/INST]255 characters"
"[INST]In the context of the C64, What happens when the receiver buffer overflows?[/INST]All characters received during a full buffer condition, from that point on, are lost."
"[INST]In the context of the C64, Why is it important to keep the buffer as clear as possible?[/INST]To avoid losing characters received during a full buffer condition."
"[INST]In the context of the C64, What is recommended for receiving RS-232 data at high speeds?[/INST]Using machine language routines to handle data bursts."
"[INST]In the context of the C64, What is the recommended BASIC syntax for receiving RS-232 data?[/INST]GET#lfn, <string variable>"
"[INST]In the context of the C64, What is NOT recommended for receiving RS-232 data?[/INST]INPUT#lfn <variable list>"
"[INST]In the context of the C64, What is the purpose of the CHKIN kernal entry?[/INST]To handle the x-line handshake which follows the EIA standard for RS-232-C interfaces."
"[INST]In the context of the C64, What is the purpose of the GETIN kernal entry?[/INST]To get input from the RS-232 channel."
"[INST]In the context of the C64, What is the purpose of the CHRIN kernal entry?[/INST]To get a character from the RS-232 channel."
"[INST]In the context of the C64, What happens if the word length is less than 8 bits?[/INST]All unused bit(s) will be assigned a value of zero."
"[INST]In the context of the C64, What is returned if a GET# does not find any data in the buffer?[/INST]A null character."
"[INST]In the context of the C64, What happens if INPUT# is used and no data is received?[/INST]The system will hang in a waiting condition until a non-null character and a following carriage return is received."
"[INST]In the context of the C64, Why are INPUT# and CHRIN routines NOT recommended?[/INST]Because they can cause the system to hang in a RESTORE-only state if the CTS or DSR lines disappear during character input."
"[INST]In the context of the C64, What is the purpose of the RTS line in the RS-232-C interface?[/INST]To implement the x-line handshake."
"[INST]In the context of the C64, What is the purpose of the CTS line in the RS-232-C interface?[/INST]To implement the x-line handshake."
"[INST]In the context of the C64, What is the purpose of the DCD line in the RS-232-C interface?[/INST]To implement the x-line handshake."
"[INST]In the context of the C64, What is the EIA standard for RS-232-C interfaces?[/INST]A standard for RS-232-C interfaces published in August 1979."
"[INST]In the context of the C64, What is the Commodore 64 computer defined as in the RS-232-C interface?[/INST]A Data Terminal device."
"[INST]In the context of the C64, What is the purpose of the RS-232 status word?[/INST]To indicate the status of the RS-232 channel."
"[INST]In the context of the C64, What is the RS-232 status word referred to in BASIC?[/INST]ST"
"[INST]In the context of the C64, What is the RS-232 status word referred to in machine language?[/INST]RSSTAT"
"[INST]In the context of the C64, What happens if the receiver buffer overflows during high-speed data transfer?[/INST]All characters received during a full buffer condition, from that point on, are lost."
"[INST]In the context of the C64, Why is it important to use machine language routines for high-speed data transfer?[/INST]Because BASIC can only go so fast, especially considering garbage collects."
"[INST]In the context of the C64, What is the purpose of garbage collects in BASIC?[/INST]To free up memory and improve performance."
"[INST]In the context of the C64, Why can't BASIC handle high-speed data transfer?[/INST]Because it can only go so fast, especially considering garbage collects."
"[INST]In the context of the C64, What is the recommended way to receive RS-232 data in BASIC?[/INST]Using the GET# statement."
"[INST]In the context of the C64, What is the purpose of the GET# statement?[/INST]To get a string of characters from the RS-232 channel."
"[INST]In the context of the C64, What is the purpose of the INPUT# statement?[/INST]To get a list of variables from the RS-232 channel."
"[INST]In the context of the C64, Why is the INPUT# statement NOT recommended?[/INST]Because it can cause the system to hang in a RESTORE-only state if the CTS or DSR lines disappear during character input."
"[INST]In the context of the C64, what is the addressing mode of the BPL instruction?[/INST]The addressing mode of the BPL instruction is Relative, which means the branch target is specified by a signed 8-bit offset from the current program counter."
"[INST]In the context of the C64, what is the assembly language form of the BPL instruction?[/INST]The assembly language form of the BPL instruction is simply 'BPL' followed by the branch target, for example 'BPL label'."
"[INST]In the context of the C64, what is the opcode of the BPL instruction?[/INST]The opcode of the BPL instruction is 10 in hexadecimal notation."
"[INST]In the context of the C64, how many bytes does the BPL instruction occupy in memory?[/INST]The BPL instruction occupies 2 bytes in memory, one for the opcode and one for the branch target offset."
"[INST]In the context of the C64, how many cycles does the BPL instruction take to execute?[/INST]The BPL instruction takes 2 cycles to execute, but this can increase to 3 or 4 cycles if the branch occurs to the same or different page, respectively."
"[INST]In the context of the C64, what happens if the branch target is on the same page as the current instruction?[/INST]If the branch target is on the same page as the current instruction, the BPL instruction takes 3 cycles to execute, one more cycle than the minimum."
"[INST]In the context of the C64, what happens if the branch target is on a different page as the current instruction?[/INST]If the branch target is on a different page as the current instruction, the BPL instruction takes 4 cycles to execute, two more cycles than the minimum."
"[INST]In the context of the C64, in what situations does the BPL instruction take the minimum 2 cycles to execute?[/INST]The BPL instruction takes the minimum 2 cycles to execute when the branch target is on the same page as the current instruction and the branch does not occur."
"[INST]In the context of the C64, can you give an example of a BPL instruction in assembly language?[/INST]Here is an example of a BPL instruction in assembly language: 'BPL loop' which branches to the label 'loop' if the result of the previous instruction was plus."
"[INST]In the context of the C64, what is the purpose of the BPL instruction?[/INST]The purpose of the BPL instruction is to branch to a target location if the result of the previous instruction was plus, allowing the programmer to implement conditional logic in their code."
"[INST]In the context of the C64, how is an absolute address expressed in terms of bytes?[/INST]An absolute address is expressed in terms of a high order byte and a low order byte. The high order byte is often referred to as the page of memory. For example, the address $1637 is in page $16 (22), and $0277 is in page $02 (2)."
"[INST]In the context of the C64, what is zero page addressing mode?[/INST]Zero page addressing mode is a special mode of addressing associated with the addressing of memory locations in page zero. These addresses always have a high order byte of zero."
"[INST]In the context of the C64, what is the advantage of zero page addressing mode?[/INST]The zero page addressing mode only expects one byte to describe the address, rather than two when using an absolute address."
"[INST]In the context of the C64, in which page are addresses between $0000 and $00FF located?[/INST]Addresses between $0000 and $00FF are located in page zero."
"[INST]In the context of the C64, why does the microprocessor assume a high order address of zero in zero page addressing mode?[/INST]The microprocessor assumes a high order address of zero in zero page addressing mode because the addresses in this mode always have a high order byte of zero."
"[INST]In the context of the C64, what is the range of addresses that can be referenced using zero page addressing mode?[/INST]The range of addresses that can be referenced using zero page addressing mode is between $0000 and $00FF."
"[INST]In the context of the C64, what is the significance of page zero in zero page addressing mode?[/INST]Page zero is significant in zero page addressing mode because it is the page that contains the addresses that can be referenced using this mode."
"[INST]In the context of the C64, how does zero page addressing mode differ from absolute addressing mode?[/INST]Zero page addressing mode differs from absolute addressing mode in that it only expects one byte to describe the address, whereas absolute addressing mode expects two bytes."
"[INST]In the context of the C64, in which situations is zero page addressing mode used?[/INST]Zero page addressing mode is used when referencing memory locations in page zero, whose addresses are between $0000 and $00FF."
"[INST]In the context of the C64, what is the benefit of using zero page addressing mode?[/INST]The benefit of using zero page addressing mode is that it requires less memory to store the address, since only one byte is needed to describe the address."
"[INST]In the context of the C64, What is the printer similar to?[/INST]The printer is an output device similar to the screen."
"[INST]In the context of the C64, How do you create a format that is easy on the eyes when sending output to the printer?[/INST]You can use reversed, double-width, capital and lower case letters, as well as dot-programmable graphics."
"[INST]In the context of the C64, What is the purpose of the SPC function on the printer?[/INST]The SPC function works for the printer in the same way it works for the screen."
"[INST]In the context of the C64, Why does the TAB function not work correctly on the printer?[/INST]The TAB function does not work correctly on the printer because it calculates the current position on the line based on the cursor's position on the screen, not on the paper."
"[INST]In the context of the C64, What does the OPEN statement for the printer do?[/INST]The OPEN statement for the printer creates the channel for communication and specifies which character set will be used, either upper case with graphics or upper and lower case."
"[INST]In the context of the C64, What is the purpose of the cursor down character (CHR$(17))?[/INST]When in upper case with graphics, the cursor down character (CHR$(17)) switches the characters to the upper and lower case set."
"[INST]In the context of the C64, What is the purpose of the cursor up character (CHR$(145))?[/INST]When in upper and lower case, the cursor up character (CHR$(145)) allows upper case and graphics characters to be PRINTed."
"[INST]In the context of the C64, How are special functions in the printer controlled?[/INST]Special functions in the printer are controlled through character codes, which are simply PRINTed just like any other character."
"[INST]In the context of the C64, What is the purpose of CHR$(10)?[/INST]CHR$(10) is a line feed."
"[INST]In the context of the C64, What is the purpose of CHR$(13)?[/INST]CHR$(13) is a RETURN (automatic line feed on CBM printers)."
"[INST]In the context of the C64, What is the purpose of CHR$(14)?[/INST]CHR$(14) begins double-width character mode."
"[INST]In the context of the C64, What is the purpose of CHR$(15)?[/INST]CHR$(15) ends double-width character mode."
"[INST]In the context of the C64, What is the purpose of CHR$(18)?[/INST]CHR$(18) begins reverse character mode."
"[INST]In the context of the C64, What is the purpose of CHR$(146)?[/INST]CHR$(146) ends reverse character mode."
"[INST]In the context of the C64, What is the purpose of CHR$(17)?[/INST]CHR$(17) switches to upper/lower case character set."
"[INST]In the context of the C64, What is the purpose of CHR$(145)?[/INST]CHR$(145) switches to upper case/graphics character set."
"[INST]In the context of the C64, What is the purpose of CHR$(16)?[/INST]CHR$(16) tabs to a position in the next 2 characters."
"[INST]In the context of the C64, What is the purpose of CHR$(27)?[/INST]CHR$(27) moves to a specified dot position."
"[INST]In the context of the C64, What is the purpose of CHR$(8)?[/INST]CHR$(8) begins dot-programmable graphic mode."
"[INST]In the context of the C64, What is the purpose of CHR$(26)?[/INST]CHR$(26) repeats graphics data."
"[INST]In the context of the C64, How do you specify the character set when opening the printer?[/INST]The character set is specified in the OPEN statement, either upper case with graphics or upper and lower case."
"[INST]In the context of the C64, What is the format of the OPEN statement for the printer?[/INST]The format of the OPEN statement for the printer is OPEN 1,4 for upper case with graphics or OPEN 1,4,7 for upper and lower case."
"[INST]In the context of the C64, How do you switch between character sets when printing?[/INST]Individual lines can be PRINTed in the opposite character set by using the cursor down or cursor up characters."
"[INST]In the context of the C64, What is the purpose of the printer control character codes?[/INST]The printer control character codes control special functions in the printer."
"[INST]In the context of the C64, Where can you find more information on using the command codes?[/INST]You can find more information on using the command codes in your Commodore printer's manual."
"[INST]In the context of the C64, What is the purpose of the dot-programmable graphics mode?[/INST]The dot-programmable graphics mode allows for graphics to be printed on the printer."
"[INST]In the context of the C64, How do you use the dot-programmable graphics mode?[/INST]The dot-programmable graphics mode is used by printing CHR$(8) followed by the graphics data."
"[INST]In the context of the C64, What is the purpose of the repeat graphics data code?[/INST]The repeat graphics data code (CHR$(26)) repeats the graphics data."
"[INST]In the context of the C64, what is the direction of the lower six address pins A5-A0 during a processor read or write of the video device[/INST]The lower six address pins A5-A0 are bidirectional, but during a processor read or write of the video device, these address pins are inputs."
"[INST]In the context of the C64, what determines the register for read or write during a processor access to the video device[/INST]The data on the address inputs selects the register for read or write as defined in the register map."
"[INST]In the context of the C64, in what way are the lower six address pins A5-A0 used during a processor access to the video device[/INST]The lower six address pins A5-A0 are used as inputs during a processor read or write of the video device, and the data on these pins selects the register for read or write as defined in the register map."
"[INST]In the context of the C64, what is the purpose of the address pins A5-A0 during a processor access to the video device[/INST]The purpose of the address pins A5-A0 is to select the register for read or write as defined in the register map during a processor access to the video device."
"[INST]In the context of the C64, what is the direction of the data flow on the address pins A5-A0 during a processor read of the video device[/INST]The direction of the data flow on the address pins A5-A0 is from the video device to the processor during a processor read of the video device."
"[INST]In the context of the C64, in what way do the address pins A5-A0 participate in the processor access to the video device[/INST]The address pins A5-A0 participate in the processor access to the video device by selecting the register for read or write as defined in the register map."
"[INST]In the context of the C64, what is the role of the address pins A5-A0 in the register selection during a processor access to the video device[/INST]The role of the address pins A5-A0 is to select the register for read or write as defined in the register map during a processor access to the video device."
"[INST]In the context of the C64, what is the function of the address pins A5-A0 during a processor write to the video device[/INST]The function of the address pins A5-A0 is to select the register for write as defined in the register map during a processor write to the video device."
"[INST]In the context of the C64, how do the address pins A5-A0 affect the processor access to the video device[/INST]The address pins A5-A0 affect the processor access to the video device by determining the register for read or write as defined in the register map."
"[INST]In the context of the C64, what is the relationship between the address pins A5-A0 and the register map during a processor access to the video device[/INST]The address pins A5-A0 are used to select the register for read or write as defined in the register map during a processor access to the video device."
"[INST]In the context of the C64, what is the purpose of Bit 4 in the MODE/VOL register?[/INST]Low-Pass output selection"
"[INST]In the context of the C64, What happens to frequency components below the Filter Cutoff Frequency when Bit 4 is set to a one?[/INST]they are passed unaltered"
"[INST]In the context of the C64, What is the rate of attenuation for frequency components above the Cutoff when Bit 4 is set to a one?[/INST]12 dB/Octave"
"[INST]In the context of the C64, What type of sounds does the Low-Pass mode produce?[/INST]fullbodied sounds"
"[INST]In the context of the C64, What is the purpose of Bit 5 in the MODE/VOL register?[/INST]Bandpass output selection"
"[INST]In the context of the C64, What happens to frequency components above and below the Cutoff when Bit 5 is set to a one?[/INST]they are attenuated at a rate of 6 dB/Octave"
"[INST]In the context of the C64, What type of sounds does the Bandpass mode produce?[/INST]thin, open sounds"
"[INST]In the context of the C64, What is the purpose of Bit 6 in the MODE/VOL register?[/INST]High-Pass output selection"
"[INST]In the context of the C64, What happens to frequency components below the Cutoff when Bit 6 is set to a one?[/INST]they are attenuated at a rate of 12 dB/Octave"
"[INST]In the context of the C64, What type of sounds does the High-Pass mode produce?[/INST]tinny, buzzy sounds"
"[INST]In the context of the C64, What is the purpose of Bit 7 in the MODE/VOL register?[/INST]disconnection of Voice 3 from the direct audio path"
"[INST]In the context of the C64, What happens when Bit 7 is set to a one?[/INST]the output of Voice 3 is disconnected from the direct audio path"
"[INST]In the context of the C64, What is the purpose of the Filter in the SID?[/INST]to generate complex tone colors via subtractive synthesis"
"[INST]In the context of the C64, What is the most important element in the SID?[/INST]the Filter"
"[INST]In the context of the C64, What is the purpose of varying the Cutoff Frequency in real-time?[/INST]to achieve the best results"
"[INST]In the context of the C64, What are the 16 overall Volume levels for the final composite audio output?[/INST]0 to 15 or $F in 16 linear steps"
"[INST]In the context of the C64, What is the purpose of the Volume control?[/INST]to balance levels in multi-chip systems or create dynamic volume effects"
"[INST]In the context of the C64, What must be selected in order for the SID to produce any sound?[/INST]a Volume level other than zero"
"[INST]In the context of the C64, What is the purpose of the Tremolo effect?[/INST]to create dynamic volume effects"
"[INST]In the context of the C64, What is the range of the overall Volume levels?[/INST]0 to maximum volume"
"[INST]In the context of the C64, What is the purpose of the Filter output modes?[/INST]to produce complex tone colors"
"[INST]In the context of the C64, What is the purpose of the Filter Cutoff Frequency?[/INST]to determine the frequency components passed or attenuated"
"[INST]In the context of the C64, What is the purpose of the Filter modes?[/INST]to produce different tone colors"
"[INST]In the context of the C64, What is the purpose of the Filter output modes being additive?[/INST]to allow multiple Filter modes to be selected simultaneously"
"[INST]In the context of the C64, what is bit mapping used for[/INST]It is used to create highly detailed pictures."
"[INST]In the context of the C64, what is the resolution of standard bit mapped mode[/INST]320-dot by 200-dot resolution"
"[INST]In the context of the C64, what is the resolution of multi-color bit mapped mode[/INST]160-dot by 200-dot resolution"
"[INST]In the context of the C64, what is the difference between standard and multi-color bit mapping[/INST]Standard has greater resolution, but fewer color selections, while multi-color trades horizontal resolution for a greater number of colors"
"[INST]In the context of the C64, how do you select bit map mode[/INST]By setting bit 5 of the VIC-II control register to a 1 at location 53265"
"[INST]In the context of the C64, how do you turn off bit map mode[/INST]By setting bit 5 of the VIC-II control register to 0 at location 53265"
"[INST]In the context of the C64, what is the purpose of the POKE command in bit map mode[/INST]To set the bit pattern of a character stored in RAM"
"[INST]In the context of the C64, what is the basis of bit-mapping[/INST]The entire screen is filled with programmable characters, and you make your changes directly into the memory that the programmable characters get their patterns from"
"[INST]In the context of the C64, what is the difference between color memory and screen memory in bit map mode[/INST]Colors are taken from screen memory, not color memory"
"[INST]In the context of the C64, what is the formula to calculate the correct bit in the character memory to set to a 1[/INST]X and Y to stand for the horizontal and vertical positions of a dot"
"[INST]In the context of the C64, Can a sprite be expanded in both the vertical and horizontal directions?[/INST]The VIC-II chip has the ability to expand a sprite in the vertical direction, the horizontal direction, or both at once."
"[INST]In the context of the C64, Can a sprite be expanded in the vertical direction?[/INST]The VIC-II chip has the ability to expand a sprite in the vertical direction, the horizontal direction, or both at once."
"[INST]In the context of the C64, What happens to the resolution when a sprite is expanded?[/INST]Resolution doesn't actually increase... the sprite just gets bigger."
"[INST]In the context of the C64, Can a sprite be expanded in the horizontal direction?[/INST]The VIC-II chip has the ability to expand a sprite in the vertical direction, the horizontal direction, or both at once."
"[INST]In the context of the C64, What happens to each dot in a sprite when it is expanded?[/INST]each dot in the sprite is twice as wide or twice as tall."
"[INST]In the context of the C64, Can a sprite be expanded in both the vertical and horizontal directions at once?[/INST]The VIC-II chip has the ability to expand a sprite in the vertical direction, the horizontal direction, or both at once."
"[INST]In the context of the C64, What is the effect of expanding a sprite on its size?[/INST]the sprite just gets bigger."
"[INST]In the context of the C64, Can a sprite be expanded in the vertical direction only?[/INST]The VIC-II chip has the ability to expand a sprite in the vertical direction, the horizontal direction, or both at once."
"[INST]In the context of the C64, What happens to the size of a sprite when it is expanded?[/INST]the sprite just gets bigger."
"[INST]In the context of the C64, Can a sprite be expanded in the horizontal direction only?[/INST]The VIC-II chip has the ability to expand a sprite in the vertical direction, the horizontal direction, or both at once."
"[INST]In the context of the C64, what is the opcode for the TXA instruction?[/INST]The opcode for the TXA instruction is 8A, which is used to transfer the value of the X register to the accumulator."
"[INST]In the context of the C64, what is the addressing mode used by the TXA instruction?[/INST]The TXA instruction uses the implied addressing mode, which means that the instruction does not require a memory address as an operand."
"[INST]In the context of the C64, how many bytes are required to store the TXA instruction?[/INST]The TXA instruction requires only 1 byte of memory to store the opcode."
"[INST]In the context of the C64, what is the number of cycles required to execute the TXA instruction?[/INST]The TXA instruction requires 2 cycles to execute, making it a relatively fast instruction."
"[INST]In the context of the C64, what is the purpose of the TXA instruction?[/INST]The TXA instruction is used to transfer the value of the X register to the accumulator, allowing the programmer to manipulate the value in the accumulator."
"[INST]In the context of the C64, can the TXA instruction be used with other addressing modes?[/INST]No, the TXA instruction can only be used with the implied addressing mode, as it does not require a memory address as an operand."
"[INST]In the context of the C64, what is the assembly language form of the TXA instruction?[/INST]The assembly language form of the TXA instruction is simply 'TXA', with no operands required."
"[INST]In the context of the C64, is the TXA instruction commonly used in programming?[/INST]Yes, the TXA instruction is commonly used in programming, particularly when the value of the X register needs to be manipulated or used in calculations."
"[INST]In the context of the C64, can the TXA instruction be used to transfer values from other registers?[/INST]No, the TXA instruction is specifically designed to transfer the value of the X register to the accumulator, and cannot be used to transfer values from other registers."
"[INST]In the context of the C64, what is the relationship between the TXA instruction and the accumulator?[/INST]The TXA instruction transfers the value of the X register to the accumulator, allowing the programmer to manipulate the value in the accumulator and use it in further calculations."
"[INST]In the context of the C64, Can a BRK command be masked by setting I?[/INST]No"
"[INST]In the context of the C64, What is the number of bytes used by the BRK command?[/INST]1"
"[INST]In the context of the C64, What is the number of cycles used by the BRK command?[/INST]7"
"[INST]In the context of the C64, What is the assembly language form of the BRK command?[/INST]BRK"
"[INST]In the context of the C64, What is the operation of the BRK command?[/INST]Forced Interrupt"
"[INST]In the context of the C64, What is the effect of setting I on a BRK command?[/INST]Cannot be masked"
"[INST]In the context of the C64, What is the opcode of the BRK command?[/INST]00"
"[INST]In the context of the C64, What is the addressing mode of the BRK command?[/INST]Implied"
"[INST]In the context of the C64, What is the purpose of the BRK command?[/INST]Forced Interrupt PC + 2 to S P to S"
"[INST]In the context of the C64, What is the number of cycles used by the BRK command in hexadecimal?[/INST]7"
"[INST]In the context of the C64, INC Operates on what type of memory?[/INST]Increment memory by one"
"[INST]In the context of the C64, What is the operation of INC?[/INST]M + 1 -> M"
"[INST]In the context of the C64, What is the purpose of INC?[/INST]Increment memory by one"
"[INST]In the context of the C64, What is the assembly language form of INC?[/INST]INC Oper"
"[INST]In the context of the C64, What is the OP CODE of INC in Zero Page mode?[/INST]E6"
"[INST]In the context of the C64, What is the number of bytes required for INC in Zero Page mode?[/INST]2"
"[INST]In the context of the C64, What is the number of cycles required for INC in Zero Page mode?[/INST]5"
"[INST]In the context of the C64, What is the assembly language form of INC in Absolute mode?[/INST]INC Oper"
"[INST]In the context of the C64, What is the OP CODE of INC in Absolute mode?[/INST]EE"
"[INST]In the context of the C64, What is the number of bytes required for INC in Absolute mode?[/INST]3"
"[INST]In the context of the C64, What is the number of cycles required for INC in Absolute mode?[/INST]6"
"[INST]In the context of the C64, What is the opcode for ASL instruction when using the accumulator as the addressing mode?[/INST]The opcode for ASL instruction when using the accumulator as the addressing mode is 0A."
"[INST]In the context of the C64, What is the number of bytes required for the ASL instruction when using the zero page addressing mode?[/INST]The number of bytes required for the ASL instruction when using the zero page addressing mode is 2."
"[INST]In the context of the C64, What is the number of cycles required for the ASL instruction when using the accumulator as the addressing mode?[/INST]The number of cycles required for the ASL instruction when using the accumulator as the addressing mode is 2."
"[INST]In the context of the C64, What is the assembly language form for the ASL instruction when using the zero page addressing mode?[/INST]The assembly language form for the ASL instruction when using the zero page addressing mode is ASL Oper."
"[INST]In the context of the C64, How many bytes are required for the ASL instruction when using the absolute addressing mode?[/INST]The number of bytes required for the ASL instruction when using the absolute addressing mode is 3."
"[INST]In the context of the C64, What is the opcode for the ASL instruction when using the zero page addressing mode?[/INST]The opcode for the ASL instruction when using the zero page addressing mode is 06."
"[INST]In the context of the C64, What is the number of cycles required for the ASL instruction when using the zero page, X addressing mode?[/INST]The number of cycles required for the ASL instruction when using the zero page, X addressing mode is 6."
"[INST]In the context of the C64, What is the assembly language form for the ASL instruction when using the absolute, X addressing mode?[/INST]The assembly language form for the ASL instruction when using the absolute, X addressing mode is ASL Oper,X."
"[INST]In the context of the C64, What is the opcode for the ASL instruction when using the absolute addressing mode?[/INST]The opcode for the ASL instruction when using the absolute addressing mode is 0E."
"[INST]In the context of the C64, What is the number of bytes required for the ASL instruction when using the zero page, X addressing mode?[/INST]The number of bytes required for the ASL instruction when using the zero page, X addressing mode is 2."
"[INST]In the context of the C64, what is the source of color information in standard bit map mode?[/INST]In standard bit map mode, the color information is derived only from the data stored in the video matrix, and the color nybble is disregarded."
"[INST]In the context of the C64, How are the 8 bits divided in standard bit map mode?[/INST]In standard bit map mode, the 8 bits are divided into two 4-bit nybbles which allow two colors to be independently selected in each 8*8 dot block."
"[INST]In the context of the C64, What determines the output color when a bit in the display memory is a '0'?[/INST]When a bit in the display memory is a '0', the color of the output dot is set by the least significant (lower) nybble (LSN)."
"[INST]In the context of the C64, What determines the output color when a bit in the display memory is a '1'?[/INST]When a bit in the display memory is a '1', the output color is determined by the most significant nybble (MSN)."
"[INST]In the context of the C64, How many colors can be selected in each 8*8 dot block in standard bit map mode?[/INST]In standard bit map mode, two colors can be independently selected in each 8*8 dot block."
"[INST]In the context of the C64, What is the role of the video matrix pointer in standard bit map mode?[/INST]In standard bit map mode, the video matrix pointer is used to determine the display color, with the lower nybble of the video matrix pointer selecting the color when a bit in the display memory is a '0', and the upper nybble selecting the color when a bit in the display memory is a '1'."
"[INST]In the context of the C64, What is the significance of the least significant nybble (LSN) in standard bit map mode?[/INST]In standard bit map mode, the least significant nybble (LSN) determines the output color when a bit in the display memory is a '0'."
"[INST]In the context of the C64, What is the significance of the most significant nybble (MSN) in standard bit map mode?[/INST]In standard bit map mode, the most significant nybble (MSN) determines the output color when a bit in the display memory is a '1'."
"[INST]In the context of the C64, How does the bit value in the display memory affect the output color in standard bit map mode?[/INST]In standard bit map mode, the bit value in the display memory affects the output color, with a '0' selecting the color determined by the LSN and a '1' selecting the color determined by the MSN."
"[INST]In the context of the C64, What is the relationship between the display memory and the video matrix in standard bit map mode?[/INST]In standard bit map mode, the display memory and the video matrix are used together to determine the output color, with the display memory providing the bit values and the video matrix providing the color information."
"[INST]In the context of the C64, What is the opcode for the EOR instruction with immediate addressing mode?[/INST]The opcode for the EOR instruction with immediate addressing mode is 49."
"[INST]In the context of the C64, What is the number of bytes required for the EOR instruction with zero page addressing mode?[/INST]The number of bytes required for the EOR instruction with zero page addressing mode is 2."
"[INST]In the context of the C64, How many cycles does the EOR instruction with absolute addressing mode take?[/INST]The EOR instruction with absolute addressing mode takes 4 cycles."
"[INST]In the context of the C64, What is the assembly language form for the EOR instruction with zero page,X addressing mode?[/INST]The assembly language form for the EOR instruction with zero page,X addressing mode is EOR Oper,X."
"[INST]In the context of the C64, What is the opcode for the EOR instruction with absolute,Y addressing mode?[/INST]The opcode for the EOR instruction with absolute,Y addressing mode is 59."
"[INST]In the context of the C64, How many cycles does the EOR instruction with (indirect,X) addressing mode take?[/INST]The EOR instruction with (indirect,X) addressing mode takes 6 cycles."
"[INST]In the context of the C64, What is the number of bytes required for the EOR instruction with absolute addressing mode?[/INST]The number of bytes required for the EOR instruction with absolute addressing mode is 3."
"[INST]In the context of the C64, What is the assembly language form for the EOR instruction with immediate addressing mode?[/INST]The assembly language form for the EOR instruction with immediate addressing mode is EOR #Oper."
"[INST]In the context of the C64, How many cycles does the EOR instruction with absolute,X addressing mode take if a page boundary is crossed?[/INST]The EOR instruction with absolute,X addressing mode takes 5 cycles if a page boundary is crossed."
"[INST]In the context of the C64, What is the opcode for the EOR instruction with (indirect),Y addressing mode?[/INST]The opcode for the EOR instruction with (indirect),Y addressing mode is 51."
"[INST]In the context of the C64, what is the purpose of poking V+16 with the number of the sprite being used[/INST]The purpose of poking V+16 with the number of the sprite being used is to set the sprite for display beyond the 255th X-position, allowing the sprite to be displayed on the right side of the screen. This is necessary because the X counter starts over from 0 at the 256th position on the screen, and poking V+16 with the sprite number enables the display of the sprite in this region."
"[INST]In the context of the C64, how do you display a sprite beyond the 255th X-position[/INST]To display a sprite beyond the 255th X-position, you need to POKE V+16 with the number of the sprite being used, and then set the X position, taking into account that the X counter starts over from 0 at the 256th position on the screen. For example, to display sprite 0 at X position 24, you would use the following code: POKE V+16,1:POKE V,24:POKE V+1,75."
"[INST]In the context of the C64, what is the effect of poking V+16 with the number of the sprite being used[/INST]Poking V+16 with the number of the sprite being used sets the most significant bit of the X position, allowing the sprite to be displayed beyond the 255th X-position. This enables the sprite to be displayed on the right side of the screen, starting from the 256th pixel position."
"[INST]In the context of the C64, what is the purpose of the X-Y chart in relation to sprite display[/INST]The X-Y chart is used to determine the correct settings for displaying sprites on the screen. The 'RIGHT X' row in the chart provides the necessary information for displaying sprites beyond the 255th X-position, and is used in conjunction with the POKE commands to set the X position and display the sprite correctly."
"[INST]In the context of the C64, how do you determine the correct X position for a sprite beyond the 255th X-position[/INST]To determine the correct X position for a sprite beyond the 255th X-position, you need to take into account that the X counter starts over from 0 at the 256th position on the screen. You can use the X-Y chart to determine the correct settings, and then adjust the X position accordingly. For example, to display sprite 0 at X position 24, you would use the following code: POKE V+16,1:POKE V,24:POKE V+1,75."
"[INST]In the context of the C64, what is the purpose of line 50 in the code[/INST]Line 50 in the code is used to set the X position of the sprite, taking into account that the X counter starts over from 0 at the 256th position on the screen. The code POKE V+16,1:POKE V,24:POKE V+1,75 sets the X position of sprite 0 to 24, which is 24 pixels to the right of the 255th X-position."
"[INST]In the context of the C64, how do you move sprites on the left and right sides of the screen[/INST]To move sprites on the left and right sides of the screen, you need to experiment with the settings in the sprite chart and use the correct POKE commands to set the X position. The section on 'moving sprites' provides additional information on how to move sprites around the screen."
"[INST]In the context of the C64, what is the significance of the 256th pixel position on the screen[/INST]The 256th pixel position on the screen is significant because it marks the point at which the X counter starts over from 0. This means that sprites can be displayed beyond the 255th X-position by setting the most significant bit of the X position and using the correct POKE commands."
"[INST]In the context of the C64, how do you check the right edge of the screen for sprite display[/INST]To check the right edge of the screen for sprite display, you can use the following code: POKE V+16,1:POKE V,65:POKE V+1,75. This code sets the X position of sprite 0 to 65, which is near the right edge of the screen."
"[INST]In the context of the C64, what is the relationship between the X-Y chart and sprite positioning[/INST]The X-Y chart is used to determine the correct settings for displaying sprites on the screen, including positioning beyond the 255th X-position. The chart provides the necessary information for setting the X position and displaying the sprite correctly, taking into account the wrap-around of the X counter at the 256th pixel position."
"[INST]In the context of the C64, what is the purpose of the VIC-II control register at 53269?[/INST]The VIC-II control register at 53269 is used to control the sprites on the Commodore 64, specifically to turn them on or off by setting or clearing the corresponding bit for each sprite."
"[INST]In the context of the C64, how do you turn off a sprite using the VIC-II control register?[/INST]To turn off a sprite, you need to set the corresponding bit in the VIC-II control register at 53269 to 0, which can be achieved using the POKE command with the AND operator to clear the bit, as shown in the following code: POKE 53269,PEEK(53269)AND(255-2^SN), where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, what is the role of the POKE command in turning off a sprite?[/INST]The POKE command is used to set the value of a memory location, in this case, the VIC-II control register at 53269, to turn off a sprite by setting the corresponding bit to 0, effectively disabling the sprite."
"[INST]In the context of the C64, what is the purpose of the PEEK function in the code snippet?[/INST]The PEEK function is used to read the current value of the VIC-II control register at 53269, which is then modified using the AND operator to clear the bit corresponding to the sprite number SN, and then written back to the register using the POKE command."
"[INST]In the context of the C64, what is the significance of the number 255 in the code snippet?[/INST]The number 255 is used as a mask to clear the bit corresponding to the sprite number SN in the VIC-II control register at 53269, by performing a bitwise AND operation with the current value of the register, effectively turning off the sprite."
"[INST]In the context of the C64, how do you specify the sprite number in the code snippet?[/INST]The sprite number SN is specified as a variable in the code snippet, which can take a value from 0 to 7, corresponding to one of the 8 sprites available on the Commodore 64."
"[INST]In the context of the C64, what is the effect of setting a bit in the VIC-II control register to 0?[/INST]Setting a bit in the VIC-II control register to 0 turns off the corresponding sprite, making it invisible on the screen."
"[INST]In the context of the C64, what is the range of values that the sprite number SN can take?[/INST]The sprite number SN can take a value from 0 to 7, corresponding to one of the 8 sprites available on the Commodore 64."
"[INST]In the context of the C64, what is the purpose of the bitwise AND operator in the code snippet?[/INST]The bitwise AND operator is used to clear the bit corresponding to the sprite number SN in the VIC-II control register at 53269, effectively turning off the sprite."
"[INST]In the context of the C64, what is the address of the VIC-II control register used to turn off a sprite?[/INST]The address of the VIC-II control register used to turn off a sprite is 53269, which is equivalent to $D015 in hexadecimal."
"[INST]In the context of the C64, what is the function of the INY instruction in 6502 assembly language?[/INST]The INY instruction increments the Index Y register by one, which is a 8-bit register used to store memory addresses or counters. This instruction is essential in various programming scenarios, such as looping, array indexing, and memory manipulation."
"[INST]In the context of the C64, what is the addressing mode of the INY instruction?[/INST]The addressing mode of the INY instruction is implied, which means that the instruction operates on the Index Y register directly, without the need to specify a memory address or operand."
"[INST]In the context of the C64, what is the opcode of the INY instruction?[/INST]The opcode of the INY instruction is C8, which is a single-byte opcode that represents the instruction in the machine language."
"[INST]In the context of the C64, how many bytes does the INY instruction occupy in memory?[/INST]The INY instruction occupies only 1 byte in memory, making it a compact and efficient instruction."
"[INST]In the context of the C64, how many cycles does the INY instruction take to execute?[/INST]The INY instruction takes 2 cycles to execute, which is relatively fast compared to other instructions that may take more cycles to complete."
"[INST]In the context of the C64, what is the purpose of the Index Y register in 6502 assembly language?[/INST]The Index Y register is an 8-bit register used to store memory addresses or counters, and is essential for various programming tasks, such as looping, array indexing, and memory manipulation."
"[INST]In the context of the C64, can the INY instruction be used for looping?[/INST]Yes, the INY instruction can be used for looping by incrementing the Index Y register, which can be used as a counter to control the loop iterations."
"[INST]In the context of the C64, how can the INY instruction be used for memory manipulation?[/INST]The INY instruction can be used for memory manipulation by incrementing the Index Y register, which can be used as a pointer to access memory locations, allowing for efficient data manipulation and processing."
"[INST]In the context of the C64, what is the difference between the INY and INX instructions?[/INST]The INY instruction increments the Index Y register, while the INX instruction increments the Index X register, which are both 8-bit registers used for different purposes in 6502 assembly language."
"[INST]In the context of the C64, can the INY instruction be used with other instructions to perform complex tasks?[/INST]Yes, the INY instruction can be used with other instructions, such as load and store instructions, to perform complex tasks, such as data processing, array manipulation, and memory management."
"[INST]In the context of the C64, how many bytes are needed to define a sprite?[/INST]A sprite is 24 by 21 dots, or 504 dots, which works out to 63 bytes (504/8 bits)"
"[INST]In the context of the C64, what is the resolution of a multi-color sprite?[/INST]The resolution of the sprite becomes 12 horizontal dots by 21 vertical dots, with each dot in the sprite becoming twice as wide, allowing for 4 colors to be displayed"
"[INST]In the context of the C64, what happens when a bit is set to 0 in a sprite definition?[/INST]Each bit set to 0 is transparent and will display whatever data is behind it"
"[INST]In the context of the C64, how do multi-color sprites trade off resolution for color?[/INST]Horizontal resolution is traded for extra color resolution, allowing for 4 colors to be displayed in the sprite"
"[INST]In the context of the C64, what is the difference between a standard sprite and a multi-color sprite?[/INST]A standard sprite has a higher horizontal resolution, while a multi-color sprite has a lower horizontal resolution but can display more colors"
"[INST]In the context of the C64, what is the size of a sprite in dots?[/INST]A sprite is 24 by 21 dots, or 504 dots"
"[INST]In the context of the C64, how are sprites defined?[/INST]Sprites are defined like programmable characters, but require more bytes due to their larger size"
"[INST]In the context of the C64, what happens when a bit is set to 1 in a sprite definition?[/INST]Each bit set to 1 is displayed in that sprite's foreground color"
"[INST]In the context of the C64, can you explain how a sprite definition block works?[/INST]A sprite definition block works by setting each bit to 0 for transparency or 1 for the foreground color, allowing for the creation of a sprite"
"[INST]In the context of the C64, what is the advantage of using multi-color sprites?[/INST]The advantage of using multi-color sprites is that they can display more colors, making them useful for creating detailed and colorful graphics"
"[INST]In the context of the C64, Each sprite data block is stored in how many consecutive bytes of memory?[/INST]63"
"[INST]In the context of the C64, Where are the sprite pointers stored in memory?[/INST]At the end of the VIDEO MATRIX"
"[INST]In the context of the C64, What is the range of video matrix locations used for sprite pointers?[/INST]$3F8 to $3FF"
"[INST]In the context of the C64, What is the total address field size in bits?[/INST]14"
"[INST]In the context of the C64, What are the bits from the video matrix used for?[/INST]sprite pointer bits"
"[INST]In the context of the C64, What are the bits from the sprite byte counter used for?[/INST]addressing 63 bytes"
"[INST]In the context of the C64, What is the purpose of the sprite pointer bits?[/INST]defining the 14-bit address field"
"[INST]In the context of the C64, What is the purpose of the internally generated sprite counter bits?[/INST]addressing 63 bytes"
"[INST]In the context of the C64, When are the sprite pointers read from the video matrix?[/INST]at the end of every raster line"
"[INST]In the context of the C64, What happens when the Y position register matches the current raster line count?[/INST]actual fetches of sprite data begin"
"[INST]In the context of the C64, What is displayed on each raster line?[/INST]three bytes of sprite data"
"[INST]In the context of the C64, Character display mode fetches what from the VIDEO MATRIX area of memory?[/INST]Character pointers"
"[INST]In the context of the C64, What is the purpose of the 4-bit COLOR NYBBLE associated with each video matrix location?[/INST]Defines one of sixteen colors for each character"
"[INST]In the context of the C64, What is the width of the VIDEO MATRIX memory?[/INST]12 bits"
"[INST]In the context of the C64, What is the range of the 8-bit character pointer?[/INST]0-255"
"[INST]In the context of the C64, What is the purpose of the 3-bit raster counter (RC2-RC0) in the character base address?[/INST]Selects one of the eight character bytes"
"[INST]In the context of the C64, What is the purpose of the 4-bit color nybble in the character display mode?[/INST]Defines the foreground color"
"[INST]In the context of the C64, What is the purpose of the 8-bit character pointer in the character display mode?[/INST]Selects a particular character"
"[INST]In the context of the C64, What is the range of the 3-bit raster counter (RC2-RC0) in the character base address?[/INST]0-7"
"[INST]In the context of the C64, What is the purpose of the 4 MSB of the video matrix address?[/INST]Defines the location of the video matrix within memory"
"[INST]In the context of the C64, What is the purpose of the internal counter (VC9-VC0) in the video matrix address?[/INST]Steps through the 1000 character locations"
"[INST]In the context of the C64, What is the purpose of the 14 address outputs of the 6566/6567?[/INST]Provides additional system memory decodes"
"[INST]In the context of the C64, What is the purpose of the 8-bit character pointer in the character display mode?[/INST]Selects a particular character"
"[INST]In the context of the C64, What is the range of the 4-bit color nybble in the character display mode?[/INST]0-15"
"[INST]In the context of the C64, What is the purpose of the 3 most significant bits (MSB) of the character base address?[/INST]Defines the location of the character base"
"[INST]In the context of the C64, What is the purpose of the 8*8 dot matrix in the character base?[/INST]Stores character definitions"
"[INST]In the context of the C64, What is the purpose of the 8 sequential bytes from the character base in the standard character mode?[/INST]Displays directly on the 8 lines in each character region"
"[INST]In the context of the C64, What is the purpose of the background #0 color in the standard character mode?[/INST]Displays when a '0' bit is present"
"[INST]In the context of the C64, What is the purpose of the color selected by the 4-bit color nybble in the standard character mode?[/INST]Displays when a '1' bit is present"
"[INST]In the context of the C64, What is the purpose of the 4-bit color nybble in the standard character mode?[/INST]Defines the foreground color"
"[INST]In the context of the C64, What is the purpose of the 4-bit color nybble in the character display mode?[/INST]Defines the foreground color"
"[INST]In the context of the C64, What is the purpose of the 8-bit character pointer in the character display mode?[/INST]Selects a particular character"
"[INST]In the context of the C64, What is the purpose of the 3-bit raster counter (RC2-RC0) in the character base address?[/INST]Selects one of the eight character bytes"
"[INST]In the context of the C64, What is the purpose of the 4 MSB of the character base address?[/INST]Defines the location of the character base"
"[INST]In the context of the C64, What is the purpose of the 4-bit color nybble in the standard character mode?[/INST]Defines the foreground color"
"[INST]In the context of the C64, What is the purpose of the 8-bit character pointer in the character display mode?[/INST]Selects a particular character"
"[INST]In the context of the C64, What is the purpose of the 4-bit color nybble in the character display mode?[/INST]Defines the foreground color"
"[INST]In the context of the C64, What is the purpose of the 4-bit color nybble in the standard character mode?[/INST]Defines the foreground color"
"[INST]In the context of the C64, what is a commodore sprite composed of?[/INST]a commodore sprite is composed of tiny dots called pixels, which are essentially the building blocks of the sprite, and by coloring in these pixels, you can create a sprite"
"[INST]In the context of the C64, what is the process of drawing a sprite similar to?[/INST]the process of drawing a sprite is similar to coloring the empty spaces in a coloring book, where you fill in the blank spaces to create a complete image"
"[INST]In the context of the C64, what is the purpose of the spritemaking grid in figure 3-6?[/INST]the spritemaking grid in figure 3-6 is a blank template that represents a sprite, and it is used as a guide to help you create and design your own sprites"
"[INST]In the context of the C64, what do you need to do to draw a sprite?[/INST]to draw a sprite, you need to 'color in' some of the pixels, which means selecting specific pixels and assigning them a color or shade to create the desired image"
"[INST]In the context of the C64, what is the significance of pixels in sprite creation?[/INST]pixels are the fundamental units of a sprite, and by carefully selecting and arranging them, you can create complex and detailed images"
"[INST]In the context of the C64, can you explain the concept of a sprite in simple terms?[/INST]a sprite is essentially a small, movable image that can be used in graphics and games, and it is composed of tiny pixels that are arranged to form a cohesive image"
"[INST]In the context of the C64, what is the role of the spritemaking grid in the sprite creation process?[/INST]the spritemaking grid serves as a guide or template that helps you organize and arrange the pixels to create a sprite, making it easier to design and create complex images"
"[INST]In the context of the C64, how do you create a sprite from a blank template?[/INST]to create a sprite from a blank template, you need to selectively 'color in' the pixels to create the desired image, using the spritemaking grid as a guide"
"[INST]In the context of the C64, what is the relationship between pixels and sprites?[/INST]pixels are the individual components that make up a sprite, and by combining and arranging them in a specific way, you can create a wide range of sprites with unique characteristics"
"[INST]In the context of the C64, what is the purpose of 'coloring in' pixels when creating a sprite?[/INST]the purpose of 'coloring in' pixels is to assign a color or shade to specific pixels, which allows you to create a detailed and complex image from a blank template"
"[INST]In the context of the C64, what is the mnemonic for the instruction that transfers the accumulator to index Y?[/INST]The mnemonic for the instruction that transfers the accumulator to index Y is TAY. This instruction is used to copy the contents of the accumulator to the Y-register. The opcode for this instruction is A8, and it takes 1 byte of memory and 2 clock cycles to execute."
"[INST]In the context of the C64, what is the addressing mode of the TAY instruction?[/INST]The addressing mode of the TAY instruction is implied, which means that the instruction operates on the accumulator and the Y-register implicitly, without the need to specify an explicit memory address."
"[INST]In the context of the C64, what is the opcode for the TAY instruction?[/INST]The opcode for the TAY instruction is A8. This is a single-byte opcode that is used to represent the TAY instruction in machine code."
"[INST]In the context of the C64, how many bytes of memory does the TAY instruction occupy?[/INST]The TAY instruction occupies 1 byte of memory. This is because the opcode for the instruction is a single byte, and there are no additional bytes required to specify an address or operand."
"[INST]In the context of the C64, how many clock cycles does the TAY instruction take to execute?[/INST]The TAY instruction takes 2 clock cycles to execute. This is a relatively fast instruction that can be executed quickly by the CPU."
"[INST]In the context of the C64, what is the purpose of the TAY instruction?[/INST]The purpose of the TAY instruction is to transfer the contents of the accumulator to the Y-register. This allows the programmer to use the Y-register as a temporary storage location or to perform operations on the value in the accumulator."
"[INST]In the context of the C64, can the TAY instruction be used to transfer data between other registers?[/INST]No, the TAY instruction is specifically designed to transfer data from the accumulator to the Y-register. It cannot be used to transfer data between other registers or to load data from memory."
"[INST]In the context of the C64, what is the assembly language form of the TAY instruction?[/INST]The assembly language form of the TAY instruction is simply 'TAY'. This is a single mnemonic that represents the instruction to transfer the accumulator to the Y-register."
"[INST]In the context of the C64, is the TAY instruction a load instruction or a store instruction?[/INST]The TAY instruction is a load instruction, because it loads the value from the accumulator into the Y-register."
"[INST]In the context of the C64, can the TAY instruction be used to perform arithmetic operations?[/INST]No, the TAY instruction is a data transfer instruction, and it does not perform any arithmetic operations. It simply copies the value from the accumulator to the Y-register."
"[INST]In the context of the C64, Is there a pseudo 6551 control register in the RS-232 storage?[/INST]Yes, it is located at $0293-M51CTR-Pseudo 6551 control register."
"[INST]In the context of the C64, What is the purpose of the two bytes following the control and command registers in the file name field?[/INST]They contain the baud rate for the start of the bit test during the interface activity."
"[INST]In the context of the C64, What is the function of the RS-232 status register?[/INST]It is used to calculate baud rate."
"[INST]In the context of the C64, What is the purpose of the number of bits to be sent/received?[/INST]It is used to calculate baud rate."
"[INST]In the context of the C64, What is the purpose of the two bytes that are equal to the time of one bit cell?[/INST]They are used to calculate baud rate."
"[INST]In the context of the C64, What is the purpose of the byte index to the end of the receiver FIFO buffer?[/INST]It is used to calculate baud rate."
"[INST]In the context of the C64, What is the purpose of the byte index to the start of the receiver FIFO buffer?[/INST]It is used to calculate baud rate."
"[INST]In the context of the C64, What is the purpose of the byte index to the start of the transmitter FIFO buffer?[/INST]It is used to calculate baud rate."
"[INST]In the context of the C64, What is the purpose of the byte index to the end of the transmitter FIFO buffer?[/INST]It is used to calculate baud rate."
"[INST]In the context of the C64, What is the function of the CIA #2 ICR?[/INST]It holds current active interrupts in the CIA #2 ICR."
"[INST]In the context of the C64, Is the VIC chip register map a table of registers?[/INST]Yes"
"[INST]In the context of the C64, What is the starting address of the VIC chip register map?[/INST]53248 ($D000)"
"[INST]In the context of the C64, What is the purpose of the SPRITE 0 X register?[/INST]Defines the X coordinate of the first sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 0 Y register?[/INST]Defines the Y coordinate of the first sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 1 X register?[/INST]Defines the X coordinate of the second sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 1 Y register?[/INST]Defines the Y coordinate of the second sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 2 X register?[/INST]Defines the X coordinate of the third sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 2 Y register?[/INST]Defines the Y coordinate of the third sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 3 X register?[/INST]Defines the X coordinate of the fourth sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 3 Y register?[/INST]Defines the Y coordinate of the fourth sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 4 X register?[/INST]Defines the X coordinate of the fifth sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 4 Y register?[/INST]Defines the Y coordinate of the fifth sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 5 X register?[/INST]Defines the X coordinate of the sixth sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 5 Y register?[/INST]Defines the Y coordinate of the sixth sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 6 X register?[/INST]Defines the X coordinate of the seventh sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 6 Y register?[/INST]Defines the Y coordinate of the seventh sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 7 X register?[/INST]Defines the X coordinate of the eighth sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE 7 Y register?[/INST]Defines the Y coordinate of the eighth sprite"
"[INST]In the context of the C64, What is the purpose of the MSB of X register?[/INST]Defines the most significant bit of the X coordinate"
"[INST]In the context of the C64, What is the purpose of the Y SCROLL MODE register?[/INST]Controls the scrolling of the sprites"
"[INST]In the context of the C64, What is the purpose of the RASTER register?[/INST]Controls the raster beam"
"[INST]In the context of the C64, What is the purpose of the LIGHT PEN X register?[/INST]Defines the X coordinate of the light pen"
"[INST]In the context of the C64, What is the purpose of the LIGHT PEN Y register?[/INST]Defines the Y coordinate of the light pen"
"[INST]In the context of the C64, What is the purpose of the SPRITE ENABLE register?[/INST]Enables or disables the sprites"
"[INST]In the context of the C64, What is the purpose of the X SCROLL MODE register?[/INST]Controls the scrolling of the sprites"
"[INST]In the context of the C64, What is the purpose of the SPRITE EXPAND Y register?[/INST]Expands the Y coordinate of the sprites"
"[INST]In the context of the C64, What is the purpose of the SCREEN and CHARACTER MEMORY BASE register?[/INST]Defines the base address of the screen and character memory"
"[INST]In the context of the C64, What is the purpose of the INTERRUPT REQUEST register?[/INST]Requests an interrupt"
"[INST]In the context of the C64, What is the purpose of the IRQ MASKS register?[/INST]Masks the interrupt requests"
"[INST]In the context of the C64, What is the purpose of the BACKGROUND SPRITE register?[/INST]Defines the background sprite"
"[INST]In the context of the C64, What is the purpose of the MULTICOLOR SPRITE SELECT register?[/INST]Selects the color of the sprite"
"[INST]In the context of the C64, What is the purpose of the SPRITE EXPAND X register?[/INST]Expands the X coordinate of the sprites"
"[INST]In the context of the C64, What is the purpose of the SPRITE COLLISION register?[/INST]Detects collisions between sprites"
"[INST]In the context of the C64, What is the purpose of the BORDER COLOR register?[/INST]Defines the color of the border"
"[INST]In the context of the C64, What is the purpose of the BACKGROUND COLOR register?[/INST]Defines the color of the background"
"[INST]In the context of the C64, What is the purpose of the SPRITE COLOR register?[/INST]Defines the color of the sprite"
"[INST]In the context of the C64, what is the serial bus designed for[/INST]a daisy chain arrangement to let the Commodore 64 communicate with devices"
"[INST]In the context of the C64, What is the advantage of the serial bus[/INST]more than one device can be connected to the port"
"[INST]In the context of the C64, How many devices can be connected to the serial bus at one time[/INST]up to 5 devices"
"[INST]In the context of the C64, What are the three types of operation over a serial bus[/INST]CONTROL, TALK, and LISTEN"
"[INST]In the context of the C64, What is a CONTROLLER device[/INST]a device which controls operation of the serial bus"
"[INST]In the context of the C64, What is a TALKER device[/INST]a device that transmits data onto the bus"
"[INST]In the context of the C64, What is a LISTENER device[/INST]a device that receives data from the bus"
"[INST]In the context of the C64, Who is the controller of the serial bus[/INST]the Commodore 64"
"[INST]In the context of the C64, What are the three roles the Commodore 64 plays on the serial bus[/INST]controller, TALKER, and LISTENER"
"[INST]In the context of the C64, What is the purpose of a bus ADDRESS[/INST]to allow the Commodore 64 to route data to its intended destination"
"[INST]In the context of the C64, What is the range of addresses on the serial bus[/INST]from 4 to 31"
"[INST]In the context of the C64, What can the Commodore 64 COMMAND a device to do[/INST]to TALK or LISTEN"
"[INST]In the context of the C64, What happens if more than one device tries to TALK on the bus at the same time[/INST]the system will crash in confusion"
"[INST]In the context of the C64, How many devices can LISTEN to one TALKER at the same time[/INST]any number"
"[INST]In the context of the C64, What is the purpose of the SECONDARY ADDRESS[/INST]to let the Commodore 64 transmit setup information to a device"
"[INST]In the context of the C64, What is an example of using the SECONDARY ADDRESS[/INST]OPEN 1,4,7"
"[INST]In the context of the C64, What are the 6 lines used in serial bus operations[/INST]input and 3 output"
"[INST]In the context of the C64, What are the 3 input lines used for[/INST]data, control, and timing signals into the Commodore 64"
"[INST]In the context of the C64, What are the 3 output lines used for[/INST]data, control, and timing signals from the Commodore 64 to external devices"
"[INST]In the context of the C64, What is the purpose of the serial bus[/INST]to let the Commodore 64 communicate with devices"
"[INST]In the context of the C64, what is the function of bit 0 in CRA?[/INST]1=START TIMER A, 0=STOP TIMER A. This bit is automatically reset when underflow occurs during one-shot mode."
"[INST]In the context of the C64, what is the function of bit 1 in CRA?[/INST]1=TIMER A output appears on PB6, 0=PB6 normal operation."
"[INST]In the context of the C64, what is the function of bit 2 in CRA?[/INST]1=TOGGLE, 0=PULSE"
"[INST]In the context of the C64, what is the function of bit 3 in CRA?[/INST]1=ONE-SHOT, 0=CONTINUOUS"
"[INST]In the context of the C64, what is the function of bit 4 in CRA?[/INST]1=FORCE LOAD (this is a STROBE input, there is no data storage, bit 4 will always read back a zero and writing a zero has no effect)."
"[INST]In the context of the C64, what is the function of bit 5 in CRA?[/INST]1=TIMER A counts positive CNT transitions, 0=TIMER A counts 02 pulses."
"[INST]In the context of the C64, what is the function of bit 6 in CRA?[/INST]1=SERIAL PORT output (CNT sources shift clock), 0=SERIAL PORT input (external shift clock required)."
"[INST]In the context of the C64, what is the function of bit 7 in CRA?[/INST]1=50 Hz clock required on TOD pin for accurate time, 0=60 Hz clock required on TOD pin for accurate time."
"[INST]In the context of the C64, what is the function of bits 0-4 in CRB?[/INST](Bits CRB0-CRB4 are identical to CRA0-CRA4 for TIMER B with the exception that bit 1 controls the output of TIMER B on PB7)."
"[INST]In the context of the C64, what is the function of bits 5-6 in CRB?[/INST]Bits CRB5 and CRB6 select one of four input modes for TIMER B as: CRB6   CRB5 0      0       TIMER B counts 02 pulses. 0      1       TIMER B counts positive CNT transistions. 1      0       TIMER B counts TIMER A underflow pulses. 1      1       TIMER B counts TIMER A underflow pulses while CNT is high."
"[INST]In the context of the C64, what is the function of bit 7 in CRB?[/INST]1=writing to TOD registers sets ALARM, 0=writing to TOD registers sets TOD clock."
"[INST]In the context of the C64, what happens to unused register bits?[/INST]All unused register bits are unaffected by a write and are forced to zero on a read."
"[INST]In the context of the C64, Can the priority of each sprite be individually controlled?[/INST]Yes, the priority of each sprite may be individually controlled with respect to the other displayed information from character or bit map modes."
"[INST]In the context of the C64, What determines the priority of each sprite?[/INST]The priority of each sprite is set by the corresponding bit (MnDP) of register 27 ($1B) as follows:"
"[INST]In the context of the C64, What happens when sprite data bits of '0' are used?[/INST]Sprite data bits of '0' are transparent, always permitting any other information to be displayed."
"[INST]In the context of the C64, What is the highest priority sprite?[/INST]Sprite 0 has the highest priority."
"[INST]In the context of the C64, What happens when two sprites have coincident data?[/INST]When sprite data (except transparent data) of two sprites are coincident, the data from the lower number sprite will be displayed."
"[INST]In the context of the C64, What is the lowest priority sprite?[/INST]Sprite 7 has the lowest priority."
"[INST]In the context of the C64, What is prioritized first in sprite vs. sprite data?[/INST]Sprite vs. sprite data is prioritized before priority resolution with character or bit map data."
"[INST]In the context of the C64, What happens when sprite data is coincident with character or bit map data?[/INST]Sprite vs. sprite data is prioritized before priority resolution with character or bit map data."
"[INST]In the context of the C64, Can transparent sprite data be displayed?[/INST]Yes, transparent sprite data will be displayed."
"[INST]In the context of the C64, What is the purpose of the MnDP register?[/INST]The MnDP register is used to set the priority of each sprite."
"[INST]In the context of the C64, What is the range of sprite numbers?[/INST]The sprites have a fixed priority with respect to each other, with sprite 0 having the highest priority and sprite 7 the lowest."
"[INST]In the context of the C64, what is the function of the MnXE register in the Commodore 64?[/INST]The MnXE register is used to control the horizontal expansion of a sprite, where a value of '1' enables expansion and a value of '0' sets it to normal size."
"[INST]In the context of the C64, How does the vertical expansion of a sprite work on the Commodore 64?[/INST]The vertical expansion of a sprite is controlled by the MnYE register, where a value of '1' enables expansion and a value of '0' sets it to normal size, allowing the sprite to be doubled in the vertical direction."
"[INST]In the context of the C64, What is the effect of expanding a sprite on the Commodore 64?[/INST]Expanding a sprite on the Commodore 64 does not increase the resolution, but rather doubles the overall sprite dimension in the desired direction, with the smallest sprite dot potentially becoming up to 4 times the standard dot dimension if the sprite is both multi-colored and expanded."
"[INST]In the context of the C64, What is the default size of a sprite on the Commodore 64?[/INST]The default size of a sprite on the Commodore 64 is a 24x21 array, which can be doubled in size through expansion."
"[INST]In the context of the C64, How do you enable horizontal expansion of a sprite on the Commodore 64?[/INST]To enable horizontal expansion of a sprite on the Commodore 64, you need to set the MnXE register to '1', which will double the sprite's size in the horizontal direction."
"[INST]In the context of the C64, What is the register address for controlling vertical expansion of a sprite?[/INST]The register address for controlling vertical expansion of a sprite is $1D, which corresponds to the MnYE register."
"[INST]In the context of the C64, What is the effect of setting MnXE to '0'?[/INST]Setting MnXE to '0' sets the sprite to its normal size, disabling horizontal expansion."
"[INST]In the context of the C64, Can a sprite be expanded in both horizontal and vertical directions on the Commodore 64?[/INST]Yes, a sprite can be expanded in both horizontal and vertical directions on the Commodore 64 by setting both MnXE and MnYE registers to '1'."
"[INST]In the context of the C64, What is the size of a multi-colored sprite on the Commodore 64?[/INST]A multi-colored sprite on the Commodore 64 is a 12x21 array, which can be doubled in size through expansion."
"[INST]In the context of the C64, How do you control the magnification of a sprite on the Commodore 64?[/INST]The magnification of a sprite on the Commodore 64 is controlled through the MnXE and MnYE registers, which allow for selective expansion in the horizontal and vertical directions."
"[INST]In the context of the C64, what is the purpose of the OPEN function in C64?[/INST]The purpose of the OPEN function is to open a logical file, which can then be used for input/output operations. This routine is used by most I/O KERNAL routines to create the logical files they operate on."
"[INST]In the context of the C64, what is the call address of the OPEN function in C64?[/INST]The call address of the OPEN function is $FFC0 (hex) or 65472 (decimal)."
"[INST]In the context of the C64, what preparatory routines need to be called before using the OPEN function?[/INST]Before using the OPEN function, both the SETLFS and SETNAM KERNAL routines must be called."
"[INST]In the context of the C64, what error returns can be expected from the OPEN function?[/INST]The OPEN function can return error codes 1, 2, 4, 5, 6, 240, or READST."
"[INST]In the context of the C64, what registers are affected by the OPEN function?[/INST]The OPEN function affects registers A, X, and Y."
"[INST]In the context of the C64, what is the stack requirement for the OPEN function?[/INST]The OPEN function has no stack requirements."
"[INST]In the context of the C64, can arguments be set up before using the OPEN function?[/INST]No arguments need to be set up to use the OPEN function, but the SETLFS and SETNAM routines must be called beforehand."
"[INST]In the context of the C64, what is the role of the OPEN function in I/O operations?[/INST]The OPEN function is used to create logical files, which are then used by most I/O KERNAL routines for input/output operations."
"[INST]In the context of the C64, in what order should the preparatory routines be called before using the OPEN function?[/INST]The correct order is to call the SETLFS routine first, followed by the SETNAM routine, and then the OPEN function."
"[INST]In the context of the C64, why is the OPEN function important in the C64 KERNAL?[/INST]The OPEN function is important because it is used by most I/O KERNAL routines to create the logical files they operate on, and is a crucial step in setting up input/output operations."
"[INST]In the context of the C64, what is the main difference between indexed indirect and indirect indexed addressing modes?[/INST]The main difference between indexed indirect and indirect indexed addressing modes is that in indexed indirect, the zero page address of the pointer is indexed, whereas in indirect indexed, the actual base address is indexed."
"[INST]In the context of the C64, in what scenario would you use indexed indirect addressing mode?[/INST]You would use indexed indirect addressing mode when you have a table of indirect pointers located in zero page memory and you want to specify which indirect pointer to use with the X register."
"[INST]In the context of the C64, what is the role of the X register in indexed indirect addressing mode?[/INST]The X register is used as an index to specify which indirect pointer to use in the zero page memory, allowing you to dynamically change the base address of the indirect pointer."
"[INST]In the context of the C64, how does the indexed indirect addressing mode calculate the actual address?[/INST]The actual address is calculated by taking the contents of the zero page address plus the value of the X register, where the low order byte of the address is taken from the contents of the calculated address and the high order byte is taken from the next byte."
"[INST]In the context of the C64, what is an example of a scenario where indexed indirect addressing mode would be useful?[/INST]An example of a scenario where indexed indirect addressing mode would be useful is when you have a table of function pointers in zero page memory and you want to dynamically call a function based on a variable index."
"[INST]In the context of the C64, what is the equivalent code for the example given in the text?[/INST]The equivalent code for the example given in the text is: LDA #$00, STA $06, LDA #$16, STA $07, LDX #$05, LDA ($02,X)"
"[INST]In the context of the C64, how does the analogy of delivering a letter to a post office relate to indexed indirect addressing mode?[/INST]The analogy of delivering a letter to a post office relates to indexed indirect addressing mode in that the letter (data) is delivered to a post office (indirect address) which then forwards it to the actual address (indirect pointer) specified by the index (X register)."
"[INST]In the context of the C64, in what way is the actual base address different from the indirect address in indexed indirect addressing mode?[/INST]The actual base address is the address of the indirect pointer, whereas the indirect address is the address contained in the indirect pointer, which is the actual address accessed."
"[INST]In the context of the C64, what is the significance of the X register being set to $00 in the example?[/INST]The significance of the X register being set to $00 in the example is that it means the index is not added to the base address, resulting in the actual address being the same as the base address."
"[INST]In the context of the C64, how does the indexed indirect addressing mode handle the high and low order bytes of the address?[/INST]The indexed indirect addressing mode handles the high and low order bytes of the address by taking the low order byte from the contents of the calculated address and the high order byte from the next byte."
"[INST]In the context of the C64, what is the purpose of the SETTIM function?[/INST]The purpose of the SETTIM function is to set the system clock, which is maintained by an interrupt routine that updates the clock every 1/60th of a second (one 'jiffy')."
"[INST]In the context of the C64, what is the call address of the SETTIM function?[/INST]The call address of the SETTIM function is $FFDB in hexadecimal, which is equivalent to 65499 in decimal."
"[INST]In the context of the C64, what are the communication registers used by the SETTIM function?[/INST]The communication registers used by the SETTIM function are A, X, and Y."
"[INST]In the context of the C64, what is the stack requirement for calling the SETTIM function?[/INST]The stack requirement for calling the SETTIM function is 2."
"[INST]In the context of the C64, how does the system clock maintained by the SETTIM function work?[/INST]The system clock maintained by the SETTIM function is a three-byte clock that can count up to 5,184,000 jiffies (24 hours), after which it resets to zero."
"[INST]In the context of the C64, in what order should the registers be loaded when calling the SETTIM function?[/INST]When calling the SETTIM function, the accumulator should be loaded with the most significant byte, the X index register with the next most significant byte, and the Y index register with the least significant byte of the initial time setting (in jiffies)."
"[INST]In the context of the C64, what is the purpose of the interrupt routine used by the SETTIM function?[/INST]The purpose of the interrupt routine used by the SETTIM function is to update the clock every 1/60th of a second (one 'jiffy')."
"[INST]In the context of the C64, how many bytes does the system clock maintained by the SETTIM function consist of?[/INST]The system clock maintained by the SETTIM function consists of three bytes, which gives it the capability to count up to 5,184,000 jiffies (24 hours)."
"[INST]In the context of the C64, what is an example of how to use the SETTIM function?[/INST]An example of how to use the SETTIM function is to load the accumulator with the MSB of the 3-byte number to set the clock, load the X register with the next byte, load the Y register with the LSB, and then call the SETTIM function, as shown in the following example: LDA #0; LDX #>3600; LDY #<3600; JSR SETTIM>."
"[INST]In the context of the C64, what is the significance of the 5,184,000 jiffies count in the SETTIM function?[/INST]The significance of the 5,184,000 jiffies count in the SETTIM function is that it represents the maximum count of the system clock, after which it resets to zero, equivalent to 24 hours."
"[INST]In the context of the C64, what is the operation of the BNE instruction?[/INST]Branch on result not zero"
"[INST]In the context of the C64, what is the condition for the BNE instruction to execute?[/INST]result not zero"
"[INST]In the context of the C64, what is the abbreviation for the BNE instruction?[/INST]BNE"
"[INST]In the context of the C64, what is the purpose of the BNE instruction?[/INST]Branch on result not zero"
"[INST]In the context of the C64, what is the condition for the BNE instruction to execute?[/INST]result not zero"
"[INST]In the context of the C64, what is the operation of the BNE instruction in assembly language?[/INST]BMI Oper"
"[INST]In the context of the C64, what is the opcode for the BNE instruction?[/INST]D0"
"[INST]In the context of the C64, what is the number of bytes required for the BNE instruction?[/INST]2"
"[INST]In the context of the C64, what is the number of cycles required for the BNE instruction?[/INST]2"
"[INST]In the context of the C64, what is the condition for the BNE instruction to execute?[/INST]result not zero"
"[INST]In the context of the C64, DEY operation is used to decrement what index?[/INST]Y"
"[INST]In the context of the C64, DEY operation is used to decrement the index by how many?[/INST]1"
"[INST]In the context of the C64, What is the opcode for DEY operation?[/INST]88"
"[INST]In the context of the C64, How many bytes does DEY operation use?[/INST]1"
"[INST]In the context of the C64, How many cycles does DEY operation take?[/INST]2"
"[INST]In the context of the C64, What is the addressing mode for DEY operation?[/INST]Implied"
"[INST]In the context of the C64, What is the assembly language form for DEY operation?[/INST]DEY"
"[INST]In the context of the C64, What is the operation performed by DEY operation?[/INST]Decrement"
"[INST]In the context of the C64, What is the result of DEY operation?[/INST]Y - 1"
"[INST]In the context of the C64, Is DEY operation used to increment or decrement?[/INST]Decrement"
"[INST]In the context of the C64, What is the purpose of DEY operation?[/INST]To decrement the index Y by one"
"[INST]In the context of the C64, what is the main limitation of standard high-resolution graphics in terms of color control?[/INST]In standard high-resolution graphics, each dot within an 8x8 character can only have either the background color or the foreground color, which limits the color resolution within that space and can cause problems when two different colored lines cross."
"[INST]In the context of the C64, what is the main advantage of multi-color mode over standard high-resolution graphics?[/INST]Multi-color mode allows each dot to be one of four colors: screen color, background color register #1, background color register #2, or character color, which provides more color resolution and flexibility than standard high-resolution graphics."
"[INST]In the context of the C64, how does multi-color mode affect the horizontal resolution compared to standard high-resolution graphics?[/INST]In multi-color mode, each dot is twice as wide as a high-resolution dot, which results in a minimal loss of horizontal resolution compared to standard high-resolution graphics."
"[INST]In the context of the C64, in what way does the color of a dot in standard high-resolution graphics depend on its value?[/INST]In standard high-resolution graphics, when a dot is off (value 0), the color of the screen is used in the space reserved for that dot, and when a dot is on (value 1), the dot is colored with the character color chosen for that screen position."
"[INST]In the context of the C64, what is the purpose of background color registers in multi-color mode?[/INST]In multi-color mode, background color registers #1 and #2 allow for two additional colors to be used for each dot, providing more color flexibility and resolution than standard high-resolution graphics."
"[INST]In the context of the C64, how does the character color relate to the dot color in standard high-resolution graphics?[/INST]In standard high-resolution graphics, when a dot is on, the dot is colored with the character color chosen for that screen position."
"[INST]In the context of the C64, what is the main difference between multi-color mode and standard high-resolution graphics in terms of color control?[/INST]Multi-color mode allows each dot to be one of four colors, while standard high-resolution graphics only allow each dot to be either the background color or the character color."
"[INST]In the context of the C64, in what way does multi-color mode compensate for the minimal loss of horizontal resolution?[/INST]The extra abilities of multi-color mode, such as the ability to use four different colors for each dot, more than compensate for the minimal loss of horizontal resolution."
"[INST]In the context of the C64, what is the main advantage of using multi-color mode over standard high-resolution graphics for graphics design?[/INST]Multi-color mode provides more color flexibility and resolution than standard high-resolution graphics, making it a better choice for graphics design that requires more complex and detailed color schemes."
"[INST]In the context of the C64, how does the screen color relate to the dot color in standard high-resolution graphics?[/INST]In standard high-resolution graphics, when a dot is off, the color of the screen is used in the space reserved for that dot."
"[INST]In the context of the C64, what are the primary uses of the 6566/6567 devices?[/INST]The 6566/6567 devices are multi-purpose color video controller devices, primarily used in both computer video terminals and video game applications, making them versatile components for a wide range of applications."
"[INST]In the context of the C64, how do the 6566/6567 devices interface with a microprocessor?[/INST]The 6566/6567 devices interface with a microprocessor via a standard 8-bit microprocessor bus (65XX), allowing for seamless communication and control between the two components."
"[INST]In the context of the C64, what is the maximum amount of memory that the 6566/6567 devices can access?[/INST]The 6566/6567 devices can access up to 16K of memory for display information, providing a significant amount of storage for graphics and video data."
"[INST]In the context of the C64, how many control registers do the 6566/6567 devices contain?[/INST]The 6566/6567 devices contain 47 control registers, which can be accessed and configured to customize the behavior of the devices and optimize their performance."
"[INST]In the context of the C64, in what type of applications are the 6566/6567 devices commonly used?[/INST]The 6566/6567 devices are commonly used in computer video terminals and video game applications, where high-quality video and graphics are essential for an engaging user experience."
"[INST]In the context of the C64, what is the primary function of the control registers in the 6566/6567 devices?[/INST]The primary function of the control registers in the 6566/6567 devices is to provide a means of configuring and customizing the behavior of the devices, allowing developers to fine-tune their performance and optimize their operation."
"[INST]In the context of the C64, how do the 6566/6567 devices manage display information?[/INST]The 6566/6567 devices manage display information by accessing up to 16K of memory, which is used to store graphics and video data, and by providing a range of operating modes and options to customize the display."
"[INST]In the context of the C64, what is the significance of the 65XX microprocessor bus in the 6566/6567 devices?[/INST]The 65XX microprocessor bus is a standard interface that allows the 6566/6567 devices to communicate with a microprocessor, enabling the exchange of data and control signals between the two components."
"[INST]In the context of the C64, in what ways can the 6566/6567 devices be customized?[/INST]The 6566/6567 devices can be customized through the use of their 47 control registers, which provide a range of options for configuring and optimizing their behavior, as well as through the selection of various operating modes and options."
"[INST]In the context of the C64, what is the advantage of using the 6566/6567 devices in video game applications?[/INST]The advantage of using the 6566/6567 devices in video game applications is that they provide high-quality video and graphics capabilities, which are essential for creating an engaging and immersive gaming experience."
"[INST]In the context of the C64, Extended color mode is turned OFF by setting what bit of the VIC-II register?[/INST]bit 6"
"[INST]In the context of the C64, What is the location of the VIC-II register that needs to be modified to turn off extended color mode?[/INST]53265"
"[INST]In the context of the C64, What is the hexadecimal value that needs to be written to the VIC-II register to turn off extended color mode?[/INST]191"
"[INST]In the context of the C64, What is the condition to turn off extended color mode?[/INST]setting bit 6 of the VIC-II register to a 0"
"[INST]In the context of the C64, What is the statement that turns off extended color mode?[/INST]POKE 53265,PEEK(53265)AND 191"
"[INST]In the context of the C64, What is the register that needs to be modified to turn off extended color mode?[/INST]VIC-II register"
"[INST]In the context of the C64, how do I turn off extended color mode on a commodore 64[/INST]To turn off extended color mode on a Commodore 64, you need to set bit 6 of the VIC-II register to 0 at location 53265 ($D011). This can be achieved by using the following statement: POKE 53265,PEEK(53265)AND 191. This statement uses the PEEK function to read the current value at location 53265, performs a bitwise AND operation with 191 to clear bit 6, and then uses the POKE function to write the result back to location 53265, effectively turning off extended color mode."
"[INST]In the context of the C64, what is the purpose of the VIC-II register in a commodore 64[/INST]The VIC-II register is a crucial component of the Commodore 64's graphics and video system. It is responsible for controlling the video output, including the display of graphics, text, and colors. The register is located at memory address 53265 ($D011) and contains various bits that control different aspects of the video system, including the extended color mode, which can be turned off by setting bit 6 to 0."
"[INST]In the context of the C64, what is the function of the PEEK function in the commodore 64[/INST]The PEEK function in the Commodore 64 is used to read the value stored at a specific memory address. It is often used in conjunction with the POKE function, which writes a value to a specific memory address. In the context of turning off extended color mode, the PEEK function is used to read the current value at location 53265, which is then modified using a bitwise AND operation before being written back to the same location using the POKE function."
"[INST]In the context of the C64, what is the purpose of the bitwise AND operation in the statement POKE 53265,PEEK(53265)AND 191[/INST]The bitwise AND operation in the statement POKE 53265,PEEK(53265)AND 191 is used to clear bit 6 of the value read from location 53265. The value 191 is a binary mask that has all bits set to 1 except for bit 6, which is set to 0. When this value is used in a bitwise AND operation with the value read from location 53265, it effectively clears bit 6, turning off extended color mode."
"[INST]In the context of the C64, what is the significance of memory address 53265 in the commodore 64[/INST]Memory address 53265 ($D011) is a crucial location in the Commodore 64's memory map. It is the location of the VIC-II register, which controls various aspects of the video system, including the display of graphics, text, and colors. The value stored at this location determines the state of the video system, including whether extended color mode is enabled or disabled."
"[INST]In the context of the C64, how do I use the POKE function to write a value to a memory address in commodore 64 basic[/INST]The POKE function is used in Commodore 64 BASIC to write a value to a specific memory address. The syntax for the POKE function is POKE address, value, where address is the memory address to write to, and value is the value to be written. For example, the statement POKE 53265,PEEK(53265)AND 191 writes the result of the bitwise AND operation to location 53265, effectively turning off extended color mode."
"[INST]In the context of the C64, what is the difference between the PEEK and POKE functions in commodore 64 basic[/INST]The PEEK and POKE functions in Commodore 64 BASIC are used to read and write values to specific memory addresses, respectively. The PEEK function is used to read the value stored at a specific memory address, while the POKE function is used to write a value to a specific memory address. In the context of turning off extended color mode, the PEEK function is used to read the current value at location 53265, and the POKE function is used to write the modified value back to the same location."
"[INST]In the context of the C64, what is the purpose of bit 6 in the VIC-II register in a commodore 64[/INST]Bit 6 of the VIC-II register in a Commodore 64 controls the extended color mode. When bit 6 is set to 1, extended color mode is enabled, and when it is set to 0, extended color mode is disabled. The statement POKE 53265,PEEK(53265)AND 191 clears bit 6, turning off extended color mode."
"[INST]In the context of the C64, what is the significance of the hexadecimal value $D011 in the commodore 64[/INST]The hexadecimal value $D011 is the memory address of the VIC-II register in the Commodore 64. This register controls various aspects of the video system, including the display of graphics, text, and colors. The value stored at this location determines the state of the video system, including whether extended color mode is enabled or disabled."
"[INST]In the context of the C64, how do I modify the VIC-II register to turn off extended color mode in a commodore 64[/INST]To turn off extended color mode in a Commodore 64, you need to modify the VIC-II register by clearing bit 6. This can be achieved by using the following statement: POKE 53265,PEEK(53265)AND 191. This statement uses the PEEK function to read the current value at location 53265, performs a bitwise AND operation with 191 to clear bit 6, and then uses the POKE function to write the result back to location 53265, effectively turning off extended color mode."
"[INST]In the context of the C64, Multi-color mode allows how many different colors in each sprite?[/INST]up to 4"
"[INST]In the context of the C64, What happens to the horizontal resolution in multi-color mode?[/INST]it is cut in half"
"[INST]In the context of the C64, What is the term for a pair of dots in multi-color mode?[/INST]a bit pair"
"[INST]In the context of the C64, What is the total number of dots across the sprite in multi-color mode?[/INST]12 pairs"
"[INST]In the context of the C64, What is the term for the values needed to turn ON each of the four colors?[/INST]bit pair values"
"[INST]In the context of the C64, What is the purpose of the sprite foreground color?[/INST]it is a 10"
"[INST]In the context of the C64, What is the purpose of the character foreground color?[/INST]it is a 11"
"[INST]In the context of the C64, POTY is used for[/INST]POTY (Register $1A) is used for tying the clock signal to the POTX pin 23."
"[INST]In the context of the C64, Pin 23 is used for[/INST]Pin 23 is used for tying the clock signal to POTY."
"[INST]In the context of the C64, POTY is tied to[/INST]POTY is tied to pin 23."
"[INST]In the context of the C64, POTX is same as[/INST]POTX is same as POTY for the pot tied to POTY."
"[INST]In the context of the C64, POTY is register[/INST]POTY is a register $1A."
"[INST]In the context of the C64, Pin 23 is tied to[/INST]Pin 23 is tied to POTY."
"[INST]In the context of the C64, POTY is used for what[/INST]POTY is used for tying the clock signal to the POTX pin 23."
"[INST]In the context of the C64, POTY is register $1A[/INST]POTY is a register $1A."
"[INST]In the context of the C64, POTX is tied to[/INST]POTX is tied to POTY pin 23."
"[INST]In the context of the C64, what is smooth scrolling?[/INST]Smooth scrolling is a one pixel movement of the entire screen in one direction."
"[INST]In the context of the C64, what directions can smooth scrolling move?[/INST]It can move either UP, or down, or left, or right."
"[INST]In the context of the C64, what is the purpose of smooth scrolling?[/INST]It is used to move new information smoothly onto the screen, while smoothly removing characters from the other side."
"[INST]In the context of the C64, what chip supports smooth scrolling?[/INST]The VIC-II chip supports smooth scrolling in both the horizontal and vertical directions."
"[INST]In the context of the C64, how many horizontal positions can the VIC-II chip place the video screen in?[/INST]The VIC-II chip features the ability to place the video screen in any of 8 horizontal positions."
"[INST]In the context of the C64, how many vertical positions can the VIC-II chip place the video screen in?[/INST]The VIC-II chip features the ability to place the video screen in any of 8 vertical positions."
"[INST]In the context of the C64, what is the purpose of the 38 column mode?[/INST]The 38 column mode is used to give you a place for your new data to scroll on from."
"[INST]In the context of the C64, what is the purpose of the 24 row mode?[/INST]The 24 row mode is used to give you a place for your new data to scroll on from."
"[INST]In the context of the C64, how do you go into 38 column mode?[/INST]To go into 38 column mode, bit 3 of location 53270 ($D016) must be set to a 0."
"[INST]In the context of the C64, how do you return to 40 column mode?[/INST]To return to 40 column mode, set bit 3 of location 53270 ($D016) to a 1."
"[INST]In the context of the C64, how do you go into 24 row mode?[/INST]To go into 24 row mode, bit 3 of location 53265 ($D011) must be set to a 0."
"[INST]In the context of the C64, how do you return to 25 row mode?[/INST]To return to 25 row mode, set bit 3 of location 53265 ($D011) to a 1."
"[INST]In the context of the C64, what is necessary when scrolling in the X direction?[/INST]When scrolling in the X direction, it is necessary to place the VIC-II chip into 38 column mode."
"[INST]In the context of the C64, where should new data be placed when scrolling LEFT?[/INST]When scrolling LEFT, the new data should be placed on the right."
"[INST]In the context of the C64, where should new data be placed when scrolling RIGHT?[/INST]When scrolling RIGHT the new data should be placed on the left."
"[INST]In the context of the C64, what is necessary when scrolling in the Y direction?[/INST]When scrolling in the Y direction, it is necessary to place the VIC-II chip into 24 row mode."
"[INST]In the context of the C64, where should new data be placed when scrolling UP?[/INST]When scrolling UP, place the new data in the LAST row."
"[INST]In the context of the C64, where should new data be placed when scrolling DOWN?[/INST]When scrolling DOWN, place the new data on the FIRST row."
"[INST]In the context of the C64, where is the scroll register located for X direction scrolling?[/INST]For scrolling in the X direction, the scroll register is located in bits 2 to 0 of the VIC-II control register at location 53270 ($D016 in HEX)."
"[INST]In the context of the C64, where is the scroll register located for Y direction scrolling?[/INST]For scrolling in the Y direction, the scroll register is located in bits 2 to 0 of the VIC-II control register at location 53265 ($D011 in HEX)."
"[INST]In the context of the C64, how do you scroll text onto the screen from the bottom?[/INST]To scroll text onto the screen from the bottom, you would step the low-order 3 bits of location 53265 from 0-7, put more data on the covered line at the bottom of the screen, and then repeat the process."
"[INST]In the context of the C64, how do you scroll characters onto the screen from left to right?[/INST]To scroll characters onto the screen from left to right, you would step the low-order 3 bits of location 53270 from 0 to 7, print or POKE another column of new data into column 0 of the screen, then repeat the process."
"[INST]In the context of the C64, what happens if you step the scroll bits by -1?[/INST]If you step the scroll bits by -1, your text will move in the opposite direction."
"[INST]In the context of the C64, what is the purpose of the VIC-II scrolling registers?[/INST]The VIC-II scrolling registers control the positioning of the video screen."
"[INST]In the context of the C64, what is the range of values for the X position of the screen?[/INST]The X position of the screen can be set to a value from 0 to 7."
"[INST]In the context of the C64, what is the range of values for the Y position of the screen?[/INST]The Y position of the screen can be set to a value from 0 to 7."
"[INST]In the context of the C64, what is the purpose of the machine language program in smooth scrolling?[/INST]The machine language program is used to shift the entire screen one entire character in the direction of the scroll."
"[INST]In the context of the C64, what is the chip responsible for the Commodore 64's graphics abilities?[/INST]The 6567 Video Interface Chip, also known as the VIC-II chip, is responsible for the Commodore 64's graphics abilities, providing a variety of graphics modes including text display, high resolution display, and SPRITES."
"[INST]In the context of the C64, what are the three main categories of graphics modes provided by the VIC-II chip?[/INST]The VIC-II chip provides three main categories of graphics modes: CHARACTER DISPLAY MODES, BIT MAP MODES, and SPRITES, each with its own sub-modes and features."
"[INST]In the context of the C64, what are the two types of character modes in the CHARACTER DISPLAY MODES category?[/INST]The CHARACTER DISPLAY MODES category has two types of character modes: Standard Character Mode and Multi-Color Character Mode, each with ROM characters and RAM programmable characters options."
"[INST]In the context of the C64, what is the difference between Standard Character Mode and Multi-Color Character Mode?[/INST]The main difference between Standard Character Mode and Multi-Color Character Mode is that Multi-Color Character Mode allows for more colorful and detailed characters, while Standard Character Mode has limited color options."
"[INST]In the context of the C64, what is the Extended Background Color Mode used for?[/INST]The Extended Background Color Mode is used to set a background color for the entire screen, allowing for more colorful and visually appealing graphics."
"[INST]In the context of the C64, what are the two types of BIT MAP MODES provided by the VIC-II chip?[/INST]The BIT MAP MODES category has two types of modes: Standard Bit Map Mode and Multi-Color Bit Map Mode, each providing high-resolution graphics capabilities."
"[INST]In the context of the C64, what is the main advantage of using SPRITES in graphics programming?[/INST]The main advantage of using SPRITES in graphics programming is that they allow for small, movable objects to be easily created and manipulated on the screen, making game development and animation easier."
"[INST]In the context of the C64, can SPRITES be used in combination with other graphics modes?[/INST]Yes, SPRITES can be used in combination with other graphics modes, allowing for complex and visually appealing graphics to be created."
"[INST]In the context of the C64, what is the main difference between Standard Sprites and Multi-Color Sprites?[/INST]The main difference between Standard Sprites and Multi-Color Sprites is that Multi-Color Sprites allow for more colorful and detailed sprites, while Standard Sprites have limited color options."
"[INST]In the context of the C64, what is an example of combining different graphics modes on the same screen?[/INST]An example of combining different graphics modes on the same screen is defining the top half of the screen to be in high resolution mode, while the bottom half is in text mode, and adding SPRITES to create a visually appealing and interactive graphics display."
"[INST]In the context of the C64, Can the POTX register read the position of a potentiometer?[/INST]This register allows the microprocessor to read the position of the potentiometer tied to POTX (pin 24)"
"[INST]In the context of the C64, What is the range of values for the POTX register?[/INST]values ranging from 0 at minimum resistance, to 255 ($FF) at maximum resistance"
"[INST]In the context of the C64, What is the minimum value for the POTX register?[/INST]0 at minimum resistance"
"[INST]In the context of the C64, What is the maximum value for the POTX register?[/INST]255 ($FF) at maximum resistance"
"[INST]In the context of the C64, What is the validity of the POTX register value?[/INST]The value is always valid"
"[INST]In the context of the C64, How often is the POTX register value updated?[/INST]updated every 512 (02 clock cycles"
"[INST]In the context of the C64, What is the clock cycle frequency for POTX register updates?[/INST]02 clock cycles"
"[INST]In the context of the C64, What is the purpose of the POTX register?[/INST]allows the microprocessor to read the position of the potentiometer"
"[INST]In the context of the C64, What is the pin number for the POTX register?[/INST]pin 24"
"[INST]In the context of the C64, What is the unit of measurement for the POTX register?[/INST]resistance"
"[INST]In the context of the C64, How do you switch a sprite into multi-color mode?[/INST]To switch a sprite into multi-color mode you must turn ON the VIC-II control register at location 53276 ($D01C)."
"[INST]In the context of the C64, What is the location of the VIC-II control register?[/INST]53276 ($D01C)"
"[INST]In the context of the C64, What is the POKE command to switch a sprite into multi-color mode?[/INST]POKE 53276,PEEK(53276)OR(2^SN)"
"[INST]In the context of the C64, What is the POKE command to switch a sprite out of multi-color mode?[/INST]POKE 53276,PEEK(53276)AND(255-2^SN)"
"[INST]In the context of the C64, What is the condition to switch a sprite into multi-color mode?[/INST]To turn ON the VIC-II control register at location 53276 ($D01C)"
"[INST]In the context of the C64, What is the condition to switch a sprite out of multi-color mode?[/INST]To turn OFF the VIC-II control register at location 53276 ($D01C)"
"[INST]In the context of the C64, What is bit mapping in the context of graphics?[/INST]Bit mapping is the method in which each possible dot (pixel) of resolution on the screen is assigned its own bit (location) in memory."
"[INST]In the context of the C64, What is the main advantage of using bit mapping?[/INST]The main advantage is that it allows for high-resolution displays."
"[INST]In the context of the C64, Why is bit mapping not used all the time?[/INST]It takes lots of memory to bit map the entire screen."
"[INST]In the context of the C64, How much memory is needed to map the whole screen?[/INST]8000 bytes of memory are needed to map the whole screen."
"[INST]In the context of the C64, What is the resolution of the Commodore 64 screen?[/INST]The resolution is 320 pixels by 200 pixels for the whole screen."
"[INST]In the context of the C64, Why are high-resolution operations slow in BASIC?[/INST]High-resolution operations are slow in BASIC because they are made of many short, simple, repetitive routines."
"[INST]In the context of the C64, What is the solution to the slow performance of high-resolution operations in BASIC?[/INST]The solution is to either write your programs entirely in machine language, or call machine language, high-resolution sub-routines from your BASIC program using the SYS command from BASIC."
"[INST]In the context of the C64, What is the VSP cartridge used for?[/INST]The VSP cartridge is used to add high-resolution commands to COMMODORE 64 BASIC."
"[INST]In the context of the C64, What is the main difference between writing in BASIC and machine language?[/INST]Machine language is faster than BASIC for graphics."
"[INST]In the context of the C64, What is the main advantage of using machine language for graphics?[/INST]Machine language is faster than BASIC for graphics."
"[INST]In the context of the C64, What is the main disadvantage of using machine language for graphics?[/INST]Machine language is more difficult to write than BASIC for graphics."
"[INST]In the context of the C64, What is the main advantage of using the SYS command?[/INST]The main advantage is that it allows you to call machine language, high-resolution sub-routines from your BASIC program."
"[INST]In the context of the C64, What is the main disadvantage of using the SYS command?[/INST]The main disadvantage is that it requires you to write your programs in machine language."
"[INST]In the context of the C64, What is the main advantage of using the VSP cartridge?[/INST]The main advantage is that it adds high-resolution commands to COMMODORE 64 BASIC."
"[INST]In the context of the C64, What is the main disadvantage of using the VSP cartridge?[/INST]The main disadvantage is that it requires additional hardware."
"[INST]In the context of the C64, What is the main advantage of using high-resolution graphics?[/INST]The main advantage is that it allows for high-resolution displays."
"[INST]In the context of the C64, What is the main disadvantage of using high-resolution graphics?[/INST]The main disadvantage is that it takes lots of memory to bit map the entire screen."
"[INST]In the context of the C64, What is the main advantage of using machine language for graphics?[/INST]Machine language is faster than BASIC for graphics."
"[INST]In the context of the C64, What is the main disadvantage of using machine language for graphics?[/INST]Machine language is more difficult to write than BASIC for graphics."
"[INST]In the context of the C64, What is the main advantage of using the SYS command?[/INST]The main advantage is that it allows you to call machine language, high-resolution sub-routines from your BASIC program."
"[INST]In the context of the C64, What is the main disadvantage of using the SYS command?[/INST]The main disadvantage is that it requires you to write your programs in machine language."
"[INST]In the context of the C64, What is the instruction to call a subroutine in machine language?[/INST]JSR (Jump to Sub-Routine)"
"[INST]In the context of the C64, What is the address of the machine language subroutine that prints a character to the screen?[/INST]$FFD2"
"[INST]In the context of the C64, What is the purpose of the CBM ASCII code in the accumulator before calling the print subroutine?[/INST]To specify the character to be printed"
"[INST]In the context of the C64, what is DEX doing?[/INST]Operation:  X - 1 -> X"
"[INST]In the context of the C64, DEX: OP CODE[/INST]CA"
"[INST]In the context of the C64, DEX: No. Bytes[/INST]1"
"[INST]In the context of the C64, DEX: No. Cycles[/INST]2"
"[INST]In the context of the C64, DEX: Addressing Mode[/INST]Implied"
"[INST]In the context of the C64, DEX: Assembly Language Form[/INST]DEX"
"[INST]In the context of the C64, DEX: Operation[/INST]X - 1 -> X"
"[INST]In the context of the C64, DEX: Number of Cycles[/INST]2"
"[INST]In the context of the C64, DEX: Number of Bytes[/INST]1"
"[INST]In the context of the C64, DEX: OP CODE[/INST]CA"
"[INST]In the context of the C64, Is the BMI operation used in assembly language?[/INST]Yes, it is used in BMI Oper"
"[INST]In the context of the C64, What is the OP CODE for the BMI operation?[/INST]The OP CODE is 30"
"[INST]In the context of the C64, What is the number of bytes used by the BMI operation?[/INST]The number of bytes is 2"
"[INST]In the context of the C64, What is the number of cycles used by the BMI operation?[/INST]The number of cycles is 2"
"[INST]In the context of the C64, Is the BMI operation used in relative addressing mode?[/INST]Yes, it is used in relative addressing mode"
"[INST]In the context of the C64, What is the purpose of adding 1 if the branch occurs to the same page?[/INST]To add 1 if branch occurs to same page"
"[INST]In the context of the C64, What is the purpose of adding 1 if the branch occurs to a different page?[/INST]To add 1 if branch occurs to different page"
"[INST]In the context of the C64, What is the purpose of the BMI operation?[/INST]To branch on result minus BMI"
"[INST]In the context of the C64, Is the BMI operation used in assembly language form?[/INST]Yes, it is used in assembly language form"
"[INST]In the context of the C64, What is the number of cycles used by the BMI operation when branching to the same page?[/INST]The number of cycles is 2*"
"[INST]In the context of the C64, what is the opcode for the php instruction in 6502 assembly language?[/INST]the opcode for the php instruction in 6502 assembly language is 08, which stands for push processor status on stack, and it takes 1 byte and 3 cycles to execute."
"[INST]In the context of the C64, what is the addressing mode for the php instruction in 6502 assembly language?[/INST]the addressing mode for the php instruction in 6502 assembly language is implied, which means that the instruction operates on the accumulator implicitly."
"[INST]In the context of the C64, what is the assembly language form of the php instruction in 6502 assembly language?[/INST]the assembly language form of the php instruction in 6502 assembly language is simply 'php', which is used to push the processor status onto the stack."
"[INST]In the context of the C64, what is the purpose of the php instruction in 6502 assembly language?[/INST]the purpose of the php instruction in 6502 assembly language is to push the processor status onto the stack, which is useful for saving the current state of the processor and restoring it later."
"[INST]In the context of the C64, how many bytes does the php instruction occupy in 6502 assembly language?[/INST]the php instruction occupies 1 byte in 6502 assembly language, making it a compact and efficient instruction."
"[INST]In the context of the C64, how many cycles does the php instruction take to execute in 6502 assembly language?[/INST]the php instruction takes 3 cycles to execute in 6502 assembly language, making it a relatively fast instruction."
"[INST]In the context of the C64, what is the effect of the php instruction on the stack in 6502 assembly language?[/INST]the effect of the php instruction is to push the processor status onto the stack, which means that the current state of the processor is saved onto the stack."
"[INST]In the context of the C64, can the php instruction be used to save the current state of the processor in 6502 assembly language?[/INST]yes, the php instruction can be used to save the current state of the processor by pushing the processor status onto the stack, which can be restored later using the plp instruction."
"[INST]In the context of the C64, what is the relationship between the php instruction and the plp instruction in 6502 assembly language?[/INST]the php instruction is used to push the processor status onto the stack, while the plp instruction is used to pull the processor status from the stack, effectively restoring the previous state of the processor."
"[INST]In the context of the C64, why is the php instruction important in 6502 assembly language?[/INST]the php instruction is important in 6502 assembly language because it allows the programmer to save the current state of the processor and restore it later, which is essential for implementing complex algorithms and subroutines."
"[INST]In the context of the C64, What is the purpose of the 6566/6567 devices?[/INST]multi-purpose color video controller devices for use in both computer video terminals and video game applications"
"[INST]In the context of the C64, What is the size of the memory that can be accessed by the devices?[/INST]up to 16K of memory for display information"
"[INST]In the context of the C64, What type of bus is used to access the control registers?[/INST]a standard 8-bit microprocessor bus (65XX)"
"[INST]In the context of the C64, How many control registers are present in the devices?[/INST]47 control registers"
"[INST]In the context of the C64, What is the purpose of the microprocessor bus in the devices?[/INST]to access the control registers"
"[INST]In the context of the C64, What are the two types of sprite collision?[/INST]Sprite to sprite collision and sprite to display data collision."
"[INST]In the context of the C64, What is the purpose of the sprite-DATA COLLISION register?[/INST]To detect sprite to display data collisions."
"[INST]In the context of the C64, What happens when a collision occurs between two sprites?[/INST]The sprite bits (MnM) in the sprite-sprite COLLISION register are set to '1' for both colliding sprites."
"[INST]In the context of the C64, What happens when a collision occurs between a sprite and foreground display data?[/INST]The sprite-DATA COLLISION register has a 'bit (MnD) for each sprite which is set to '1' when both the sprite and non-background display data are coincident."
"[INST]In the context of the C64, Can transparent data generate a collision?[/INST]No, coincidence of transparent data will not generate a collision."
"[INST]In the context of the C64, Can a sprite-DATA collision occur off-screen?[/INST]Yes, a sprite-DATA collision can occur off-screen in the horizontal direction if actual display data has been scrolled to an off-screen position."
"[INST]In the context of the C64, What happens when the first bit of either register is set to '1'?[/INST]The collision interrupt latches are set."
"[INST]In the context of the C64, Do subsequent collisions set the interrupt latch?[/INST]No, subsequent collisions will not set the interrupt latch until that collision register has been cleared to all '0s' by a read."
"[INST]In the context of the C64, What happens when a collision register is read?[/INST]The collision bits are automatically cleared."
"[INST]In the context of the C64, Can a sprite collision occur off-screen?[/INST]Yes, sprites collisions are detected even if positioned off-screen."
"[INST]In the context of the C64, What is the purpose of the scrolling feature?[/INST]To allow sprite collisions to be detected even if positioned off-screen."
"[INST]In the context of the C64, Can the 0-1 multicolor bit pair be used as background display data?[/INST]Yes, the 0-1 multicolor bit pair can be used as background display data without interfering with true sprite collisions."
"[INST]In the context of the C64, What is the purpose of the scrolling feature in sprite collisions?[/INST]To allow sprite collisions to be detected even if positioned off-screen."
"[INST]In the context of the C64, Can a sprite-DATA collision occur off-screen?[/INST]Yes, a sprite-DATA collision can occur off-screen in the horizontal direction if actual display data has been scrolled to an off-screen position."
"[INST]In the context of the C64, What happens when a collision register is read?[/INST]The collision bits are automatically cleared."
"[INST]In the context of the C64, Can a sprite collision occur off-screen in the vertical direction?[/INST]No, sprite collisions are detected even if positioned off-screen, but not in the vertical direction."
"[INST]In the context of the C64, What is the purpose of the sprite-sprite COLLISION register?[/INST]To detect sprite to sprite collisions."
"[INST]In the context of the C64, What is the purpose of the sprite-DATA COLLISION register?[/INST]To detect sprite to display data collisions."
"[INST]In the context of the C64, Can a sprite collision occur off-screen in the vertical direction?[/INST]No, sprite collisions are detected even if positioned off-screen, but not in the vertical direction."
"[INST]In the context of the C64, what is the recommended approach for setting sprite pointers in RAM memory?[/INST]It is recommended to set sprite pointers at a higher area of memory, such as 2040,192 for sprite 0 at locations 12288 to 12350, to protect sprite data from being overwritten by a long BASIC program."
"[INST]In the context of the C64, how can you define multiple sprites with different shapes?[/INST]You can define multiple sprites with different shapes by defining several sprite 'shapes' in your DATA statements and then redefining a particular sprite by changing the 'pointer' to point to different areas of memory containing different sprite picture data."
"[INST]In the context of the C64, what is the purpose of adjusting the memory locations of sprite pointers?[/INST]The purpose of adjusting the memory locations of sprite pointers is to define as many as 64 different sprites plus a sizable BASIC program, by changing the memory locations from which sprites get their 'data'."
"[INST]In the context of the C64, how can you make two or more sprites have the same shape?[/INST]You can make two or more sprites have the same shape by using the same sprite pointer and memory location for the sprites you want to match, for example, by using POKE 2040,192 and POKE 2041, 192 to point sprites 0 and 1 to the same location."
"[INST]In the context of the C64, what is the risk of setting sprite pointers too low in memory?[/INST]The risk of setting sprite pointers too low in memory is that a long BASIC program may overwrite the sprite data, or vice versa."
"[INST]In the context of the C64, how can you protect sprite data from being overwritten by a long BASIC program?[/INST]You can protect sprite data from being overwritten by a long BASIC program by setting the sprites at a higher area of memory, such as 2040,192 for sprite 0 at locations 12288 to 12350."
"[INST]In the context of the C64, what is the purpose of redefining a sprite pointer?[/INST]The purpose of redefining a sprite pointer is to point to different areas of memory containing different sprite picture data, allowing you to define multiple sprites with different shapes."
"[INST]In the context of the C64, can you set sprite pointers anywhere in RAM memory?[/INST]Yes, you can set sprite pointers anywhere in RAM memory, but it is recommended to set them at a higher area of memory to protect sprite data from being overwritten by a long BASIC program."
"[INST]In the context of the C64, how many different sprites can you define using this method?[/INST]You can define as many as 64 different sprites using this method, plus a sizable BASIC program."
"[INST]In the context of the C64, what is the 'Dancing Mouse' an example of?[/INST]The 'Dancing Mouse' is an example of how to redefine a sprite pointer to point to different areas of memory containing different sprite picture data, allowing you to define multiple sprites with different shapes."
"[INST]In the context of the C64, Where does the Commodore 64 screen start and end?[/INST]The Commodore 64 screen starts at location 1024 ($0400 in HEXadecimal notation) and goes to location 2023, with each location being 8 bits wide, capable of holding any integer number from 0 to 255."
"[INST]In the context of the C64, How many possible colors can the Commodore 64 use?[/INST]The Commodore 64 can use 16 possible colors, which is well-suited to the 4-bit wide color RAM locations that can hold any integer number from 0 to 15."
"[INST]In the context of the C64, What is the purpose of the 1000 locations in screen memory?[/INST]Each of the 1000 locations in screen memory contains a code number that tells the VIC-II chip which character to display at that screen location, allowing for 256 different characters to be displayed at any time."
"[INST]In the context of the C64, What is the function of the 47 CONTROL registers in the VIC-II chip?[/INST]The 47 CONTROL registers in the VIC-II chip are used to select various graphics modes, with many graphics functions able to be controlled by POKEing the correct value into one of the registers."
"[INST]In the context of the C64, What is the address range of the VIC-II chip?[/INST]The VIC-II chip is located starting at 53248 ($D000 in HEX) through 53294 ($D02E in HEX)."
"[INST]In the context of the C64, How many bits wide are the color RAM locations?[/INST]The color RAM locations are 4 bits wide, which means they can hold any integer number from 0 to 15."
"[INST]In the context of the C64, How many locations are in the COLOR MEMORY or COLOR RAM?[/INST]There are 1000 locations in the COLOR MEMORY or COLOR RAM, starting at location 55296 ($D800 in HEX) and going up to 56295."
"[INST]In the context of the C64, What is the purpose of the screen memory?[/INST]The screen memory is used to store the code numbers that tell the VIC-II chip which character to display at each screen location."
"[INST]In the context of the C64, How many characters can be displayed at any time?[/INST]Up to 256 different characters can be displayed at any time, with each of the 1000 locations in screen memory containing a code number that specifies which character to display."
"[INST]In the context of the C64, What is the relationship between the screen memory and the COLOR MEMORY or COLOR RAM?[/INST]The screen memory and the COLOR MEMORY or COLOR RAM are connected, with the screen memory storing the code numbers for the characters and the COLOR MEMORY or COLOR RAM storing the color information for each character."
"[INST]In the context of the C64, What is the significance of the 8-bit width of the screen memory locations?[/INST]The 8-bit width of the screen memory locations means that each location can hold any integer number from 0 to 255, allowing for a wide range of character codes to be stored."
"[INST]In the context of the C64, Can the Commodore 64 connect to the outside world?[/INST]Yes, through the user port."
"[INST]In the context of the C64, What is the user port used for?[/INST]To connect the Commodore 64 to a printer, a Votrax Type and Talk, a MODEM, even another computer."
"[INST]In the context of the C64, What chip is the user port directly connected to?[/INST]The 6526 CIA chip."
"[INST]In the context of the C64, What is the purpose of the CIA chip?[/INST]To connect to many other devices."
"[INST]In the context of the C64, What is the user port pin description?[/INST]A table showing the pin numbers and their descriptions."
"[INST]In the context of the C64, What is the purpose of the reset pin?[/INST]To do a cold start, resetting the Commodore 64 completely."
"[INST]In the context of the C64, What is the purpose of the serial port counter pins?[/INST]To count the number of serial port transmissions."
"[INST]In the context of the C64, What is the purpose of the handshaking line?[/INST]To handshake with an outside device."
"[INST]In the context of the C64, What is the purpose of the ATN line?[/INST]To connect to the serial bus."
"[INST]In the context of the C64, What is the purpose of the 9 VAC phase pin?[/INST]To connect to the Commodore 64 transformer."
"[INST]In the context of the C64, What is the purpose of the GND pin?[/INST]To ground the circuit."
"[INST]In the context of the C64, What is the purpose of the DATA DIRECTION REGISTER?[/INST]To control whether a line is an input or an output."
"[INST]In the context of the C64, What is the purpose of the PORT?[/INST]To connect to an outside device."
"[INST]In the context of the C64, What is the purpose of the FLAG1 line?[/INST]For handshaking and as a general purpose interrupt input."
"[INST]In the context of the C64, What is the purpose of the PA2 line?[/INST]To control bit 2 of PORT A of the CIA."
"[INST]In the context of the C64, What is the purpose of the interrupt register?[/INST]To poll the interrupt register under program control."
"[INST]In the context of the C64, What is the purpose of the 6526 chip specifications?[/INST]To provide more information on the chip's specifications."
"[INST]In the context of the C64, What is the purpose of the user port?[/INST]To connect the Commodore 64 to the outside world."
"[INST]In the context of the C64, What is the purpose of the CIA chip?[/INST]To connect to many other devices."
"[INST]In the context of the C64, What is the purpose of the user port pin description?[/INST]To show the pin numbers and their descriptions."
"[INST]In the context of the C64, What is the purpose of the reset pin?[/INST]To do a cold start, resetting the Commodore 64 completely."
"[INST]In the context of the C64, What is the purpose of the serial port counter pins?[/INST]To count the number of serial port transmissions."
"[INST]In the context of the C64, What is the purpose of the handshaking line?[/INST]To handshake with an outside device."
"[INST]In the context of the C64, What is the purpose of the ATN line?[/INST]To connect to the serial bus."
"[INST]In the context of the C64, What is the purpose of the 9 VAC phase pin?[/INST]To connect to the Commodore 64 transformer."
"[INST]In the context of the C64, What is the purpose of the GND pin?[/INST]To ground the circuit."
"[INST]In the context of the C64, What is the purpose of the DATA DIRECTION REGISTER?[/INST]To control whether a line is an input or an output."
"[INST]In the context of the C64, What is the purpose of the PORT?[/INST]To connect to an outside device."
"[INST]In the context of the C64, What is the purpose of the FLAG1 line?[/INST]For handshaking and as a general purpose interrupt input."
"[INST]In the context of the C64, What is the purpose of the PA2 line?[/INST]To control bit 2 of PORT A of the CIA."
"[INST]In the context of the C64, What is the purpose of the interrupt register?[/INST]To poll the interrupt register under program control."
"[INST]In the context of the C64, What is the purpose of the 6526 chip specifications?[/INST]To provide more information on the chip's specifications."
"[INST]In the context of the C64, What is the purpose of the user port?[/INST]To connect the Commodore 64 to the outside world."
"[INST]In the context of the C64, What is the purpose of the CIA chip?[/INST]To connect to many other devices."
"[INST]In the context of the C64, What is the purpose of the user port pin description?[/INST]To show the pin numbers and their descriptions."
"[INST]In the context of the C64, What is the purpose of the reset pin?[/INST]To do a cold start, resetting the Commodore 64 completely."
"[INST]In the context of the C64, What is the purpose of the serial port counter pins?[/INST]To count the number of serial port transmissions."
"[INST]In the context of the C64, What is the purpose of the handshaking line?[/INST]To handshake with an outside device."
"[INST]In the context of the C64, What is the purpose of the ATN line?[/INST]To connect to the serial bus."
"[INST]In the context of the C64, What is the purpose of the 9 VAC phase pin?[/INST]To connect to the Commodore 64 transformer."
"[INST]In the context of the C64, What is the purpose of the GND pin?[/INST]To ground the circuit."
"[INST]In the context of the C64, What is the purpose of the DATA DIRECTION REGISTER?[/INST]To control whether a line is an input or an output."
"[INST]In the context of the C64, What is the purpose of the PORT?[/INST]To connect to an outside device."
"[INST]In the context of the C64, What is the purpose of the FLAG1 line?[/INST]For handshaking and as a general purpose interrupt input."
"[INST]In the context of the C64, What is the purpose of the PA2 line?[/INST]To control bit 2 of PORT A of the CIA."
"[INST]In the context of the C64, What is the purpose of the interrupt register?[/INST]To poll the interrupt register under program control."
"[INST]In the context of the C64, What is the purpose of the 6526 chip specifications?[/INST]To provide more information on the chip's specifications."
"[INST]In the context of the C64, about SID: Is the cutoff frequency adjustable?[/INST]Yes, it is adjustable between 0-7"
"[INST]In the context of the C64, about SID: What is the range of the high cutoff frequency?[/INST]The range is 0-255"
"[INST]In the context of the C64, about SID: What determines the resonance of the filter?[/INST]It is determined by bits 4-7"
"[INST]In the context of the C64, about SID: Can the filter voice be adjusted?[/INST]Yes, it can be adjusted through bit 2"
"[INST]In the context of the C64, about SID: What is the purpose of the high pass filter?[/INST]It is used to filter out high frequencies"
"[INST]In the context of the C64, about SID: What is the purpose of the bandpass filter?[/INST]It is used to filter out specific frequency ranges"
"[INST]In the context of the C64, about SID: What is the purpose of the low pass filter?[/INST]It is used to filter out low frequencies"
"[INST]In the context of the C64, about SID: What is the range of the volume?[/INST]The range is 0-3"
"[INST]In the context of the C64, about SID: Can the filter voice be adjusted independently?[/INST]Yes, it can be adjusted independently through bits 1 and 0"
"[INST]In the context of the C64, about SID: What is the purpose of the filter settings?[/INST]It is used to customize the filter's behavior"
"[INST]In the context of the C64, what is the device number for the cassette device in the open statement?[/INST]The device number for the cassette device in the open statement is 1."
"[INST]In the context of the C64, what are the possible values for the number parameter when using the screen device in the open statement?[/INST]The possible values for the number parameter when using the screen device in the open statement are 0 and 1."
"[INST]In the context of the C64, what is the purpose of the string parameter when using the cassette device in the open statement?[/INST]The purpose of the string parameter when using the cassette device in the open statement is to specify the file name."
"[INST]In the context of the C64, what is the difference between using number 0 and number 1 when using the printer device in the open statement?[/INST]The difference between using number 0 and number 1 when using the printer device in the open statement is that 0 is used for upper case and graphics, while 1 is used for upper and lower case."
"[INST]In the context of the C64, what is the purpose of the number 15 when using the disk device in the open statement?[/INST]The purpose of the number 15 when using the disk device in the open statement is to specify a command channel."
"[INST]In the context of the C64, what are the possible device numbers for the disk device in the open statement?[/INST]The possible device numbers for the disk device in the open statement are 8 to 11."
"[INST]In the context of the C64, what is the purpose of the number 2 when using the modem device in the open statement?[/INST]The purpose of the number 2 when using the modem device in the open statement is not specified, as the number parameter is not used with the modem device."
"[INST]In the context of the C64, what is the purpose of the string parameter when using the disk device in the open statement?[/INST]The purpose of the string parameter when using the disk device in the open statement is to specify the drive number, file name, file type, and read/write status."
"[INST]In the context of the C64, what is the difference between using number 0 and number 1 when using the cassette device in the open statement?[/INST]The difference between using number 0 and number 1 when using the cassette device in the open statement is that 0 is used for input, while 1 is used for output."
"[INST]In the context of the C64, what is the purpose of the number 2 when using the cassette device in the open statement?[/INST]The purpose of the number 2 when using the cassette device in the open statement is to specify output with EOT (end of tape)."
"[INST]In the context of the C64, What is the problem facing programmers in the microcomputer field?[/INST]The problem is that changes to the operating system by the company can make machine language programs obsolete."
"[INST]In the context of the C64, What is the KERNAL?[/INST]The KERNAL is a standardized JUMP TABLE to the input, output, and memory management routines in the operating system."
"[INST]In the context of the C64, What is the purpose of the KERNAL?[/INST]The purpose of the KERNAL is to protect software writers from changes to the operating system."
"[INST]In the context of the C64, How does the KERNAL alleviate the problem of changes to the operating system?[/INST]The KERNAL alleviates the problem by providing a standardized jump table that always matches the locations of the system ROM routines."
"[INST]In the context of the C64, What is the KERNAL jump table located in?[/INST]The KERNAL jump table is located on the last page of memory, in read-only memory (ROM)."
"[INST]In the context of the C64, What is the benefit of using the KERNAL jump table?[/INST]The benefit is that it saves time and makes it easier to translate programs from one Commodore computer to another."
"[INST]In the context of the C64, How do you use the KERNAL jump table?[/INST]You set up the parameters that the KERNAL routine needs to work, then JSR to the proper place in the KERNAL jump table."
"[INST]In the context of the C64, What happens after the KERNAL routine performs its function?[/INST]The KERNAL transfers control back to your machine language program."
"[INST]In the context of the C64, What is the purpose of the registers in the KERNAL routine?[/INST]The registers pass parameters back to your program."
"[INST]In the context of the C64, Why is the jump table used instead of JSR directly to the KERNAL subroutine?[/INST]The jump table is used so that if the KERNAL or BASIC is changed, your machine language programs will still work."
"[INST]In the context of the C64, What happens to the KERNAL routines if the operating system is changed?[/INST]The KERNAL routines may have their memory locations moved around to a different position in the memory map."
"[INST]In the context of the C64, How does the jump table ensure compatibility with future operating systems?[/INST]The jump table will still work correctly even if the KERNAL or BASIC is changed."
"[INST]In the context of the C64, What is the advantage of using the KERNAL jump table?[/INST]The advantage is that your machine language programs will not become obsolete even if the operating system is changed."
"[INST]In the context of the C64, What is the KERNAL responsible for in the Commodore 64 computer?[/INST]The KERNAL is responsible for controlling all input, output, and memory management."
"[INST]In the context of the C64, How many input/output routines are available in the KERNAL jump table?[/INST]There are 39 input/output routines available in the KERNAL jump table."
"[INST]In the context of the C64, What is the benefit of using the KERNAL jump table for machine language programs?[/INST]The benefit is that it takes much less work to modify them if the operating system is changed."
"[INST]In the context of the C64, What is the KERNAL jump table used for?[/INST]The KERNAL jump table is used to simplify machine language programs and ensure compatibility with future operating systems."
"[INST]In the context of the C64, How does the KERNAL jump table make it easier to translate programs?[/INST]The KERNAL jump table makes it easier to translate programs from one Commodore computer to another."
"[INST]In the context of the C64, What is the purpose of the parameters in the KERNAL routine?[/INST]The parameters are used to set up the KERNAL routine to work properly."
"[INST]In the context of the C64, What happens to the control after the KERNAL routine performs its function?[/INST]The control is transferred back to your machine language program."
"[INST]In the context of the C64, What is the advantage of using the KERNAL jump table for software writers?[/INST]The advantage is that it protects software writers from changes to the operating system."
"[INST]In the context of the C64, How does the KERNAL jump table ensure that machine language programs remain compatible?[/INST]The KERNAL jump table ensures that machine language programs remain compatible by providing a standardized interface to the operating system."
"[INST]In the context of the C64, What is the benefit of using the KERNAL jump table for future-proofing?[/INST]The benefit is that it ensures that machine language programs will still work even if the operating system is changed."
"[INST]In the context of the C64, What is the purpose of the ROM in the KERNAL jump table?[/INST]The ROM is used to store the KERNAL jump table in read-only memory."
"[INST]In the context of the C64, How does the KERNAL jump table simplify machine language programs?[/INST]The KERNAL jump table simplifies machine language programs by providing a standardized interface to the operating system."
"[INST]In the context of the C64, What is the benefit of using the KERNAL jump table for machine language programmers?[/INST]The benefit is that it saves time and makes it easier to develop machine language programs."
"[INST]In the context of the C64, What is the purpose of the KERNAL in the Commodore 64 computer?[/INST]The purpose of the KERNAL is to provide a standardized interface to the operating system for machine language programs."
"[INST]In the context of the C64, What is the advantage of using the KERNAL jump table for compatibility?[/INST]The advantage is that it ensures that machine language programs will still work even if the operating system is changed."
"[INST]In the context of the C64, What is a sound wave composed of?[/INST]a fundamental frequency and all of the harmonics it takes to make up that sound"
"[INST]In the context of the C64, What defines the overall pitch of a note?[/INST]the fundamental frequency"
"[INST]In the context of the C64, What are harmonics?[/INST]sine waves having frequencies which are integer multiples of the fundamental frequency"
"[INST]In the context of the C64, What is harmonic number 1 in musical theory?[/INST]the fundamental frequency"
"[INST]In the context of the C64, What is the frequency of the second harmonic?[/INST]twice the fundamental frequency"
"[INST]In the context of the C64, How does the harmonic structure of an acoustic instrument change?[/INST]it may vary as a single note is played"
"[INST]In the context of the C64, What type of wave contains only odd harmonics?[/INST]a triangular wave"
"[INST]In the context of the C64, How does the amount of each harmonic in a triangular wave change?[/INST]it is proportional to the reciprocal of the square of the harmonic number"
"[INST]In the context of the C64, What is the relationship between harmonic number 3 and harmonic number 1 in a triangular wave?[/INST]harmonic number 3 is 1/9 quieter than harmonic number 1"
"[INST]In the context of the C64, What type of wave contains all the harmonics?[/INST]a sawtooth wave"
"[INST]In the context of the C64, How does the amount of each harmonic in a sawtooth wave change?[/INST]it is proportional to the reciprocal of the harmonic number"
"[INST]In the context of the C64, What is the relationship between harmonic number 2 and harmonic number 1 in a sawtooth wave?[/INST]harmonic number 2 is 1/2 as loud as harmonic number 1"
"[INST]In the context of the C64, What type of wave contains odd harmonics in proportion to the reciprocal of the harmonic number?[/INST]a square wave"
"[INST]In the context of the C64, How can the timbre of a rectangular wave be varied?[/INST]by changing the pulse width"
"[INST]In the context of the C64, What is the purpose of filtering in sound synthesis?[/INST]to refine the sound"
"[INST]In the context of the C64, What is the fundamental frequency in a sound wave?[/INST]the lowest frequency of the sound wave"
"[INST]In the context of the C64, What is the role of harmonics in a sound wave?[/INST]they give the sound its timbre"
"[INST]In the context of the C64, How do harmonics affect the sound of a note?[/INST]they give the note its timbre"
"[INST]In the context of the C64, What is the difference between a triangular wave and a sine wave?[/INST]a triangular wave contains only odd harmonics, while a sine wave is a single frequency"
"[INST]In the context of the C64, What is the harmonic structure of an acoustic instrument?[/INST]very complicated"
"[INST]In the context of the C64, How does the waveform used affect the sound produced?[/INST]it determines the harmonic structure of the sound"
"[INST]In the context of the C64, What is the relationship between the waveform and the timbre of a sound?[/INST]the waveform determines the timbre"
"[INST]In the context of the C64, What is the purpose of choosing a waveform in sound synthesis?[/INST]to create a harmonic structure that looks somewhat like the sound you want"
"[INST]In the context of the C64, How can the sound of a rectangular wave be varied?[/INST]by changing the pulse width"
"[INST]In the context of the C64, What is the effect of changing the pulse width of a rectangular wave?[/INST]it varies the timbre of the sound"
"[INST]In the context of the C64, What is the role of filtering in refining a sound?[/INST]it allows for further refinement of the sound"
"[INST]In the context of the C64, What is the relationship between the waveform and the sound produced?[/INST]the waveform determines the sound"
"[INST]In the context of the C64, How does the harmonic structure of a sound affect its timbre?[/INST]it gives the sound its timbre"
"[INST]In the context of the C64, What is the difference between a sawtooth wave and a triangular wave?[/INST]a sawtooth wave contains all harmonics, while a triangular wave contains only odd harmonics"
"[INST]In the context of the C64, What is the CHR$ code for a space character?[/INST]32"
"[INST]In the context of the C64, What is the CHR$ code for the letter 'A'?[/INST]65"
"[INST]In the context of the C64, What is the CHR$ code for the symbol '#'?[/INST]35"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]34"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '![/INST]33"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]39"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]40"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]41"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]42"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]43"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]44"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]45"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]46"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]47"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]48"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]49"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]50"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]51"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]52"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]53"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]54"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]55"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]56"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]57"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]58"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]59"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]60"
"[INST]In the context of the C64, What is the CHR$ code for the symbol ' '?[/INST]61"
"[INST]In the context of the C64, What is the maximum time for ATN RESPONSE (REQUIRED)?[/INST]1000us"
"[INST]In the context of the C64, What is the minimum time for LISTENER HOLD-OFF?[/INST]0"
"[INST]In the context of the C64, What is the typical time for NON-EOI RESPONSE TO RFD?[/INST]40us"
"[INST]In the context of the C64, What is the maximum time for BIT SET-UP TALKER?[/INST]-"
"[INST]In the context of the C64, What is the minimum time for DATA VALID?[/INST]20us"
"[INST]In the context of the C64, What is the maximum time for FRAME HANDSHAKE?[/INST]1000us"
"[INST]In the context of the C64, What is the minimum time for FRAME TO RELEASE OF ATN?[/INST]20us"
"[INST]In the context of the C64, What is the maximum time for BETWEEN BYTES TIME?[/INST]-"
"[INST]In the context of the C64, What is the minimum time for EOI RESPONSE TIME?[/INST]200us"
"[INST]In the context of the C64, What is the maximum time for EOI RESPONSE HOLD TIME?[/INST]-"
"[INST]In the context of the C64, What is the minimum time for TALKER RESPONSE LIMIT?[/INST]0"
"[INST]In the context of the C64, What is the maximum time for BYTE-ACKNOWLEDGE?[/INST]-"
"[INST]In the context of the C64, What is the minimum time for TALK-ATTENTION RELEASE?[/INST]20us"
"[INST]In the context of the C64, What is the maximum time for TALK-ATTENTION ACKNOWLEDGE?[/INST]-"
"[INST]In the context of the C64, What is the minimum time for TALK-ATTENTION ACK. HOLD?[/INST]80us"
"[INST]In the context of the C64, What is the maximum time for EOI ACKNOWLEDGE?[/INST]-"
"[INST]In the context of the C64, What is the purpose of the SERIAL CLK IN/OUT signal?[/INST]timing the data sent on the serial bus"
"[INST]In the context of the C64, What is transmitted on the SERIAL DATA IN/OUT line?[/INST]one bit at a time"
"[INST]In the context of the C64, What is the type of connector on the expansion port?[/INST]44-pin (22122) female edge connector"
"[INST]In the context of the C64, What is the purpose of the expansion port?[/INST]for expansions of the Commodore 64 system"
"[INST]In the context of the C64, What is the arrangement of the expansion bus?[/INST]2 2 2 1 1 1 1 1 1 1 1 1 1 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1"
"[INST]In the context of the C64, What is the caution when using the expansion bus?[/INST]possible to damage the Commodore 64"
"[INST]In the context of the C64, What happens if the maximum time for ATN RESPONSE (REQUIRED) is exceeded?[/INST]device not present error"
"[INST]In the context of the C64, What happens if the maximum time for NON-EOI RESPONSE TO RFD is exceeded?[/INST]EOI response required"
"[INST]In the context of the C64, What happens if the maximum time for FRAME HANDSHAKE is exceeded?[/INST]frame error"
"[INST]In the context of the C64, What is the minimum value of Tv and Tpr for an external device to be a talker?[/INST]60us"
"[INST]In the context of the C64, What is the minimum value of Tei for an external device to be a listener?[/INST]80us"
"[INST]In the context of the C64, What is the purpose of the expansion connector?[/INST]to use the connector, a 44-pin (22/22) male edge connector is required"
"[INST]In the context of the C64, what is the purpose of pin 6 on the SID chip?[/INST]This TTL-Level input serves as the master clock for SID, controlling oscillator frequencies and envelope rates, as well as data transfers between SID and the microprocessor, only allowing data transfer when the pin is high."
"[INST]In the context of the C64, what is the typical operating frequency of pin 6?[/INST]The nominal operating frequency of pin 6 is 1.0 MHz, which is typically connected to the system clock."
"[INST]In the context of the C64, what is the effect of pin 6 on data transfers?[/INST]Pin 6 acts as a high-active chip select, allowing data transfers between SID and the microprocessor only when the pin is high."
"[INST]In the context of the C64, what is the relationship between pin 6 and the system clock?[/INST]Pin 6 is typically connected to the system clock, which provides the master clock signal for SID."
"[INST]In the context of the C64, what is the significance of pin 6 being high?[/INST]When pin 6 is high, it enables data transfers between SID and the microprocessor, allowing them to communicate and exchange data."
"[INST]In the context of the C64, what is the role of pin 6 in controlling oscillator frequencies?[/INST]Pin 6 serves as the master clock, controlling oscillator frequencies and envelope rates, which are referenced to this clock signal."
"[INST]In the context of the C64, what is the effect of pin 6 on the SID chip?[/INST]Pin 6 has a profound impact on the SID chip, controlling its internal clock, data transfers, and overall operation."
"[INST]In the context of the C64, how does pin 6 control data transfers?[/INST]Pin 6 acts as a high-active chip select, allowing data transfers to occur only when the pin is high, effectively controlling when data can be transferred between SID and the microprocessor."
"[INST]In the context of the C64, what is the relationship between pin 6 and the microprocessor?[/INST]Pin 6 controls data transfers between SID and the microprocessor, allowing them to communicate and exchange data when the pin is high."
"[INST]In the context of the C64, what is the significance of the 1.0 MHz frequency on pin 6?[/INST]The 1.0 MHz frequency on pin 6 is the nominal operating frequency, which provides the master clock signal for SID, controlling its internal operation and data transfers."
"[INST]In the context of the C64, Each sprite is positioned via its X and Y position register with a resolution of what?[/INST]Each sprite is positioned via its X and Y position register with a resolution of 512 horizontal and 256 vertical positions."
"[INST]In the context of the C64, What is the resolution of the X position register?[/INST]The resolution of the X position register is 512 horizontal positions."
"[INST]In the context of the C64, What is the resolution of the Y position register?[/INST]The resolution of the Y position register is 256 vertical positions."
"[INST]In the context of the C64, What is the range of X locations that are visible?[/INST]The range of X locations that are visible is 23 to 347 ($17-$157)."
"[INST]In the context of the C64, What is the range of Y locations that are visible?[/INST]The range of Y locations that are visible is 50 to 249 ($32-$F9)."
"[INST]In the context of the C64, Can all available sprite positions be entirely visible on the screen?[/INST]No, not all available sprite positions are entirely visible on the screen."
"[INST]In the context of the C64, Can sprites be moved smoothly on and off the display screen?[/INST]Yes, sprites may be moved smoothly on and off the display screen."
"[INST]In the context of the C64, what is the screen resolution in bit map mode?[/INST]In bit map mode, the screen resolution is 320H * 200V individually controlled display dots, providing a one-to-one correspondence between each displayed dot and a memory bit."
"[INST]In the context of the C64, how is bit map mode selected?[/INST]Bit map mode is selected by setting the BMM bit in register 17 ($11) to a '1'."
"[INST]In the context of the C64, what is the purpose of the VIDEO MATRIX in bit map mode?[/INST]In bit map mode, the VIDEO MATRIX is accessed as in character mode, but the video matrix data is no longer interpreted as character pointers, but rather as color data."
"[INST]In the context of the C64, what is the role of the VIDEO MATRIX COUNTER in bit map mode?[/INST]The VIDEO MATRIX COUNTER is used as an address to fetch the dot data for display from the 8000-byte DISPLAY BASE in bit map mode."
"[INST]In the context of the C64, how is the display base address formed in bit map mode?[/INST]The display base address is formed by combining the following bits: A13, VC9, VC8, VC7, VC6, VC5, VC4, VC3, VC2, VC1, VC0, RC2, RC1, and RC0."
"[INST]In the context of the C64, what is the size of the DISPLAY BASE in bit map mode?[/INST]The DISPLAY BASE is 8000 bytes in size in bit map mode."
"[INST]In the context of the C64, in bit map mode, what is the relationship between memory bits and displayed dots?[/INST]In bit map mode, there is a one-to-one correspondence between each displayed dot and a memory bit."
"[INST]In the context of the C64, what is the difference in data interpretation between character mode and bit map mode?[/INST]In character mode, video matrix data is interpreted as character pointers, whereas in bit map mode, video matrix data is interpreted as color data."
"[INST]In the context of the C64, what is the register used to select bit map mode?[/INST]Register 17 ($11) is used to select bit map mode by setting the BMM bit to a '1'."
"[INST]In the context of the C64, what is the purpose of the BMM bit in register 17?[/INST]The BMM bit in register 17 is used to select bit map mode, allowing for a one-to-one correspondence between each displayed dot and a memory bit."
"[INST]In the context of the C64, Is the BEQ instruction used for branching?[/INST]Yes, it is used for branching."
"[INST]In the context of the C64, What is the purpose of the BEQ instruction?[/INST]The purpose of the BEQ instruction is to branch on the result being zero."
"[INST]In the context of the C64, What is the format of the BEQ instruction?[/INST]The format of the BEQ instruction is BEQ Branch on result zero."
"[INST]In the context of the C64, What is the addressing mode of the BEQ instruction?[/INST]The addressing mode of the BEQ instruction is Relative."
"[INST]In the context of the C64, What is the assembly language form of the BEQ instruction?[/INST]The assembly language form of the BEQ instruction is BEQ Oper."
"[INST]In the context of the C64, What is the OP CODE of the BEQ instruction?[/INST]The OP CODE of the BEQ instruction is F0."
"[INST]In the context of the C64, How many bytes does the BEQ instruction occupy?[/INST]The BEQ instruction occupies 2 bytes."
"[INST]In the context of the C64, How many cycles does the BEQ instruction take?[/INST]The BEQ instruction takes 2 cycles."
"[INST]In the context of the C64, What happens if the branch occurs to the same page?[/INST]If the branch occurs to the same page, add 1 to the cycle count."
"[INST]In the context of the C64, What happens if the branch occurs to the next page?[/INST]If the branch occurs to the next page, add 2 to the cycle count."
"[INST]In the context of the C64, What is the purpose of the SECOND function?[/INST]The purpose of the SECOND function is to send a secondary address for LISTEN, which is used to give setup information to a device before I/O operations begin."
"[INST]In the context of the C64, What is the call address of the SECOND function in hexadecimal?[/INST]The call address of the SECOND function is $FF93."
"[INST]In the context of the C64, What is the decimal equivalent of the call address of the SECOND function?[/INST]The decimal equivalent of the call address of the SECOND function is 65427."
"[INST]In the context of the C64, What communication register is used by the SECOND function?[/INST]The SECOND function uses the accumulator (A) as the communication register."
"[INST]In the context of the C64, What is the preparatory routine required for the SECOND function?[/INST]The preparatory routine required for the SECOND function is LISTEN."
"[INST]In the context of the C64, What is the error return behavior of the SECOND function?[/INST]The error return behavior of the SECOND function is the same as the READST function."
"[INST]In the context of the C64, How much stack is required by the SECOND function?[/INST]The SECOND function requires 8 bytes of stack space."
"[INST]In the context of the C64, What register is affected by the SECOND function?[/INST]The accumulator (A) is the register affected by the SECOND function."
"[INST]In the context of the C64, How do you use the SECOND function to send a secondary address to a device?[/INST]To use the SECOND function, load the accumulator with the secondary address to be sent, and then call the SECOND function."
"[INST]In the context of the C64, What is the importance of ORing the secondary address with $60 when sending it to a device on the serial bus?[/INST]When sending a secondary address to a device on the serial bus, it must be ORed with $60, which is a required step to ensure proper communication with the device."
"[INST]In the context of the C64, Is the BVC instruction used for branch on overflow clear?[/INST]Yes"
"[INST]In the context of the C64, What is the operation of the BVC instruction?[/INST]Branch on V = 0"
"[INST]In the context of the C64, What is the addressing mode of the BVC instruction?[/INST]Relative"
"[INST]In the context of the C64, What is the assembly language form of the BVC instruction?[/INST]BVC Oper"
"[INST]In the context of the C64, What is the OP CODE of the BVC instruction?[/INST]50"
"[INST]In the context of the C64, How many bytes does the BVC instruction occupy?[/INST]2"
"[INST]In the context of the C64, How many cycles does the BVC instruction take?[/INST]2*"
"[INST]In the context of the C64, What is the condition for adding 1 to the branch count?[/INST]Add 1 if branch occurs to same page"
"[INST]In the context of the C64, What is the condition for adding 2 to the branch count?[/INST]Add 2 if branch occurs to different page"
"[INST]In the context of the C64, What is the purpose of the BVC instruction?[/INST]Branch on overflow clear"
"[INST]In the context of the C64, What is the format of the BVC instruction?[/INST]Assembly Language Form"
"[INST]In the context of the C64, Compare memory and accumulator[/INST]CMP Compare memory and accumulator"
"[INST]In the context of the C64, CMP: Number of bytes in immediate addressing mode[/INST]2"
"[INST]In the context of the C64, CMP: Number of cycles in immediate addressing mode[/INST]2"
"[INST]In the context of the C64, CMP: Number of bytes in zero page addressing mode[/INST]2"
"[INST]In the context of the C64, CMP: Number of cycles in zero page addressing mode[/INST]3"
"[INST]In the context of the C64, CMP: Number of bytes in zero page,X addressing mode[/INST]2"
"[INST]In the context of the C64, CMP: Number of cycles in zero page,X addressing mode[/INST]4"
"[INST]In the context of the C64, CMP: Number of bytes in absolute addressing mode[/INST]3"
"[INST]In the context of the C64, CMP: Number of cycles in absolute addressing mode[/INST]4"
"[INST]In the context of the C64, CMP: Number of bytes in absolute,X addressing mode[/INST]3"
"[INST]In the context of the C64, CMP: Number of cycles in absolute,X addressing mode[/INST]4"
"[INST]In the context of the C64, CMP: Number of bytes in absolute,Y addressing mode[/INST]3"
"[INST]In the context of the C64, CMP: Number of cycles in absolute,Y addressing mode[/INST]4"
"[INST]In the context of the C64, What is the name of the VIC-II control register that controls sprite enable?[/INST]The VIC-II control register at location 53269 ($D015 in HEX) is known as the SPRITE ENABLE register."
"[INST]In the context of the C64, What is the purpose of the SPRITE ENABLE register?[/INST]Each of the sprites has a bit in this register which controls whether that sprite is ON or OFF."
"[INST]In the context of the C64, How do you turn on sprite 1?[/INST]To turn on sprite 1, for example, it is necessary to turn that bit to a 1."
"[INST]In the context of the C64, What is the command to turn on sprite 1?[/INST]POKE 53269,PEEK(53269)OR 2"
"[INST]In the context of the C64, What is the general statement to turn on a sprite?[/INST]POKE 53269,PEEK(53269)OR (2^SN)"
"[INST]In the context of the C64, What is the importance of turning on a sprite?[/INST]A sprite must be turned ON before it can be seen."
"[INST]In the context of the C64, What is the range of sprite numbers?[/INST]from 0 to 7"
"[INST]In the context of the C64, What is the purpose of the POKE command?[/INST]To turn on a sprite"
"[INST]In the context of the C64, What is the role of the OR operator in the POKE command?[/INST]To turn on a sprite"
"[INST]In the context of the C64, What is the significance of the 2 in the POKE command?[/INST]To turn on sprite 1"
"[INST]In the context of the C64, Extended color mode is turned ON by setting which bit of the VIC-II register?[/INST]bit 6"
"[INST]In the context of the C64, Which register is used to turn ON extended color mode?[/INST]VIC-II register"
"[INST]In the context of the C64, What is the hexadecimal value of the location where the bit is set?[/INST]$D011"
"[INST]In the context of the C64, What is the POKE command used to turn ON extended color mode?[/INST]POKE 53265,PEEK(53265)OR 64"
"[INST]In the context of the C64, What is the purpose of setting bit 6 of the VIC-II register?[/INST]to turn ON extended color mode"
"[INST]In the context of the C64, What are the pins used to connect the two integrating capacitors?[/INST]CAP1A,CAP1B, (Pins 1,2)/ CAP2A,CAP2B (Pins 3,4)"
"[INST]In the context of the C64, What is the normal operation frequency range of the Filter?[/INST]audio range (approximately 30 Hz-12 kHz)"
"[INST]In the context of the C64, What is the recommended capacitor value for C1 and C2 for normal operation?[/INST]2200 pF"
"[INST]In the context of the C64, What type of capacitors are preferred for the Filter?[/INST]Polystyrene capacitors"
"[INST]In the context of the C64, Why are matched capacitors recommended in complex polyphonic systems?[/INST]to track each other"
"[INST]In the context of the C64, What is the frequency range of the Filter that can be tailored to specific applications?[/INST]the choice of capacitor values"
"[INST]In the context of the C64, What is the maximum Cutoff Frequency of the Filter?[/INST]FCmax = 2.6E-5/C"
"[INST]In the context of the C64, What is the range of the Filter extends below the maximum Cutoff Frequency?[/INST]9 octaves"
"[INST]In the context of the C64, What is the formula to calculate the maximum Cutoff Frequency?[/INST]FCmax = 2.6E-5/C"
"[INST]In the context of the C64, Why may a low-cost game not require full high-frequency response?[/INST]to provide more control over the bass frequencies"
"[INST]In the context of the C64, Should the ground line between SID and the power supply be separate?[/INST]Yes, for best results."
"[INST]In the context of the C64, What is the purpose of separating the ground line between SID and the power supply?[/INST]To minimize digital noise at the audio output."
"[INST]In the context of the C64, What should be done to minimize digital noise at the audio output?[/INST]Separate the ground line between SID and the power supply."
"[INST]In the context of the C64, What is the recommended approach for the ground line between SID and the power supply?[/INST]Make it separate from ground lines to other digital circuitry."
"[INST]In the context of the C64, Why is it important to separate the ground line between SID and the power supply?[/INST]To minimize digital noise at the audio output."
"[INST]In the context of the C64, What happens if the ground line between SID and the power supply is not separate?[/INST]Digital noise at the audio output may occur."
"[INST]In the context of the C64, What is the consequence of not separating the ground line between SID and the power supply?[/INST]Digital noise at the audio output."
"[INST]In the context of the C64, What is the recommended way to prevent digital noise at the audio output?[/INST]Separate the ground line between SID and the power supply."
"[INST]In the context of the C64, Why is digital noise at the audio output a problem?[/INST]It may affect the quality of the audio output."
"[INST]In the context of the C64, What is the recommended approach to prevent digital noise at the audio output?[/INST]Separate the ground line between SID and the power supply."
"[INST]In the context of the C64, what is the purpose of the SETMSG function?[/INST]The purpose of the SETMSG function is to control system message output, specifically to select whether to print error messages or control messages by setting the accumulator when the routine is called."
"[INST]In the context of the C64, what is the call address of the SETMSG function?[/INST]The call address of the SETMSG function is $FF90 (hex) or 65424 (decimal)."
"[INST]In the context of the C64, what is the role of bits 6 and 7 in the accumulator when calling the SETMSG function?[/INST]Bits 6 and 7 of the accumulator value determine where the message will come from; if bit 7 is 1, one of the error messages from the KERNAL is printed, and if bit 6 is set, control messages are printed."
"[INST]In the context of the C64, what is an example of an error message that can be printed by the SETMSG function?[/INST]An example of an error message that can be printed by the SETMSG function is 'FILE NOT FOUND'."
"[INST]In the context of the C64, what is an example of a control message that can be printed by the SETMSG function?[/INST]An example of a control message that can be printed by the SETMSG function is 'PRESS PLAY ON CASSETTE'."
"[INST]In the context of the C64, how do you turn on control messages using the SETMSG function?[/INST]To turn on control messages using the SETMSG function, you set the accumulator to a value with bit 6 set, for example LDA #$40, and then call the SETMSG routine."
"[INST]In the context of the C64, how do you turn on error messages using the SETMSG function?[/INST]To turn on error messages using the SETMSG function, you set the accumulator to a value with bit 7 set, for example LDA #$80, and then call the SETMSG routine."
"[INST]In the context of the C64, what is the stack requirement for the SETMSG function?[/INST]The stack requirement for the SETMSG function is 2."
"[INST]In the context of the C64, which register is affected by the SETMSG function?[/INST]The accumulator (A) register is affected by the SETMSG function."
"[INST]In the context of the C64, what is the preparatory routine required for the SETMSG function?[/INST]There is no preparatory routine required for the SETMSG function."
"[INST]In the context of the C64, Within which X coordinates are unexpanded sprites at least partially visible in the 40 column by 25 row mode?[/INST]Unexpanded sprites are at least partially visible in the 40 column by 25 row mode within the X coordinates 1 < X < 343."
"[INST]In the context of the C64, What are the Y coordinates for unexpanded sprites in the 24 row mode?[/INST]In the 24 row mode, the Y coordinates for unexpanded sprites are 34 <= Y <= 245."
"[INST]In the context of the C64, What are the X coordinates for expanded sprites in the 38 column mode?[/INST]In the 38 column mode, the X coordinates for expanded sprites are 496 >= X <= 334."
"[INST]In the context of the C64, What are the Y coordinates for unexpanded sprites in the 40 column by 25 row mode?[/INST]In the 40 column by 25 row mode, the Y coordinates for unexpanded sprites are 30 < Y < 249."
"[INST]In the context of the C64, What are the X coordinates for unexpanded sprites in the 38 column mode?[/INST]In the 38 column mode, the X coordinates for unexpanded sprites are 8 <= X <= 334."
"[INST]In the context of the C64, What are the X coordinates for expanded sprites in the 40 column by 25 row mode?[/INST]In the 40 column by 25 row mode, the X coordinates for expanded sprites are 489 >= X <= 343."
"[INST]In the context of the C64, What are the Y coordinates for expanded sprites in the 40 column by 25 row mode?[/INST]In the 40 column by 25 row mode, the Y coordinates for expanded sprites are 9 >= Y <= 249."
"[INST]In the context of the C64, What are the Y coordinates for unexpanded sprites in the 24 row mode?[/INST]In the 24 row mode, the Y coordinates for unexpanded sprites are 34 <= Y <= 245."
"[INST]In the context of the C64, What are the X coordinates for expanded sprites in the 40 column by 25 row mode when using expanded sprites?[/INST]In the 40 column by 25 row mode, the X coordinates for expanded sprites are 489 >= X <= 343."
"[INST]In the context of the C64, What are the Y coordinates for expanded sprites in the 24 row mode?[/INST]In the 24 row mode, the Y coordinates for expanded sprites are 13 <= Y <= 245."
"[INST]In the context of the C64, What is the purpose of the MEMTOP function?[/INST]The purpose of the MEMTOP function is to set the top of RAM, which can be done by calling the routine with the carry bit of the accumulator set to load the pointer to the top of RAM into the X and Y registers, or by calling it with the carry bit clear to set the top of memory to the value in the X and Y registers."
"[INST]In the context of the C64, What is the call address of the MEMTOP function in hexadecimal?[/INST]The call address of the MEMTOP function in hexadecimal is $FF99."
"[INST]In the context of the C64, What is the decimal equivalent of the MEMTOP function call address?[/INST]The decimal equivalent of the MEMTOP function call address is 65433."
"[INST]In the context of the C64, What registers are affected by the MEMTOP function?[/INST]The X and Y registers are affected by the MEMTOP function."
"[INST]In the context of the C64, What is the stack requirement for the MEMTOP function?[/INST]The stack requirement for the MEMTOP function is 2."
"[INST]In the context of the C64, How do you read the top of memory using the MEMTOP function?[/INST]You can read the top of memory using the MEMTOP function by calling it with the carry bit of the accumulator set, which loads the pointer to the top of RAM into the X and Y registers."
"[INST]In the context of the C64, What happens when you call the MEMTOP function with the accumulator carry bit clear?[/INST]When you call the MEMTOP function with the accumulator carry bit clear, the contents of the X and Y registers are loaded into the top of memory pointer, changing the top of memory."
"[INST]In the context of the C64, What is an example of using the MEMTOP function to deallocate a buffer?[/INST]An example of using the MEMTOP function to deallocate a buffer is by calling it to read the top of memory, decrementing the value, and then calling it again to set the new top of memory, as shown in the example code: SEC; JSR MEMTOP; DEX; CLC; JSR MEMTOP;"
"[INST]In the context of the C64, How do you set a new top of memory using the MEMTOP function?[/INST]You can set a new top of memory using the MEMTOP function by calling it with the accumulator carry bit clear, which loads the contents of the X and Y registers into the top of memory pointer."
"[INST]In the context of the C64, What are the communication registers used by the MEMTOP function?[/INST]The communication registers used by the MEMTOP function are X and Y."
"[INST]In the context of the C64, What is the purpose of the TTL-Level inputs on pins 9-13?[/INST]These inputs are used to select one of the 29 SID registers, allowing the microprocessor to address the SID chip in a similar manner to memory."
"[INST]In the context of the C64, What is the total number of registers that can be addressed using pins 9-13?[/INST]Although the addressing scheme allows for 32 registers, only 29 are actually used, with the remaining three locations being unused and returning invalid data when accessed."
"[INST]In the context of the C64, How do the pins 9-13 connect to the microprocessor?[/INST]The pins 9-13 are normally connected to the corresponding address lines of the microprocessor, enabling the SID chip to be addressed in a similar manner to memory."
"[INST]In the context of the C64, What happens when a write operation is performed on one of the unused register locations?[/INST]A write operation to any of the three unused register locations is ignored and has no effect on the SID chip."
"[INST]In the context of the C64, What is the result of reading from one of the unused register locations?[/INST]Reading from one of the unused register locations returns invalid data, as these locations are not actually connected to a valid SID register."
"[INST]In the context of the C64, What is the significance of the 29 SID registers?[/INST]The 29 SID registers are used to control and configure the SID chip, allowing for the generation of sound and music on the Commodore 64."
"[INST]In the context of the C64, How do the pins 9-13 enable the SID chip to be addressed?[/INST]The pins 9-13 provide the necessary address lines to select one of the 29 SID registers, allowing the microprocessor to access and control the SID chip."
"[INST]In the context of the C64, What is the relationship between the pins 9-13 and the microprocessor's address lines?[/INST]The pins 9-13 are connected to the corresponding address lines of the microprocessor, enabling the SID chip to be addressed in a similar manner to memory."
"[INST]In the context of the C64, Why are the remaining three register locations not used?[/INST]The remaining three register locations are not used, and any attempts to access them will result in invalid data being returned."
"[INST]In the context of the C64, How do the pins 9-13 enable the SID chip to be controlled?[/INST]The pins 9-13 provide the necessary address lines to select one of the 29 SID registers, allowing the microprocessor to control and configure the SID chip."
"[INST]In the context of the C64, what does LDA represent in 6510 assembly language[/INST]LDA represents 'load accumulator with...' and what the accumulator should be loaded with is decided by the parameter(s) associated with that instruction."
"[INST]In the context of the C64, in 6510 assembly language, how many characters do mnemonics have[/INST]mnemonics are always three characters."
"[INST]In the context of the C64, what happens when you put a '#' symbol in front of the parameter associated with the instruction[/INST]this means that you want the register specified in the instruction to be loaded with the 'value' after the '#'."
"[INST]In the context of the C64, what is the token for the LDA instruction in immediate mode[/INST]the token for this particular instruction, in this mode, is $A9."
"[INST]In the context of the C64, what is the difference between immediate mode and absolute mode of instruction[/INST]in immediate mode, the parameter is a 'value', rather than the contents of a memory location, or another register, whereas in absolute mode, the parameter is the contents of a memory location."
"[INST]In the context of the C64, what is the token for the LDA instruction in absolute mode[/INST]the token for the LDA instruction in absolute mode is $AD."
"[INST]In the context of the C64, in which mode is the parameter a 'value'[/INST]in immediate mode, the parameter is a 'value'."
"[INST]In the context of the C64, in which mode is the parameter the contents of a memory location[/INST]in absolute mode, the parameter is the contents of a memory location."
"[INST]In the context of the C64, what is the purpose of the '#' symbol in the instruction[/INST]the '#' symbol indicates that the parameter is a 'value'."
"[INST]In the context of the C64, what is the result of the instruction LDA #$05[/INST]this instruction will put $05 (decimal 5) into the accumulator register."
"[INST]In the context of the C64, what does the assembler do when assembling an instruction[/INST]the assembler puts into memory (at whatever address has been specified), the token, and what parameters, are given."
"[INST]In the context of the C64, what happens if you try to assemble something that the assembler or the 6510 microprocessor cannot do[/INST]some assemblers give error messages, or warnings."
"[INST]In the context of the C64, what is the purpose of the assembler[/INST]the assembler puts into memory (at whatever address has been specified), the token, and what parameters, are given."
"[INST]In the context of the C64, what is the difference between the LDA instruction in immediate mode and absolute mode[/INST]the LDA instruction in immediate mode has $A9 as its token, and the LDA instruction in absolute mode has $AD as its token."
"[INST]In the context of the C64, what is the result of the instruction LDA $102E[/INST]this instruction will put the contents of memory location $102E into the accumulator."
"[INST]In the context of the C64, in which mode is the parameter the contents of another register[/INST]neither immediate nor absolute mode, as the parameter is either a 'value' or the contents of a memory location."
"[INST]In the context of the C64, what is the purpose of the token in the instruction[/INST]the token is used by the 6510 microprocessor to distinguish between different instructions."
"[INST]In the context of the C64, what is the purpose of the parameter in the instruction[/INST]the parameter specifies what the accumulator should be loaded with."
"[INST]In the context of the C64, what is the difference between the LDA instruction and other instructions[/INST]the LDA instruction is used to load the accumulator, whereas other instructions are used for different purposes."
"[INST]In the context of the C64, what is the purpose of the accumulator[/INST]the accumulator is a register that holds the result of an instruction."
"[INST]In the context of the C64, what is the result of the instruction LDA #$05 in decimal[/INST]this instruction will put 5 into the accumulator register."
"[INST]In the context of the C64, what is the address where the token and parameters are stored[/INST]the address is specified by the programmer."
"[INST]In the context of the C64, what is the purpose of the assembler warnings or error messages[/INST]the warnings or error messages are used to inform the programmer of errors or inconsistencies in the code."
"[INST]In the context of the C64, what is the token for the LDA instruction in immediate mode in hexadecimal[/INST]the token for the LDA instruction in immediate mode is $A9 in hexadecimal."
"[INST]In the context of the C64, what is the token for the LDA instruction in absolute mode in hexadecimal[/INST]the token for the LDA instruction in absolute mode is $AD in hexadecimal."
"[INST]In the context of the C64, in which mode is the parameter a memory location[/INST]in absolute mode, the parameter is a memory location."
"[INST]In the context of the C64, What is the purpose of the RES pin?[/INST]The RES pin is the reset control for the SID."
"[INST]In the context of the C64, What happens when the RES pin is brought low for at least 10 clock cycles?[/INST]All internal registers are reset to zero and the audio output is silenced."
"[INST]In the context of the C64, What is the typical connection for the RES pin?[/INST]The RES pin is normally connected to the reset line of the microprocessor or a power-on-clear circuit."
"[INST]In the context of the C64, What happens to the audio output when the RES pin is brought low?[/INST]The audio output is silenced."
"[INST]In the context of the C64, What is the minimum duration for the RES pin to be low to reset the SID?[/INST]At least 10 clock cycles."
"[INST]In the context of the C64, What is the effect of bringing the RES pin low for at least 10 clock cycles?[/INST]All internal registers are reset to zero."
"[INST]In the context of the C64, What is the typical use of the RES pin?[/INST]The RES pin is used as a reset control for the SID."
"[INST]In the context of the C64, What happens to the internal registers when the RES pin is brought low?[/INST]All internal registers are reset to zero."
"[INST]In the context of the C64, What is the typical connection for the RES pin in a microprocessor?[/INST]The RES pin is connected to the reset line of the microprocessor."
"[INST]In the context of the C64, What is the purpose of the RES pin in a microprocessor?[/INST]The RES pin is used as a reset control for the SID."
"[INST]In the context of the C64, what is the purpose of the CIOUT function?[/INST]The purpose of the CIOUT function is to transmit a byte over the serial bus."
"[INST]In the context of the C64, what is the call address of the CIOUT function?[/INST]The call address of the CIOUT function is $FFA8 (hex) or 65448 (decimal)."
"[INST]In the context of the C64, what are the preparatory routines required before calling the CIOUT function?[/INST]The preparatory routines required before calling the CIOUT function are LISTEN and SECOND (if a secondary address is needed)."
"[INST]In the context of the C64, what is the role of the accumulator in the CIOUT function?[/INST]The accumulator is loaded with a byte to be sent as data on the serial bus, and it is used for handshaking."
"[INST]In the context of the C64, what happens if a device is not listening when the CIOUT function is called?[/INST]If a device is not listening when the CIOUT function is called, the status word will return a timeout."
"[INST]In the context of the C64, how does the CIOUT function handle the transmission of data?[/INST]The CIOUT function always buffers one character, holding the previous character to be sent back, and when the UNLSN routine is called to end the data transmission, the buffered character is sent with an End Or Identify (EOI) set."
"[INST]In the context of the C64, what is the sequence of steps to use the CIOUT function?[/INST]The sequence of steps to use the CIOUT function is: 1) use the LISTEN KERNAL routine (and the SECOND routine if needed), 2) load the accumulator with a byte of data, and 3) call the CIOUT routine to send the data byte."
"[INST]In the context of the C64, what is the significance of the UNLSN routine in relation to the CIOUT function?[/INST]The UNLSN routine is used to end the data transmission, and when called, the buffered character is sent with an End Or Identify (EOI) set, and then the UNLSN command is sent to the device."
"[INST]In the context of the C64, what is the error return mechanism of the CIOUT function?[/INST]The error returns of the CIOUT function are handled according to the READST routine."
"[INST]In the context of the C64, what is the stack requirement of the CIOUT function?[/INST]The stack requirement of the CIOUT function is 5."
"[INST]In the context of the C64, what is the purpose of the Programmable Character Worksheet[/INST]to help design your own characters"
"[INST]In the context of the C64, what is CHROMA noise[/INST]color distortion on a TV screen"
"[INST]In the context of the C64, What is the main advantage of using extended background color mode?[/INST]Extended background color mode gives you control over the background color of each individual character, as well as over the foreground color, allowing for more customization and flexibility in your graphics and text displays."
"[INST]In the context of the C64, How many registers are available for extended background color mode?[/INST]There are 4 registers available for extended background color mode, each of which can be set to any of the 16 available colors."
"[INST]In the context of the C64, What is the limitation of using extended character mode?[/INST]Extended character mode places a limit on the number of different characters you can display, restricting the use of characters to only the first 64 characters in the character ROM or programmable character set."
"[INST]In the context of the C64, How does extended color mode affect the character code?[/INST]In extended color mode, two bits of the character code are used to select the background color, which affects how the character is displayed on the screen."
"[INST]In the context of the C64, What is the purpose of color memory in extended background mode?[/INST]Color memory is used to hold the foreground color in extended background mode, and is used in the same way as in standard character mode."
"[INST]In the context of the C64, Can you use all characters in extended character mode?[/INST]No, when extended color mode is on, only the first 64 characters in the character ROM (or the first 64 characters in your programmable character set) can be used."
"[INST]In the context of the C64, How does POKEing a character code to the screen work in extended color mode?[/INST]When you POKE a character code to the screen in extended color mode, the character appears with the specified background color, rather than the default color."
"[INST]In the context of the C64, What happens when you POKE a character code with a value greater than 64 in extended color mode?[/INST]In extended color mode, POKEing a character code with a value greater than 64 does not result in the reversed character, but rather the same character with a different background color."
"[INST]In the context of the C64, Can you display a blue character with a yellow background on a white screen using extended background color mode?[/INST]Yes, extended background color mode allows you to display a blue character with a yellow background on a white screen, giving you more flexibility in your graphics and text displays."
"[INST]In the context of the C64, How many colors can each register be set to in extended background color mode?[/INST]Each of the 4 registers in extended background color mode can be set to any of the 16 available colors."
"[INST]In the context of the C64, What is the formula to calculate the start of the 64 bytes of the sprite definition block?[/INST]LOCATION = (BANK * 16384) + (SPRITE POINTER VALUE * 64)"
"[INST]In the context of the C64, What is the purpose of the ROM IMAGE in the BANK 0 or BANK 2?[/INST]there is a ROM IMAGE of the character set present in certain locations"
"[INST]In the context of the C64, What is the limitation of placing sprite definitions in certain locations?[/INST]Sprite definitions can NOT be placed there"
"[INST]In the context of the C64, What is the reason to use BANK 1 or BANK 3 for sprite definitions?[/INST]you should use one of the banks without the ROM IMAGE"
"[INST]In the context of the C64, What is the value of the sprite pointer #0 at location 2040?[/INST]14"
"[INST]In the context of the C64, What is the location of the sprite definition block for sprite 0?[/INST]896"
"[INST]In the context of the C64, What is the formula to calculate the location of the sprite definition block?[/INST]LOCATION = (BANK * 16384) + (SPRITE POINTER VALUE * 64)"
"[INST]In the context of the C64, What is the purpose of the cassette buffer?[/INST]it is used to store the 64 bytes of the sprite definition block"
"[INST]In the context of the C64, What is the size of the sprite definition block?[/INST]64 bytes"
"[INST]In the context of the C64, Can the VIC-II chip support smooth scrolling?[/INST]Yes, it supports smooth scrolling in both horizontal and vertical directions."
"[INST]In the context of the C64, What is smooth scrolling?[/INST]It is a one pixel movement of the entire screen in one direction."
"[INST]In the context of the C64, What are the directions of smooth scrolling?[/INST]It can move either UP, or down, or left, or right."
"[INST]In the context of the C64, Why is smooth scrolling used?[/INST]It is used to move new information smoothly onto the screen, while smoothly removing characters from the other side."
"[INST]In the context of the C64, What are the steps for SMOOTH SCROLLING?[/INST]Shrink the screen, set the scrolling register to maximum, place new data, increment the register, and shift the screen."
"[INST]In the context of the C64, What is the purpose of the scrolling registers?[/INST]To control the positioning of the video screen."
"[INST]In the context of the C64, What are the modes of the VIC-II chip?[/INST]38 column mode and 24 row mode."
"[INST]In the context of the C64, How do you go into 38 column mode?[/INST]By setting bit 3 of location 53270 to a 0."
"[INST]In the context of the C64, How do you return to 40 column mode?[/INST]By setting bit 3 of location 53270 to a 1."
"[INST]In the context of the C64, How do you go into 24 row mode?[/INST]By setting bit 3 of location 53265 to a 0."
"[INST]In the context of the C64, How do you return to 25 row mode?[/INST]By setting bit 3 of location 53265 to a 1."
"[INST]In the context of the C64, What is the purpose of 38 column mode?[/INST]To give new data a place to scroll from."
"[INST]In the context of the C64, What is the purpose of 24 row mode?[/INST]To place new data in the LAST row."
"[INST]In the context of the C64, What is the difference between X and Y scrolling?[/INST]X scrolling has covered areas on each side of the screen, while Y scrolling has only one covered area."
"[INST]In the context of the C64, What is the scroll register for X direction?[/INST]Located in bits 2 to 0 of the VIC-II control register at location 53270."
"[INST]In the context of the C64, What is the scroll register for Y direction?[/INST]Located in bits 2 to 0 of the VIC-II control register at location 53265."
"[INST]In the context of the C64, How do you scroll text onto the screen from the bottom?[/INST]By stepping the low-order 3 bits of location 53265 from 0-7."
"[INST]In the context of the C64, How do you scroll characters onto the screen from left to right?[/INST]By stepping the low-order 3 bits of location 53270 from 0 to 7."
"[INST]In the context of the C64, What happens if you step the scroll bits by -1?[/INST]Your text will move in the opposite direction."
"[INST]In the context of the C64, CPX has how many addressing modes?[/INST]Immediate, Zero Page, and Absolute"
"[INST]In the context of the C64, CPX has how many bytes in its opcode?[/INST]2"
"[INST]In the context of the C64, CPX has how many cycles in its execution?[/INST]2"
"[INST]In the context of the C64, CPX has how many bytes in its execution?[/INST]2"
"[INST]In the context of the C64, CPX has how many cycles in its execution?[/INST]4"
"[INST]In the context of the C64, CPX has what type of addressing mode?[/INST]Immediate"
"[INST]In the context of the C64, CPX has what type of addressing mode?[/INST]Zero Page"
"[INST]In the context of the C64, CPX has what type of addressing mode?[/INST]Absolute"
"[INST]In the context of the C64, CPX has what is the opcode for Immediate mode?[/INST]E0"
"[INST]In the context of the C64, CPX has what is the opcode for Zero Page mode?[/INST]E4"
"[INST]In the context of the C64, Is the BVS instruction used for branching?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the BVS instruction?[/INST]Branching"
"[INST]In the context of the C64, What is the BVS instruction short for?[/INST]Branch on Overflow Set"
"[INST]In the context of the C64, What happens to the program counter when a branch occurs?[/INST]It increments"
"[INST]In the context of the C64, What is the default value of the V flag?[/INST]1"
"[INST]In the context of the C64, What is the purpose of the N flag?[/INST]To indicate if the result of the operation is negative"
"[INST]In the context of the C64, What is the purpose of the C flag?[/INST]To indicate if the result of the operation is carry"
"[INST]In the context of the C64, What is the purpose of the I flag?[/INST]To indicate if the result of the operation is interrupt"
"[INST]In the context of the C64, What is the purpose of the D flag?[/INST]To indicate if the result of the operation is decimal"
"[INST]In the context of the C64, What is the purpose of the V flag?[/INST]To indicate if the result of the operation is overflow"
"[INST]In the context of the C64, What is the purpose of the PLOT function in C64?[/INST]The purpose of the PLOT function is to set the cursor location, and it can be used to either read the current cursor position or move the cursor to a specific location on the screen."
"[INST]In the context of the C64, What is the call address of the PLOT function?[/INST]The call address of the PLOT function is $FFF0 (hex) or 65520 (decimal)."
"[INST]In the context of the C64, What registers are affected by the PLOT function?[/INST]The PLOT function affects the A, X, and Y registers."
"[INST]In the context of the C64, What is the stack requirement for the PLOT function?[/INST]The stack requirement for the PLOT function is 2."
"[INST]In the context of the C64, How do you read the current cursor location using the PLOT function?[/INST]To read the current cursor location, set the carry flag, call the PLOT function, and then retrieve the X and Y position from the Y and X registers, respectively."
"[INST]In the context of the C64, What is the range of column numbers that can be set using the PLOT function?[/INST]The column number can be set to a value between 6 and 39 using the PLOT function."
"[INST]In the context of the C64, How do you set the cursor location to a specific row and column using the PLOT function?[/INST]To set the cursor location, clear the carry flag, set the Y and X registers to the desired row and column, and then call the PLOT function."
"[INST]In the context of the C64, What is the purpose of setting the carry flag when using the PLOT function?[/INST]The carry flag determines the operation of the PLOT function, with the carry flag set to read the current cursor location and clear to set the cursor location."
"[INST]In the context of the C64, What is an example of how to move the cursor to row 10, column 5 using the PLOT function?[/INST]An example of how to move the cursor to row 10, column 5 is: LDX #10, LDY #5, CLC, JSR PLOT."
"[INST]In the context of the C64, In what situation would you use the PLOT function with the carry flag set?[/INST]You would use the PLOT function with the carry flag set to read the current cursor location."
"[INST]In the context of the C64, What is the relationship between the X and Y registers and the row and column numbers when using the PLOT function?[/INST]When using the PLOT function, the X register contains the row number (0-24) and the Y register contains the column number (6-39)."
"[INST]In the context of the C64, BIT Test bits in memory with accumulator[/INST]The operation is used to test bits in memory with the accumulator."
"[INST]In the context of the C64, Accumulator is used in BIT operation[/INST]Yes, the accumulator is used in the BIT operation."
"[INST]In the context of the C64, Result of A /\ M is transferred to status register[/INST]Yes, the result of A /\ M is transferred to the status register."
"[INST]In the context of the C64, Z = 1 if result of A /\ M is zero[/INST]Yes, Z = 1 if the result of A /\ M is zero."
"[INST]In the context of the C64, Z = 0 if result of A /\ M is not zero[/INST]Yes, Z = 0 if the result of A /\ M is not zero."
"[INST]In the context of the C64, Addressing modes for BIT operation[/INST]The addressing modes for the BIT operation are Zero Page and Absolute."
"[INST]In the context of the C64, OP CODE for Zero Page BIT operation[/INST]The OP CODE for the Zero Page BIT operation is 24."
"[INST]In the context of the C64, Number of bytes for Zero Page BIT operation[/INST]The number of bytes for the Zero Page BIT operation is 2."
"[INST]In the context of the C64, Number of cycles for Zero Page BIT operation[/INST]The number of cycles for the Zero Page BIT operation is 3."
"[INST]In the context of the C64, Number of bytes for Absolute BIT operation[/INST]The number of bytes for the Absolute BIT operation is 3."
"[INST]In the context of the C64, what is the capacity of cassette tapes for data storage[/INST]almost unlimited"
"[INST]In the context of the C64, what is the limitation of cassette tapes[/INST]time it takes to find information"
"[INST]In the context of the C64, how can a programmer minimize the time factor when working with tape storage[/INST]read entire cassette data file into RAM, process it, and re-write all data on tape"
"[INST]In the context of the C64, what is the limitation of reading data from cassette tapes[/INST]must read through all data to access specific information"
"[INST]In the context of the C64, what is an alternative to cassette tapes for larger data files[/INST]floppy disk"
"[INST]In the context of the C64, what is an advantage of using floppy disks over cassette tapes[/INST]can read data at any position on the disk"
"[INST]In the context of the C64, how does the PRINT# statement format data[/INST]like the PRINT statement, but with consideration for the INPUT# statement"
"[INST]In the context of the C64, what happens when the INPUT# statement tries to read formatted strings from a cassette tape[/INST]it discovers no data for subsequent variables and combines all variables into one"
"[INST]In the context of the C64, how can you avoid wasting space on a cassette tape when using the PRINT# statement[/INST]use a separator such as a comma or RETURN code between variables"
"[INST]In the context of the C64, what is the RETURN code in CHR$ format[/INST]CHR$(13)"
"[INST]In the context of the C64, how can you put a RETURN code between each item when using the PRINT# statement[/INST]set a variable to the RETURN CHR$ code or use a comma"
"[INST]In the context of the C64, what is the GET# statement used for[/INST]to pick data from the tape one character at a time"
"[INST]In the context of the C64, what happens when the GET# statement receives a CHR$(0) code[/INST]it receives an empty string, not a one character string with a code of 0"
"[INST]In the context of the C64, how can you avoid an ILLEGAL QUANTITY ERROR when using the ASC function with the GET# statement[/INST]modify the line to GET#1, A$: A=ASC(A$+CHR$(0))"
"[INST]In the context of the C64, what is the purpose of adding CHR$(0) to the end of a string when using the ASC function[/INST]as insurance against empty strings"
"[INST]In the context of the C64, what happens when you try to use the ASC function on an empty string[/INST]you get an ILLEGAL QUANTITY ERROR"
"[INST]In the context of the C64, what is the advantage of using a floppy disk for business applications[/INST]can read data at any position on the disk"
"[INST]In the context of the C64, what type of applications typically use floppy disks[/INST]business applications like ledgers and mailing lists"
"[INST]In the context of the C64, how does the PRINT# statement work with the INPUT# statement[/INST]formats data with consideration for the INPUT# statement"
"[INST]In the context of the C64, what is the purpose of the INPUT# statement[/INST]to read data from a cassette tape"
"[INST]In the context of the C64, what happens when you use commas to separate variables in a PRINT# statement[/INST]it adds blank spaces between items, wasting space on the tape"
"[INST]In the context of the C64, how can you sort, edit, and examine data on a cassette tape[/INST]read the entire cassette data file into RAM, process it, and re-write all data on the tape"
"[INST]In the context of the C64, what is the limitation of using cassette tapes for data storage[/INST]size of available RAM"
"[INST]In the context of the C64, what happens when your data file is larger than the available RAM[/INST]it's probably time to switch to using a floppy disk"
"[INST]In the context of the C64, what is the purpose of the R$ variable in the PRINT# statement[/INST]to set a separator, such as a comma, between variables"
"[INST]In the context of the C64, what is the format of a proper tape file[/INST]with separators, such as commas or RETURN codes, between variables"
"[INST]In the context of the C64, Where is the sprite to sprite collision register located in the VIC-II chip control register?[/INST]The sprite to sprite collision register is located at location 53278 ($D01E in HEX) in the VIC-II chip control register."
"[INST]In the context of the C64, What happens to the bits in the sprite to sprite collision register when a collision is detected?[/INST]When a collision is detected, the corresponding bit in the sprite to sprite collision register is set to 1, indicating that the sprite is involved in a collision."
"[INST]In the context of the C64, What happens to the bits in the sprite to sprite collision register after they are read?[/INST]Once the bits in the sprite to sprite collision register are read (PEEKed), they are automatically cleared, so it is a good idea to save the value in a variable until you are finished with it."
"[INST]In the context of the C64, Can collisions occur even when sprites are off screen?[/INST]Yes, collisions can take place even when the sprites are off screen."
"[INST]In the context of the C64, How can you preserve the value of the sprite to sprite collision register after reading it?[/INST]You can preserve the value of the sprite to sprite collision register by saving it in a variable until you are finished with it."
"[INST]In the context of the C64, What is the purpose of the sprite to sprite collision register?[/INST]The purpose of the sprite to sprite collision register is to recognize sprite to sprite collisions and flag them for the computer to take action."
"[INST]In the context of the C64, How many bits are in the sprite to sprite collision register?[/INST]Each sprite has a bit in the sprite to sprite collision register, so the number of bits depends on the number of sprites being used."
"[INST]In the context of the C64, What happens if you don't save the value of the sprite to sprite collision register after reading it?[/INST]If you don't save the value of the sprite to sprite collision register after reading it, the value will be lost because the register is automatically cleared after being read."
"[INST]In the context of the C64, In what format is the location of the sprite to sprite collision register typically represented?[/INST]The location of the sprite to sprite collision register is typically represented in hexadecimal format, which is $D01E in this case."
"[INST]In the context of the C64, Why is it important to read the sprite to sprite collision register carefully?[/INST]It is important to read the sprite to sprite collision register carefully because the register is automatically cleared after being read, and you may lose the value if you don't save it in a variable."
"[INST]In the context of the C64, Is the extended color mode enabled by setting a specific register bit?[/INST]Yes, it is enabled by setting the ECM bit of register 17 to 1."
"[INST]In the context of the C64, What is the purpose of the 2 MSB of the character pointer in extended color mode?[/INST]They are used to select the background color for each character region."
"[INST]In the context of the C64, Can the 6566/6567 force CB10 and CB9 to specific values?[/INST]Yes, they will force CB10 and CB9 to '0' regardless of the original pointer values."
"[INST]In the context of the C64, How many different character definitions are available in extended color mode?[/INST]Only 64 different character definitions are available."
"[INST]In the context of the C64, Can a character have multiple foreground colors in extended color mode?[/INST]No, each character has only one individually defined foreground color."
"[INST]In the context of the C64, Are there any restrictions on enabling extended color mode?[/INST]Yes, it should not be enabled simultaneously with multi-color mode."
"[INST]In the context of the C64, What is the maximum number of background colors available in extended color mode?[/INST]There are four available background colors."
"[INST]In the context of the C64, Can the background color of a character be changed in extended color mode?[/INST]Yes, the background color can be selected for each character region."
"[INST]In the context of the C64, Is the character dot data displayed differently in extended color mode?[/INST]No, it is displayed as in the standard mode."
"[INST]In the context of the C64, What is the purpose of the color nybble in extended color mode?[/INST]The color nybble determines the foreground color for a '1' data bit."
"[INST]In the context of the C64, what is the function of the DEX instruction in 6502 assembly language?[/INST]The DEX instruction decrements the value of the X register by one. This instruction is useful for looping and counting applications where the X register is used as a counter. It is an implied mode instruction, meaning it does not require any operands and affects only the X register. The opcode for DEX is CA and it takes 1 byte of memory and 2 clock cycles to execute."
"[INST]In the context of the C64, what is the addressing mode of the DEX instruction?[/INST]The addressing mode of the DEX instruction is implied, which means it does not require any operands and affects only the X register."
"[INST]In the context of the C64, what is the opcode for the DEX instruction?[/INST]The opcode for the DEX instruction is CA, which is a single byte that represents the decrement X instruction."
"[INST]In the context of the C64, how many bytes does the DEX instruction occupy in memory?[/INST]The DEX instruction occupies 1 byte of memory, making it a very compact and efficient instruction."
"[INST]In the context of the C64, how many clock cycles does the DEX instruction take to execute?[/INST]The DEX instruction takes 2 clock cycles to execute, making it a relatively fast instruction."
"[INST]In the context of the C64, what is the purpose of the X register in the context of the DEX instruction?[/INST]The X register is used as a counter in the context of the DEX instruction, and decrementing it allows for looping and counting applications."
"[INST]In the context of the C64, can the DEX instruction be used with other addressing modes?[/INST]No, the DEX instruction can only be used with the implied addressing mode, which means it does not require any operands and affects only the X register."
"[INST]In the context of the C64, what happens to the X register when the DEX instruction is executed?[/INST]When the DEX instruction is executed, the value of the X register is decremented by one, which allows for looping and counting applications."
"[INST]In the context of the C64, is the DEX instruction a load or store instruction?[/INST]The DEX instruction is neither a load nor a store instruction, but rather a register modification instruction that affects the X register."
"[INST]In the context of the C64, can the DEX instruction be used to increment the X register?[/INST]No, the DEX instruction can only be used to decrement the X register, not increment it."
"[INST]In the context of the C64, Can a sprite be selectively enabled for display?[/INST]Each sprite can be selectively enabled for display by setting its corresponding enable bit to 1 in register 21 ($15)."
"[INST]In the context of the C64, Is the enable bit a binary value?[/INST]The enable bit is a binary value, where 1 enables the sprite and 0 disables it."
"[INST]In the context of the C64, What happens if the MnE bit is 0?[/INST]If the MnE bit is 0, no sprite operations will occur involving the disabled sprite."
"[INST]In the context of the C64, Can a sprite be disabled?[/INST]Yes, a sprite can be disabled by setting its corresponding enable bit to 0."
"[INST]In the context of the C64, What is the purpose of the enable bit?[/INST]The purpose of the enable bit is to selectively enable or disable sprites for display."
"[INST]In the context of the C64, Is the enable bit used in register 21?[/INST]Yes, the enable bit is used in register 21 ($15)."
"[INST]In the context of the C64, Can a sprite be enabled for display?[/INST]Yes, a sprite can be enabled for display by setting its corresponding enable bit to 1."
"[INST]In the context of the C64, What happens when a sprite is enabled?[/INST]When a sprite is enabled, it can be used for display."
"[INST]In the context of the C64, Is the enable bit used to control sprite operations?[/INST]Yes, the enable bit is used to control sprite operations."
"[INST]In the context of the C64, Can a sprite be disabled for display?[/INST]Yes, a sprite can be disabled for display by setting its corresponding enable bit to 0."
"[INST]In the context of the C64, Can I add peripherals to my Commodore 64?[/INST]Peripherals are things like Datassette(TM) recorders, disk drives, printers, and modems. All these items can be added to your Commodore 64 through the various ports and sockets on the back of your machine."
"[INST]In the context of the C64, What makes Commodore peripherals special?[/INST]The thing that makes Commodore peripherals so good is the fact that they don't take up valuable Random Access Memory space when they're in use. You're free to use all 64K of memory in your Commodore 64."
"[INST]In the context of the C64, Can I use all 64K of memory in my Commodore 64?[/INST]The thing that makes Commodore peripherals so good is the fact that they don't take up valuable Random Access Memory space when they're in use. You're free to use all 64K of memory in your Commodore 64."
"[INST]In the context of the C64, What is the advantage of writing programs on my Commodore 64?[/INST]Most programs you write on your Commodore 64 today will be upwardly compatible with any new Commodore computer you buy in the future. This is partially because of the qualities of the computer's Operating System (OS)."
"[INST]In the context of the C64, Can I use software from another company on my Commodore 64?[/INST]However, there is one thing that the Commodore OS can't do: make your programs compatible with a computer made by another company."
"[INST]In the context of the C64, What is the Commodore CP/M(R) cartridge?[/INST]CP/M(R) is not a computer dependent"" operating system. Instead it uses some of the memory space normally available for programming to run its own operating system."""
"[INST]In the context of the C64, Why would I want to use the Commodore CP/M(R) cartridge?[/INST]The advantages are that you can now use a large amount of software that has been specifically designed for CP/M(R) and the Z-80 microprocessor, and the programs that you write using the CP/M(R) operating system can be transported and run on any other computer that has CP/M(R) and a Z-80 card."
"[INST]In the context of the C64, Can I install a Z-80 card in my Commodore 64?[/INST]By the way, most computers that have a Z-80 microprocessor require that you go inside the computer to actually install a Z-80 card."
"[INST]In the context of the C64, How does the Commodore CP/M(R) cartridge make it easier to install a Z-80 card?[/INST]The Commodore CP/M& cartridge eliminates this hassle because our Z-80 cartridge plugs into the back of your Commodore 64 quickly and easily, without any messy wires that can cause problems later."
"[INST]In the context of the C64, Can I use my Commodore 64 with a Z-80 card?[/INST]Yes, you can use your Commodore 64 with a Z-80 card using the Commodore CP/M(R) cartridge."
"[INST]In the context of the C64, Is the Commodore 64 easy to use?[/INST]Most of the time you won't even have to think about using another company's computer, because your Commodore 64 is so easy to use."
"[INST]In the context of the C64, Can I use software that is not available in Commodore 64 format?[/INST]Most of the time you won't even have to think about using another company's computer, because your Commodore 64 is so easy to use. But for the occasional user who wants to take advantage of software that may not be available in Commodore 64 format we have created a Commodore CP/M(R) cartridge."
"[INST]In the context of the C64, What are the advantages of using the Commodore CP/M(R) cartridge?[/INST]The advantages are that you can now use a large amount of software that has been specifically designed for CP/M(R) and the Z-80 microprocessor, and the programs that you write using the CP/M(R) operating system can be transported and run on any other computer that has CP/M(R) and a Z-80 card."
"[INST]In the context of the C64, What are the disadvantages of using the Commodore CP/M(R) cartridge?[/INST]The disadvantages are that the programs you write will have to be shorter than the programs you can write using the Commodore 64's built-in operating system. In addition, you can NOT use the Commodore 64's powerful screen editing capabilities."
"[INST]In the context of the C64, Can I use the Commodore 64's screen editing capabilities with the CP/M(R) cartridge?[/INST]No, you can NOT use the Commodore 64's powerful screen editing capabilities."
"[INST]In the context of the C64, Can I write longer programs with the CP/M(R) cartridge?[/INST]The programs you write will have to be shorter than the programs you can write using the Commodore 64's built-in operating system."
"[INST]In the context of the C64, Can I use the Commodore 64's memory with the CP/M(R) cartridge?[/INST]There are advantages and disadvantages to this. The disadvantages are that the programs you write will have to be shorter than the programs you can write using the Commodore 64's built-in operating system. In addition, you can NOT use the Commodore 64's powerful screen editing capabilities."
"[INST]In the context of the C64, What is the function of the ACPTR routine?[/INST]Input byte from serial port"
"[INST]In the context of the C64, What is the address of the CHKIN routine?[/INST]$FFC6"
"[INST]In the context of the C64, What is the function of the CHRIN routine?[/INST]Input character from channel"
"[INST]In the context of the C64, What is the address of the CIOUT routine?[/INST]$FFA8"
"[INST]In the context of the C64, What is the function of the CINT routine?[/INST]Initialize screen editor"
"[INST]In the context of the C64, What is the address of the CLALL routine?[/INST]$FFE7"
"[INST]In the context of the C64, What is the function of the CLOSE routine?[/INST]Close a specified logical file"
"[INST]In the context of the C64, What is the address of the CLRCHN routine?[/INST]$FFCC"
"[INST]In the context of the C64, What is the function of the GETIN routine?[/INST]Get character from keyboard queue"
"[INST]In the context of the C64, What is the address of the IOBASE routine?[/INST]$FFF3"
"[INST]In the context of the C64, What is the function of the IOINIT routine?[/INST]Initialize input/output"
"[INST]In the context of the C64, What is the address of the LISTEN routine?[/INST]$FFB1"
"[INST]In the context of the C64, What is the function of the LOAD routine?[/INST]Load RAM from a device"
"[INST]In the context of the C64, What is the address of the MEMBOT routine?[/INST]$FF9C"
"[INST]In the context of the C64, What is the function of the MEMTOP routine?[/INST]Read/set the top of memory"
"[INST]In the context of the C64, What is the address of the OPEN routine?[/INST]$FFC0"
"[INST]In the context of the C64, What is the function of the PLOT routine?[/INST]Read/set X,Y cursor position"
"[INST]In the context of the C64, What is the address of the RAMTAS routine?[/INST]$FF87"
"[INST]In the context of the C64, What is the function of the RDTIM routine?[/INST]Read real time clock"
"[INST]In the context of the C64, What is the address of the READST routine?[/INST]$FFB7"
"[INST]In the context of the C64, What is the function of the RESTOR routine?[/INST]Restore default I/O vectors"
"[INST]In the context of the C64, What is the address of the SAVE routine?[/INST]$FFD8"
"[INST]In the context of the C64, What is the function of the SCNKEY routine?[/INST]Scan keyboard"
"[INST]In the context of the C64, What is the address of the SCREEN routine?[/INST]$FFED"
"[INST]In the context of the C64, What is the function of the SECOND routine?[/INST]Send secondary address after LISTEN"
"[INST]In the context of the C64, What is the address of the SETLFS routine?[/INST]$FFBA"
"[INST]In the context of the C64, What is the function of the SETMSG routine?[/INST]Control KERNAL messages"
"[INST]In the context of the C64, Is there a control register associated with TIMER A?[/INST]The CRA control register is associated with TIMER A."
"[INST]In the context of the C64, What is the function of bit 0 in the CRA register?[/INST]Bit 0 in the CRA register is used to start or stop TIMER A."
"[INST]In the context of the C64, What is the function of bit 1 in the CRA register?[/INST]Bit 1 in the CRA register is used to control the output of TIMER A on PB6."
"[INST]In the context of the C64, What is the function of bit 2 in the CRA register?[/INST]Bit 2 in the CRA register is used to toggle or pulse the TIMER A output."
"[INST]In the context of the C64, What is the function of bit 3 in the CRA register?[/INST]Bit 3 in the CRA register is used to select one-shot or continuous mode for TIMER A."
"[INST]In the context of the C64, What is the function of bit 4 in the CRA register?[/INST]Bit 4 in the CRA register is used to force a load of TIMER A."
"[INST]In the context of the C64, What is the function of bit 5 in the CRA register?[/INST]Bit 5 in the CRA register is used to select the input mode for TIMER A."
"[INST]In the context of the C64, What is the function of bit 6 in the CRA register?[/INST]Bit 6 in the CRA register is used to select the output mode for TIMER A."
"[INST]In the context of the C64, What is the function of bit 7 in the CRA register?[/INST]Bit 7 in the CRA register is used to select the clock source for TIMER A."
"[INST]In the context of the C64, What is the function of the CRB register?[/INST]The CRB register is associated with TIMER B."
"[INST]In the context of the C64, What is the function of bit 5 and 6 in the CRB register?[/INST]Bits 5 and 6 in the CRB register are used to select one of four input modes for TIMER B."
"[INST]In the context of the C64, What is the function of bit 7 in the CRB register?[/INST]Bit 7 in the CRB register is used to set the alarm or TOD clock."
"[INST]In the context of the C64, What happens to unused register bits?[/INST]Unused register bits are unaffected by a write and are forced to zero on a read."
"[INST]In the context of the C64, Who reserves the right to make changes to the product?[/INST]COMMODORE SEMICONDUCTOR GROUP reserves the right to make changes to the product."
"[INST]In the context of the C64, What is the purpose of the disclaimer?[/INST]The disclaimer is to inform that COMMODORE SEMICONDUCTOR GROUP does not assume any liability arising out of the application or use of the product."
"[INST]In the context of the C64, what is the purpose of the SERIAL ATN OUT signal in the Commodore 64[/INST]The Commodore 64 uses this signal to start a command sequence for a device on the serial bus."
"[INST]In the context of the C64, What happens when the Commodore 64 brings the SERIAL ATN OUT signal LOW[/INST]All other devices on the bus start listening for the Commodore 64 to transmit an address."
"[INST]In the context of the C64, What happens if the device addressed does not respond in a preset period of time[/INST]The Commodore 64 will assume that the device addressed is not on the bus, and will return an error in the STATUS WORD."
"[INST]In the context of the C64, What is the consequence of not responding to the address in the preset period of time[/INST]The Commodore 64 will return an error in the STATUS WORD."
"[INST]In the context of the C64, What is the purpose of the preset period of time in the SERIAL ATN OUT signal[/INST]The device addressed must respond in this period of time."
"[INST]In the context of the C64, What happens when the Commodore 64 brings the SERIAL ATN OUT signal LOW[/INST]All other devices on the bus start listening for the Commodore 64 to transmit an address."
"[INST]In the context of the C64, What is the purpose of the SERIAL ATN OUT signal in the Commodore 64[/INST]The Commodore 64 uses this signal to start a command sequence for a device on the serial bus."
"[INST]In the context of the C64, What happens when the device addressed does not respond in the preset period of time[/INST]The Commodore 64 will assume that the device addressed is not on the bus, and will return an error in the STATUS WORD."
"[INST]In the context of the C64, What is the consequence of not responding to the address in the preset period of time[/INST]The Commodore 64 will return an error in the STATUS WORD."
"[INST]In the context of the C64, What is the purpose of the preset period of time in the SERIAL ATN OUT signal[/INST]The device addressed must respond in this period of time."
"[INST]In the context of the C64, What happens when the device addressed does not respond in the preset period of time[/INST]The Commodore 64 will assume that the device addressed is not on the bus, and will return an error in the STATUS WORD."
"[INST]In the context of the C64, how do you switch between the two character sets on the commodore 64[/INST]The two character sets on the Commodore 64 can be switched by holding down the <SHIFT> and <C=> keys simultaneously. Additionally, from BASIC, POKE 53272,21 will switch to upper case mode and POKE 53272,23 switches to lower case."
"[INST]In the context of the C64, what is the memory location range for screen memory on the commodore 64[/INST]The memory location range for screen memory on the Commodore 64 is 1024-2023."
"[INST]In the context of the C64, how do you display a solid circle at a specific location on the screen[/INST]To display a solid circle at a specific location on the screen, you need to POKE the code for the circle (81) into the desired location. For example, to display a solid circle at location 1504, you would use the following command: POKE 1504,81."
"[INST]In the context of the C64, how do you change the color of a character on the screen[/INST]To change the color of a character on the screen, you need to POKE the corresponding memory location with the desired color code. For example, to change the color of the circle to yellow (color code 7) at location 1504, you would use the following commands: POKE 1504,81 and POKE 55776,7."
"[INST]In the context of the C64, what is the purpose of the memory locations 55296-56295[/INST]The memory locations 55296-56295 are used to control the color of each character displayed on the screen."
"[INST]In the context of the C64, how do you obtain the reverse character code for a character[/INST]The reverse character code for a character can be obtained by adding 128 to the values shown in the character chart."
"[INST]In the context of the C64, what is the purpose of appendix d in the commodore 64 documentation[/INST]Appendix D in the Commodore 64 documentation provides the complete screen and color memory maps, along with color codes."
"[INST]In the context of the C64, what characters have the same symbol in set 1 and 2[/INST]The characters that have the same symbol in set 1 and 2 are: 1, 27-64, 91-93, 96-104, 106-121, 123-127."
"[INST]In the context of the C64, how do you poke a character into screen memory[/INST]To poke a character into screen memory, you need to use the POKE command followed by the memory location and the code for the character. For example, to poke the code for a circle (81) into location 1504, you would use the following command: POKE 1504,81."
"[INST]In the context of the C64, what is the range of memory locations used to control the color of characters on the screen[/INST]The range of memory locations used to control the color of characters on the screen is 55296-56295."
"[INST]In the context of the C64, VCx denotes the video matrix counter outputs, what does RCx denote?[/INST]The 3-bit raster line counter"
"[INST]In the context of the C64, Video matrix counter steps through how many locations?[/INST]40"
"[INST]In the context of the C64, What is the increment of the raster counter?[/INST]once for each horizontal video line"
"[INST]In the context of the C64, What is the purpose of the video matrix counter?[/INST]to step through the same 40 locations"
"[INST]In the context of the C64, What is the purpose of the raster counter?[/INST]to increment once for each horizontal video line"
"[INST]In the context of the C64, How many locations are formatted as an 8*8 dot block on the video display?[/INST]8"
"[INST]In the context of the C64, What is the addressing result of the video matrix and raster counters?[/INST]each eight sequential memory locations being formatted as an 8*8 dot block"
"[INST]In the context of the C64, What is the frequency of the raster counter increment?[/INST]once for each horizontal video line"
"[INST]In the context of the C64, What is the range of the video matrix counter?[/INST]40 locations"
"[INST]In the context of the C64, What is the purpose of the raster line counter?[/INST]to increment once for each horizontal video line"
"[INST]In the context of the C64, what is the opcode for the cli instruction in 6502 assembly language?[/INST]The opcode for the CLI instruction in 6502 assembly language is 58."
"[INST]In the context of the C64, what is the addressing mode for the cli instruction?[/INST]The addressing mode for the CLI instruction is implied."
"[INST]In the context of the C64, what is the number of bytes required to store the cli instruction?[/INST]The number of bytes required to store the CLI instruction is 1."
"[INST]In the context of the C64, what is the number of cycles required to execute the cli instruction?[/INST]The number of cycles required to execute the CLI instruction is 2."
"[INST]In the context of the C64, what is the purpose of the cli instruction?[/INST]The purpose of the CLI instruction is to clear the interrupt disable bit."
"[INST]In the context of the C64, how does the cli instruction affect the interrupt disable flag?[/INST]The CLI instruction clears the interrupt disable flag, enabling interrupts."
"[INST]In the context of the C64, in what situations would you use the cli instruction?[/INST]The CLI instruction would be used in situations where interrupts need to be enabled, such as when an interrupt-driven I/O operation is required."
"[INST]In the context of the C64, what is the difference between the cli and sei instructions?[/INST]The CLI instruction clears the interrupt disable flag, while the SEI instruction sets the interrupt disable flag."
"[INST]In the context of the C64, can the cli instruction be used to disable interrupts?[/INST]No, the CLI instruction is used to enable interrupts, not disable them."
"[INST]In the context of the C64, in what type of programming scenarios would the cli instruction be used?[/INST]The CLI instruction would be used in scenarios that require interrupt-driven I/O operations, such as in device drivers or interrupt handlers."
"[INST]In the context of the C64, What happens when a '0' bit is displayed in standard mode?[/INST]Standard mode allows any background data to show through when a '0' bit is displayed."
"[INST]In the context of the C64, How is sprite data interpreted in multi-color mode?[/INST]In multi-color mode, sprite data is interpreted in pairs."
"[INST]In the context of the C64, What is the interpretation of sprite data in multi-color mode?[/INST]The sprite data is interpreted as follows: BIT PAIR | COLOR DISPLAYED."
"[INST]In the context of the C64, How many colors can be displayed in each sprite in multi-color mode?[/INST]Up to 3 colors can be displayed in each sprite in addition to transparent."
"[INST]In the context of the C64, Which colors are shared among all the sprites in multi-color mode?[/INST]Two of the colors are shared among all the sprites in the multi-color mode."
"[INST]In the context of the C64, What is the resolution of the sprite in multi-color mode?[/INST]The resolution of the sprite is reduced to 12X21 in multi-color mode."
"[INST]In the context of the C64, How are horizontal dots affected in multi-color mode?[/INST]Each horizontal dot is expanded to twice the standard size in multi-color mode."
"[INST]In the context of the C64, How many colors can be displayed in each sprite in addition to transparent?[/INST]Up to 3 colors can be displayed in each sprite in addition to transparent."
"[INST]In the context of the C64, What is the opcode for loading the Y register with an immediate value?[/INST]The opcode for loading the Y register with an immediate value is A0, and it requires 2 bytes and 2 cycles to execute."
"[INST]In the context of the C64, What is the difference in cycles required for loading the Y register with a zero page address versus an absolute address?[/INST]The difference in cycles required for loading the Y register with a zero page address versus an absolute address is 1 cycle, with zero page addressing taking 3 cycles and absolute addressing taking 4 cycles."
"[INST]In the context of the C64, How does the LDY instruction with the X register as an index affect the number of cycles required?[/INST]When the X register is used as an index with the LDY instruction, the number of cycles required increases by 1, from 3 to 4 cycles, and an additional cycle is required if a page boundary is crossed."
"[INST]In the context of the C64, What is the addressing mode used when the LDY instruction is used with an immediate value?[/INST]The addressing mode used when the LDY instruction is used with an immediate value is Immediate addressing, which requires 2 bytes and 2 cycles to execute."
"[INST]In the context of the C64, What is the opcode for loading the Y register with a zero page address?[/INST]The opcode for loading the Y register with a zero page address is A4, and it requires 2 bytes and 3 cycles to execute."
"[INST]In the context of the C64, How does the LDY instruction with a zero page address differ from the LDY instruction with an absolute address?[/INST]The LDY instruction with a zero page address differs from the LDY instruction with an absolute address in that it uses a shorter address and requires fewer cycles, with the zero page address taking 3 cycles and the absolute address taking 4 cycles."
"[INST]In the context of the C64, What is the effect of crossing a page boundary when using the LDY instruction with an absolute address and the X register as an index?[/INST]When using the LDY instruction with an absolute address and the X register as an index, crossing a page boundary adds an additional cycle to the execution time, increasing the total number of cycles from 4 to 5."
"[INST]In the context of the C64, What is the purpose of the LDY instruction?[/INST]The purpose of the LDY instruction is to load the Y register with a value from memory, which can be used for various purposes such as indexing, counting, and storing data."
"[INST]In the context of the C64, In what way does the LDY instruction with the X register as an index differ from the LDY instruction without the X register?[/INST]The LDY instruction with the X register as an index differs from the LDY instruction without the X register in that it allows for more flexibility in addressing memory locations, as the X register can be used to offset the address."
"[INST]In the context of the C64, What is the opcode for loading the Y register with an absolute address?[/INST]The opcode for loading the Y register with an absolute address is AC, and it requires 3 bytes and 4 cycles to execute."
"[INST]In the context of the C64, what is the purpose of the stack pointer register?[/INST]The stack pointer register is a crucial component in the Commodore 64's architecture, and it serves as a pointer to the first empty location on the stack. The stack is a region of memory that is used for temporary storage by both machine language programs and the computer itself. The stack pointer register plays a vital role in managing this temporary storage, allowing the computer to efficiently allocate and deallocate memory as needed."
"[INST]In the context of the C64, what is the stack used for in machine language programs?[/INST]The stack is a critical component in machine language programs, providing a temporary storage area for data and program instructions. It allows programs to store and retrieve data temporarily, enabling efficient use of memory and facilitating the execution of complex algorithms and routines."
"[INST]In the context of the C64, what is the relationship between the stack pointer and the stack?[/INST]The stack pointer register contains the memory address of the first empty location on the stack. This means that the stack pointer points to the next available location on the stack, allowing the computer to efficiently allocate and deallocate memory as needed. The stack pointer and the stack are intimately connected, with the stack pointer serving as a gateway to the stack's temporary storage area."
"[INST]In the context of the C64, how does the computer use the stack?[/INST]The computer uses the stack to temporarily store data and program instructions, allowing it to efficiently execute complex algorithms and routines. The stack provides a flexible and dynamic memory allocation system, enabling the computer to adapt to changing program requirements and optimize system performance."
"[INST]In the context of the C64, what is the significance of the stack in machine language programming?[/INST]The stack is a fundamental component in machine language programming, providing a temporary storage area for data and program instructions. It allows programmers to write efficient and optimized code, leveraging the stack's dynamic memory allocation capabilities to minimize memory usage and maximize system performance."
"[INST]In the context of the C64, how does the stack pointer register facilitate memory allocation?[/INST]The stack pointer register facilitates memory allocation by providing a pointer to the first empty location on the stack. This allows the computer to efficiently allocate and deallocate memory as needed, ensuring that memory is used optimally and minimizing the risk of memory-related errors."
"[INST]In the context of the C64, what is the role of the stack in temporary storage?[/INST]The stack plays a critical role in temporary storage, providing a region of memory that can be used to store data and program instructions temporarily. This allows programs to efficiently use memory, minimizing the need for permanent storage and enabling the execution of complex algorithms and routines."
"[INST]In the context of the C64, how does the stack pointer register interact with the stack?[/INST]The stack pointer register interacts with the stack by pointing to the first empty location on the stack. This allows the computer to efficiently allocate and deallocate memory as needed, ensuring that the stack is used optimally and minimizing the risk of memory-related errors."
"[INST]In the context of the C64, what are the implications of the stack pointer register on program execution?[/INST]The stack pointer register has significant implications for program execution, as it enables efficient use of memory and facilitates the execution of complex algorithms and routines. By providing a pointer to the first empty location on the stack, the stack pointer register allows programs to efficiently allocate and deallocate memory, minimizing the risk of memory-related errors and optimizing system performance."
"[INST]In the context of the C64, how does the stack pointer register contribute to system performance?[/INST]The stack pointer register contributes to system performance by facilitating efficient use of memory and enabling the execution of complex algorithms and routines. By providing a pointer to the first empty location on the stack, the stack pointer register allows the computer to optimize memory allocation and deallocation, minimizing the risk of memory-related errors and maximizing system performance."
"[INST]In the context of the C64, what are the three components of a voice in the 6581 synthesizer?[/INST]A voice in the 6581 synthesizer consists of three components: a Tone Oscillator/Waveform Generator, an Envelope Generator, and an Amplitude Modulator."
"[INST]In the context of the C64, how does the tone oscillator control the pitch of a voice?[/INST]The Tone Oscillator controls the pitch of a voice over a wide range, producing four waveforms at the selected frequency, with the unique harmonic content of each waveform providing simple control of tone color."
"[INST]In the context of the C64, what is the function of the amplitude modulator in a voice?[/INST]The Amplitude Modulator controls the volume dynamics of the oscillator under the direction of the Envelope Generator, allowing for programmable rates of increasing and decreasing volume."
"[INST]In the context of the C64, what is the purpose of the envelope generator in a voice?[/INST]The Envelope Generator creates an amplitude envelope with programmable rates of increasing and decreasing volume when triggered, allowing for dynamic control of the voice's volume."
"[INST]In the context of the C64, how can the third oscillator be used in addition to generating sound?[/INST]The third oscillator can be used as a random number generator for games, and its output can be read by the microprocessor to create vibrato, frequency/filter sweeps, and similar effects."
"[INST]In the context of the C64, what is the purpose of the two A/D converters in the SID chip?[/INST]The two A/D converters are provided for interfacing SID with potentiometers, allowing for the use of 'paddles' in a game environment or as front panel controls in a music synthesizer."
"[INST]In the context of the C64, how can multiple SID chips be used together?[/INST]Multiple SID chips can be daisy-chained or mixed in complex polyphonic systems, allowing for the processing of external audio signals and the creation of complex sounds."
"[INST]In the context of the C64, what is the function of the programmable filter in the SID chip?[/INST]The programmable Filter is provided for generating complex, dynamic tone colors via subtractive synthesis, allowing for a wide range of tonal possibilities."
"[INST]In the context of the C64, how can the SID chip be used in conjunction with external audio sources?[/INST]The SID chip can process external audio signals, allowing for the integration of external audio sources into the sound generation process."
"[INST]In the context of the C64, what is the advantage of using the SID chip in a music synthesizer?[/INST]The SID chip provides a powerful and flexible sound generation system, allowing for the creation of complex and dynamic sounds through the use of its three voices, programmable filter, and external audio processing capabilities."
"[INST]In the context of the C64, what is the purpose of the R/W input in a C64 system?[/INST]The R/W input determines the direction of data transfer on the data bus, in conjunction with /CS, where a high signal indicates data transfer from the selected register to the data bus output, and a low signal indicates data presented on the data bus pins is loaded into the selected register."
"[INST]In the context of the C64, what happens when the R/W input is high?[/INST]When the R/W input is high, data is transferred from the selected register to the data bus output, allowing the system to read data from the register."
"[INST]In the context of the C64, what is the function of the R/W input in conjunction with /CS?[/INST]The R/W input, in conjunction with /CS, determines the direction of data transfer on the data bus, controlling whether data is read from or written to the selected register."
"[INST]In the context of the C64, what is the effect of a low R/W input signal?[/INST]A low R/W input signal indicates that data presented on the data bus pins is loaded into the selected register, allowing the system to write data to the register."
"[INST]In the context of the C64, in what way does the R/W input influence data transfer on the data bus?[/INST]The R/W input influences data transfer on the data bus by determining the direction of data transfer, where a high signal indicates a read operation and a low signal indicates a write operation."
"[INST]In the context of the C64, what is the relationship between the R/W input and the data bus?[/INST]The R/W input controls the direction of data transfer on the data bus, where a high signal enables data transfer from the selected register to the data bus output, and a low signal enables data transfer from the data bus pins to the selected register."
"[INST]In the context of the C64, how does the R/W input interact with the /CS signal?[/INST]The R/W input interacts with the /CS signal to determine the direction of data transfer on the data bus, where the /CS signal selects the register and the R/W input determines the direction of data transfer."
"[INST]In the context of the C64, in what way does the R/W input control data transfer?[/INST]The R/W input controls data transfer by determining the direction of data transfer, where a high signal indicates a read operation and a low signal indicates a write operation, allowing the system to control the flow of data."
"[INST]In the context of the C64, what is the significance of the R/W input in a C64 system?[/INST]The R/W input is significant in a C64 system as it determines the direction of data transfer on the data bus, controlling whether data is read from or written to the selected register."
"[INST]In the context of the C64, how does the R/W input affect the data bus?[/INST]The R/W input affects the data bus by controlling the direction of data transfer, where a high signal enables data transfer from the selected register to the data bus output, and a low signal enables data transfer from the data bus pins to the selected register."
"[INST]In the context of the C64, what is the first type of sprite collision detected?[/INST]A collision between two sprites occurs when non-transparent output data of two sprites are coincident."
"[INST]In the context of the C64, what happens when a collision occurs between two sprites?[/INST]The sprite bits (MnM) in the sprite-sprite COLLISION register 30 ($1E) will be set to '1' for both colliding sprites."
"[INST]In the context of the C64, what happens to the collision bits after a read of the collision register?[/INST]The collision bits remain set until a read of the collision register, when all bits are automatically cleared."
"[INST]In the context of the C64, are sprites collisions detected even if positioned off-screen?[/INST]Yes, sprites collisions are detected even if positioned off-screen."
"[INST]In the context of the C64, what is the second type of collision detected?[/INST]A sprite-DATA collision between a sprite and foreground display data from the character or bit map modes."
"[INST]In the context of the C64, what is the purpose of the sprite-DATA COLLISION register 31 ($1F)?[/INST]The sprite-DATA COLLISION register 31 ($1F) has a 'bit (MnD) for each sprite which is set to '1' when both the sprite and non-background display data are coincident."
"[INST]In the context of the C64, what does not generate a collision in sprite-DATA collision?[/INST]The coincidence of only transparent data does not generate a collision."
"[INST]In the context of the C64, what is a special feature of the display data from the 0-1 multicolor bit pair?[/INST]The display data from the 0-1 multicolor bit pair also does not cause a collision."
"[INST]In the context of the C64, why is the display data from the 0-1 multicolor bit pair special?[/INST]This feature permits their use as background display data without interfering with true sprite collisions."
"[INST]In the context of the C64, can a sprite-DATA collision occur off-screen?[/INST]A sprite-DATA collision can occur off-screen in the horizontal direction if actual display data has been scrolled to an off-screen position."
"[INST]In the context of the C64, what happens to the sprite-DATA COLLISION register when read?[/INST]The sprite-DATA COLLISION register also automatically clears when read."
"[INST]In the context of the C64, what triggers the collision interrupt latches?[/INST]The collision interrupt latches are set whenever the first bit of either register is set to '1'."
"[INST]In the context of the C64, what happens to subsequent collisions after the collision interrupt latches are set?[/INST]Once any collision bit within a register is set high, subsequent collisions will not set the interrupt latch until that collision register has been cleared to all '0s' by a read."
"[INST]In the context of the C64, what is the purpose of the sprite-sprite COLLISION register 30 ($1E)?[/INST]The sprite-sprite COLLISION register 30 ($1E) has bits (MnM) that are set to '1' for both colliding sprites when a collision occurs."
"[INST]In the context of the C64, what is the difference between sprite-sprite collision and sprite-DATA collision?[/INST]Sprite-sprite collision occurs between two sprites, while sprite-DATA collision occurs between a sprite and foreground display data."
"[INST]In the context of the C64, can a collision occur between two transparent sprites?[/INST]No, coincidence of sprite transparent areas will not generate a collision."
"[INST]In the context of the C64, what is the purpose of the collision registers?[/INST]The collision registers detect and store information about sprite collisions."
"[INST]In the context of the C64, how many types of sprite collisions are detected?[/INST]Two types of sprite collisions are detected: sprite to sprite and sprite to display data."
"[INST]In the context of the C64, what is the purpose of the collision interrupt latches?[/INST]The collision interrupt latches are set whenever the first bit of either register is set to '1'."
"[INST]In the context of the C64, what happens when a sprite collides with display data?[/INST]The sprite-DATA COLLISION register 31 ($1F) has a 'bit (MnD) for each sprite which is set to '1' when both the sprite and non-background display data are coincident."
"[INST]In the context of the C64, can a sprite collision occur off-screen in the vertical direction?[/INST]The text does not specify whether a sprite collision can occur off-screen in the vertical direction."
"[INST]In the context of the C64, what is the purpose of the sprite bits (MnM)?[/INST]The sprite bits (MnM) in the sprite-sprite COLLISION register 30 ($1E) are set to '1' for both colliding sprites when a collision occurs."
"[INST]In the context of the C64, what is the purpose of the bit (MnD)?[/INST]The bit (MnD) in the sprite-DATA COLLISION register 31 ($1F) is set to '1' when both the sprite and non-background display data are coincident."
"[INST]In the context of the C64, what happens when a sprite collides with another sprite?[/INST]The sprite bits (MnM) in the sprite-sprite COLLISION register 30 ($1E) will be set to '1' for both colliding sprites."
"[INST]In the context of the C64, can a sprite-DATA collision occur on-screen?[/INST]A sprite-DATA collision can occur on-screen if the sprite and non-background display data are coincident."
"[INST]In the context of the C64, what is the purpose of clearing the collision registers?[/INST]Clearing the collision registers allows subsequent collisions to set the interrupt latch again."
"[INST]In the context of the C64, what happens when the collision registers are cleared?[/INST]The collision registers are automatically cleared when read."
"[INST]In the context of the C64, Where are the integrating capacitors C1 and C2 connected on the SID chip?[/INST]C1 connects between pins 1 and 2, and C2 connects between pins 3 and 4, both capacitors should be of the same value."
"[INST]In the context of the C64, What is the recommended value for C1 and C2 for normal operation of the Filter over the audio range?[/INST]A value of 2200 pF for C1 and C2 is recommended for normal operation of the Filter over the audio range, which is approximately 30 Hz-12 kHz."
"[INST]In the context of the C64, Why are polystyrene capacitors preferred for the SID chip?[/INST]Polystyrene capacitors are preferred because they provide a more stable and accurate filtering operation, especially in complex polyphonic systems where many SID chips must track each other."
"[INST]In the context of the C64, What is the formula to calculate the maximum Cutoff Frequency of the Filter?[/INST]The formula to calculate the maximum Cutoff Frequency of the Filter is FCmax = 2.6E-5/C, where C is the capacitor value."
"[INST]In the context of the C64, How many octaves does the range of the Filter extend below the maximum Cutoff Frequency?[/INST]The range of the Filter extends 9 octaves below the maximum Cutoff Frequency."
"[INST]In the context of the C64, What is the purpose of the capacitors C1 and C2 in the SID chip?[/INST]The capacitors C1 and C2 are used to connect the two integrating capacitors required by the programmable Filter."
"[INST]In the context of the C64, Why are matched capacitors recommended in complex polyphonic systems?[/INST]Matched capacitors are recommended in complex polyphonic systems because they ensure that many SID chips track each other accurately and consistently."
"[INST]In the context of the C64, How can the frequency range of the Filter be tailored to specific applications?[/INST]The frequency range of the Filter can be tailored to specific applications by the choice of capacitor values, for example, larger values for C1 and C2 can be chosen to provide more control over the bass frequencies of the Filter."
"[INST]In the context of the C64, What type of capacitors are recommended for use in the SID chip?[/INST]Polystyrene capacitors are recommended for use in the SID chip because of their stability and accuracy."
"[INST]In the context of the C64, What is the effect of using larger values for C1 and C2 on the Filter's frequency range?[/INST]Using larger values for C1 and C2 can provide more control over the bass frequencies of the Filter, making it suitable for applications that do not require full high-frequency response."
"[INST]In the context of the C64, what is the opcode for the BVC instruction?[/INST]The opcode for the BVC instruction is 50, which is a single byte that represents the operation code for the Branch on Overflow Clear instruction."
"[INST]In the context of the C64, What is the addressing mode used by the BVC instruction?[/INST]The addressing mode used by the BVC instruction is Relative, which means the instruction uses a relative address to determine the target of the branch."
"[INST]In the context of the C64, What is the number of bytes required to encode the BVC instruction?[/INST]The BVC instruction requires 2 bytes to encode, with the first byte being the opcode and the second byte being the relative offset."
"[INST]In the context of the C64, What is the number of cycles required to execute the BVC instruction?[/INST]The BVC instruction requires 2 cycles to execute, but this can increase to 3 cycles if the branch occurs to the same page, and 4 cycles if the branch occurs to a different page."
"[INST]In the context of the C64, What happens to the cycle count if the branch occurs to the same page?[/INST]If the branch occurs to the same page, the cycle count increases by 1, making it a total of 3 cycles."
"[INST]In the context of the C64, What happens to the cycle count if the branch occurs to a different page?[/INST]If the branch occurs to a different page, the cycle count increases by 2, making it a total of 4 cycles."
"[INST]In the context of the C64, What is the purpose of the BVC instruction?[/INST]The purpose of the BVC instruction is to branch to a target location if the Overflow flag is clear, allowing for conditional branching based on the state of the Overflow flag."
"[INST]In the context of the C64, In what situations would you use the BVC instruction?[/INST]You would use the BVC instruction in situations where you need to branch to a different location based on the state of the Overflow flag, such as in error handling or conditional logic."
"[INST]In the context of the C64, How does the BVC instruction interact with the Overflow flag?[/INST]The BVC instruction interacts with the Overflow flag by branching to a target location if the Overflow flag is clear, and not branching if the Overflow flag is set."
"[INST]In the context of the C64, What is the difference between the BVC and BVS instructions?[/INST]The BVC instruction branches if the Overflow flag is clear, whereas the BVS instruction branches if the Overflow flag is set, making them complementary instructions."
"[INST]In the context of the C64, When approaching a large task in machine language, what should you do to break it down into manageable pieces?[/INST]Write it out on paper, using block diagrams of memory usage, functional modules of code required, and a program flow to visualize the task and make it more manageable."
"[INST]In the context of the C64, What is the first step in outlining a machine language task, such as a roulette game?[/INST]Display the title of the game, and then ask the player if they require instructions."
"[INST]In the context of the C64, How can you make a large task seem less daunting?[/INST]Break it down into small enough pieces that can be tackled individually, making the task seem less impossible and more achievable."
"[INST]In the context of the C64, What is the key to successfully approaching a large task in machine language?[/INST]Practice, as the process of breaking down large tasks into smaller pieces only improves with practice and repetition."
"[INST]In the context of the C64, In what way can you visualize the flow of a machine language program?[/INST]By creating a program flow, which outlines the sequence of events and processes that the program will follow."
"[INST]In the context of the C64, What is the benefit of breaking down a large task into smaller modules?[/INST]It allows you to focus on one module at a time, making the task seem less overwhelming and more manageable."
"[INST]In the context of the C64, How can you ensure that you don't miss any important steps in a machine language program?[/INST]By outlining the program flow and breaking it down into smaller modules, you can ensure that all necessary steps are included."
"[INST]In the context of the C64, What is the main goal of outlining a machine language task?[/INST]To break it down into smaller, more manageable pieces that can be tackled individually, making the task seem less impossible and more achievable."
"[INST]In the context of the C64, How can you make a complex task seem more achievable?[/INST]By breaking it down into smaller, more manageable pieces, and focusing on one piece at a time, you can make the task seem less overwhelming and more achievable."
"[INST]In the context of the C64, What is the importance of practice in approaching large tasks in machine language?[/INST]Practice improves your ability to break down large tasks into smaller pieces, making it easier to approach and complete complex tasks."
"[INST]In the context of the C64, DEC instruction decreases the value of what memory location?[/INST]memory location"
"[INST]In the context of the C64, What is the operation performed by the DEC instruction?[/INST]decrement"
"[INST]In the context of the C64, What is the effect of the DEC instruction on the N flag?[/INST]no change"
"[INST]In the context of the C64, What is the effect of the DEC instruction on the Z flag?[/INST]no change"
"[INST]In the context of the C64, What is the effect of the DEC instruction on the C flag?[/INST]no change"
"[INST]In the context of the C64, What is the effect of the DEC instruction on the I flag?[/INST]no change"
"[INST]In the context of the C64, What is the effect of the DEC instruction on the D flag?[/INST]no change"
"[INST]In the context of the C64, What is the effect of the DEC instruction on the V flag?[/INST]no change"
"[INST]In the context of the C64, What is the number of bytes required to execute the DEC instruction?[/INST]2"
"[INST]In the context of the C64, What is the number of cycles required to execute the DEC instruction?[/INST]5"
"[INST]In the context of the C64, Where is the position of a sprite calculated from?[/INST]The position of a sprite is calculated from the top left corner of the 24 dot by 21 dot area that your sprite can be designed in."
"[INST]In the context of the C64, What is the reference point for calculating the position of a sprite?[/INST]The reference point for calculating the position of a sprite is the top left corner of the sprite's 24x21 dot area, regardless of the number of dots used to make up the sprite."
"[INST]In the context of the C64, How does the number of dots used in a sprite affect its positioning?[/INST]The number of dots used in a sprite does not affect its positioning, as the position is always calculated from the top left corner of the 24x21 dot area."
"[INST]In the context of the C64, What happens if I only use one dot to make up a sprite?[/INST]Even if only one dot is used to make up a sprite, the position is still calculated from the top left corner of the 24x21 dot area."
"[INST]In the context of the C64, How do I position a sprite in the middle of the screen?[/INST]To position a sprite in the middle of the screen, you must calculate the exact positioning by starting at the top left corner location of the sprite's 24x21 dot area."
"[INST]In the context of the C64, What is the significance of the top left corner in sprite positioning?[/INST]The top left corner is the reference point for calculating the position of a sprite, and it is used regardless of the size or complexity of the sprite."
"[INST]In the context of the C64, Can I use a different reference point for calculating sprite position?[/INST]No, the top left corner is the fixed reference point for calculating the position of a sprite, and it cannot be changed."
"[INST]In the context of the C64, How does the size of the sprite affect its positioning?[/INST]The size of the sprite does not affect its positioning, as the position is always calculated from the top left corner of the 24x21 dot area."
"[INST]In the context of the C64, What is the importance of considering the top left corner in sprite design?[/INST]Considering the top left corner is crucial in sprite design, as it is the reference point for calculating the position of the sprite, and ignoring it can lead to incorrect positioning."
"[INST]In the context of the C64, Can I ignore the top left corner when designing a sprite?[/INST]No, ignoring the top left corner can lead to incorrect positioning of the sprite, so it is essential to consider it when designing a sprite."
"[INST]In the context of the C64, CLD operation mode[/INST]Clear decimal mode"
"[INST]In the context of the C64, What is the purpose of the CLD operation?[/INST]To clear the decimal mode"
"[INST]In the context of the C64, What is the assembly language form of the CLD operation?[/INST]CLD"
"[INST]In the context of the C64, What is the OP CODE of the CLD operation?[/INST]D8"
"[INST]In the context of the C64, How many bytes does the CLD operation use?[/INST]1"
"[INST]In the context of the C64, How many cycles does the CLD operation take?[/INST]2"
"[INST]In the context of the C64, What is the addressing mode of the CLD operation?[/INST]Implied"
"[INST]In the context of the C64, What is the purpose of the CLD operation in decimal mode?[/INST]To clear the decimal mode"
"[INST]In the context of the C64, What is the assembly language form of the CLD operation in decimal mode?[/INST]CLD"
"[INST]In the context of the C64, What is the OP CODE of the CLD operation in decimal mode?[/INST]D8"
"[INST]In the context of the C64, How many bytes does the CLD operation in decimal mode use?[/INST]1"
"[INST]In the context of the C64, How many cycles does the CLD operation in decimal mode take?[/INST]2"
"[INST]In the context of the C64, Can a sprite be turned off by setting its bit in the VIC-II control register?[/INST]A sprite is turned off by setting its bit in the VIC-II control register at 53269 ($D015 in HEX) to a 0."
"[INST]In the context of the C64, What is the address of the VIC-II control register?[/INST]The VIC-II control register is located at address 53269 ($D015 in HEX)."
"[INST]In the context of the C64, How do you turn off a sprite?[/INST]A sprite is turned off by setting its bit in the VIC-II control register at 53269 ($D015 in HEX) to a 0."
"[INST]In the context of the C64, What is the POKE command to turn off a sprite?[/INST]The POKE command to turn off a sprite is POKE 53269,PEEK(53269)AND(255-2^SN), where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, What is the purpose of the POKE command in turning off a sprite?[/INST]The POKE command is used to turn off a sprite by setting its bit in the VIC-II control register at 53269 ($D015 in HEX) to a 0."
"[INST]In the context of the C64, Can you turn off a sprite using a POKE command?[/INST]Yes, a sprite can be turned off using a POKE command, such as POKE 53269,PEEK(53269)AND(255-2^SN), where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, Can you turn off multiple sprites using a single POKE command?[/INST]No, a separate POKE command is required for each sprite to be turned off."
"[INST]In the context of the C64, Can a sprite be displayed anywhere on the screen?[/INST]Yes, a sprite can be displayed anywhere on the screen."
"[INST]In the context of the C64, What chip maintains sprites?[/INST]The VIC-II chip maintains sprites."
"[INST]In the context of the C64, What information do you need to tell a sprite?[/INST]You need to tell a sprite what to look like, what color to be, and where to appear."
"[INST]In the context of the C64, Can sprites be used with any graphics mode?[/INST]Yes, sprites can be used with any of the other graphics modes."
"[INST]In the context of the C64, Can a sprite carry its own color definition?[/INST]Yes, a sprite can carry its own color definition."
"[INST]In the context of the C64, How many sprites can be maintained by the VIC-II chip at a time?[/INST]Up to 8 sprites can be maintained by the VIC-II chip at a time."
"[INST]In the context of the C64, What are the features of sprites?[/INST]The features of sprites include 24 horizontal dot by 21 vertical dot size, individual color control, sprite multi-color mode, magnification, and more."
"[INST]In the context of the C64, Can sprites be magnified?[/INST]Yes, sprites can be magnified in horizontal, vertical, or both directions."
"[INST]In the context of the C64, Can sprite priorities be selected?[/INST]Yes, sprite to background priority can be selected."
"[INST]In the context of the C64, Can sprite collisions be detected?[/INST]Yes, sprite to sprite and sprite to background collisions can be detected."
"[INST]In the context of the C64, What is the purpose of the SERIAL ATN OUT signal on the Commodore 64?[/INST]The SERIAL ATN OUT signal is used to start a command sequence for a device on the serial bus, and when the Commodore 64 brings this signal LOW, all other devices on the bus start listening for the Commodore 64 to transmit an address."
"[INST]In the context of the C64, What happens when the Commodore 64 brings the SERIAL ATN OUT signal LOW?[/INST]When the Commodore 64 brings the SERIAL ATN OUT signal LOW, all other devices on the bus start listening for the Commodore 64 to transmit an address, and the device addressed must respond in a preset period of time."
"[INST]In the context of the C64, What is the consequence if the device addressed does not respond in time?[/INST]If the device addressed does not respond in the preset period of time, the Commodore 64 will assume that the device addressed is not on the bus, and will return an error in the STATUS WORD."
"[INST]In the context of the C64, What is the role of the SERIAL ATN OUT signal in the serial bus communication?[/INST]The SERIAL ATN OUT signal plays a crucial role in the serial bus communication by initiating the command sequence for a device on the bus, and ensuring that the addressed device responds in a timely manner."
"[INST]In the context of the C64, How does the Commodore 64 use the SERIAL ATN OUT signal to communicate with devices on the bus?[/INST]The Commodore 64 uses the SERIAL ATN OUT signal to start a command sequence for a device on the serial bus, and then transmits an address to the device, which must respond in a preset period of time."
"[INST]In the context of the C64, What is the significance of the preset period of time in the SERIAL ATN OUT signal sequence?[/INST]The preset period of time is critical in the SERIAL ATN OUT signal sequence, as it allows the addressed device to respond to the Commodore 64's command, and if the device fails to respond within this time, an error is returned in the STATUS WORD."
"[INST]In the context of the C64, How does the Commodore 64 handle a situation where the addressed device is not present on the bus?[/INST]If the addressed device is not present on the bus, the Commodore 64 will return an error in the STATUS WORD, indicating that the device is not available."
"[INST]In the context of the C64, What is the relationship between the SERIAL ATN OUT signal and the STATUS WORD?[/INST]The SERIAL ATN OUT signal is closely tied to the STATUS WORD, as the Commodore 64 updates the STATUS WORD with an error code if the addressed device fails to respond in time or is not present on the bus."
"[INST]In the context of the C64, In what scenario would the Commodore 64 return an error in the STATUS WORD?[/INST]The Commodore 64 would return an error in the STATUS WORD if the addressed device fails to respond in the preset period of time or is not present on the bus."
"[INST]In the context of the C64, What is the primary function of the SERIAL ATN OUT signal in the Commodore 64's serial bus communication?[/INST]The primary function of the SERIAL ATN OUT signal is to initiate the command sequence for a device on the serial bus, ensuring that the addressed device responds in a timely manner."
"[INST]In the context of the C64, Bits 4-7 of Register 05 select one of how many ATTACK rates?[/INST]16"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 rises from zero to peak amplitude?[/INST]The ATTACK rate"
"[INST]In the context of the C64, What is the purpose of the Gate bit in the Envelope Generator?[/INST]To gate and release the envelope"
"[INST]In the context of the C64, What is the function of the SUSTAIN cycle?[/INST]To maintain the output of Voice 1 at a selected amplitude"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 falls from the SUSTAIN amplitude to zero?[/INST]The RELEASE rate"
"[INST]In the context of the C64, What is the purpose of the SYNC function in Voice 2 and 3?[/INST]To synchronize Oscillators"
"[INST]In the context of the C64, What is the function of the RING MOD function in Voice 2 and 3?[/INST]To replace the Triangle output with a ring modulated combination of Oscillators"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 rises from zero to peak amplitude?[/INST]The ATTACK rate"
"[INST]In the context of the C64, What is the purpose of the DECAY cycle?[/INST]To determine how rapidly the output falls from the peak amplitude to the selected SUSTAIN level"
"[INST]In the context of the C64, What is the function of the RELEASE cycle?[/INST]To determine how rapidly the output falls from the SUSTAIN amplitude to zero"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 falls from the SUSTAIN amplitude to zero?[/INST]The RELEASE rate"
"[INST]In the context of the C64, What is the purpose of the SUSTAIN level?[/INST]To maintain the output of Voice 1 at a selected amplitude"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 rises from zero to peak amplitude?[/INST]The ATTACK rate"
"[INST]In the context of the C64, What is the function of the Envelope Generator?[/INST]To generate an envelope for Voice 1"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 falls from the SUSTAIN amplitude to zero?[/INST]The RELEASE rate"
"[INST]In the context of the C64, What is the purpose of the Gate bit?[/INST]To gate and release the envelope"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 rises from zero to peak amplitude?[/INST]The ATTACK rate"
"[INST]In the context of the C64, What is the function of the SYNC function?[/INST]To synchronize Oscillators"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 falls from the SUSTAIN amplitude to zero?[/INST]The RELEASE rate"
"[INST]In the context of the C64, What is the purpose of the RING MOD function?[/INST]To replace the Triangle output with a ring modulated combination of Oscillators"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 rises from zero to peak amplitude?[/INST]The ATTACK rate"
"[INST]In the context of the C64, What is the function of the Envelope Generator?[/INST]To generate an envelope for Voice 1"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 falls from the SUSTAIN amplitude to zero?[/INST]The RELEASE rate"
"[INST]In the context of the C64, What is the purpose of the SUSTAIN level?[/INST]To maintain the output of Voice 1 at a selected amplitude"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 rises from zero to peak amplitude?[/INST]The ATTACK rate"
"[INST]In the context of the C64, What is the function of the RELEASE cycle?[/INST]To determine how rapidly the output falls from the SUSTAIN amplitude to zero"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 falls from the SUSTAIN amplitude to zero?[/INST]The RELEASE rate"
"[INST]In the context of the C64, What is the purpose of the Gate bit?[/INST]To gate and release the envelope"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 rises from zero to peak amplitude?[/INST]The ATTACK rate"
"[INST]In the context of the C64, What is the function of the SYNC function?[/INST]To synchronize Oscillators"
"[INST]In the context of the C64, What determines the rate at which the output of Voice 1 falls from the SUSTAIN amplitude to zero?[/INST]The RELEASE rate"
"[INST]In the context of the C64, What is the purpose of the RING MOD function?[/INST]To replace the Triangle output with a ring modulated combination of Oscillators"
"[INST]In the context of the C64, what is the function of bits 4-7 in register 05[/INST]these bits select 1 of 16 ATTACK rates for the Voice 1 Envelope Generator"
"[INST]In the context of the C64, what determines how rapidly the output of Voice 1 rises from zero to peak amplitude[/INST]the ATTACK rate"
"[INST]In the context of the C64, what cycle follows the ATTACK cycle[/INST]the DECAY cycle"
"[INST]In the context of the C64, what determines how rapidly the output falls from the peak amplitude to the selected SUSTAIN level[/INST]the DECAY rate"
"[INST]In the context of the C64, what are the 16 DECAY rates listed in[/INST]Table 2"
"[INST]In the context of the C64, what do bits 0-3 of register 06 select[/INST]1 of 16 SUSTAIN levels for the Envelope Generator"
"[INST]In the context of the C64, what happens when the Gate bit remains set[/INST]the output of Voice 1 will remain at the selected SUSTAIN amplitude"
"[INST]In the context of the C64, what do bits 0-3 of register 06 also select[/INST]1 of 16 RELEASE rates for the Envelope Generator"
"[INST]In the context of the C64, what cycle follows the SUSTAIN cycle when the Gate bit is reset to zero[/INST]the RELEASE cycle"
"[INST]In the context of the C64, what happens to the output of Voice 1 when the Gate bit is reset to zero[/INST]it will fall from the SUSTAIN amplitude to zero amplitude at the selected RELEASE rate"
"[INST]In the context of the C64, can the cycling of the Envelope Generator be altered at any point[/INST]yes, via the Gate bit"
"[INST]In the context of the C64, what technique can be used to generate complex amplitude envelopes[/INST]real-time software control"
"[INST]In the context of the C64, what is the ATTACK rate for a value of 0 (0) in Table 2[/INST]2 ms"
"[INST]In the context of the C64, what is the DECAY/RELEASE rate for a value of 0 (0) in Table 2[/INST]6 ms"
"[INST]In the context of the C64, what is the ATTACK rate for a value of 15 (F) in Table 2[/INST]8 s"
"[INST]In the context of the C64, what is the DECAY/RELEASE rate for a value of 15 (F) in Table 2[/INST]24 s"
"[INST]In the context of the C64, what is the function of registers 07-$0D[/INST]they control Voice 2 and are functionally identical to registers 00-06"
"[INST]In the context of the C64, what is the function of registers $0E-$14[/INST]they control Voice 3 and are functionally identical to registers 00-06"
"[INST]In the context of the C64, what happens when SYNC is selected in Voice 2[/INST]Oscillator 2 is synchronized with Oscillator 1"
"[INST]In the context of the C64, what happens when RING MOD is selected in Voice 2[/INST]the Triangle output of Oscillator 2 is replaced with the ring modulated combination of Oscillators 2 and 1"
"[INST]In the context of the C64, Which pins are used to select one of the 29 SID registers?[/INST]These TTL-Level inputs"
"[INST]In the context of the C64, What happens when a Write is performed to any of the three unused locations?[/INST]A Write is ignored and a Read returns invalid data"
"[INST]In the context of the C64, What is the purpose of connecting the pins to the corresponding address lines of the micro-processor?[/INST]So that SID may be addressed in the same manner as memory"
"[INST]In the context of the C64, How many registers can be selected using the provided addresses?[/INST]1 of 32 registers"
"[INST]In the context of the C64, What happens when a Read is performed on the three unused locations?[/INST]A Read returns invalid data"
"[INST]In the context of the C64, Why are the three remaining register locations not used?[/INST]The remaining three register locations are not used"
"[INST]In the context of the C64, What is the significance of the three unused locations?[/INST]These pins are normally connected to the corresponding address lines of the micro-processor"
"[INST]In the context of the C64, What is the function of the TTL-Level inputs?[/INST]These TTL-Level inputs are used to select one of the 29 SID registers"
"[INST]In the context of the C64, What happens when a Write is performed to any of the three locations?[/INST]A Write is ignored"
"[INST]In the context of the C64, What is the purpose of the provided addresses?[/INST]Enough addresses are provided to select 1 of 32 registers"
"[INST]In the context of the C64, What is the purpose of the CHROUT function?[/INST]The purpose of the CHROUT function is to output a character to an already opened channel."
"[INST]In the context of the C64, What is the call address of the CHROUT function?[/INST]The call address of the CHROUT function is $FFD2 (hex) or 65490 (decimal)."
"[INST]In the context of the C64, What communication register is used by the CHROUT function?[/INST]The CHROUT function uses the accumulator (A) as the communication register."
"[INST]In the context of the C64, What preparatory routines are required before calling the CHROUT function?[/INST]The preparatory routines required before calling the CHROUT function are CHKOUT and OPEN."
"[INST]In the context of the C64, What is the error return value of the CHROUT function?[/INST]The error return value of the CHROUT function is 0, which is described in the READST routine."
"[INST]In the context of the C64, How much stack is required by the CHROUT function?[/INST]The CHROUT function requires at least 8 bytes of stack space."
"[INST]In the context of the C64, What registers are affected by the CHROUT function?[/INST]The CHROUT function affects the accumulator (A) register."
"[INST]In the context of the C64, How do you specify the output channel for the CHROUT function?[/INST]You specify the output channel for the CHROUT function by using the KERNAL OPEN and CHKOUT routines before calling CHROUT."
"[INST]In the context of the C64, What happens if you don't call CHKOUT and OPEN before calling CHROUT?[/INST]If you don't call CHKOUT and OPEN before calling CHROUT, the data will be sent to the default output device, which is the screen (device number 3)."
"[INST]In the context of the C64, How can you avoid sending data to all open output channels on the serial bus when using CHROUT?[/INST]You can avoid sending data to all open output channels on the serial bus when using CHROUT by closing all open output channels on the bus except for the intended destination channel using the CLRCHN routine."
"[INST]In the context of the C64, Can the Voice 3 Envelope Generator be read by the microprocessor?[/INST]The output of the Voice 3 Envelope Generator can be read by the microprocessor."
"[INST]In the context of the C64, What is the purpose of the ENV 3 register?[/INST]This register allows the microprocessor to read the output of the Voice 3 Envelope Generator."
"[INST]In the context of the C64, Can the ENV 3 register produce harmonic envelopes?[/INST]Yes, the output of the Voice 3 Envelope Generator can be added to the Filter Frequency to produce harmonic envelopes."
"[INST]In the context of the C64, Can the ENV 3 register produce WAH-WAH effects?[/INST]Yes, the output of the Voice 3 Envelope Generator can be added to the Filter Frequency to produce WAH-WAH effects."
"[INST]In the context of the C64, Can the ENV 3 register produce 'Phaser' sounds?[/INST]Yes, the output of the Voice 3 Envelope Generator can be added to the frequency control registers of an oscillator to produce 'Phaser' sounds."
"[INST]In the context of the C64, Is the OSC 3 register affected by the Envelope Generator?[/INST]No, the OSC 3 register always reflects the changing output of the oscillator and is not affected in any way by the Envelope Generator."
"[INST]In the context of the C64, Is the Voice 3 Envelope Generator required to produce output from the ENV 3 register?[/INST]Yes, the Voice 3 Envelope Generator must be Gated in order to produce any output from the ENV 3 register."
"[INST]In the context of the C64, Can the ENV 3 register produce any output without the Voice 3 Envelope Generator?[/INST]No, the ENV 3 register requires the output of the Voice 3 Envelope Generator to produce any output."
"[INST]In the context of the C64, Is the ENV 3 register always reflecting the changing output of the oscillator?[/INST]No, the OSC 3 register always reflects the changing output of the oscillator, not the ENV 3 register."
"[INST]In the context of the C64, Can the ENV 3 register be used to produce different sounds?[/INST]Yes, the output of the Voice 3 Envelope Generator can be used to produce different sounds such as harmonic envelopes, WAH-WAH, and 'Phaser' sounds."
"[INST]In the context of the C64, What is the purpose of the TKSA function?[/INST]The purpose of the TKSA function is to send a secondary address to a device commanded to TALK."
"[INST]In the context of the C64, What is the call address of the TKSA function in hexadecimal?[/INST]The call address of the TKSA function in hexadecimal is $FF96."
"[INST]In the context of the C64, What is the communication register used by the TKSA function?[/INST]The communication register used by the TKSA function is A."
"[INST]In the context of the C64, What is the preparatory routine required to be called before calling the TKSA function?[/INST]The preparatory routine required to be called before calling the TKSA function is TALK."
"[INST]In the context of the C64, What is the error return mechanism used by the TKSA function?[/INST]The error return mechanism used by the TKSA function is the same as the READST function."
"[INST]In the context of the C64, How many bytes of stack are required by the TKSA function?[/INST]The TKSA function requires 8 bytes of stack."
"[INST]In the context of the C64, What register is affected by the TKSA function?[/INST]The TKSA function affects the A register."
"[INST]In the context of the C64, What is the range of values that can be loaded into the accumulator before calling the TKSA function?[/INST]The range of values that can be loaded into the accumulator before calling the TKSA function is between 0 and 31."
"[INST]In the context of the C64, What is the sequence of steps to use the TKSA function?[/INST]The sequence of steps to use the TKSA function is to first call the TALK routine, then load the accumulator with the secondary address, and finally call the TKSA function."
"[INST]In the context of the C64, How can you tell a device with ID #4 to talk with command #7 using the TKSA function?[/INST]You can tell a device with ID #4 to talk with command #7 using the TKSA function by loading the accumulator with #4, calling the TALK routine, loading the accumulator with #7, and then calling the TKSA function, as shown in the example: LDA #4; JSR TALK; LDA #7; JSR TKSA."
"[INST]In the context of the C64, What is the opcode for the SBC instruction in immediate addressing mode?[/INST]The opcode for the SBC instruction in immediate addressing mode is E9, which requires 2 bytes and takes 2 cycles to execute."
"[INST]In the context of the C64, What is the difference in cycles between the SBC instruction in zero page and absolute addressing modes?[/INST]The SBC instruction in zero page addressing mode takes 3 cycles to execute, while in absolute addressing mode it takes 4 cycles, a difference of 1 cycle."
"[INST]In the context of the C64, How many bytes are required to execute the SBC instruction in absolute,X addressing mode?[/INST]The SBC instruction in absolute,X addressing mode requires 3 bytes and takes 4 cycles to execute, with an additional cycle added if a page boundary is crossed."
"[INST]In the context of the C64, What is the opcode for the SBC instruction in (indirect,X) addressing mode?[/INST]The opcode for the SBC instruction in (indirect,X) addressing mode is E1, which requires 2 bytes and takes 6 cycles to execute."
"[INST]In the context of the C64, What is the purpose of the SBC instruction in the context of the Commodore 64?[/INST]The SBC instruction subtracts the value in memory from the accumulator with borrow, which is useful for performing arithmetic operations and handling borrow flags."
"[INST]In the context of the C64, How does the SBC instruction handle page boundaries in absolute,X and absolute,Y addressing modes?[/INST]When the SBC instruction is used in absolute,X and absolute,Y addressing modes, an additional cycle is added to the execution time if a page boundary is crossed."
"[INST]In the context of the C64, What is the difference in opcode between the SBC instruction in zero page and zero page,X addressing modes?[/INST]The opcode for the SBC instruction in zero page addressing mode is E5, while in zero page,X addressing mode it is F5, a difference of 10 in hexadecimal."
"[INST]In the context of the C64, In what situations would you use the SBC instruction with the (indirect),Y addressing mode?[/INST]The SBC instruction with the (indirect),Y addressing mode is useful when the memory location is stored in a zero page location and the Y register contains the offset, allowing for flexible and efficient memory access."
"[INST]In the context of the C64, How does the SBC instruction interact with the borrow flag on the Commodore 64?[/INST]The SBC instruction sets the borrow flag if a borrow is required to perform the subtraction, and clears it otherwise, allowing for efficient handling of arithmetic operations."
"[INST]In the context of the C64, What is the primary advantage of using the SBC instruction in immediate addressing mode?[/INST]The primary advantage of using the SBC instruction in immediate addressing mode is that it allows for fast and efficient subtraction of a constant value from the accumulator, with a shorter opcode and fewer cycles required compared to other addressing modes."
"[INST]In the context of the C64, what is the purpose of the MEMBOT function?[/INST]The purpose of the MEMBOT function is to set the bottom of memory. It returns a pointer to the lowest byte of RAM in the X and Y registers if the accumulator carry bit is set when the routine is called, or sets the bottom of memory to the value in the X and Y registers if the carry bit is clear."
"[INST]In the context of the C64, what is the call address of the MEMBOT function?[/INST]The call address of the MEMBOT function is $FF9C (hex) or 65436 (decimal)."
"[INST]In the context of the C64, what registers are affected by the MEMBOT function?[/INST]The MEMBOT function affects the X and Y registers."
"[INST]In the context of the C64, what is the initial value of the pointer to the lowest byte of RAM on an unexpanded Commodore 64?[/INST]The initial value of the pointer to the lowest byte of RAM on an unexpanded Commodore 64 is $0800 (2048 in decimal)."
"[INST]In the context of the C64, how do you read the bottom of RAM using the MEMBOT function?[/INST]To read the bottom of RAM using the MEMBOT function, you need to set the carry bit and then call the MEMBOT function."
"[INST]In the context of the C64, what happens when the accumulator carry bit is set when calling the MEMBOT function?[/INST]When the accumulator carry bit is set when calling the MEMBOT function, a pointer to the lowest byte of RAM is returned in the X and Y registers."
"[INST]In the context of the C64, what happens when the accumulator carry bit is clear when calling the MEMBOT function?[/INST]When the accumulator carry bit is clear when calling the MEMBOT function, the values of the X and Y registers are transferred to the low and high bytes, respectively, of the pointer to the beginning of RAM."
"[INST]In the context of the C64, how do you set the bottom of memory using the MEMBOT function?[/INST]To set the bottom of memory using the MEMBOT function, you need to clear the carry bit, set the X and Y registers to the desired value, and then call the MEMBOT function."
"[INST]In the context of the C64, what is the purpose of the example code snippet provided?[/INST]The example code snippet provided demonstrates how to move the bottom of memory up one page by calling the MEMBOT function twice, once to read the current bottom of memory and once to set the new bottom of memory."
"[INST]In the context of the C64, what is the significance of the SEC and CLC instructions in the example code snippet?[/INST]The SEC instruction sets the carry bit to read the current bottom of memory, and the CLC instruction clears the carry bit to set the new bottom of memory."
"[INST]In the context of the C64, Can the OSC 3 register be used as a random number generator?[/INST]Yes, it can be used as a random number generator for games."
"[INST]In the context of the C64, What is the range of numbers generated by the OSC 3 register when the Sawtooth waveform is selected?[/INST]The range is from 0 to 255 ($FF)."
"[INST]In the context of the C64, What happens to the output of the OSC 3 register when the Triangle waveform is selected?[/INST]The output will increment from 0 up to 255, then decrement down to 0."
"[INST]In the context of the C64, What is the purpose of the OSC 3 register in modulation?[/INST]The purpose is to generate modulation for various audio effects."
"[INST]In the context of the C64, What is the effect of adding the OSC 3 Sawtooth output to the frequency control of another oscillator?[/INST]It can create siren-like sounds."
"[INST]In the context of the C64, What is the effect of adding the OSC 3 Noise output to the Filter Frequency control registers?[/INST]It can produce synthesizer Sample and Hold"" effects."""
"[INST]In the context of the C64, What is the effect of adding the OSC 3 Triangle output to the Frequency control of another oscillator?[/INST]It can produce vibrato."
"[INST]In the context of the C64, What is the range of effects available by altering the frequency of Oscillator 3 and scaling the OSC 3 output?[/INST]The range is unlimited."
"[INST]In the context of the C64, What happens to the audio output of Voice 3 when Oscillator 3 is used for modulation?[/INST]The audio output should be eliminated (3 OFF = 1)."
"[INST]In the context of the C64, what is the purpose of the CS pin on the SID chip?[/INST]The CS pin is a low-active chip select input that controls data transfers between the SID and the microprocessor, and it must be low for any data transfer to occur."
"[INST]In the context of the C64, What is the condition for a Read operation to occur on the SID register?[/INST]A Read operation can only occur if CS is low, 02 is high, and R/W is high."
"[INST]In the context of the C64, What is the condition for a Write operation to occur on the SID register?[/INST]A Write operation can only occur if CS is low, 02 is high, and R/W is low."
"[INST]In the context of the C64, How is the CS pin typically connected in a system?[/INST]The CS pin is normally connected to address decoding circuitry, allowing the SID to reside in the memory map of a system."
"[INST]In the context of the C64, What is the logic level of the CS pin?[/INST]The CS pin is a TTL-Level input, which means it operates at a transistor-transistor logic level."
"[INST]In the context of the C64, What is the effect of CS being low on data transfers?[/INST]When CS is low, it enables data transfers between the SID and the microprocessor."
"[INST]In the context of the C64, What is the relationship between CS and the microprocessor?[/INST]The CS pin controls data transfers between the SID and the microprocessor, and it must be low for any transfer to occur."
"[INST]In the context of the C64, How does the CS pin affect the SID register?[/INST]The CS pin controls access to the SID register, and it must be low for a Read or Write operation to occur."
"[INST]In the context of the C64, What is the significance of the CS pin in the SID chip?[/INST]The CS pin is a critical input that enables or disables data transfers between the SID and the microprocessor."
"[INST]In the context of the C64, What is the role of the CS pin in the memory map of a system?[/INST]The CS pin allows the SID to reside in the memory map of a system, enabling the microprocessor to access the SID registers."
"[INST]In the context of the C64, Does the GATE bit control the Envelope Generator for Voice 1?[/INST]Yes"
"[INST]In the context of the C64, What happens when the GATE bit is set to a one?[/INST]The Envelope Generator is triggered and the ATTACK/DECAY/SUSTAIN cycle is initiated"
"[INST]In the context of the C64, What is the purpose of the SYNC bit?[/INST]To synchronize the fundamental frequency of Oscillator 1 with the fundamental frequency of Oscillator 3"
"[INST]In the context of the C64, What is the effect of varying the frequency of Oscillator 1 with respect to Oscillator 3?[/INST]It produces a wide range of complex harmonic structures from Voice I at the frequency of Oscillator 3"
"[INST]In the context of the C64, What is the purpose of the RING MOD bit?[/INST]To replace the Triangle waveform output of Oscillator 1 with a 'Ring Modulated' combination of Oscillators 1 and 3"
"[INST]In the context of the C64, What is the effect of varying the frequency of Oscillator 1 with respect to Oscillator 3 in Ring Modulation?[/INST]It produces a wide range of non-harmonic overtone structures for creating bell or gong sounds and for special effects"
"[INST]In the context of the C64, What is the purpose of the TEST bit?[/INST]To reset and lock Oscillator 1 at zero until the TEST bit is cleared"
"[INST]In the context of the C64, What is the effect of setting the TEST bit to a one?[/INST]The Noise waveform output of Oscillator 1 is reset and the Pulse waveform output is held at a DC level"
"[INST]In the context of the C64, What is the purpose of the (Bit 4) bit?[/INST]To select the Triangle waveform output of Oscillator 1"
"[INST]In the context of the C64, What is the characteristic of the Triangle waveform output?[/INST]It is low in harmonics and has a mellow, flute-like quality"
"[INST]In the context of the C64, What is the purpose of the (Bit 5) bit?[/INST]To select the Sawtooth waveform output of Oscillator 1"
"[INST]In the context of the C64, What is the characteristic of the Sawtooth waveform output?[/INST]It is rich in even and odd harmonics and has a bright, brassy quality"
"[INST]In the context of the C64, What is the purpose of the (Bit 6) bit?[/INST]To select the Pulse waveform output of Oscillator 1"
"[INST]In the context of the C64, What is the effect of adjusting the Pulse Width registers?[/INST]It produces tone qualities ranging from a bright, hollow square wave to a nasal, reedy pulse"
"[INST]In the context of the C64, What is the purpose of the NOISE bit?[/INST]To select the Noise output waveform of Oscillator 1"
"[INST]In the context of the C64, What is the characteristic of the Noise output waveform?[/INST]It is a random signal which changes at the frequency of Oscillator 1"
"[INST]In the context of the C64, What is the effect of sweeping the oscillator frequency with Noise selected?[/INST]It produces a dramatic rushing effect"
"[INST]In the context of the C64, What happens when more than one output waveform is selected simultaneously?[/INST]The result is a logical ANDing of the waveforms"
"[INST]In the context of the C64, What is the effect of selecting Noise while another waveform is selected?[/INST]The Noise output can 'lock up' and remain silent until reset by the TEST bit or by bringing RES low"
"[INST]In the context of the C64, What is the purpose of the Envelope Generator?[/INST]To control the amplitude of Oscillator 1 appearing at the audio output"
"[INST]In the context of the C64, What is the purpose of the GATE bit in the Envelope Generator?[/INST]To initiate the ATTACK/DECAY/SUSTAIN cycle"
"[INST]In the context of the C64, What is the purpose of the SYNC bit in the Envelope Generator?[/INST]To synchronize the fundamental frequency of Oscillator 1 with the fundamental frequency of Oscillator 3"
"[INST]In the context of the C64, What is the purpose of the RING MOD bit in the Envelope Generator?[/INST]To replace the Triangle waveform output of Oscillator 1 with a 'Ring Modulated' combination of Oscillators 1 and 3"
"[INST]In the context of the C64, What is the purpose of the VECTOR function?[/INST]The purpose of the VECTOR function is to manage RAM vectors, specifically to store and retrieve system vector jump addresses in RAM."
"[INST]In the context of the C64, What is the call address of the VECTOR function?[/INST]The call address of the VECTOR function is $FF8D (hex) or 65421 (decimal)."
"[INST]In the context of the C64, What registers are used for communication in the VECTOR function?[/INST]The X and Y registers are used for communication in the VECTOR function."
"[INST]In the context of the C64, What is the stack requirement for the VECTOR function?[/INST]The stack requirement for the VECTOR function is 2."
"[INST]In the context of the C64, What registers are affected by the VECTOR function?[/INST]The registers affected by the VECTOR function are A, X, and Y."
"[INST]In the context of the C64, How do you read the system RAM vectors using the VECTOR function?[/INST]To read the system RAM vectors, set the carry bit, set the X and Y registers to the address to store the vectors, and call the VECTOR function."
"[INST]In the context of the C64, How do you load the system RAM vectors using the VECTOR function?[/INST]To load the system RAM vectors, clear the carry bit, set the X and Y registers to the address of the vector list in RAM, and call the VECTOR function."
"[INST]In the context of the C64, What is the recommended way to use the VECTOR function?[/INST]The recommended way to use the VECTOR function is to first read the entire vector contents into the user area, alter the desired vectors, and then copy the contents back to the system vectors."
"[INST]In the context of the C64, What is an example of how to change the input routines to a new system using the VECTOR function?[/INST]An example of how to change the input routines to a new system using the VECTOR function is to set the carry bit, call the VECTOR function to read the old vectors, alter the input routine, and then call the VECTOR function again to load the new vectors."
"[INST]In the context of the C64, What is the address of the user-defined vector list in the example code?[/INST]The address of the user-defined vector list in the example code is stored in the X and Y registers, which are set to the address of the USER variable."
"[INST]In the context of the C64, what is the built-in interface of the Commodore 64 for connection to devices?[/INST]RS-232 interface"
"[INST]In the context of the C64, what is the voltage range of the RS-232 interface on the Commodore 64?[/INST]TTL levels (0 to 5V)"
"[INST]In the context of the C64, what is the purpose of the cable between the Commodore 64 and the RS-232 device?[/INST]to take care of the necessary voltage conversions"
"[INST]In the context of the C64, how can the RS-232 interface software be accessed?[/INST]from BASIC or from the KERNAL for machine language programming"
"[INST]In the context of the C64, what are the normal BASIC commands used for RS-232 on the BASIC level?[/INST]OPEN, CLOSE, CMD, INPUT#, GET#, PRINT#, and the reserved variable ST"
"[INST]In the context of the C64, what do INPUT# and GET# do in RS-232 on the BASIC level?[/INST]fetch data from the receiving buffer"
"[INST]In the context of the C64, what do PRINT# and CMD do in RS-232 on the BASIC level?[/INST]place data into the transmitting buffer"
"[INST]In the context of the C64, what generates NMI requests for RS-232 processing?[/INST]the 6526 CIA #2 device timers and interrupts"
"[INST]In the context of the C64, what is the purpose of the built-in hold-offs in the KERNAL, cassette, and serial bus routines?[/INST]to prevent the disruption of data storage or transmission by the NMIs"
"[INST]In the context of the C64, can data be received from RS-232 devices during cassette or serial bus activities?[/INST]no"
"[INST]In the context of the C64, what is the purpose of the two buffers in the Commodore 64 RS-232 interface?[/INST]to help prevent the loss of data when transmitting or receiving RS-232 information"
"[INST]In the context of the C64, what is the size of each of the two FIFO buffers in the Commodore 64 RS-232 interface?[/INST]256 bytes"
"[INST]In the context of the C64, what happens when an RS-232 channel is OPENed?[/INST]512 bytes of memory are automatically allocated for the buffers"
"[INST]In the context of the C64, what happens if there is not enough free space beyond the end of your BASIC program when an RS-232 channel is OPENed?[/INST]no error message will be printed, and the end of your program will be destroyed"
"[INST]In the context of the C64, how are the buffers automatically removed?[/INST]by using the CLOSE command"
"[INST]In the context of the C64, Can sprites be used to program arcade style games?[/INST]Yes, it is simple to program many arcade style games using sprites."
"[INST]In the context of the C64, What is the advantage of using sprites for game development?[/INST]Because the sprites are maintained by hardware, it is even possible to write a good quality game in BASIC!"
"[INST]In the context of the C64, How many sprites are supported directly by the VIC-II chip?[/INST]There are 8 sprites supported directly by the VIC-II chip."
"[INST]In the context of the C64, What is the range of sprite numbers?[/INST]The sprites are numbered from 0 to 7."
"[INST]In the context of the C64, What are the components of a sprite definition?[/INST]Each of the sprites has its own definition location, position registers and color register."
"[INST]In the context of the C64, What are the additional features of a sprite?[/INST]Each of the sprites has its own bits for enable and collision detection."
"[INST]In the context of the C64, Can sprites be used for collision detection?[/INST]Yes, sprites have its own bits for collision detection."
"[INST]In the context of the C64, What is the purpose of the enable bit in a sprite?[/INST]The enable bit is used to enable or disable a sprite."
"[INST]In the context of the C64, Can sprites be used for game development in BASIC?[/INST]Yes, it is even possible to write a good quality game in BASIC!"
"[INST]In the context of the C64, What is the benefit of using sprites for game development?[/INST]It is simple to program many arcade style games using sprites."
"[INST]In the context of the C64, Can a sprite have any color?[/INST]A sprite can be any of the 16 colors generated by the VIC-II chip."
"[INST]In the context of the C64, Are there specific memory locations for sprite color registers?[/INST]Each of the sprites has its own sprite color register. These are the memory locations of the color registers..."
"[INST]In the context of the C64, Can a sprite have the same color as another sprite?[/INST]Each of the sprites has its own sprite color register."
"[INST]In the context of the C64, Are there 16 possible colors for a sprite?[/INST]A sprite can be any of the 16 colors generated by the VIC-II chip."
"[INST]In the context of the C64, Can a sprite be transparent?[/INST]The rest of the sprite will be transparent, and will show whatever is behind the sprite."
"[INST]In the context of the C64, Are sprite colors stored in memory locations?[/INST]These are the memory locations of the color registers..."
"[INST]In the context of the C64, Can a sprite have the same color as the background?[/INST]The rest of the sprite will be transparent, and will show whatever is behind the sprite."
"[INST]In the context of the C64, Are there specific memory locations for sprite 0, 1, 2, 3, 4, 5, 6, 7 color registers?[/INST]These are the memory locations of the color registers..."
"[INST]In the context of the C64, Can a sprite have a color that is not in the 16 possible colors?[/INST]A sprite can be any of the 16 colors generated by the VIC-II chip."
"[INST]In the context of the C64, Are sprite colors determined by the VIC-II chip?[/INST]A sprite can be any of the 16 colors generated by the VIC-II chip."
"[INST]In the context of the C64, CLC operation[/INST]CLC operation clears the carry flag"
"[INST]In the context of the C64, What is the purpose of CLC operation[/INST]The purpose of CLC operation is to clear the carry flag"
"[INST]In the context of the C64, What is the effect of CLC operation on the carry flag[/INST]The effect of CLC operation is to clear the carry flag"
"[INST]In the context of the C64, What is the opcode of CLC operation[/INST]The opcode of CLC operation is 18"
"[INST]In the context of the C64, What is the number of bytes required for CLC operation[/INST]The number of bytes required for CLC operation is 1"
"[INST]In the context of the C64, What is the number of cycles required for CLC operation[/INST]The number of cycles required for CLC operation is 2"
"[INST]In the context of the C64, What is the addressing mode of CLC operation[/INST]The addressing mode of CLC operation is implied"
"[INST]In the context of the C64, What is the purpose of clearing the carry flag[/INST]The purpose of clearing the carry flag is to reset the carry flag to zero"
"[INST]In the context of the C64, CPY instruction has how many addressing modes?[/INST]Immediate, Zero Page, Absolute"
"[INST]In the context of the C64, CPY instruction uses how many bytes in Zero Page mode?[/INST]2"
"[INST]In the context of the C64, CPY instruction uses how many cycles in Zero Page mode?[/INST]3"
"[INST]In the context of the C64, CPY instruction uses how many bytes in Absolute mode?[/INST]3"
"[INST]In the context of the C64, CPY instruction uses how many cycles in Absolute mode?[/INST]4"
"[INST]In the context of the C64, What is the OP CODE for CPY instruction in Immediate mode?[/INST]C0"
"[INST]In the context of the C64, What is the OP CODE for CPY instruction in Zero Page mode?[/INST]C4"
"[INST]In the context of the C64, What is the OP CODE for CPY instruction in Absolute mode?[/INST]CC"
"[INST]In the context of the C64, How many bytes does CPY instruction use in Immediate mode?[/INST]2"
"[INST]In the context of the C64, How many cycles does CPY instruction take in Immediate mode?[/INST]2"
"[INST]In the context of the C64, what is the purpose of filtering in the SID chip?[/INST]The purpose of filtering in the SID chip is to change the harmonic content of a waveform, allowing for the modification of the sound produced by the chip."
"[INST]In the context of the C64, what are the three types of filtering available in the SID chip?[/INST]The three types of filtering available in the SID chip are high-pass filtering, low-pass filtering, and bandpass filtering, which can be used separately or in combination with one another."
"[INST]In the context of the C64, how do you set the cutoff frequency of the filter in the SID chip?[/INST]The cutoff frequency of the filter in the SID chip is set by POKEing the values into registers 21 and 22, with register 21 determining the low 3 bits of the cutoff frequency (Lcf) and register 22 determining the 8 bits of the high cutoff frequency (Hcf)."
"[INST]In the context of the C64, what is the function of register 24 in the SID chip?[/INST]Register 24 in the SID chip determines which type of filter to use, with bit 6 controlling the high-pass filter, bit 5 controlling the bandpass filter, and bit 4 controlling the low-pass filter, in addition to its function as the overall volume control."
"[INST]In the context of the C64, what is the difference between a high-pass filter and a low-pass filter?[/INST]A high-pass filter passes frequencies above the cutoff frequency and attenuates those below, while a low-pass filter passes frequencies below the cutoff frequency and attenuates those above."
"[INST]In the context of the C64, how do you turn on the filter for voice 1 in the SID chip?[/INST]The filter for voice 1 in the SID chip is turned on by POKEing the value into register 23."
"[INST]In the context of the C64, what is a notch reject filter and how is it created?[/INST]A notch reject filter is a type of filter that passes frequencies away from the cutoff while attenuating at the cutoff frequency, and it is created by combining the high- and low-pass filters."
"[INST]In the context of the C64, what is the purpose of registers 21 and 22 in the SID chip?[/INST]Registers 21 and 22 in the SID chip determine the cutoff frequency of the filter, with register 21 setting the low 3 bits of the cutoff frequency (Lcf) and register 22 setting the 8 bits of the high cutoff frequency (Hcf)."
"[INST]In the context of the C64, how can filtering be used to create interesting effects in the SID chip?[/INST]Filtering can be used to create interesting effects in the SID chip by changing the harmonic structure of a waveform, and by changing the filtering of a sound as it goes through the ADSR phases of its life."
"[INST]In the context of the C64, what is the advantage of using filtering in the SID chip?[/INST]The advantage of using filtering in the SID chip is that it allows for the modification of the harmonic structure of a waveform, allowing for the creation of a wide range of sounds and effects."
"[INST]In the context of the C64, Where is the low cutoff frequency stored in the SID chip?[/INST]The low cutoff frequency is stored in location 54293 of the SID chip, and its value ranges from 0 to 7."
"[INST]In the context of the C64, What is the purpose of the resonance bits in location 54295?[/INST]The resonance bits, which are bits 4-7 in location 54295, control the resonance of the filter, affecting the tone and timbre of the sound produced by the SID chip."
"[INST]In the context of the C64, What is the function of bit 2 in location 54295?[/INST]Bit 2 in location 54295 determines whether filter voice 3 is enabled or disabled, allowing for more complex sound synthesis and manipulation."
"[INST]In the context of the C64, How does the high pass filter bit affect the sound produced by the SID chip?[/INST]The high pass filter bit, located in bit 6 of location 54296, allows high-frequency components of the sound to pass through, while attenuating low-frequency components, resulting in a brighter, more trebly sound."
"[INST]In the context of the C64, What is the purpose of the volume bits in location 54296?[/INST]The volume bits, which are bits 0-3 in location 54296, control the overall volume of the sound produced by the SID chip, allowing for a range of volume settings from 0 to 15."
"[INST]In the context of the C64, In what location is the high cutoff frequency stored?[/INST]The high cutoff frequency is stored in location 54294 of the SID chip, and its value ranges from 0 to 255."
"[INST]In the context of the C64, What is the difference between a low pass filter and a bandpass filter in the SID chip?[/INST]A low pass filter, enabled by bit 4 in location 54296, allows low-frequency components of the sound to pass through, while attenuating high-frequency components, resulting in a warmer, more mellow sound. A bandpass filter, enabled by bit 5 in location 54296, allows a specific range of frequencies to pass through, while attenuating all other frequencies, resulting in a more focused, resonant sound."
"[INST]In the context of the C64, How do the filter voice bits in location 54295 affect the sound produced by the SID chip?[/INST]The filter voice bits, which are bits 0-2 in location 54295, determine which filter voices are enabled or disabled, allowing for a range of tonal colors and textures to be produced by the SID chip."
"[INST]In the context of the C64, What is the range of values for the high cutoff frequency in the SID chip?[/INST]The high cutoff frequency, stored in location 54294, has a range of values from 0 to 255, allowing for a wide range of tonal possibilities."
"[INST]In the context of the C64, In what location is the resonance stored in the SID chip?[/INST]The resonance is stored in bits 4-7 of location 54295, and affects the tone and timbre of the sound produced by the SID chip."
"[INST]In the context of the C64, what is the term for the rate at which a note rises from zero volume to its peak volume?[/INST]The term for the rate at which a note rises from zero volume to its peak volume is called the ATTACK."
"[INST]In the context of the C64, what is the term for the rate at which a note falls from its peak volume to a mid-ranged volume?[/INST]The term for the rate at which a note falls from its peak volume to a mid-ranged volume is called the DECAY."
"[INST]In the context of the C64, what is the term for the mid-ranged volume that a note sustains at after the decay phase?[/INST]The term for the mid-ranged volume that a note sustains at after the decay phase is called the SUSTAIN level."
"[INST]In the context of the C64, what is the term for the rate at which a note falls from the sustain level to zero volume when it stops playing?[/INST]The term for the rate at which a note falls from the sustain level to zero volume when it stops playing is called the RELEASE."
"[INST]In the context of the C64, what is the collective term for the ATTACK, DECAY, SUSTAIN, and RELEASE parameters that control the qualities and restrictions of a note?[/INST]The collective term for the ATTACK, DECAY, SUSTAIN, and RELEASE parameters that control the qualities and restrictions of a note is called ADSR."
"[INST]In the context of the C64, what do the parameters ATTACK, DECAY, SUSTAIN, and RELEASE control in a note?[/INST]The parameters ATTACK, DECAY, SUSTAIN, and RELEASE control the qualities and restrictions of a note, such as its volume and duration."
"[INST]In the context of the C64, where are the ADSR parameters controlled in a sound generator chip?[/INST]The ADSR parameters are controlled by a set of locations in the sound generator chip."
"[INST]In the context of the C64, what happens to a note when it is first struck?[/INST]When a note is first struck, it rises from zero volume to its peak volume, and the rate at which this happens is called the ATTACK."
"[INST]In the context of the C64, what happens to a note after it reaches its peak volume?[/INST]After a note reaches its peak volume, it falls from the peak to a mid-ranged volume, and the rate at which the fall of the note occurs is called the DECAY."
"[INST]In the context of the C64, what happens to a note when it stops playing?[/INST]When a note stops playing, it falls from the sustain level to zero volume, and the rate at which it falls is called the RELEASE."
"[INST]In the context of the C64, Can sprites be selectively expanded?[/INST]Yes, each sprite can be selectively expanded in both the horizontal and vertical directions."
"[INST]In the context of the C64, What are the control bits for magnification control?[/INST]The control bits are MnXE and MnYE."
"[INST]In the context of the C64, What is the function of register 23?[/INST]Register 23 ($17) is used for horizontal expand MnXE."
"[INST]In the context of the C64, What is the function of register 29?[/INST]Register 29 ($1D) is used for vertical expand MnYE."
"[INST]In the context of the C64, Does expanding sprites increase resolution?[/INST]No, expanding sprites does not increase resolution."
"[INST]In the context of the C64, What is the size of the sprite array when expanded?[/INST]The sprite array is the same 24*21 array (12X21 if multi-colored) when expanded."
"[INST]In the context of the C64, What is the maximum sprite dot dimension?[/INST]The smallest sprite dot may be up to 4X standard dot dimension if a sprite is both multi-colored and expanded."
"[INST]In the context of the C64, Are there any limitations to sprite expansion?[/INST]Yes, there are limitations to sprite expansion, such as the smallest sprite dot dimension."
"[INST]In the context of the C64, What is the purpose of magnification control?[/INST]The purpose of magnification control is to selectively expand sprites in both the horizontal and vertical directions."
"[INST]In the context of the C64, Can sprites be expanded in both directions?[/INST]Yes, sprites can be selectively expanded in both the horizontal and vertical directions."
"[INST]In the context of the C64, how do you turn on multi-color character mode on a commodore 64[/INST]To turn on multi-color character mode, set bit 4 of the VIC-II control register at 53270 ($D016) to a 1 by using the following POKE: POKE 53270,PEEK(53270)OR 16. This will enable multi-color mode for the entire screen, allowing for more colorful graphics and characters."
"[INST]In the context of the C64, what is the purpose of bit 3 in color memory[/INST]Bit 3 in color memory determines whether a space on the screen is displayed in high-resolution mode or multi-color mode. If the number in color memory is less than 8 (0-7), the corresponding space on the video screen will be standard hi-res, in the color (0-7) chosen. If the number located in color memory is greater or equal to 8 (from 8 to 15), then that space will be displayed in multi-color mode."
"[INST]In the context of the C64, how do you turn off multi-color character mode on a commodore 64[/INST]To turn off multi-color character mode, set bit 4 of location 53270 to a 0 by using the following POKE: POKE 53270,PEEK(53270)AND 239. This will disable multi-color mode for the entire screen, reverting back to standard high-resolution mode."
"[INST]In the context of the C64, what is the significance of the number in color memory[/INST]The number in color memory determines the display mode for a space on the screen. If the number is between 0 and 7, the space will be displayed in high-resolution mode with the corresponding color. If the number is between 8 and 15, the space will be displayed in multi-color mode, with the color determined by the lower 3 bits in color memory."
"[INST]In the context of the C64, what is the purpose of the VIC-II control register at 53270 ($D016)[/INST]The VIC-II control register at 53270 ($D016) is used to control the display mode of the Commodore 64. Bit 4 of this register determines whether multi-color character mode is enabled or disabled for the entire screen."
"[INST]In the context of the C64, how do you change the color of a character in multi-color mode[/INST]By POKEing a number into color memory, you can change the color of the character in that position on the screen. POKEing a number from 0 to 7 gives the normal character colors. POKEing a number between 8 and 15 puts the space into multi-color mode, with the color determined by the lower 3 bits in color memory."
"[INST]In the context of the C64, what is the difference between high-resolution mode and multi-color mode[/INST]In high-resolution mode, the screen color is displayed everywhere there is a 0 bit, and the character color is displayed where the bit is a 1. In multi-color mode, the bits in pairs determine the color, according to the following chart: BIT PAIR - COLOR REGISTER - LOCATION, 00 - Background #0 color (screen color) - 53281 ($D021), 01 - Background #1 color - 53282 ($D022), 10 - Background #2 color - 53283 ($D023), 11 - Color specified by the lower 3 bits in color memory - color RAM."
"[INST]In the context of the C64, what is the purpose of the color memory starting at location 55296 ($D800)[/INST]The color memory starting at location 55296 ($D800) is used to store the color information for each character on the screen. The number in color memory determines whether a space on the screen is displayed in high-resolution mode or multi-color mode, and also determines the color of the character in multi-color mode."
"[INST]In the context of the C64, how do you set a space on the screen to high-resolution mode[/INST]To set a space on the screen to high-resolution mode, POKE a number from 0 to 7 into the corresponding location in color memory. This will display the character in the chosen color in high-resolution mode."
"[INST]In the context of the C64, what is the significance of the bit pairs in multi-color mode[/INST]In multi-color mode, the bits in pairs determine the color, according to the following chart: BIT PAIR - COLOR REGISTER - LOCATION, 00 - Background #0 color (screen color) - 53281 ($D021), 01 - Background #1 color - 53282 ($D022), 10 - Background #2 color - 53283 ($D023), 11 - Color specified by the lower 3 bits in color memory - color RAM."
"[INST]In the context of the C64, Standard bit map mode is used when?[/INST]When the color information is derived only from the data stored in the video matrix."
"[INST]In the context of the C64, When color nybble is disregarded in standard bit map mode?[/INST]The color nybble is disregarded."
"[INST]In the context of the C64, How many colors can be independently selected in each 8*8 dot block?[/INST]Two colors can be independently selected."
"[INST]In the context of the C64, What happens when a bit in the display memory is a '0' in standard bit map mode?[/INST]The color of the output dot is set by the least significant nybble."
"[INST]In the context of the C64, What happens when a bit in the display memory is a '1' in standard bit map mode?[/INST]The output color is determined by the most significant nybble."
"[INST]In the context of the C64, What is the least significant nybble used for in standard bit map mode?[/INST]The least significant nybble is used to set the output dot color."
"[INST]In the context of the C64, What is the most significant nybble used for in standard bit map mode?[/INST]The most significant nybble is used to determine the output color."
"[INST]In the context of the C64, What is the purpose of dividing the 8 bits into two 4-bit nybbles in standard bit map mode?[/INST]To allow two colors to be independently selected in each 8*8 dot block."
"[INST]In the context of the C64, In standard bit map mode, what happens to the color information?[/INST]The color information is derived only from the data stored in the video matrix."
"[INST]In the context of the C64, What is the significance of the video matrix pointer in standard bit map mode?[/INST]The video matrix pointer determines the output color."
"[INST]In the context of the C64, what is the purpose of the RDTIM function?[/INST]The purpose of the RDTIM function is to read the system clock, which has a resolution of a 60th of a second, and returns three bytes of data, with the most significant byte in the accumulator, the next most significant byte in the X index register, and the least significant byte in the Y index register."
"[INST]In the context of the C64, what is the call address of the RDTIM function?[/INST]The call address of the RDTIM function is $FFDE in hexadecimal, which is equivalent to 65502 in decimal."
"[INST]In the context of the C64, what registers are affected by the RDTIM function?[/INST]The RDTIM function affects the A, X, and Y registers, as it returns the system clock data in these registers."
"[INST]In the context of the C64, what is the stack requirement for the RDTIM function?[/INST]The stack requirement for the RDTIM function is 2, which means that the function requires 2 bytes of stack space to operate."
"[INST]In the context of the C64, what is the significance of the three bytes returned by the RDTIM function?[/INST]The three bytes returned by the RDTIM function represent the system clock data, with the most significant byte in the accumulator, the next most significant byte in the X index register, and the least significant byte in the Y index register, providing a resolution of a 60th of a second."
"[INST]In the context of the C64, how do you store the system clock data returned by the RDTIM function?[/INST]To store the system clock data returned by the RDTIM function, you can use the following code: JSR RDTIM, STY TIME, STX TIME+1, STA TIME+2, where TIME is a 3-byte memory location."
"[INST]In the context of the C64, what is the resolution of the system clock read by the RDTIM function?[/INST]The resolution of the system clock read by the RDTIM function is a 60th of a second."
"[INST]In the context of the C64, what are the communication registers used by the RDTIM function?[/INST]The communication registers used by the RDTIM function are A, X, and Y, which are used to return the system clock data."
"[INST]In the context of the C64, are there any preparatory routines required for the RDTIM function?[/INST]No, there are no preparatory routines required for the RDTIM function, as it can be called directly."
"[INST]In the context of the C64, what is the error return behavior of the RDTIM function?[/INST]The RDTIM function does not return any error codes, as it does not have any error returns."
"[INST]In the context of the C64, Any device on the serial bus can bring this signal LOW when it requires attention from the Commodore 64.[/INST]The Commodore 64 will then take care of the device."
"[INST]In the context of the C64, What is the purpose of bringing the signal LOW on the serial bus?[/INST]Any device on the serial bus can bring this signal LOW when it requires attention from the Commodore 64."
"[INST]In the context of the C64, What happens when a device brings the signal LOW on the serial bus?[/INST]The Commodore 64 will then take care of the device."
"[INST]In the context of the C64, What is the role of the Commodore 64 in this scenario?[/INST]The Commodore 64 will then take care of the device."
"[INST]In the context of the C64, What happens when a device requires attention from the Commodore 64?[/INST]The Commodore 64 will then take care of the device."
"[INST]In the context of the C64, What is the signal LOW used for on the serial bus?[/INST]Any device on the serial bus can bring this signal LOW when it requires attention from the Commodore 64."
"[INST]In the context of the C64, What is the purpose of the Commodore 64 in this scenario?[/INST]The Commodore 64 will then take care of the device."
"[INST]In the context of the C64, What happens when a device brings the signal LOW on the serial bus?[/INST]The Commodore 64 will then take care of the device."
"[INST]In the context of the C64, What is the role of the device in this scenario?[/INST]Any device on the serial bus can bring this signal LOW when it requires attention from the Commodore 64."
"[INST]In the context of the C64, What happens when the Commodore 64 receives a signal LOW on the serial bus?[/INST]The Commodore 64 will then take care of the device."
"[INST]In the context of the C64, What are the five sources of interrupts on the 6526?[/INST]underflow from TIMER A, underflow from TIMER B, TOD ALARM, Serial Port full/empty and /FLAG."
"[INST]In the context of the C64, What is the purpose of the MASK register?[/INST]provides convenient control of individual mask bits."
"[INST]In the context of the C64, What happens when writing to the MASK register with bit 7 as ZERO?[/INST]any mask bit written with a one will be cleared, while those mask bits written with a zero will be unaffected."
"[INST]In the context of the C64, What happens when writing to the MASK register with bit 7 as ONE?[/INST]any mask bit written with a one will be set, while those mask bits written with a zero will be unaffected."
"[INST]In the context of the C64, What is the condition for an interrupt flag to set IR and generate an Interrupt Request?[/INST]the corresponding MASK bit must be set."
"[INST]In the context of the C64, What is the purpose of the DATA register?[/INST]any interrupt will set the corresponding bit in the DATA register."
"[INST]In the context of the C64, What happens to the DATA register after a read?[/INST]it is cleared."
"[INST]In the context of the C64, What is the purpose of the /IRQ pin?[/INST]bring the /IRQ pin low."
"[INST]In the context of the C64, What is the purpose of polling the IR bit?[/INST]detect which chip has generated an interrupt request."
"[INST]In the context of the C64, What is the limitation of polling the IR bit?[/INST]it will cause the DATA register to clear."
"[INST]In the context of the C64, What is the responsibility of the user when polled interrupts are present?[/INST]preserve the information contained in the DATA register if any polled interrupts were present."
"[INST]In the context of the C64, Is the 6510 a low-cost microcomputer system?[/INST]Yes, the 6510 is a low-cost microcomputer system capable of solving a broad range of small-systems and peripheral-control problems at minimum cost to the user."
"[INST]In the context of the C64, What is the type of I/O Port on the 6510?[/INST]The 6510 has an 8-bit Bi-Directional I/O Port."
"[INST]In the context of the C64, What is the architecture of the 6510 processor?[/INST]The internal processor architecture of the 6510 is identical to the MOS Technology 6502 to provide software compatibility."
"[INST]In the context of the C64, What is the addressable memory range of the 6510?[/INST]The addressable memory range of the 6510 is up to 64K bytes."
"[INST]In the context of the C64, What is the clock speed of the 6510?[/INST]The 6510 operates at 1-MHz and 2-MHz."
"[INST]In the context of the C64, What is the type of supply voltage required by the 6510?[/INST]The 6510 requires a single +5-volt supply."
"[INST]In the context of the C64, What is the type of technology used in the 6510?[/INST]The 6510 uses N-channel, silicon gate, depletion load technology."
"[INST]In the context of the C64, What is the number of instructions in the 6510?[/INST]The 6510 has 56 instructions."
"[INST]In the context of the C64, What is the type of arithmetic supported by the 6510?[/INST]The 6510 supports decimal and binary arithmetic."
"[INST]In the context of the C64, What is the number of addressing modes in the 6510?[/INST]The 6510 has 13 addressing modes."
"[INST]In the context of the C64, What is the capability of the 6510 regarding indexing?[/INST]The 6510 has true indexing capability."
"[INST]In the context of the C64, What is the type of stack pointer in the 6510?[/INST]The 6510 has a programmable stack pointer."
"[INST]In the context of the C64, What is the type of memory access capability in the 6510?[/INST]The 6510 has direct memory access capability."
"[INST]In the context of the C64, What is the compatibility of the 6510 with other processors?[/INST]The 6510 is bus compatible with the M6800."
"[INST]In the context of the C64, What is the pipeline architecture of the 6510?[/INST]The 6510 has a pipeline architecture."
"[INST]In the context of the C64, What is the interrupt capability of the 6510?[/INST]The 6510 has interrupt capability."
"[INST]In the context of the C64, What is the type of data bus in the 6510?[/INST]The 6510 has an 8-bit Bi-Directional Data Bus."
"[INST]In the context of the C64, What is the type of bus configuration in the 6510?[/INST]The 6510 has a three-state sixteen-bit Address Bus."
"[INST]In the context of the C64, What is the type of memory access in the 6510?[/INST]The 6510 has direct memory access capability."
"[INST]In the context of the C64, What is the type of memory in the 6510?[/INST]The 6510 can use any type or speed memory."
"[INST]In the context of the C64, What is the type of configuration in the 6510?[/INST]The 6510 has a pin configuration."
"[INST]In the context of the C64, What does the ADC instruction do?[/INST]Add Memory to Accumulator with Carry"
"[INST]In the context of the C64, What is the function of the AND instruction?[/INST]AND Memory with Accumulator"
"[INST]In the context of the C64, What is the purpose of the ASL instruction?[/INST]Shift left One Bit (Memory or Accumulator)"
"[INST]In the context of the C64, What is the condition for the BCC instruction?[/INST]Branch on Carry Clear"
"[INST]In the context of the C64, What is the condition for the BCS instruction?[/INST]Branch on Carry Set"
"[INST]In the context of the C64, What is the condition for the BEQ instruction?[/INST]Branch on Result Zero"
"[INST]In the context of the C64, What does the BIT instruction do?[/INST]Test Bits in Memory with Accumulator"
"[INST]In the context of the C64, What is the condition for the BMI instruction?[/INST]Branch on Result Minus"
"[INST]In the context of the C64, What is the condition for the BNE instruction?[/INST]Branch on Result not Zero"
"[INST]In the context of the C64, What is the condition for the BPL instruction?[/INST]Branch on Result Plus"
"[INST]In the context of the C64, What does the BRK instruction do?[/INST]Force Break"
"[INST]In the context of the C64, What is the condition for the BVC instruction?[/INST]Branch on Overflow Clear"
"[INST]In the context of the C64, What is the condition for the BVS instruction?[/INST]Branch on Overflow Set"
"[INST]In the context of the C64, What does the CLC instruction do?[/INST]Clear Carry Flag"
"[INST]In the context of the C64, What does the CLD instruction do?[/INST]Clear Decimal Mode"
"[INST]In the context of the C64, What does the CLI instruction do?[/INST]Clear Interrupt Disable Bit"
"[INST]In the context of the C64, What does the CLV instruction do?[/INST]Clear Overflow Flag"
"[INST]In the context of the C64, What does the CMP instruction do?[/INST]Compare Memory and Accumulator"
"[INST]In the context of the C64, What does the CPX instruction do?[/INST]Compare Memory and Index X"
"[INST]In the context of the C64, What does the CPY instruction do?[/INST]Compare Memory and Index Y"
"[INST]In the context of the C64, What does the DEC instruction do?[/INST]Decrement Memory by One"
"[INST]In the context of the C64, What does the DEX instruction do?[/INST]Decrement Index X by One"
"[INST]In the context of the C64, What does the DEY instruction do?[/INST]Decrement Index Y by One"
"[INST]In the context of the C64, What does the EOR instruction do?[/INST]Exclusive-OR Memory with Accumulator"
"[INST]In the context of the C64, What does the INC instruction do?[/INST]Increment Memory by One"
"[INST]In the context of the C64, What does the INX instruction do?[/INST]Increment Index X by one"
"[INST]In the context of the C64, What does the INY instruction do?[/INST]Increment Index Y by one"
"[INST]In the context of the C64, What does the JMP instruction do?[/INST]Jump to New location"
"[INST]In the context of the C64, Handshaking on data transfers can be accomplished using which pins?[/INST]the /PC output pin and the FLAG input pin"
"[INST]In the context of the C64, What is the function of the /PC output pin?[/INST]to indicate 'data ready' at PORT B or 'data accepted' from PORT B"
"[INST]In the context of the C64, How can handshaking on 16-bit data transfers be accomplished?[/INST]by always reading or writing PORT A first"
"[INST]In the context of the C64, What is the function of the /FLAG input pin?[/INST]a negative edge sensitive input which can be used for receiving the /PC output from another 6526, or as a general purpose interrupt input"
"[INST]In the context of the C64, What happens when there is a negative transition of /FLAG?[/INST]the /FLAG interrupt bit is set"
"[INST]In the context of the C64, What is an interval timer composed of?[/INST]a 16-bit read-only Timer Counter and a 16-bit write-only Timer Latch"
"[INST]In the context of the C64, What is the function of the Timer Latch?[/INST]to latch in the data written to the timer"
"[INST]In the context of the C64, What is the function of the Timer Counter?[/INST]to hold the present contents of the timer"
"[INST]In the context of the C64, How can the timers be used?[/INST]independently or linked for extended operations"
"[INST]In the context of the C64, What can the timers generate?[/INST]long time delays, variable width pulses, pulse trains and variable frequency waveforms"
"[INST]In the context of the C64, What is the function of the CNT input?[/INST]to count external pulses or measure frequency, pulse width and delay times of external signals"
"[INST]In the context of the C64, What is the function of the control register?[/INST]to provide independent control of the timer functions"
"[INST]In the context of the C64, What is the function of the Start/Stop control bit?[/INST]to allow the timer to be started or stopped by the micro-processor at any time"
"[INST]In the context of the C64, What is the function of the PB On/Off control bit?[/INST]to allow the timer output to appear on a PORT B output line"
"[INST]In the context of the C64, What is the function of the Toggle/Pulse control bit?[/INST]to select the output applied to PORT B"
"[INST]In the context of the C64, What is the function of the One-Shot/Continuous control bit?[/INST]to select either timer mode"
"[INST]In the context of the C64, What is the function of the Force Load control bit?[/INST]to allow the timer latch to be loaded into the timer counter at any time"
"[INST]In the context of the C64, What is the function of the Input Mode control bits?[/INST]to select the clock used to decrement the timer"
"[INST]In the context of the C64, what is the opcode for the ORA instruction in immediate addressing mode?[/INST]The opcode for the ORA instruction in immediate addressing mode is 09, which is used in the assembly language form ORA #Oper, and it takes 2 bytes and 2 cycles to execute."
"[INST]In the context of the C64, how many cycles does the ORA instruction take in zero page addressing mode?[/INST]The ORA instruction in zero page addressing mode takes 3 cycles to execute, and it has an opcode of 05, with an assembly language form of ORA Oper, and it takes 2 bytes."
"[INST]In the context of the C64, what is the difference in cycles between the ORA instruction in zero page and absolute addressing modes?[/INST]The ORA instruction in zero page addressing mode takes 3 cycles to execute, while in absolute addressing mode it takes 4 cycles to execute, with an opcode of 0D, and an assembly language form of ORA Oper, and it takes 3 bytes."
"[INST]In the context of the C64, how does the ORA instruction behave when the page is crossed in absolute,X addressing mode?[/INST]When the page is crossed in absolute,X addressing mode, the ORA instruction takes an additional cycle to execute, making it take 5 cycles in total, with an opcode of 10, and an assembly language form of ORA Oper,X, and it takes 3 bytes."
"[INST]In the context of the C64, what is the purpose of the ORA instruction in the context of bitwise operations?[/INST]The ORA instruction performs a bitwise OR operation between the accumulator and the memory location specified by the operand, setting the flags accordingly, and it is commonly used to set bits in a memory location or to test the state of bits in a memory location."
"[INST]In the context of the C64, what is the difference between the ORA instruction and the AND instruction?[/INST]The ORA instruction performs a bitwise OR operation, whereas the AND instruction performs a bitwise AND operation, the ORA instruction sets the flags based on the result of the OR operation, whereas the AND instruction sets the flags based on the result of the AND operation."
"[INST]In the context of the C64, how does the ORA instruction affect the flags in the processor status register?[/INST]The ORA instruction affects the flags in the processor status register by setting the N flag if the result of the OR operation is negative, setting the Z flag if the result is zero, and setting the V flag if an overflow occurs."
"[INST]In the context of the C64, what is the purpose of the ORA instruction in the context of input/output operations?[/INST]The ORA instruction can be used to read the state of input devices or to set the state of output devices, by performing a bitwise OR operation between the accumulator and the memory location specified by the operand."
"[INST]In the context of the C64, how does the ORA instruction interact with the X and Y registers?[/INST]The ORA instruction can use the X and Y registers as indices to access memory locations, allowing for more flexible and dynamic memory access, and enabling the use of tables and arrays in programming."
"[INST]In the context of the C64, what is the advantage of using the ORA instruction with indexed addressing modes?[/INST]The advantage of using the ORA instruction with indexed addressing modes is that it allows for more flexible and dynamic memory access, enabling the use of tables and arrays in programming, and making it easier to write efficient and compact code."
"[INST]In the context of the C64, what is the opcode for BMI branch instruction?[/INST]The opcode for BMI branch instruction is 30. This instruction is used to branch on the result of a comparison, and it is commonly used to implement conditional jumps in 6502 assembly language programming."
"[INST]In the context of the C64, what is the addressing mode used in BMI instruction?[/INST]The addressing mode used in BMI instruction is Relative. This means that the target address of the branch is specified as a relative offset from the current program counter."
"[INST]In the context of the C64, how many bytes does the BMI instruction occupy in memory?[/INST]The BMI instruction occupies 2 bytes in memory. This is because the opcode is 1 byte, and the relative offset is 1 byte."
"[INST]In the context of the C64, what is the minimum number of cycles required to execute the BMI instruction?[/INST]The minimum number of cycles required to execute the BMI instruction is 2. However, this can increase to 3 or 4 cycles depending on whether the branch occurs to the same page or a different page."
"[INST]In the context of the C64, what happens to the cycle count if the branch occurs to the same page?[/INST]If the branch occurs to the same page, the cycle count increases by 1, making it a total of 3 cycles."
"[INST]In the context of the C64, what happens to the cycle count if the branch occurs to a different page?[/INST]If the branch occurs to a different page, the cycle count increases by 1, making it a total of 3 cycles. This is because the CPU needs to perform a page boundary crossing, which takes an additional cycle."
"[INST]In the context of the C64, can you give an example of BMI instruction in assembly language?[/INST]Here is an example of BMI instruction in assembly language: BMI Oper. This instruction branches to the target address specified by the oper operand if the result of the previous comparison is minus."
"[INST]In the context of the C64, what is the purpose of the BMI instruction in 6502 assembly language programming?[/INST]The purpose of the BMI instruction is to branch on the result of a comparison, allowing the program to implement conditional jumps and make decisions based on the result of a comparison."
"[INST]In the context of the C64, how does the BMI instruction affect the program counter?[/INST]The BMI instruction affects the program counter by modifying it to point to the target address specified by the relative offset. This allows the program to jump to a different location in memory."
"[INST]In the context of the C64, what is the relationship between the BMI instruction and the comparison flags?[/INST]The BMI instruction is related to the comparison flags because it branches on the result of a comparison, which sets or clears the comparison flags. The BMI instruction tests the minus flag, which is set if the result of the comparison is minus."
"[INST]In the context of the C64, what is the opcode for the SED instruction?[/INST]The opcode for the SED instruction is F8, which sets the decimal mode in the Commodore 64."
"[INST]In the context of the C64, what is the addressing mode for the SED instruction?[/INST]The addressing mode for the SED instruction is implied, meaning that it does not require any additional memory address or operand."
"[INST]In the context of the C64, how many bytes does the SED instruction occupy in memory?[/INST]The SED instruction occupies only 1 byte in memory, making it a very compact instruction."
"[INST]In the context of the C64, how many cycles does the SED instruction take to execute?[/INST]The SED instruction takes 2 cycles to execute, making it a relatively fast instruction."
"[INST]In the context of the C64, what is the purpose of the SED instruction?[/INST]The purpose of the SED instruction is to set the decimal mode, which affects the way arithmetic operations are performed by the processor."
"[INST]In the context of the C64, can you provide an example of how to use the SED instruction in assembly language?[/INST]Here is an example of how to use the SED instruction in assembly language: `SED`"
"[INST]In the context of the C64, what is the assembly language form of the SED instruction?[/INST]The assembly language form of the SED instruction is simply `SED`, with no operands or additional information required."
"[INST]In the context of the C64, in what situations would you use the SED instruction?[/INST]You would use the SED instruction when you need to perform decimal arithmetic operations, such as when working with binary coded decimal (BCD) numbers."
"[INST]In the context of the C64, how does the SED instruction affect the processor's behavior?[/INST]The SED instruction affects the processor's behavior by setting the decimal mode, which changes the way the processor performs arithmetic operations, such as addition and subtraction."
"[INST]In the context of the C64, can you explain the difference between the SED instruction and the CLD instruction?[/INST]The SED instruction sets the decimal mode, while the CLD instruction clears the decimal mode, resulting in different arithmetic behavior."
"[INST]In the context of the C64, what is the significance of the X index register in machine language instructions[/INST]The X index register is a crucial register in machine language instructions, allowing for various transformations and operations that cannot be performed by the accumulator alone. It provides additional functionality, enabling the copying of contents from memory locations to the X register and vice versa, as well as direct modification of the X register or other registers."
"[INST]In the context of the C64, what types of instructions are available for the X register[/INST]There are specific machine language instructions that cater to the X register, enabling the copying of contents from memory locations into the X register, copying the contents of the X register into memory locations, and modifying the contents of the X register or other registers directly."
"[INST]In the context of the C64, what is the relationship between the accumulator and the X register[/INST]The accumulator and the X register are two separate registers that serve distinct purposes in machine language instructions. While the accumulator has a wide range of instructions available for transformations, the X register has its own set of unique instructions that allow for specific operations not possible with the accumulator."
"[INST]In the context of the C64, can the accumulator perform all the operations of the X register[/INST]No, the accumulator and the X register have different sets of instructions available, and the accumulator cannot perform all the operations that the X register can. The X register has unique instructions that allow for specific operations that are not possible with the accumulator."
"[INST]In the context of the C64, what is the purpose of copying contents from memory locations to the X register[/INST]Copying contents from memory locations to the X register allows for the manipulation and modification of data stored in memory, enabling the X register to perform operations on that data and store the results in memory or other registers."
"[INST]In the context of the C64, how does the X register enhance the functionality of machine language instructions[/INST]The X register enhances the functionality of machine language instructions by providing additional operations and transformations that are not possible with the accumulator alone. This allows for more complex and sophisticated programming capabilities."
"[INST]In the context of the C64, what is the significance of modifying the contents of the X register directly[/INST]Modifying the contents of the X register directly allows for efficient and flexible programming, enabling the X register to adapt to changing program requirements and perform complex operations that involve multiple registers and memory locations."
"[INST]In the context of the C64, can the X register be used for general-purpose programming[/INST]Yes, the X register can be used for general-purpose programming, providing a range of operations and transformations that can be used in a variety of programming applications, from simple data manipulation to complex algorithmic operations."
"[INST]In the context of the C64, is the X register limited to specific programming tasks[/INST]No, the X register is a versatile register that can be used for a wide range of programming tasks, from simple data manipulation to complex algorithmic operations, making it a valuable resource in machine language programming."
"[INST]In the context of the C64, what is the advantage of having a separate X register in machine language instructions[/INST]The advantage of having a separate X register is that it provides additional functionality and flexibility in machine language programming, enabling more complex and sophisticated programming capabilities that would not be possible with the accumulator alone."
"[INST]In the context of the C64, what is the purpose of the UNLSN function?[/INST]The purpose of the UNLSN function is to send an UNLISTEN command to all devices on the serial bus, stopping them from receiving data from the Commodore 64, and allowing the bus to be used for other purposes."
"[INST]In the context of the C64, what is the call address of the UNLSN function?[/INST]The call address of the UNLSN function is $FFAE (hex) or 65454 (decimal)."
"[INST]In the context of the C64, what are the communication registers used by the UNLSN function?[/INST]The UNLSN function does not use any communication registers."
"[INST]In the context of the C64, what preparatory routines are required by the UNLSN function?[/INST]No preparatory routines are required by the UNLSN function."
"[INST]In the context of the C64, what is the error return mechanism of the UNLSN function?[/INST]The error return mechanism of the UNLSN function is the same as the READST routine."
"[INST]In the context of the C64, what is the stack requirement of the UNLSN function?[/INST]The stack requirement of the UNLSN function is 8 bytes."
"[INST]In the context of the C64, which register is affected by the UNLSN function?[/INST]The A register is affected by the UNLSN function."
"[INST]In the context of the C64, what is the effect of calling the UNLSN function on devices that were previously commanded to listen?[/INST]Calling the UNLSN function results in an UNLISTEN command being transmitted on the serial bus, which commands devices that were previously commanded to listen to stop receiving data from the Commodore 64."
"[INST]In the context of the C64, when is the UNLSN function typically used?[/INST]The UNLSN function is typically used after the Commodore 64 is finished sending data to external devices, to command listening devices to get off the serial bus so it can be used for other purposes."
"[INST]In the context of the C64, how do you use the UNLSN function?[/INST]To use the UNLSN function, you simply need to call it, for example, by using the instruction JSR UNLSN>."
"[INST]In the context of the C64, BCS Branch on carry set[/INST]BCS Branch on carry set operation"
"[INST]In the context of the C64, BCS Branch on carry set operation explanation[/INST]BCS Branch on carry set operation explanation: Branch on C = 1"
"[INST]In the context of the C64, What is the purpose of BCS Branch on carry set[/INST]The purpose of BCS Branch on carry set is to branch on carry set operation"
"[INST]In the context of the C64, What is the format of BCS Branch on carry set[/INST]The format of BCS Branch on carry set is BCS Oper"
"[INST]In the context of the C64, What is the number of bytes in BCS Branch on carry set[/INST]The number of bytes in BCS Branch on carry set is 2"
"[INST]In the context of the C64, What is the number of cycles in BCS Branch on carry set[/INST]The number of cycles in BCS Branch on carry set is 2*"
"[INST]In the context of the C64, What is the condition for adding 1 in BCS Branch on carry set[/INST]The condition for adding 1 in BCS Branch on carry set is if branch occurs to same page"
"[INST]In the context of the C64, What is the condition for adding 2 in BCS Branch on carry set[/INST]The condition for adding 2 in BCS Branch on carry set is if branch occurs to next page"
"[INST]In the context of the C64, what is the purpose of the stack in the 6510 microprocessor[/INST]to temporarily remember things and to remember an order of events"
"[INST]In the context of the C64, what is the GOSUB statement used for[/INST]to call a subroutine and remember where it is being called from"
"[INST]In the context of the C64, what happens when a GOSUB statement is encountered[/INST]the BASIC interpreter pushes its current position onto the stack"
"[INST]In the context of the C64, what happens when a RETURN statement is executed[/INST]the interpreter pulls off the stack the information that tells it where it was before the subroutine call was made"
"[INST]In the context of the C64, what are the instructions used to push and pull values onto the stack[/INST]PHA and PLA"
"[INST]In the context of the C64, what is the status register used for[/INST]to store and retrieve values"
"[INST]In the context of the C64, what is the stack pointer used for[/INST]to point to the next available location in the stack"
"[INST]In the context of the C64, what happens when something is pushed onto the stack[/INST]it is placed where the stack pointer points to, and the stack pointer is moved down to the next position"
"[INST]In the context of the C64, what happens when something is pulled off the stack[/INST]the stack pointer is incremented, and the byte pointed to by the stack pointer is placed into the specified register"
"[INST]In the context of the C64, what is the implied mode in the 6510 microprocessor[/INST]a mode where information is implied by an instruction itself"
"[INST]In the context of the C64, what are some examples of implied mode instructions[/INST]PHA, PLA, PHP, and PLP"
"[INST]In the context of the C64, what is the X register used for[/INST]to store and retrieve values"
"[INST]In the context of the C64, what is the A register used for[/INST]to store and retrieve values"
"[INST]In the context of the C64, what is the Y register used for[/INST]to store and retrieve values"
"[INST]In the context of the C64, what is the S register used for[/INST]to store and retrieve values"
"[INST]In the context of the C64, what is the P register used for[/INST]to store and retrieve values"
"[INST]In the context of the C64, what is the purpose of the stack in the 6510 microprocessor[/INST]to temporarily remember things and to remember an order of events"
"[INST]In the context of the C64, what is the size of the stack in the 6510 microprocessor[/INST]256 bytes"
"[INST]In the context of the C64, where is the stack located in memory[/INST]in page one of memory"
"[INST]In the context of the C64, what is the range of the stack in memory[/INST]from $01 00 to $01 FF"
"[INST]In the context of the C64, what is the organization of the stack in memory[/INST]organized backwards in memory"
"[INST]In the context of the C64, what is the stack pointer used for[/INST]to point to the next available location in the stack"
"[INST]In the context of the C64, what happens when the stack pointer is incremented[/INST]the byte pointed to by the stack pointer is placed into the specified register"
"[INST]In the context of the C64, what happens when the stack pointer is decremented[/INST]the stack pointer is moved down to the next position"
"[INST]In the context of the C64, what is the purpose of the PHP instruction[/INST]to push the status register onto the stack"
"[INST]In the context of the C64, what is the purpose of the PLP instruction[/INST]to pull the status register off the stack"
"[INST]In the context of the C64, what is the purpose of the PHA instruction[/INST]to push the accumulator onto the stack"
"[INST]In the context of the C64, what is the purpose of the PLA instruction[/INST]to pull the accumulator off the stack"
"[INST]In the context of the C64, what is the purpose of the GOSUB statement[/INST]to call a subroutine and remember where it is being called from"
"[INST]In the context of the C64, what is the purpose of the RETURN statement[/INST]to return from a subroutine and remember where it was before the subroutine call was made"
"[INST]In the context of the C64, what is the purpose of the SCREEN function?[/INST]The purpose of the SCREEN function is to return the format of the screen, providing information such as the number of columns and lines, which can be used to determine the type of machine a program is running on, ensuring upward compatibility of programs."
"[INST]In the context of the C64, What is the call address of the SCREEN function?[/INST]The call address of the SCREEN function is $FFED (hex) or 65517 (decimal)."
"[INST]In the context of the C64, What communication registers are used by the SCREEN function?[/INST]The SCREEN function uses the X and Y registers for communication."
"[INST]In the context of the C64, What is the stack requirement for the SCREEN function?[/INST]The SCREEN function requires a stack of 2 bytes."
"[INST]In the context of the C64, What registers are affected by the SCREEN function?[/INST]The SCREEN function affects the X and Y registers."
"[INST]In the context of the C64, How can the SCREEN function be used to determine the type of machine a program is running on?[/INST]The SCREEN function can be used to determine the type of machine a program is running on by returning the screen format, which varies between machines, allowing the program to adapt accordingly."
"[INST]In the context of the C64, What is an example of how to use the SCREEN function?[/INST]An example of how to use the SCREEN function is to call the routine using JSR SCREEN, and then store the returned values in MAXCOL and MAXROW using STX MAXCOL and STY MAXROW."
"[INST]In the context of the C64, What is the significance of the SCREEN function in ensuring upward compatibility of programs?[/INST]The SCREEN function is significant in ensuring upward compatibility of programs as it allows programs to adapt to different machines and screen formats, ensuring that they can run on various Commodore machines."
"[INST]In the context of the C64, How does the SCREEN function return the screen format?[/INST]The SCREEN function returns the screen format by storing the number of columns in the X register and the number of lines in the Y register."
"[INST]In the context of the C64, What is the benefit of using the SCREEN function in a program?[/INST]The benefit of using the SCREEN function in a program is that it allows the program to dynamically adjust to different screen formats, ensuring that it can run on various machines without modification."
"[INST]In the context of the C64, what is the purpose of bit 4 in the VIC-II control register?[/INST]To turn on multi-color character mode"
"[INST]In the context of the C64, what is the POKE command to turn on multi-color character mode?[/INST]POKE 53270,PEEK(53270)OR 16"
"[INST]In the context of the C64, what is the POKE command to turn off multi-color character mode?[/INST]POKE 53270,PEEK(53270)AND 239"
"[INST]In the context of the C64, what is the purpose of bit 3 in color memory?[/INST]Multi-color mode is set on or off for each space on the screen"
"[INST]In the context of the C64, what is the range of values for the number in color memory?[/INST]0-15"
"[INST]In the context of the C64, what is the effect of a number in color memory being less than 8?[/INST]The corresponding space on the video screen will be standard hi-res"
"[INST]In the context of the C64, what is the effect of a number in color memory being greater or equal to 8?[/INST]The corresponding space will be displayed in multi-color mode"
"[INST]In the context of the C64, what is the purpose of POKEing a number into color memory?[/INST]To change the color of the character in that position on the screen"
"[INST]In the context of the C64, what is the effect of POKEing a number from 0 to 7?[/INST]Gives the normal character colors"
"[INST]In the context of the C64, what is the effect of POKEing a number between 8 and 15?[/INST]Puts the space into multi-color mode"
"[INST]In the context of the C64, what is the effect of turning BIT 3 ON in color memory?[/INST]Sets MULTI-COLOR MODE"
"[INST]In the context of the C64, what is the effect of turning BIT 3 OFF in color memory?[/INST]Sets the normal, HIGH-RESOLUTION mode"
"[INST]In the context of the C64, what determines the colors displayed in multi-color mode?[/INST]The bits in the character"
"[INST]In the context of the C64, what is the purpose of the background colors in multi-color mode?[/INST]To provide a background color for the characters"
"[INST]In the context of the C64, what is the purpose of the character colors in multi-color mode?[/INST]To provide a character color for the background"
"[INST]In the context of the C64, what is the effect of the bit pairs in multi-color mode?[/INST]Determine the colors displayed for the dots"
"[INST]In the context of the C64, what is the purpose of the color RAM in multi-color mode?[/INST]To specify the color for the lower 3 bits in color memory"
"[INST]In the context of the C64, what is the purpose of the color registers in multi-color mode?[/INST]To specify the colors for the background and character colors"
"[INST]In the context of the C64, what is the effect of the lower 3 bits in color memory in multi-color mode?[/INST]Specify the color for the character"
"[INST]In the context of the C64, what is the effect of the upper 2 bits in color memory in multi-color mode?[/INST]Specify the color for the background"
"[INST]In the context of the C64, what is the purpose of the screen color in multi-color mode?[/INST]To provide a background color for the characters"
"[INST]In the context of the C64, what is the purpose of the character color in multi-color mode?[/INST]To provide a character color for the background"
"[INST]In the context of the C64, what is the effect of the bits in the character in multi-color mode?[/INST]Determine the colors displayed for the dots"
"[INST]In the context of the C64, what is the purpose of the color memory in multi-color mode?[/INST]To store the colors for the characters and background"
"[INST]In the context of the C64, what is the effect of the color memory in multi-color mode?[/INST]Stores the colors for the characters and background"
"[INST]In the context of the C64, what is the purpose of the VIC-II control register in multi-color mode?[/INST]To control the multi-color character mode"
"[INST]In the context of the C64, what is the effect of the VIC-II control register in multi-color mode?[/INST]Controls the multi-color character mode"
"[INST]In the context of the C64, what is the purpose of the POKE command in multi-color mode?[/INST]To change the color of the character in that position on the screen"
"[INST]In the context of the C64, what is the effect of the POKE command in multi-color mode?[/INST]Changes the color of the character in that position on the screen"
"[INST]In the context of the C64, what is the purpose of the color registers in multi-color mode?[/INST]To specify the colors for the background and character colors"
"[INST]In the context of the C64, what is the effect of the color registers in multi-color mode?[/INST]Specify the colors for the background and character colors"
"[INST]In the context of the C64, what is the function of the raster register[/INST]The raster register is a dual-function register."
"[INST]In the context of the C64, what is the purpose of reading the raster register 18[/INST]A read of the raster register 18 returns the lower 8 bits of the current raster position"
"[INST]In the context of the C64, what is the location of the MSB-RC8[/INST]The MSB-RC8 is located in register 17 ($11)"
"[INST]In the context of the C64, what is the purpose of interrogating the raster register[/INST]The raster register can be interrogated to implement display changes outside the visible area to prevent display flicker"
"[INST]In the context of the C64, what is the range of the visible display window[/INST]The visible display window is from raster 51 through raster 251 ($033-$0FB)"
"[INST]In the context of the C64, what happens when the current raster matches the written value[/INST]When the current raster matches the written value, the raster interrupt latch is set"
"[INST]In the context of the C64, what is the purpose of writing to the raster bits[/INST]A write to the raster bits (including RC8) is latched for use in an internal raster compare"
"[INST]In the context of the C64, what is the purpose of the internal raster compare[/INST]The internal raster compare is used to compare the current raster with the written value"
"[INST]In the context of the C64, what is the purpose of the raster interrupt latch[/INST]The raster interrupt latch is set when the current raster matches the written value"
"[INST]In the context of the C64, what is the purpose of the internal raster compare latch[/INST]The internal raster compare latch is used to latch the written value for comparison with the current raster"
"[INST]In the context of the C64, Does the TTL-level input control the direction of data transfers?[/INST]This TTL-level input controls the direction of data transfers between SID and the microprocessor."
"[INST]In the context of the C64, What happens when the chip select conditions have been met and the input is high?[/INST]a high on this line allows the microprocessor to Read data from the selected SID register"
"[INST]In the context of the C64, What happens when the chip select conditions have been met and the input is low?[/INST]a low allows the microprocessor to Write data into the selected SID register"
"[INST]In the context of the C64, What is the purpose of the Read/Write line?[/INST]This pin is normally connected to the system Read/Write line."
"[INST]In the context of the C64, Can the microprocessor read data from the SID register?[/INST]a high on this line allows the microprocessor to Read data from the selected SID register"
"[INST]In the context of the C64, Can the microprocessor write data into the SID register?[/INST]a low allows the microprocessor to Write data into the selected SID register"
"[INST]In the context of the C64, What determines the direction of data transfers?[/INST]This TTL-level input controls the direction of data transfers between SID and the microprocessor."
"[INST]In the context of the C64, What happens when the input is high?[/INST]a high on this line allows the microprocessor to Read data from the selected SID register"
"[INST]In the context of the C64, What happens when the input is low?[/INST]a low allows the microprocessor to Write data into the selected SID register"
"[INST]In the context of the C64, Is the Read/Write line connected to the system?[/INST]This pin is normally connected to the system Read/Write line."
"[INST]In the context of the C64, Where is the interrupt status register located?[/INST]The interrupt status register is located at 53273 ($D019)."
"[INST]In the context of the C64, What is the purpose of bit 7 in the interrupt status register?[/INST]Bit 7 is set with a 1 whenever an interrupt occurs."
"[INST]In the context of the C64, What happens when two sprites hit each other?[/INST]The current status of bit 2 of the interrupt register will be a 1 when two sprites hit each other."
"[INST]In the context of the C64, How do you clear an interrupt bit?[/INST]Once an interrupt bit has been set, it's 'latched' in and must be cleared by writing a 1 to that bit in the interrupt register when you're ready to handle it."
"[INST]In the context of the C64, What is the function of IRST (bit 0) in the interrupt status register?[/INST]IRST (bit 0) is set when the current raster count equals the stored raster count."
"[INST]In the context of the C64, What triggers the setting of IMDC (bit 1) in the interrupt status register?[/INST]IMDC (bit 1) is set by SPRITE-DATA collision (1st one only, until reset)."
"[INST]In the context of the C64, What is the function of ILP (bit 3) in the interrupt status register?[/INST]ILP (bit 3) is set by a negative transition of the light pen (1 per frame)."
"[INST]In the context of the C64, How does the interrupt status register allow for selective interrupt handling?[/INST]The interrupt status register allows for selective interrupt handling by allowing you to clear individual interrupt bits by writing a 1 to that bit in the interrupt register when you're ready to handle it, without having to store the other interrupt bits."
"[INST]In the context of the C64, What is the significance of the 'latched' state of an interrupt bit?[/INST]Once an interrupt bit has been set, it's 'latched' in and must be cleared by writing a 1 to that bit in the interrupt register when you're ready to handle it."
"[INST]In the context of the C64, What is the relationship between the bits in the interrupt status register and the interrupt sources?[/INST]The current status of bits 0-3 in the interrupt register corresponds to a 1 to 1 relationship with the interrupt sources, including SPRITE-DATA collision, SPRITE-SPRITE collision, and negative transition of the light pen."
"[INST]In the context of the C64, what is the purpose of the light pen input[/INST]The light pen input is used to latch the current screen position into a pair of registers (LPX,LPY) on a low-going edge, allowing the X and Y positions to be captured and stored."
"[INST]In the context of the C64, what is stored in register 19 ($13)[/INST]The 8 most significant bits (MSB) of the X position at the time of transition are stored in register 19 ($13), providing a resolution of 2 horizontal dots."
"[INST]In the context of the C64, what is the resolution of the X position[/INST]The X position is defined by a 512-state counter, providing a resolution of 9 bits, which translates to 2 horizontal dots."
"[INST]In the context of the C64, what is stored in register 20 ($14)[/INST]The Y position is latched to register 20 ($14), with 8 bits providing single raster resolution within the visible display."
"[INST]In the context of the C64, why must you take several samples before turning the light pen to the screen[/INST]You must take several samples (3 or more) before turning the light pen to the screen to ensure accurate readings, depending upon the characteristics of your light pen, as the light pen latch may be triggered only once per frame."
"[INST]In the context of the C64, what happens if the light pen latch is triggered multiple times within the same frame[/INST]Subsequent triggers within the same frame will have no effect, as the light pen latch may be triggered only once per frame."
"[INST]In the context of the C64, what is the effect of the low-going edge on the light pen input[/INST]The low-going edge of the light pen input triggers the latching of the current screen position into the LPX and LPY registers."
"[INST]In the context of the C64, how does the light pen input capture the screen position[/INST]The light pen input captures the screen position by latching the current X and Y positions into the LPX and LPY registers on a low-going edge."
"[INST]In the context of the C64, what is the significance of the 9-bit counter in the X position[/INST]The 9-bit counter in the X position provides a resolution of 2 horizontal dots, allowing for precise capture of the X coordinate."
"[INST]In the context of the C64, what is the purpose of averaging multiple samples of the light pen input[/INST]Averaging multiple samples of the light pen input helps to ensure accurate readings, as the light pen latch may be triggered only once per frame and subsequent triggers within the same frame will have no effect."
"[INST]In the context of the C64, Is the master clock for SID referenced to this clock?[/INST]This TTL-Level input is the master clock for SID."
"[INST]In the context of the C64, What controls data transfers between SID and the microprocessor?[/INST]02 also controls data transfers between SID and the microprocessor."
"[INST]In the context of the C64, What is the nominal operating frequency of the system clock?[/INST]1.0 MHz."
"[INST]In the context of the C64, What is the purpose of pin 6 in the system?[/INST]This TTL-Level input is the master clock for SID."
"[INST]In the context of the C64, What is the function of pin 6 in data transfers?[/INST]Essentially, (02 acts as a high-active chip select as far as data transfers are concerned."
"[INST]In the context of the C64, What is the condition for data transfer between SID and the microprocessor?[/INST]Data can only be transferred when (02 is high."
"[INST]In the context of the C64, What is the typical connection of pin 6 in the system?[/INST]This pin is normally connected to the system clock."
"[INST]In the context of the C64, What is the frequency of the system clock?[/INST]1.0 MHz."
"[INST]In the context of the C64, What is the role of pin 6 in the system?[/INST]All oscillator frequencies and envelope rates are referenced to this clock."
"[INST]In the context of the C64, What is the purpose of the light pen input?[/INST]The light pen input latches the current screen position into a pair of registers (LPX,LPY) on a low-going edge."
"[INST]In the context of the C64, What are the two registers that store the screen position?[/INST]The two registers are LPX and LPY."
"[INST]In the context of the C64, What is the resolution of the X position?[/INST]The X position is defined by a 512-state counter (9 bits) resolution to 2 horizontal dots."
"[INST]In the context of the C64, What is the resolution of the Y position?[/INST]The Y position is latched to its register 20 ($14) but here 8 bits provide single raster resolution within the visible display."
"[INST]In the context of the C64, How many samples are needed before turning the light pen to the screen?[/INST]You must take several samples before turning the light pen to the screen (3 or more samples, average), depending upon the characteristics of your light pen."
"[INST]In the context of the C64, What happens if the light pen is triggered multiple times within the same frame?[/INST]Subsequent triggers within the same frame will have no effect."
"[INST]In the context of the C64, What is the maximum number of times the light pen latch can be triggered per frame?[/INST]The light pen latch may be triggered only once per frame."
"[INST]In the context of the C64, What is the purpose of the 8 MSB of the X position?[/INST]The 8 MSB of the X position will contain the 8 most significant bits of the X position at the time of transition."
"[INST]In the context of the C64, What is the purpose of the 8 bits in the Y position?[/INST]The 8 bits provide single raster resolution within the visible display."
"[INST]In the context of the C64, What is the definition of the X position?[/INST]The X position is defined by a 512-state counter (9 bits) resolution to 2 horizontal dots."
"[INST]In the context of the C64, What is the definition of the Y position?[/INST]The Y position is latched to its register 20 ($14) but here 8 bits provide single raster resolution within the visible display."
"[INST]In the context of the C64, What are the three synthesizer voices in the 6581?[/INST]The 6581 consists of three synthesizer voices which can be used independently or in conjunction with each other"
"[INST]In the context of the C64, What is the purpose of the Tone Oscillator in the 6581?[/INST]The Tone Oscillator controls the pitch of the voice over a wide range"
"[INST]In the context of the C64, What is the function of the Envelope Generator in the 6581?[/INST]The Envelope Generator creates an amplitude envelope with programmable rates of increasing and decreasing volume"
"[INST]In the context of the C64, What is the purpose of the Amplitude Modulator in the 6581?[/INST]The Amplitude Modulator controls the volume dynamics of the oscillator under the direction of the Envelope Generator"
"[INST]In the context of the C64, What is the purpose of the Filter in the 6581?[/INST]The Filter is provided for generating complex, dynamic tone colors via subtractive synthesis"
"[INST]In the context of the C64, What is the purpose of the third Oscillator in the 6581?[/INST]The third Oscillator can act as a random number generator for games or as a source of modulation information for creating vibrato, frequency/filter sweeps and similar effects"
"[INST]In the context of the C64, What are the two A/D converters used for in the 6581?[/INST]The two A/D converters are used for interfacing SID with potentiometers, which can be used for 'paddles' in a game environment or as front panel controls in a music synthesizer"
"[INST]In the context of the C64, What is the purpose of SID's ability to process external audio signals?[/INST]SID can process external audio signals, allowing multiple SID chips to be daisy-chained or mixed in complex polyphonic systems"
"[INST]In the context of the C64, What is the purpose of the SID chip's ability to read the changing output of the third Oscillator and Envelope Generator?[/INST]These outputs can be used as a source of modulation information for creating vibrato, frequency/filter sweeps and similar effects"
"[INST]In the context of the C64, What is the purpose of the SID chip's ability to act as a random number generator?[/INST]The third Oscillator can act as a random number generator for games"
"[INST]In the context of the C64, What is the purpose of the SID chip's ability to interface with potentiometers?[/INST]The two A/D converters are used for interfacing SID with potentiometers, which can be used for 'paddles' in a game environment or as front panel controls in a music synthesizer"
"[INST]In the context of the C64, what is the purpose of the MnDP bit in register 27?[/INST]The MnDP bit in register 27 is used to set the priority of each sprite with respect to the other displayed information from character or bit map modes, where a value of 0 means non-transparent sprite data will be displayed in front of the background, and a value of 1 means non-transparent sprite data will be displayed behind the background."
"[INST]In the context of the C64, how do sprites with coincident data interact with each other?[/INST]When sprite data (except transparent data) of two sprites are coincident, the data from the lower number sprite will be displayed, meaning that sprite 0 has the highest priority and sprite 7 the lowest."
"[INST]In the context of the C64, what is the priority of sprite data with respect to character or bit map data?[/INST]The priority of sprite data is set by the corresponding bit (MnDP) of register 27, where a value of 0 means non-transparent sprite data will be displayed in front of the background, and a value of 1 means non-transparent sprite data will be displayed behind the background."
"[INST]In the context of the C64, what happens when sprite data and background data coincide?[/INST]When sprite data and background data coincide, the sprite data will be displayed in front of the background if the MnDP bit is 0, and behind the background if the MnDP bit is 1."
"[INST]In the context of the C64, what is the purpose of the sprite priority system?[/INST]The sprite priority system allows for individual control of each sprite's priority with respect to the other displayed information from character or bit map modes, enabling complex and dynamic graphics."
"[INST]In the context of the C64, how do transparent sprite data bits affect the display?[/INST]Sprite data bits of '0' ('00' in multi-color mode) are transparent, always permitting any other information to be displayed, meaning that transparent sprite data will not be displayed and will allow the background or other sprites to be visible."
"[INST]In the context of the C64, what is the relationship between sprite priority and sprite number?[/INST]The sprites have a fixed priority with respect to each other, with sprite 0 having the highest priority and sprite 7 the lowest, meaning that sprite 0 will always be displayed on top of sprite 7 if their data coincides."
"[INST]In the context of the C64, how does the MnDP bit affect the display of sprite data?[/INST]The MnDP bit affects the display of sprite data by determining whether the sprite data will be displayed in front of or behind the background, depending on its value."
"[INST]In the context of the C64, what is the significance of the sprite priority table?[/INST]The sprite priority table shows how the priority of each sprite is determined by the MnDP bit, with a value of 1 indicating that the sprite data will be displayed behind the background, and a value of 0 indicating that it will be displayed in front of the background."
"[INST]In the context of the C64, what is the relationship between sprite data and background data?[/INST]The sprite data and background data have a priority relationship, where the sprite data can be displayed in front of or behind the background, depending on the value of the MnDP bit."
"[INST]In the context of the C64, Can characters be changed to any color?[/INST]Yes, by using the <C=> key and the COLOR keys."
"[INST]In the context of the C64, What is the command to change the character color?[/INST]POKE 53270,PEEK(53270)OR 16:PRINT'<CTRL+3>';: rem lt.red/ multi-color red"
"[INST]In the context of the C64, What is the alternative to regular text?[/INST]Another color control can set you back to regular text."
"[INST]In the context of the C64, Can you change the character color to multi-color?[/INST]Yes, by using the <C=> key and the COLOR keys."
"[INST]In the context of the C64, What is the purpose of the COLOR keys?[/INST]To change the character color to any color."
"[INST]In the context of the C64, Can you change the character color to any color?[/INST]Yes, by using the <C=> key and the COLOR keys."
"[INST]In the context of the C64, What is the command to change the character color?[/INST]POKE 53270,PEEK(53270)OR 16:PRINT'<CTRL+3>';: rem lt.red/ multi-color red"
"[INST]In the context of the C64, Can you set the character color back to regular text?[/INST]Yes, by using another color control."
"[INST]In the context of the C64, What happens to the data in the buffers when closing an RS-232 file?[/INST]When closing an RS-232 file, all data in the buffers is discarded, regardless of whether it had been transmitted or printed out."
"[INST]In the context of the C64, What is the effect on transmitting and receiving when closing an RS-232 file?[/INST]When closing an RS-232 file, all RS-232 transmitting and receiving is stopped."
"[INST]In the context of the C64, What happens to the RTS and transmitted data lines when closing an RS-232 file?[/INST]When closing an RS-232 file, the RTS and transmitted data (Sout) lines are set high."
"[INST]In the context of the C64, What is the BASIC syntax to close an RS-232 file?[/INST]The BASIC syntax to close an RS-232 file is CLOSE lfn, where lfn is the logical file number."
"[INST]In the context of the C64, What is the KERNAL entry point to close an RS-232 file?[/INST]The KERNAL entry point to close an RS-232 file is CLOSE ($FFC3), see the Memory Map for more information on entry and exit conditions."
"[INST]In the context of the C64, Why is it important to ensure all data is transmitted before closing the channel?[/INST]It is important to ensure all data is transmitted before closing the channel because any unsent data will be lost when the channel is closed."
"[INST]In the context of the C64, How can you check in BASIC if all data has been transmitted before closing the channel?[/INST]You can check in BASIC if all data has been transmitted before closing the channel by checking the status of the serial port with SS=ST, and if SS is 0 or 8, then all data has been transmitted."
"[INST]In the context of the C64, What is the purpose of the code snippet '100 SS=ST: IF(SS=0 OR SS=8) THEN 100'?[/INST]The purpose of the code snippet '100 SS=ST: IF(SS=0 OR SS=8) THEN 100' is to wait until all data has been transmitted before closing the channel."
"[INST]In the context of the C64, What happens to the RS-232 buffers when closing an RS-232 file?[/INST]When closing an RS-232 file, both RS-232 buffers are removed."
"[INST]In the context of the C64, Why is it important to close an RS-232 file?[/INST]It is important to close an RS-232 file to stop all RS-232 transmitting and receiving, and to discard any remaining data in the buffers."
"[INST]In the context of the C64, What is the high order byte referred to as in absolute addressing?[/INST]nan"
"[INST]In the context of the C64, The high order byte is often referred to as the page of memory.[/INST]nan"
"[INST]In the context of the C64, What is the page number of the address $1637?[/INST]nan"
"[INST]In the context of the C64, The page number of the address $1637 is $16.[/INST]nan"
"[INST]In the context of the C64, What is the page number of the address $0277?[/INST]nan"
"[INST]In the context of the C64, The page number of the address $0277 is $02.[/INST]nan"
"[INST]In the context of the C64, What is the special mode of addressing known as?[/INST]nan"
"[INST]In the context of the C64, The special mode of addressing known as is zero page addressing.[/INST]nan"
"[INST]In the context of the C64, What is the high order byte of addresses in zero page addressing?[/INST]nan"
"[INST]In the context of the C64, The high order byte of addresses in zero page addressing is always zero.[/INST]nan"
"[INST]In the context of the C64, What is the difference between absolute addressing and zero page addressing?[/INST]nan"
"[INST]In the context of the C64, Absolute addressing expects two bytes to describe the address, while zero page addressing only expects one byte.[/INST]nan"
"[INST]In the context of the C64, What is the range of memory locations that can be referenced by zero page addressing?[/INST]nan"
"[INST]In the context of the C64, Zero page addressing can reference memory locations whose addresses are between $0000 and $00FF.[/INST]nan"
"[INST]In the context of the C64, What is the assumption made by the microprocessor in zero page addressing?[/INST]nan"
"[INST]In the context of the C64, The microprocessor assumes that the high order address is zero in zero page addressing.[/INST]nan"
"[INST]In the context of the C64, What is the importance of understanding zero page addressing?[/INST]nan"
"[INST]In the context of the C64, You'll need the principles of zero page addressing soon.[/INST]nan"
"[INST]In the context of the C64, What is the range of memory locations that can be addressed using zero page addressing?[/INST]nan"
"[INST]In the context of the C64, Zero page addressing can reference memory locations whose addresses are between $0000 and $00FF.[/INST]nan"
"[INST]In the context of the C64, How many rows of characters are displayed in the standard display mode?[/INST]In the standard display mode, there are 25 rows of 40 characters (or character regions) per row."
"[INST]In the context of the C64, What is the purpose of the RSEL bit in register 17 ($11)?[/INST]The RSEL bit in register 17 ($11) is used to select the number of rows in the display window, with 0 selecting 24 rows and 1 selecting 25 rows."
"[INST]In the context of the C64, What is the difference in the number of columns between the larger and smaller display windows?[/INST]The larger display window has 40 columns, while the smaller display window has 38 columns."
"[INST]In the context of the C64, How do the select bits operate in the display window?[/INST]The select bits, RSEL and CSEL, operate by selecting the number of rows and columns in the display window, with RSEL selecting 24 or 25 rows and CSEL selecting 38 or 40 columns."
"[INST]In the context of the C64, What is the significance of the CSEL bit in register 22 ($16)?[/INST]The CSEL bit in register 22 ($16) is used to select the number of columns in the display window, with 0 selecting 38 columns and 1 selecting 40 columns."
"[INST]In the context of the C64, What is the normal display mode of the Commodore 64?[/INST]The normal display mode of the Commodore 64 consists of 25 rows of 40 characters (or character regions) per row."
"[INST]In the context of the C64, In what situations is the smaller display window typically used?[/INST]The smaller display window is typically used in conjunction with scrolling."
"[INST]In the context of the C64, How do the border and exterior border area interact in the display window?[/INST]Characters (bits) adjacent to the exterior border area will be covered by the border when the display window is reduced to 24 rows and 38 characters."
"[INST]In the context of the C64, What is the format of the displayed information in the reduced display window?[/INST]The format of the displayed information remains the same in the reduced display window, with the only change being the reduction in the number of rows and columns."
"[INST]In the context of the C64, What are the values of RSEL and CSEL for the standard display mode?[/INST]In the standard display mode, RSEL is 1 and CSEL is 1, selecting 25 rows and 40 columns respectively."
"[INST]In the context of the C64, Is the BCC instruction used for branching?[/INST]Yes, it is used for branching."
"[INST]In the context of the C64, What is the operation of the BCC instruction?[/INST]The operation of the BCC instruction is Branch on Carry Clear."
"[INST]In the context of the C64, What is the condition for the BCC instruction?[/INST]The condition for the BCC instruction is Branch on Carry Clear."
"[INST]In the context of the C64, What is the assembly language form of the BCC instruction?[/INST]The assembly language form of the BCC instruction is BCC Oper."
"[INST]In the context of the C64, What is the OP code of the BCC instruction?[/INST]The OP code of the BCC instruction is 90."
"[INST]In the context of the C64, How many bytes does the BCC instruction occupy?[/INST]The BCC instruction occupies 2 bytes."
"[INST]In the context of the C64, How many cycles does the BCC instruction take?[/INST]The BCC instruction takes 2 cycles."
"[INST]In the context of the C64, Is the BCC instruction used for relative addressing?[/INST]Yes, the BCC instruction is used for relative addressing."
"[INST]In the context of the C64, What is the condition for adding 1 to the cycle count for the BCC instruction?[/INST]The condition for adding 1 to the cycle count for the BCC instruction is if the branch occurs to the same page."
"[INST]In the context of the C64, What is the condition for adding 2 to the cycle count for the BCC instruction?[/INST]The condition for adding 2 to the cycle count for the BCC instruction is if the branch occurs to a different page."
"[INST]In the context of the C64, what is the opcode for the instruction that increments the index x by one?[/INST]The opcode for the instruction that increments the index x by one is E8, which is the INX instruction in implied addressing mode, requiring 1 byte and 2 cycles to execute."
"[INST]In the context of the C64, what is the addressing mode used by the INX instruction?[/INST]The addressing mode used by the INX instruction is implied addressing mode, which means that the instruction does not require a memory address as an operand."
"[INST]In the context of the C64, how many bytes does the INX instruction require?[/INST]The INX instruction requires 1 byte of memory to execute."
"[INST]In the context of the C64, what is the number of cycles required to execute the INX instruction?[/INST]The INX instruction requires 2 cycles to execute, which is a relatively fast operation."
"[INST]In the context of the C64, what is the effect of the INX instruction on the index x register?[/INST]The INX instruction increments the index x register by one, which means that the value of the register is increased by one."
"[INST]In the context of the C64, what flags are affected by the INX instruction?[/INST]The INX instruction affects the N, Z, C, I, D, and V flags, which are set or cleared based on the result of the increment operation."
"[INST]In the context of the C64, can the INX instruction be used with other addressing modes?[/INST]No, the INX instruction can only be used with implied addressing mode, which means that it does not require a memory address as an operand."
"[INST]In the context of the C64, what is the assembly language form of the INX instruction?[/INST]The assembly language form of the INX instruction is simply 'INX', which is used to increment the index x register by one."
"[INST]In the context of the C64, is the INX instruction a load instruction?[/INST]No, the INX instruction is not a load instruction, but rather an increment instruction that modifies the value of the index x register."
"[INST]In the context of the C64, what is the purpose of the INX instruction?[/INST]The purpose of the INX instruction is to increment the index x register by one, which is often used in loops and other control structures to iterate over arrays or tables."
"[INST]In the context of the C64, what is the physical phenomenon that creates sound waves?[/INST]Sound is created by the movement of air in waves, similar to the ripples that occur when a stone is thrown into a pool, and when these waves are created in air, we hear it."
"[INST]In the context of the C64, how is the frequency of a sound wave calculated?[/INST]The frequency of a sound wave is calculated by measuring the time between one peak of a wave and the next, and then taking the reciprocal of that number, which gives you the cycles per second."
"[INST]In the context of the C64, what determines the pitch of a sound?[/INST]The highness or lowness of a sound, or pitch, is determined by the frequency of the sound waves produced."
"[INST]In the context of the C64, where can you find the frequency values for a full eight octaves of musical notes?[/INST]The frequency values for a full eight octaves of musical notes can be found in Appendix E."
"[INST]In the context of the C64, what formula is used to represent the frequency of a sound wave?[/INST]The formula Fout/.06097 is used to represent the frequency (Fn) of the sound you want to create."
"[INST]In the context of the C64, how do you create the high and low frequency values for a note?[/INST]To create the high and low frequency values for a note, you must first round off Fn so that any numbers to the right of the decimal point are left off, and then use the formulas Fhi=INT(Fn/256) and Flo=Fn-(256*Fhi) to set the high frequency location (Fhi) and low frequency location (Flo)."
"[INST]In the context of the C64, what is the purpose of the Fout formula?[/INST]The Fout formula is used to create a frequency other than the ones listed in the note table."
"[INST]In the context of the C64, what is the relationship between the frequency of a sound wave and the pitch?[/INST]The frequency of a sound wave determines the pitch, with higher frequencies producing higher pitches and lower frequencies producing lower pitches."
"[INST]In the context of the C64, what is the result of using the formulas for Fhi and Flo?[/INST]The result of using the formulas for Fhi and Flo is that you can create the high and low frequency values for a note, which can be used to produce a specific sound or pitch."
"[INST]In the context of the C64, What is the purpose of the LOAD function?[/INST]The purpose of the LOAD function is to load data bytes from any input device directly into the memory of the Commodore 64, and it can also be used for a verify operation, comparing data from a device with the data already in memory, while leaving the data stored in RAM unchanged."
"[INST]In the context of the C64, What is the call address of the LOAD function in hexadecimal?[/INST]The call address of the LOAD function in hexadecimal is $FFD5."
"[INST]In the context of the C64, What are the communication registers used by the LOAD function?[/INST]The communication registers used by the LOAD function are A, X, and Y."
"[INST]In the context of the C64, What preparatory routines must be called before calling the LOAD function?[/INST]The preparatory routines that must be called before calling the LOAD function are SETLFS and SETNAM."
"[INST]In the context of the C64, What is the use of the accumulator (A) in the LOAD function?[/INST]The accumulator (A) must be set to 0 for a LOAD operation, or 1 for a verify operation."
"[INST]In the context of the C64, How does the LOAD function handle header information from the device?[/INST]If the input device is OPENed with a secondary address (SA) of 0, the header information from the device is ignored, and the X and Y registers must contain the starting address for the load."
"[INST]In the context of the C64, What is the return value of the LOAD function?[/INST]The LOAD function returns the address of the highest RAM location loaded."
"[INST]In the context of the C64, Can the LOAD function be used to load data from the keyboard, RS-232, or the screen?[/INST]No, the LOAD function cannot be used to load data from the keyboard (0), RS-232 (2), or the screen (3)."
"[INST]In the context of the C64, How do you specify the starting address for a relocated load?[/INST]To specify the starting address for a relocated load, set the X and Y registers to the start address for the load."
"[INST]In the context of the C64, What is the JSR instruction used for in the LOAD function?[/INST]The JSR instruction is used to call the LOAD function."
"[INST]In the context of the C64, What is the purpose of the Commodore Z-80 cartridge?[/INST]Allows you to run programs designed for a Z-80 microprocessor on your Commodore 64."
"[INST]In the context of the C64, What is included with the Commodore Z-80 cartridge?[/INST]A diskette containing the Commodore CP/M(R) operating system."
"[INST]In the context of the C64, How do you run CP/M(R) on your Commodore 64?[/INST]LOAD the CP/M(R) program from your disk drive, type RUN, and hit the <RETURN> key."
"[INST]In the context of the C64, What happens to the 64K bytes of RAM in the Commodore 64 when running CP/M(R)?[/INST]They become accessible by the built-in 6510 central processor."
"[INST]In the context of the C64, What is the limitation when using the Z-80 central processor?[/INST]You can't use it at the same time as the 6510 central processor in a single program."
"[INST]In the context of the C64, What is the purpose of the Commodore 64's sophisticated timing mechanism?[/INST]To allow shifting between the 6510 and Z-80 central processors."
"[INST]In the context of the C64, What is the memory address translation performed on the Z-80 cartridge?[/INST]Adding 4096 bytes to the memory locations used in CP/M(R) $1000 (hex) equals the memory addresses of the normal Commodore 64 operating system."
"[INST]In the context of the C64, What is the correspondence between Z-80 and 6510 memory addresses?[/INST]The correspondence is as follows: ..."
"[INST]In the context of the C64, What is the limitation of the Z-80 cartridge?[/INST]You can't use both the 6510 and Z-80 central processors at the same time in a single program."
"[INST]In the context of the C64, What is the purpose of the diskette included with the Commodore Z-80 cartridge?[/INST]It contains the Commodore CP/M(R) operating system."
"[INST]In the context of the C64, what is the value to poke into a color memory location to change a character's color to black?[/INST]The value to poke into a color memory location to change a character's color to black is 0. This is according to the color code table, where 0 represents black."
"[INST]In the context of the C64, what is the color code for green?[/INST]The color code for green is 5. This is according to the color code table, where 5 represents green."
"[INST]In the context of the C64, how do you change the color of a character located at the upper left-hand corner of the screen to red?[/INST]To change the color of a character located at the upper left-hand corner of the screen to red, you would type POKE 55296,2. This is because the memory location for the upper left-hand corner of the screen is 55296, and the color code for red is 2."
"[INST]In the context of the C64, what is the value to poke into a color memory location to change a character's color to light blue?[/INST]The value to poke into a color memory location to change a character's color to light blue is 14. This is according to the color code table, where 14 represents light blue."
"[INST]In the context of the C64, what is the color code for yellow?[/INST]The color code for yellow is 7. This is according to the color code table, where 7 represents yellow."
"[INST]In the context of the C64, what is the value to poke into a color memory location to change a character's color to gray 1?[/INST]The value to poke into a color memory location to change a character's color to gray 1 is 11. This is according to the color code table, where 11 represents gray 1."
"[INST]In the context of the C64, how do you change the color of a character located at a specific memory location to purple?[/INST]To change the color of a character located at a specific memory location to purple, you would type POKE <memory location>,4. This is because the color code for purple is 4, and you would replace <memory location> with the actual memory location of the character."
"[INST]In the context of the C64, what is the value to poke into a color memory location to change a character's color to orange?[/INST]The value to poke into a color memory location to change a character's color to orange is 8. This is according to the color code table, where 8 represents orange."
"[INST]In the context of the C64, what is the color code for cyan?[/INST]The color code for cyan is 3. This is according to the color code table, where 3 represents cyan."
"[INST]In the context of the C64, what is the value to poke into a color memory location to change a character's color to brown?[/INST]The value to poke into a color memory location to change a character's color to brown is 9. This is according to the color code table, where 9 represents brown."
"[INST]In the context of the C64, Can a port be both an input and an output?[/INST]If a bit in the DDR is set to a one, the corresponding bit in the PR is an output; if a DDR bit is set to a zero, the corresponding PR bit is defined as an input."
"[INST]In the context of the C64, What is the purpose of the Data Direction Register (DDR)?[/INST]The DDR determines whether a port is an input or an output."
"[INST]In the context of the C64, Can a port be read?[/INST]On a READ, the PR reflects the information present on the actual port pins."
"[INST]In the context of the C64, What is the function of the Peripheral Data Register (PR)?[/INST]The PR reflects the information present on the actual port pins."
"[INST]In the context of the C64, Can a port be written?[/INST]On a WRITE, the PR is written with the information present on the actual port pins."
"[INST]In the context of the C64, What is the purpose of the Peripheral Data Register (PR)?[/INST]The PR reflects the information present on the actual port pins."
"[INST]In the context of the C64, What is the purpose of the Data Direction Register (DDR) in Port A?[/INST]The DDR determines whether a port is an input or an output."
"[INST]In the context of the C64, What is the purpose of the Peripheral Data Register (PR) in Port B?[/INST]The PR reflects the information present on the actual port pins."
"[INST]In the context of the C64, Can a port be both an input and an output at the same time?[/INST]No, a port can be either an input or an output, but not both at the same time."
"[INST]In the context of the C64, What is the purpose of the timer output functions in Port B?[/INST]PB6 and PB7 also provide timer output functions."
"[INST]In the context of the C64, What is the error message for receiving string data when expecting numeric data?[/INST]BAD DATA"
"[INST]In the context of the C64, What happens when a program tries to reference an array element outside its range?[/INST]BAD SUBSCRIPT"
"[INST]In the context of the C64, Why was program execution stopped?[/INST]BREAK"
"[INST]In the context of the C64, Why can't the CONT command work?[/INST]CAN'T CONTINUE"
"[INST]In the context of the C64, What happens when a required I/O device is not available?[/INST]DEVICE NOT PRESENT"
"[INST]In the context of the C64, What is the error for dividing by zero?[/INST]DIVISION BY ZERO"
"[INST]In the context of the C64, What happens when too many items are typed in response to an INPUT statement?[/INST]EXTRA IGNORED"
"[INST]In the context of the C64, What happens when a file is not found?[/INST]FILE NOT FOUND"
"[INST]In the context of the C64, Why must a file be opened before closing it?[/INST]FILE NOT OPEN"
"[INST]In the context of the C64, What happens when trying to open a file using an already open file number?[/INST]FILE OPEN"
"[INST]In the context of the C64, What is the error for a formula that is too complex?[/INST]FORMULA TOO COMPLEX"
"[INST]In the context of the C64, Why can't the INPUT statement be used in direct mode?[/INST]ILLEGAL DIRECT"
"[INST]In the context of the C64, What is the error for an illegal quantity?[/INST]ILLEGAL QUANTITY"
"[INST]In the context of the C64, What happens when there is a problem with a program on tape?[/INST]LOAD"
"[INST]In the context of the C64, Why can't the NEXT statement be used without a FOR loop?[/INST]NEXT WITHOUT FOR"
"[INST]In the context of the C64, What happens when trying to input data from a file that is for output only?[/INST]NOT INPUT FILE"
"[INST]In the context of the C64, What happens when trying to print data to a file that is for input only?[/INST]NOT OUTPUT FILE"
"[INST]In the context of the C64, What happens when there is no more data to read?[/INST]OUT OF DATA"
"[INST]In the context of the C64, What happens when there is no more memory available?[/INST]OUT OF MEMORY"
"[INST]In the context of the C64, What is the error for an overflow?[/INST]OVERFLOW"
"[INST]In the context of the C64, What is the error for an array that is redimensioned?[/INST]REDIM'D ARRAY"
"[INST]In the context of the C64, What happens when character data is typed in during an INPUT statement?[/INST]REDO FROM START"
"[INST]In the context of the C64, Why can't a RETURN statement be used without a GOSUB?[/INST]RETURN WITHOUT GOSUB"
"[INST]In the context of the C64, What is the error for a string that is too long?[/INST]STRING TOO LONG"
"[INST]In the context of the C64, What is the error for a syntax error?[/INST]?SYNTAX ERROR"
"[INST]In the context of the C64, What is the error for a type mismatch?[/INST]TYPE MISMATCH"
"[INST]In the context of the C64, What is the error for an undefined function?[/INST]UNDEF'D FUNCTION"
"[INST]In the context of the C64, What is the error for an undefined statement?[/INST]UNDEF'D STATEMENT"
"[INST]In the context of the C64, Why does the program on tape or disk not match the program in memory?[/INST]VERIFY"
"[INST]In the context of the C64, Is the TOD clock a special purpose timer for real-time applications?[/INST]Yes"
"[INST]In the context of the C64, What is the resolution of the TOD clock?[/INST]1/10th second"
"[INST]In the context of the C64, What are the 4 registers of the TOD clock?[/INST]10ths of seconds, Seconds, Minutes and Hours"
"[INST]In the context of the C64, What is the purpose of the AM/PM flag?[/INST]Easy bit testing"
"[INST]In the context of the C64, What is the frequency of the external input required for accurate time-keeping?[/INST]60 Hz or 50 Hz"
"[INST]In the context of the C64, What is the programmable ALARM used for?[/INST]Generating an interrupt at a desired time"
"[INST]In the context of the C64, What is the Control Register bit used for?[/INST]Governing access to the ALARM"
"[INST]In the context of the C64, What happens when a write to the Hours register occurs?[/INST]TOD is automatically stopped"
"[INST]In the context of the C64, What is the purpose of the latching function in the TOD clock?[/INST]Keeping all Time Of Day information constant during a read sequence"
"[INST]In the context of the C64, What happens if only one register is to be read?[/INST]The register can be read on the fly"""""
"[INST]In the context of the C64, What is the maximum supply voltage rating for the 6510 microprocessor?[/INST]The maximum supply voltage rating for the 6510 microprocessor is between -0.3 to +7.0 VDC, symbolized as Vcc."
"[INST]In the context of the C64, What is the input voltage rating for the 6510 microprocessor?[/INST]The input voltage rating for the 6510 microprocessor is between -0.3 to +7.0 VDC, symbolized as Vin."
"[INST]In the context of the C64, What is the recommended operating temperature range for the 6510 microprocessor?[/INST]The recommended operating temperature range for the 6510 microprocessor is between 0 to +70 degrees Celsius, symbolized as Ta."
"[INST]In the context of the C64, What is the storage temperature range for the 6510 microprocessor?[/INST]The storage temperature range for the 6510 microprocessor is between -55 to +150 degrees Celsius, symbolized as Tstg."
"[INST]In the context of the C64, What precautions should be taken when handling the 6510 microprocessor?[/INST]Precautions should be taken to avoid application of voltages higher than the maximum rating, as the device contains input protection against damage due to high static voltages or electric fields."
"[INST]In the context of the C64, What is the unit of measurement for the supply voltage rating of the 6510 microprocessor?[/INST]The unit of measurement for the supply voltage rating of the 6510 microprocessor is Volts DC, symbolized as VDC."
"[INST]In the context of the C64, What is the significance of the Vcc symbol in the 6510 microprocessor characteristics?[/INST]The Vcc symbol in the 6510 microprocessor characteristics represents the supply voltage rating, which is between -0.3 to +7.0 VDC."
"[INST]In the context of the C64, What is the purpose of input protection in the 6510 microprocessor?[/INST]The purpose of input protection in the 6510 microprocessor is to prevent damage due to high static voltages or electric fields."
"[INST]In the context of the C64, What is the recommended temperature range for storing the 6510 microprocessor?[/INST]The recommended temperature range for storing the 6510 microprocessor is between -55 to +150 degrees Celsius, symbolized as Tstg."
"[INST]In the context of the C64, Why is it important to follow the maximum ratings for the 6510 microprocessor?[/INST]It is important to follow the maximum ratings for the 6510 microprocessor to prevent damage to the device and ensure reliable operation, as exceeding these ratings can cause permanent damage."
"[INST]In the context of the C64, Can a sprite be displayed at any position on the screen?[/INST]A sprite can be displayed at any one position on the screen without the block constraints inherent in character and bit map mode."
"[INST]In the context of the C64, Up to how many unique sprites can be displayed simultaneously?[/INST]Up to 8 unique sprites can be displayed simultaneously."
"[INST]In the context of the C64, How many bytes are used to define a sprite?[/INST]A sprite is defined by 63 bytes in memory."
"[INST]In the context of the C64, What is the size of the dot array that represents a sprite?[/INST]A sprite is displayed as a 24*21 dot array."
"[INST]In the context of the C64, What makes sprites especially suited for video graphics and game applications?[/INST]A number of special features make sprites especially suited for video graphics and game applications."
"[INST]In the context of the C64, What is the purpose of the sprite display block?[/INST]The sprite display block is used to display a sprite."
"[INST]In the context of the C64, Can a sprite be displayed as a 24*21 dot array?[/INST]Yes, a sprite is displayed as a 24*21 dot array."
"[INST]In the context of the C64, What is the size of each byte in the sprite display block?[/INST]Each byte in the sprite display block is 1 byte."
"[INST]In the context of the C64, Can multiple sprites be displayed simultaneously?[/INST]Yes, up to 8 unique sprites can be displayed simultaneously."
"[INST]In the context of the C64, What is the purpose of the sprite in video graphics and game applications?[/INST]Sprites are especially suited for video graphics and game applications."
"[INST]In the context of the C64, what is the opcode for the BVS instruction in 6502 assembly language?[/INST]The opcode for the BVS instruction in 6502 assembly language is 70."
"[INST]In the context of the C64, What is the addressing mode used by the BVS instruction?[/INST]The addressing mode used by the BVS instruction is Relative."
"[INST]In the context of the C64, What is the number of bytes used by the BVS instruction?[/INST]The number of bytes used by the BVS instruction is 2."
"[INST]In the context of the C64, What is the number of cycles used by the BVS instruction when the branch does not occur?[/INST]The number of cycles used by the BVS instruction when the branch does not occur is 2."
"[INST]In the context of the C64, What is the number of cycles used by the BVS instruction when the branch occurs to the same page?[/INST]The number of cycles used by the BVS instruction when the branch occurs to the same page is 3."
"[INST]In the context of the C64, What is the number of cycles used by the BVS instruction when the branch occurs to a different page?[/INST]The number of cycles used by the BVS instruction when the branch occurs to a different page is 4."
"[INST]In the context of the C64, What is the purpose of the BVS instruction?[/INST]The purpose of the BVS instruction is to branch to a target location if the overflow flag is set."
"[INST]In the context of the C64, What is the syntax for the BVS instruction in assembly language?[/INST]The syntax for the BVS instruction in assembly language is BVS Oper, where Oper is the target location."
"[INST]In the context of the C64, How does the BVS instruction affect the program counter?[/INST]The BVS instruction affects the program counter by loading the target location into it if the overflow flag is set."
"[INST]In the context of the C64, What is the relationship between the BVS instruction and the overflow flag?[/INST]The BVS instruction branches to the target location if and only if the overflow flag is set."
"[INST]In the context of the C64, what is one of the best ways to learn machine language[/INST]looking at other machine language programs published in magazines and newsletters, even if they are for a different computer that uses the 6510 or 6502 microprocessor, and thoroughly understanding the code, which requires perseverance, especially when encountering new techniques."
"[INST]In the context of the C64, how can you improve your machine language skills[/INST]by writing your own machine language programs, which can be utilities for BASIC programs or all machine language programs, and using available utilities that aid in writing, editing, or tracking down errors in a machine language program."
"[INST]In the context of the C64, what is an example of a utility that aids in writing machine language programs[/INST]the KERNAL, which allows you to check the keyboard, print text, control peripheral devices like disk drives, printers, modems, etc., manage memory and the screen, and is extremely powerful and strongly advised to be used."
"[INST]In the context of the C64, what is one advantage of writing programs in machine language[/INST]speed, as machine language is hundreds or thousands of times faster than a high-level language such as BASIC."
"[INST]In the context of the C64, what is another advantage of writing programs in machine language[/INST]tightness, as a machine language program can be made totally 'watertight', allowing the user to do only what the program allows, and no more, unlike high-level languages which rely on the user not crashing the interpreter."
"[INST]In the context of the C64, what is an example of a potential error in a high-level language[/INST]a DIVISION BY ZERO ERROR, which can occur when a user enters a zero that later causes an error, such as in a BASIC program."
"[INST]In the context of the C64, why is it important to understand machine language[/INST]because it allows the programmer to maximize the computer's capabilities, and is essential for creating efficient and effective programs."
"[INST]In the context of the C64, how can you gain a deeper understanding of machine language[/INST]by looking at other people's machine language programs, and thoroughly understanding the code, even if it's for a different computer that uses the 6510 or 6502 microprocessor."
"[INST]In the context of the C64, what is the importance of perseverance when learning machine language[/INST]it is essential to have perseverance when learning machine language, as it can be infuriating when encountering new techniques, but with patience, you will be the victor."
"[INST]In the context of the C64, what is the benefit of using the KERNAL utility[/INST]it is extremely powerful and allows you to check the keyboard, print text, control peripheral devices, manage memory and the screen, and is strongly advised to be used when writing machine language programs."
"[INST]In the context of the C64, What is the purpose of the user port on the Commodore 64?[/INST]To connect the Commodore 64 to the outside world, such as a printer, Votrax Type and Talk, a MODEM, or another computer."
"[INST]In the context of the C64, What is the user port directly connected to?[/INST]One of the 6526 CIA chips."
"[INST]In the context of the C64, What happens when pin 3 of the user port is grounded?[/INST]The Commodore 64 will do a COLD START, resetting completely."
"[INST]In the context of the C64, What is the function of pin 4 of the user port?[/INST]Serial port counter from CIA#1."
"[INST]In the context of the C64, What is the function of pin 5 of the user port?[/INST]Serial port from CIA #1."
"[INST]In the context of the C64, What is the function of pin 6 of the user port?[/INST]Serial port counter from CIA#2."
"[INST]In the context of the C64, What is the function of pin 7 of the user port?[/INST]Serial port from CIA #2."
"[INST]In the context of the C64, What is the function of pin 8 of the user port?[/INST]Handshaking line from CIA #2."
"[INST]In the context of the C64, What is the function of pin 9 of the user port?[/INST]Connected to the ATN line of the serial bus."
"[INST]In the context of the C64, What is the function of pin 10 of the user port?[/INST]Connected directly to the Commodore 64 transformer (50 mA MAX.)."
"[INST]In the context of the C64, What is the function of pin 11 of the user port?[/INST]Connected directly to the Commodore 64 transformer (50 mA MAX.)."
"[INST]In the context of the C64, What is the function of pin 12 of the user port?[/INST]Ground."
"[INST]In the context of the C64, What is the function of pin A of the user port?[/INST]Ground."
"[INST]In the context of the C64, What is the function of pin B of the user port?[/INST]FLAG2, controlled by PORT B on CIA chip #1."
"[INST]In the context of the C64, What is the function of pin C of the user port?[/INST]PB0, one of the eight I/O lines for PORT B."
"[INST]In the context of the C64, What is the function of pin D of the user port?[/INST]PB1, one of the eight I/O lines for PORT B."
"[INST]In the context of the C64, What is the function of pin E of the user port?[/INST]PB2, one of the eight I/O lines for PORT B."
"[INST]In the context of the C64, What is the function of pin F of the user port?[/INST]PB3, one of the eight I/O lines for PORT B."
"[INST]In the context of the C64, What is the function of pin H of the user port?[/INST]PB4, one of the eight I/O lines for PORT B."
"[INST]In the context of the C64, What is the function of pin I of the user port?[/INST]PB5, one of the eight I/O lines for PORT B."
"[INST]In the context of the C64, What is the function of pin K of the user port?[/INST]PB6, one of the eight I/O lines for PORT B."
"[INST]In the context of the C64, What is the function of pin L of the user port?[/INST]PB7, one of the eight I/O lines for PORT B."
"[INST]In the context of the C64, What is the function of pin M of the user port?[/INST]PA2, bit 2 of PORT A of the CIA."
"[INST]In the context of the C64, What is the function of pin N of the user port?[/INST]Ground."
"[INST]In the context of the C64, What is the location of the DATA DIRECTION REGISTER?[/INST]56579 ($DD03 hex)."
"[INST]In the context of the C64, How does the DATA DIRECTION REGISTER control the PORT?[/INST]Each of the eight lines in the PORT has a BIT in the eight-bit DATA DIRECTION REGISTER which controls whether that line will be an input or an output."
"[INST]In the context of the C64, What is the purpose of handshaking in device communication?[/INST]To let the devices know what the other device is doing, and if data has been received."
"[INST]In the context of the C64, What is the function of the FLAG1 line?[/INST]A negative edge sensitive input which can be used as a general purpose interrupt input."
"[INST]In the context of the C64, What is the function of the PA2 line?[/INST]Bit 2 of PORT A of the CIA, controlled like any other bit in the port."
"[INST]In the context of the C64, What are the two types of codes that can be entered in the MACHINE LANGUAGE MONITOR (64MON)?[/INST]The MACHINE LANGUAGE MONITOR (64MON) allows users to enter programs in either HEX or SYMBOLIC codes, providing flexibility in programming."
"[INST]In the context of the C64, What are some advantages of using the MACHINE LANGUAGE MONITOR (64MON)?[/INST]The MACHINE LANGUAGE MONITOR (64MON) offers several advantages, including easier entry of machine language routines, debugging aids, and a much faster means of saving and loading, making it a convenient tool for programmers."
"[INST]In the context of the C64, What is a drawback of using the MACHINE LANGUAGE MONITOR (64MON)?[/INST]One drawback of using the MACHINE LANGUAGE MONITOR (64MON) is that it generally requires the BASIC program to load the machine language routine from tape or disk when it is started, which can be time-consuming."
"[INST]In the context of the C64, How can a machine language routine prepared by 64MON be stored?[/INST]A machine language routine prepared by 64MON can be stored on tape or disk, allowing for easy retrieval and loading into a BASIC program."
"[INST]In the context of the C64, What is the purpose of the LOAD command in the example BASIC program?[/INST]The LOAD command in the example BASIC program is used to load the machine language routine from tape or disk into the BASIC program, allowing it to be executed."
"[INST]In the context of the C64, What is the role of the FLAG variable in the example BASIC program?[/INST]The FLAG variable in the example BASIC program is used to control the flow of the program, with the value of FLAG determining whether the machine language routine is loaded or not."
"[INST]In the context of the C64, How does the MACHINE LANGUAGE MONITOR (64MON) aid in debugging?[/INST]The MACHINE LANGUAGE MONITOR (64MON) provides debugging aids, which can help programmers identify and fix errors in their machine language routines, making the development process more efficient."
"[INST]In the context of the C64, What is the benefit of using a machine language monitor like 64MON?[/INST]Using a machine language monitor like 64MON provides a much faster means of saving and loading machine language routines, which can save programmers a significant amount of time and effort."
"[INST]In the context of the C64, In what section of the manual can more information about 64MON be found?[/INST]More information about 64MON can be found in the machine language section of the manual, which provides detailed documentation on its features and usage."
"[INST]In the context of the C64, What is the relationship between the MACHINE LANGUAGE MONITOR (64MON) and BASIC programs?[/INST]The MACHINE LANGUAGE MONITOR (64MON) is used to prepare machine language routines that can be loaded and executed by BASIC programs, allowing programmers to combine the strengths of both programming languages."
"[INST]In the context of the C64, what does LDA represent in 6510 assembly language[/INST]load accumulator with"
"[INST]In the context of the C64, what is the purpose of the parameter associated with the LDA instruction[/INST]decided by the parameter(s) associated with that instruction"
"[INST]In the context of the C64, what happens when you try to assemble something that the assembler or the 6510 microprocessor cannot do[/INST]error messages or warnings"
"[INST]In the context of the C64, what does the #"" symbol in front of the parameter associated with the LDA instruction mean""[/INST]the value after the #"" should be loaded into the accumulator"""
"[INST]In the context of the C64, what is the immediate mode of the LDA instruction[/INST]when the parameter is a value, rather than the contents of a memory location or another register"
"[INST]In the context of the C64, what is the absolute mode of the LDA instruction[/INST]when the parameter is the contents of a memory location"
"[INST]In the context of the C64, what is the token for the LDA instruction in immediate mode[/INST]$A9"
"[INST]In the context of the C64, what is the token for the LDA instruction in absolute mode[/INST]$AD"
"[INST]In the context of the C64, what does the mnemonic representing an instruction usually imply[/INST]what it does"
"[INST]In the context of the C64, what does the LDX instruction do[/INST]load the X register with"
"[INST]In the context of the C64, what are internal registers in the 6510 microprocessor[/INST]special memory locations that can hold one byte of information"
"[INST]In the context of the C64, what is the maximum number that can be contained in a byte[/INST]255 (decimal)"
"[INST]In the context of the C64, how is the address parameter in the absolute instruction LDA $102E expressed in memory[/INST]in two bytes"
"[INST]In the context of the C64, what are the two bytes that form the address parameter in the absolute instruction LDA $102E[/INST]low byte and high byte"
"[INST]In the context of the C64, what is the order of the bytes in the address parameter in the absolute instruction LDA $102E[/INST]low byte first, then high byte"
"[INST]In the context of the C64, what is the instruction BRK used for[/INST]the END instruction in machine language"
"[INST]In the context of the C64, what happens when you write a program with 64MON and put the BRK instruction at the end[/INST]the program will return to 64MON when it is finished"
"[INST]In the context of the C64, Where is the control register located that controls the location of screen memory?[/INST]The control register that controls the location of screen memory is located at address 53272 ($D018 HEX)."
"[INST]In the context of the C64, How do you move the screen memory location?[/INST]To move the screen memory location, you can use the following statement: POKE 53272, (PEEK(53272) AND 15) OR A, where A is one of the following values: $0000, $0400, $0800, $0C00, $1000, $1400, $1800, $1C00, $2000, $2400, $2800, $2C00, $3000, $3400, $3800, or $3C00."
"[INST]In the context of the C64, What is the purpose of the upper 4 bits of the control register at address 53272?[/INST]The upper 4 bits of the control register at address 53272 control the location of screen memory."
"[INST]In the context of the C64, Why is it important to be careful when modifying the control register at address 53272?[/INST]It is important to be careful when modifying the control register at address 53272 because it is also used to control which character set is used, and you do not want to disturb that part of the control register."
"[INST]In the context of the C64, What is the formula to calculate the page number for the KERNAL's screen editor?[/INST]The formula to calculate the page number for the KERNAL's screen editor is page = address/256, for example, 1024/256 = 4."
"[INST]In the context of the C64, What is the purpose of the POKE statement to location 648?[/INST]The POKE statement to location 648 is used to tell the KERNAL's screen editor where the screen is located, for example, POKE 648,4."
"[INST]In the context of the C64, What is the bank address of the VIC-II chip that must be added in?[/INST]The bank address of the VIC-II chip that must be added in is not specified in the text, but it is important to remember to add it in when modifying the screen memory location."
"[INST]In the context of the C64, What is the effect of modifying the control register at address 53272 on the character set used?[/INST]Modifying the control register at address 53272 can also affect which character set is used, so it is important to be careful not to disturb that part of the control register."
"[INST]In the context of the C64, How do you preserve the current character set when modifying the control register at address 53272?[/INST]To preserve the current character set when modifying the control register at address 53272, you can use the following statement: POKE 53272, (PEEK(53272) AND 15) OR A, which preserves the lower 4 bits of the control register."
"[INST]In the context of the C64, What is the range of values that can be used for A in the POKE statement to move the screen memory location?[/INST]The range of values that can be used for A in the POKE statement to move the screen memory location is $0000 to $3C00."
"[INST]In the context of the C64, what is the opcode for the BEQ instruction?[/INST]The opcode for the BEQ instruction is F0."
"[INST]In the context of the C64, what is the addressing mode for the BEQ instruction?[/INST]The addressing mode for the BEQ instruction is Relative."
"[INST]In the context of the C64, what is the assembly language form for the BEQ instruction?[/INST]The assembly language form for the BEQ instruction is BEQ Oper."
"[INST]In the context of the C64, how many bytes does the BEQ instruction occupy?[/INST]The BEQ instruction occupies 2 bytes."
"[INST]In the context of the C64, how many cycles does the BEQ instruction take?[/INST]The BEQ instruction takes 2 cycles, but it takes 1 more cycle if the branch occurs to the same page and 2 more cycles if the branch occurs to the next page."
"[INST]In the context of the C64, what is the condition for the BEQ instruction to branch?[/INST]The BEQ instruction branches on result zero."
"[INST]In the context of the C64, what happens when the result of the instruction is zero?[/INST]When the result of the instruction is zero, the BEQ instruction branches."
"[INST]In the context of the C64, can the BEQ instruction branch to the same page?[/INST]Yes, the BEQ instruction can branch to the same page, and it takes 1 more cycle to do so."
"[INST]In the context of the C64, can the BEQ instruction branch to the next page?[/INST]Yes, the BEQ instruction can branch to the next page, and it takes 2 more cycles to do so."
"[INST]In the context of the C64, what is the purpose of the BEQ instruction?[/INST]The purpose of the BEQ instruction is to branch to a location if the result of the previous instruction is zero."
"[INST]In the context of the C64, Is the CLI command used to clear an interrupt?[/INST]Yes"
"[INST]In the context of the C64, What is the opcode for the CLI command?[/INST]58"
"[INST]In the context of the C64, What is the addressing mode for the CLI command?[/INST]Implied"
"[INST]In the context of the C64, What is the number of bytes used by the CLI command?[/INST]1"
"[INST]In the context of the C64, What is the number of cycles used by the CLI command?[/INST]2"
"[INST]In the context of the C64, What is the purpose of the CLI command?[/INST]To clear an interrupt"
"[INST]In the context of the C64, What is the assembly language form of the CLI command?[/INST]CLI"
"[INST]In the context of the C64, What is the operation code for the CLI command?[/INST]58"
"[INST]In the context of the C64, What is the addressing mode for the CLI command in assembly language?[/INST]Implied"
"[INST]In the context of the C64, What is the number of cycles used by the CLI command in assembly language?[/INST]2"
"[INST]In the context of the C64, What is the purpose of the CLI command in assembly language?[/INST]To clear an interrupt"
"[INST]In the context of the C64, Each sprite takes up how many bytes?[/INST]64 bytes"
"[INST]In the context of the C64, What is the purpose of the SPRITE POINTER?[/INST]It controls where each sprite definition is located in memory"
"[INST]In the context of the C64, What is the range of values that a sprite pointer can hold?[/INST]0 to 255"
"[INST]In the context of the C64, Where are the sprite pointers located in memory?[/INST]The lost 8 bytes of the 1K chunk of screen memory"
"[INST]In the context of the C64, What is the maximum size of memory that a sprite pointer can 'see'?[/INST]16K"
"[INST]In the context of the C64, Why is 64 bytes an even number?[/INST]Because it's an even power in binary"
"[INST]In the context of the C64, What is the purpose of the extra byte at the end of each sprite definition?[/INST]It serves as a placeholder"
"[INST]In the context of the C64, How many bytes are needed to define a sprite?[/INST]63 bytes"
"[INST]In the context of the C64, What is the total size of a sprite definition including the extra byte?[/INST]64 bytes"
"[INST]In the context of the C64, Can a sprite pointer point to any location in memory?[/INST]No, it can only point to locations within the 16K block of memory"
"[INST]In the context of the C64, what is the function of the TXS instruction in 6502 assembly language?[/INST]The TXS instruction is used to transfer the value of the X register to the stack pointer, effectively setting the stack pointer to the value in X. This is useful for dynamically allocating stack space or for implementing stack-based data structures. The TXS instruction is implied, meaning it does not require any additional operands, and it takes 2 cycles to execute."
"[INST]In the context of the C64, what is the opcode for the TXS instruction?[/INST]The opcode for the TXS instruction is 9A, which is a single-byte opcode that can be used to transfer the value of the X register to the stack pointer."
"[INST]In the context of the C64, how many bytes does the TXS instruction occupy in memory?[/INST]The TXS instruction occupies only 1 byte in memory, making it a very compact instruction that can be used in tight loops or memory-constrained applications."
"[INST]In the context of the C64, in what addressing mode does the TXS instruction operate?[/INST]The TXS instruction operates in implied addressing mode, which means that it does not require any additional operands or memory accesses to perform its function."
"[INST]In the context of the C64, what is the cycle count for the TXS instruction?[/INST]The TXS instruction takes 2 cycles to execute, making it a relatively fast instruction that can be used in time-critical code."
"[INST]In the context of the C64, can the TXS instruction be used to implement stack-based data structures?[/INST]Yes, the TXS instruction can be used to implement stack-based data structures, such as stacks, queues, and recursive functions, by dynamically allocating stack space and managing the stack pointer."
"[INST]In the context of the C64, how does the TXS instruction affect the X register?[/INST]The TXS instruction does not affect the value of the X register, it only transfers the value of X to the stack pointer, leaving the X register unchanged."
"[INST]In the context of the C64, is the TXS instruction a load or store instruction?[/INST]The TXS instruction is neither a load nor a store instruction, it is a specialized instruction that transfers the value of the X register to the stack pointer."
"[INST]In the context of the C64, can the TXS instruction be used to implement recursive functions?[/INST]Yes, the TXS instruction can be used to implement recursive functions by dynamically allocating stack space and managing the stack pointer, allowing for efficient implementation of recursive algorithms."
"[INST]In the context of the C64, what is the purpose of the TXS instruction in 6502 assembly language programming?[/INST]The purpose of the TXS instruction is to provide a flexible and efficient way to manage the stack pointer, allowing programmers to implement complex data structures and algorithms that require dynamic stack allocation."
"[INST]In the context of the C64, Standard high-resolution graphics give you control of very small dots on the screen.[/INST]Each dot in character memory can have 2 possible values, 1 for on and 0 for off."
"[INST]In the context of the C64, Can you control the color of each dot in standard high-resolution graphics?[/INST]Each dot in character memory can have 2 possible values, 1 for on and 0 for off."
"[INST]In the context of the C64, What happens when a dot is off in standard high-resolution graphics?[/INST]When a dot is off, the color of the screen is used in the space reserved for that dot."
"[INST]In the context of the C64, What is the maximum number of colors that can be used in standard high-resolution graphics?[/INST]2"
"[INST]In the context of the C64, What is the limitation of standard high-resolution graphics in terms of color resolution?[/INST]In some ways this limits the color resolution within that space."
"[INST]In the context of the C64, What is the solution to the problem of colored lines crossing in standard high-resolution graphics?[/INST]Multi-color mode gives you a solution to this problem."
"[INST]In the context of the C64, What is the difference in horizontal resolution between standard high-resolution graphics and multi-color mode?[/INST]The only sacrifice is in the horizontal resolution, because each multi-color mode dot is twice as wide as a high-resolution dot."
"[INST]In the context of the C64, What is the benefit of using multi-color mode over standard high-resolution graphics?[/INST]This minimal loss of resolution is more than compensated for by the extra abilities of multi-color mode."
"[INST]In the context of the C64, An interrupt latch is set to what value when an interrupt source generates an interrupt request?[/INST]1"
"[INST]In the context of the C64, What are the four sources of interrupt?[/INST]IRST, IMDC, IMMC, ILP"
"[INST]In the context of the C64, What is the purpose of the interrupt enable bit in register 26 ($1A)?[/INST]to enable an interrupt request"
"[INST]In the context of the C64, What happens to the /IRQ output when an interrupt latch is set?[/INST]set to 0"
"[INST]In the context of the C64, What is the condition for setting the /IRQ output to 0?[/INST]corresponding interrupt enable bit in register 26 ($1A) must be set to 1"
"[INST]In the context of the C64, What is the purpose of the interrupt register?[/INST]to show the status of the four sources of interrupt"
"[INST]In the context of the C64, What happens to an interrupt latch once it has been set?[/INST]may be cleared only by writing a 1 to the desired latch in the interrupt register"
"[INST]In the context of the C64, What is the feature that allows selective handling of video interrupts without software?[/INST]ability to clear interrupt latches"
"[INST]In the context of the C64, What is the condition for clearing an interrupt latch?[/INST]writing a 1 to the desired latch in the interrupt register"
"[INST]In the context of the C64, What happens to the /IRQ output when an interrupt latch is cleared?[/INST]set high"
"[INST]In the context of the C64, What is the purpose of the raster count in the interrupt register?[/INST]to set when an interrupt source has generated an interrupt request"
"[INST]In the context of the C64, SID frequency calculation depends on system clock applied to pin 6[/INST]The frequency is determined by the equation: Fout = (Fn*Fclk/16777216) Hz"
"[INST]In the context of the C64, SID frequency calculation depends on 16-bit number in Frequency registers[/INST]The frequency is determined by the equation: Fout = (Fn*Fclk/16777216) Hz"
"[INST]In the context of the C64, What is the formula for calculating SID frequency?[/INST]The frequency is determined by the equation: Fout = (Fn*Fclk/16777216) Hz"
"[INST]In the context of the C64, What is the purpose of Frequency registers in SID?[/INST]Together these registers form a 16-bit number which linearly controls the frequency of Oscillator 1"
"[INST]In the context of the C64, What is the relationship between SID frequency and system clock?[/INST]The frequency is determined by the equation: Fout = (Fn*Fclk/16777216) Hz"
"[INST]In the context of the C64, What is the frequency resolution of SID?[/INST]The frequency resolution of SID is sufficient for any tuning scale and allows sweeping from note to note (portamento) with no discernable frequency steps"
"[INST]In the context of the C64, What is the tuning scale used in SID?[/INST]It should be noted that the frequency resolution of SID is sufficient for any tuning scale and allows sweeping from note to note (portamento) with no discernable frequency steps"
"[INST]In the context of the C64, What is the frequency range of SID?[/INST]A complete table of values for generating 8 octaves of the equally tempered musical scale with concert A (440 Hz) tuning is provided in Appendix E"
"[INST]In the context of the C64, What is the role of pin 6 in SID?[/INST]For a standard 1.0-MHz clock, the frequency is given by: Fout = (Fn*0.059604645) Hz"
"[INST]In the context of the C64, What is the formula for calculating SID frequency for a standard 1.0-MHz clock?[/INST]For a standard 1.0-MHz clock, the frequency is given by: Fout = (Fn*0.059604645) Hz"
"[INST]In the context of the C64, what is the purpose of the light pen input[/INST]The light pen input latches the current screen position into a pair of registers (LPX, LPY) on a low-going edge, allowing the X and Y positions to be captured and stored for further processing."
"[INST]In the context of the C64, what is stored in register 19 ($13)[/INST]The X position register 19 ($13) will contain the 8 most significant bits (MSB) of the X position at the time of transition, providing a resolution of 2 horizontal dots."
"[INST]In the context of the C64, what is the resolution of the X position[/INST]The X position is defined by a 512-state counter (9 bits), providing a resolution of 2 horizontal dots."
"[INST]In the context of the C64, what is stored in register 20 ($14)[/INST]The Y position is latched in its register 20 ($14), providing single raster resolution within the visible display."
"[INST]In the context of the C64, why must you take several samples before turning the pen to the screen[/INST]The light pen latch may be triggered only once per frame, and subsequent triggers within the same frame will have no effect, therefore you must take several samples (3 or more) before turning the pen to the screen, depending upon the characteristics of your light pen."
"[INST]In the context of the C64, what happens if the light pen is triggered multiple times within the same frame[/INST]Subsequent triggers within the same frame will have no effect, the light pen latch may be triggered only once per frame."
"[INST]In the context of the C64, what is the significance of the low-going edge in the light pen input[/INST]The light pen input latches the current screen position into a pair of registers (LPX, LPY) on a low-going edge, allowing the X and Y positions to be captured and stored for further processing."
"[INST]In the context of the C64, how many bits are used to store the Y position[/INST]8 bits are used to store the Y position in register 20 ($14), providing single raster resolution within the visible display."
"[INST]In the context of the C64, what is the purpose of the LPX and LPY registers[/INST]The LPX and LPY registers are used to store the current screen position, allowing the X and Y positions to be captured and stored for further processing."
"[INST]In the context of the C64, what is the maximum number of times the light pen can be triggered per frame[/INST]The light pen latch may be triggered only once per frame, and subsequent triggers within the same frame will have no effect."
"[INST]In the context of the C64, what is the addressing mode of the RTS instruction?[/INST]The addressing mode of the RTS instruction is implied, which means that the instruction does not require any additional memory references or registers to be specified."
"[INST]In the context of the C64, what is the opcode of the RTS instruction?[/INST]The opcode of the RTS instruction is 60 in hexadecimal, which is a unique binary code that the 6510 microprocessor recognizes and executes as a return from subroutine instruction."
"[INST]In the context of the C64, how many bytes does the RTS instruction occupy in memory?[/INST]The RTS instruction occupies only 1 byte in memory, making it a very compact and efficient instruction for returning from subroutines."
"[INST]In the context of the C64, how many cycles does the RTS instruction take to execute?[/INST]The RTS instruction takes 6 cycles to execute, which is a relatively fast instruction that allows for efficient subroutine returns."
"[INST]In the context of the C64, what is the purpose of the RTS instruction?[/INST]The purpose of the RTS instruction is to return from a subroutine, which means it pops the return address from the stack and transfers control to the calling program."
"[INST]In the context of the C64, can the RTS instruction be used to return from an interrupt?[/INST]No, the RTS instruction is used to return from a subroutine, not from an interrupt. The RTI instruction is used to return from an interrupt."
"[INST]In the context of the C64, what happens when the RTS instruction is executed?[/INST]When the RTS instruction is executed, the 6510 microprocessor pops the return address from the stack and transfers control to the calling program, effectively returning from the subroutine."
"[INST]In the context of the C64, can the RTS instruction be used to call a subroutine?[/INST]No, the RTS instruction is used to return from a subroutine, not to call a subroutine. The JSR instruction is used to call a subroutine."
"[INST]In the context of the C64, is the RTS instruction a jump instruction?[/INST]No, the RTS instruction is not a jump instruction, it is a return instruction that pops the return address from the stack and transfers control to the calling program."
"[INST]In the context of the C64, in what type of programming is the RTS instruction commonly used?[/INST]The RTS instruction is commonly used in assembly language programming, particularly in programming for the Commodore 64 and other 8-bit computers."
"[INST]In the context of the C64, What is the purpose of the Pulse Width registers?[/INST]Together these registers form a 12-bit number which linearly controls the Pulse Width (duty cycle) of the Pulse waveform on Oscillator 1."
"[INST]In the context of the C64, What is the range of values for the Pulse Width registers?[/INST]A value of 0 or 4095 ($FF) in the Pulse Width registers will produce a constant DC output, while a value of 2048 ($800) will produce a square wave."
"[INST]In the context of the C64, What is the resolution of the Pulse Width registers?[/INST]The pulse width resolution allows the width to be smoothly swept with no discernable stepping."
"[INST]In the context of the C64, What is the equation for calculating the Pulse Width?[/INST]PWout = (PWn/40.95) %"
"[INST]In the context of the C64, What is the unit of measurement for the Pulse Width?[/INST]%"
"[INST]In the context of the C64, What is the minimum value for the Pulse Width registers?[/INST]0"
"[INST]In the context of the C64, What is the maximum value for the Pulse Width registers?[/INST]4095 ($FF)"
"[INST]In the context of the C64, What is the effect of a value of 0 in the Pulse Width registers?[/INST]produces a constant DC output"
"[INST]In the context of the C64, What is the effect of a value of 4095 in the Pulse Width registers?[/INST]produces a constant DC output"
"[INST]In the context of the C64, What is the effect of a value of 2048 in the Pulse Width registers?[/INST]produces a square wave"
"[INST]In the context of the C64, Is a dynamic ram refresh controller built into the 6566/6567 devices?[/INST]Yes"
"[INST]In the context of the C64, What is the rate at which 8-bit row addresses are refreshed?[/INST]Every raster line"
"[INST]In the context of the C64, What is the maximum delay between the refresh of any single row address in a 128 refresh scheme?[/INST]2.02 ms"
"[INST]In the context of the C64, What is the maximum delay between the refresh of any single row address in a 256 refresh scheme?[/INST]3.66 ms"
"[INST]In the context of the C64, Is the refresh process transparent to the system?[/INST]Yes"
"[INST]In the context of the C64, What phase of the system clock does the refresh occur during?[/INST]Phase 1"
"[INST]In the context of the C64, What signals are generated by the 6567 for every Phase 2 and video data access?[/INST]/RAS and /CAS"
"[INST]In the context of the C64, Are external clock generation required for the refresh process?[/INST]No"
"[INST]In the context of the C64, What is the purpose of /RAS and /CAS signals?[/INST]Generated for every Phase 2 and video data access"
"[INST]In the context of the C64, Are the /RAS and /CAS signals connected directly to the dynamic rams?[/INST]Yes"
"[INST]In the context of the C64, Is the refresh process guaranteed for every raster line?[/INST]Yes"
"[INST]In the context of the C64, What is the size of the matrix on the Programmable Character Worksheet?[/INST]8 by 8"
"[INST]In the context of the C64, What is the purpose of the matrix on the Programmable Character Worksheet?[/INST]To design your own characters"
"[INST]In the context of the C64, what is the size of a sprite in terms of dots[/INST]24 by 21 dots"
"[INST]In the context of the C64, How many bytes are needed to store a sprite[/INST]63 bytes"
"[INST]In the context of the C64, What is the size of a sprite in terms of bytes[/INST]504/8 bits"
"[INST]In the context of the C64, How is a sprite created[/INST]by taking a look at the sprite definition block on the bit level"
"[INST]In the context of the C64, What happens to a bit set to 0 in a sprite[/INST]it will display whatever data is behind it"
"[INST]In the context of the C64, What is similar between sprites and characters[/INST]each bit set to 0 is transparent"
"[INST]In the context of the C64, What is the resolution of a multi-color sprite[/INST]12 horizontal dots by 21 vertical dots"
"[INST]In the context of the C64, What happens to the width of each dot in a multi-color sprite[/INST]it becomes twice as wide"
"[INST]In the context of the C64, What is the number of colors displayable in a multi-color sprite[/INST]4"
"[INST]In the context of the C64, Is the CLV operation an implied addressing mode?[/INST]Yes"
"[INST]In the context of the C64, What is the OP CODE for the CLV operation?[/INST]B8"
"[INST]In the context of the C64, How many bytes does the CLV operation take?[/INST]1"
"[INST]In the context of the C64, How many cycles does the CLV operation take?[/INST]2"
"[INST]In the context of the C64, What is the purpose of the CLV operation?[/INST]Clear overflow flag"
"[INST]In the context of the C64, What is the assembly language form of the CLV operation?[/INST]CLV"
"[INST]In the context of the C64, What is the addressing mode of the CLV operation?[/INST]Implied"
"[INST]In the context of the C64, What is the operation code for the CLV operation?[/INST]CLV"
"[INST]In the context of the C64, What is the number of cycles taken by the CLV operation?[/INST]2"
"[INST]In the context of the C64, What is the number of bytes taken by the CLV operation?[/INST]1"
"[INST]In the context of the C64, what is the operation of ASL instruction[/INST]Shift Left One Bit"
"[INST]In the context of the C64, what is the purpose of ASL instruction[/INST]Shift Left One Bit (Memory or Accumulator)"
"[INST]In the context of the C64, what is the format of ASL instruction[/INST]C <- |7|6|5|4|3|2|1|0| <- 0"
"[INST]In the context of the C64, what is the addressing mode of ASL instruction[/INST]Accumulator, Zero Page, Zero Page,X, Absolute, Absolute,X"
"[INST]In the context of the C64, what is the number of bytes of ASL instruction[/INST]1, 2, 2, 3, 3"
"[INST]In the context of the C64, what is the number of cycles of ASL instruction[/INST]2, 5, 6, 6, 7"
"[INST]In the context of the C64, what is the op code of ASL instruction[/INST]0A, 06, 16, 0E, 1E"
"[INST]In the context of the C64, what is the purpose of ASL instruction in Accumulator mode[/INST]Shift Left One Bit (Memory or Accumulator)"
"[INST]In the context of the C64, what is the purpose of ASL instruction in Zero Page mode[/INST]Shift Left One Bit (Memory or Accumulator)"
"[INST]In the context of the C64, what is the purpose of ASL instruction in Zero Page,X mode[/INST]Shift Left One Bit (Memory or Accumulator)"
"[INST]In the context of the C64, what is the purpose of ASL instruction in Absolute mode[/INST]Shift Left One Bit (Memory or Accumulator)"
"[INST]In the context of the C64, what is the purpose of ASL instruction in Absolute,X mode[/INST]Shift Left One Bit (Memory or Accumulator)"
"[INST]In the context of the C64, how do I detect a sprite collision with another sprite in C64?[/INST]You can detect whether a sprite has collided with another sprite by using the line: IF PEEK(V+30)ANDX=XTHEN [insert action here]. This line checks to see if a particular sprite has collided with ANY OTHER SPRITE, where X equals 1 for sprite 0, 2 for sprite 1, 4 for sprite 2, 8 for sprite 3, 16 for sprite 4, 32 for sprite 5, 64 for sprite 6, and 128 for sprite 7."
"[INST]In the context of the C64, what is the purpose of the PEEK(V+30) function in sprite collision detection?[/INST]The PEEK(V+30) function is used to detect whether a sprite has collided with another sprite. It checks to see if a particular sprite has collided with ANY OTHER SPRITE, where X equals 1 for sprite 0, 2 for sprite 1, 4 for sprite 2, 8 for sprite 3, 16 for sprite 4, 32 for sprite 5, 64 for sprite 6, and 128 for sprite 7."
"[INST]In the context of the C64, how do I detect a sprite collision with a background character in C64?[/INST]You can detect whether a sprite has collided with a background character by using the line: IF PEEK(V+31)ANDX=XTHEN [insert action here]. This line checks to see if a particular sprite has collided with a BACKGROUND CHARACTER."
"[INST]In the context of the C64, what is the difference between PEEK(V+30) and PEEK(V+31) in sprite collision detection?[/INST]PEEK(V+30) is used to detect collisions between sprites, while PEEK(V+31) is used to detect collisions between a sprite and a background character."
"[INST]In the context of the C64, what is the value of X in the sprite collision detection formula?[/INST]The value of X in the sprite collision detection formula depends on the sprite number. X equals 1 for sprite 0, 2 for sprite 1, 4 for sprite 2, 8 for sprite 3, 16 for sprite 4, 32 for sprite 5, 64 for sprite 6, and 128 for sprite 7."
"[INST]In the context of the C64, can I use PEEK(V+30) to detect collisions between a sprite and a background character?[/INST]No, PEEK(V+30) is used to detect collisions between sprites. To detect collisions between a sprite and a background character, you should use PEEK(V+31)."
"[INST]In the context of the C64, what is the purpose of the ANDX=X part in the sprite collision detection formula?[/INST]The ANDX=X part of the formula is used to specify which sprite to check for collision. X equals 1 for sprite 0, 2 for sprite 1, 4 for sprite 2, 8 for sprite 3, 16 for sprite 4, 32 for sprite 5, 64 for sprite 6, and 128 for sprite 7."
"[INST]In the context of the C64, can I use sprite collision detection to detect collisions between two specific sprites?[/INST]No, the sprite collision detection formula checks if a particular sprite has collided with ANY OTHER SPRITE. If you want to detect collisions between two specific sprites, you will need to use a different approach."
"[INST]In the context of the C64, what happens if I use PEEK(V+30) with X=0?[/INST]If you use PEEK(V+30) with X=0, it will not detect any collisions, because X=0 does not correspond to any sprite."
"[INST]In the context of the C64, is it possible to detect collisions between a sprite and a specific background character?[/INST]No, the sprite collision detection formula only checks if a sprite has collided with a background character, but it does not specify which background character."
"[INST]In the context of the C64, What is the function of the ACPTR kernel routine?[/INST]Input byte from serial port"
"[INST]In the context of the C64, What is the purpose of the CHKIN kernel routine?[/INST]Open channel for input"
"[INST]In the context of the C64, What is the function of the CIOUT kernel routine?[/INST]Output byte to serial port"
"[INST]In the context of the C64, What is the purpose of the CINT kernel routine?[/INST]Initialize screen editor"
"[INST]In the context of the C64, What is the function of the CLOSE kernel routine?[/INST]Close a specified logical file"
"[INST]In the context of the C64, What is the purpose of the CLRCHN kernel routine?[/INST]Close input and output channels"
"[INST]In the context of the C64, What is the function of the GETIN kernel routine?[/INST]Get character from keyboard queue"
"[INST]In the context of the C64, What is the purpose of the IOBASE kernel routine?[/INST]Returns base address of I/O devices"
"[INST]In the context of the C64, What is the function of the IOINIT kernel routine?[/INST]Initialize input/output"
"[INST]In the context of the C64, What is the purpose of the LISTEN kernel routine?[/INST]Command devices on the serial bus to LISTEN"
"[INST]In the context of the C64, what is the function of the CLD instruction in 6502 assembly language?[/INST]The CLD instruction is used to clear the decimal mode in the 6502 processor, which means that the processor will not use binary-coded decimal arithmetic for subsequent instructions. This is important because the decimal mode can affect the behavior of certain instructions, such as ADC and SBC, which perform arithmetic operations."
"[INST]In the context of the C64, what is the addressing mode used by the CLD instruction?[/INST]The CLD instruction uses the implied addressing mode, which means that the instruction does not require an operand and does not specify a memory location."
"[INST]In the context of the C64, what is the opcode for the CLD instruction?[/INST]The opcode for the CLD instruction is D8, which is a single byte that represents the instruction in machine code."
"[INST]In the context of the C64, how many bytes does the CLD instruction occupy in memory?[/INST]The CLD instruction occupies 1 byte in memory, which is the minimum size for a 6502 instruction."
"[INST]In the context of the C64, how many cycles does the CLD instruction take to execute?[/INST]The CLD instruction takes 2 cycles to execute, which is relatively fast compared to other instructions."
"[INST]In the context of the C64, what is the purpose of clearing the decimal mode with CLD?[/INST]Clearing the decimal mode with CLD is necessary to ensure that arithmetic operations are performed correctly, as the decimal mode can cause unexpected results if not cleared."
"[INST]In the context of the C64, in what situations would you use the CLD instruction?[/INST]You would use the CLD instruction when you need to ensure that arithmetic operations are performed in binary, rather than binary-coded decimal, such as when working with binary data or performing calculations that require precise control."
"[INST]In the context of the C64, how does the CLD instruction affect the processor's flags?[/INST]The CLD instruction does not affect the processor's flags, as it only clears the decimal mode and does not perform any arithmetic operations or affect the status register."
"[INST]In the context of the C64, can the CLD instruction be used with other instructions that use decimal mode?[/INST]No, the CLD instruction is used to clear the decimal mode, so it cannot be used with other instructions that rely on decimal mode, such as ADC and SBC with the decimal flag set."
"[INST]In the context of the C64, is the CLD instruction commonly used in 6502 assembly language programming?[/INST]While the CLD instruction is not as commonly used as other instructions, it is an important instruction in certain situations, such as when working with binary data or performing precise arithmetic operations."
"[INST]In the context of the C64, what is the location of the VIC-II control register?[/INST]The VIC-II control register is located at memory address 53271, which can also be represented in hexadecimal as $D017."
"[INST]In the context of the C64, how do you unexpand a sprite in the vertical direction?[/INST]To unexpand a sprite in the vertical direction, the corresponding bit in the VIC-II control register at location 53271 ($D017 in HEX) must be turned OFF (set to a 0)."
"[INST]In the context of the C64, what is the purpose of the POKE command in the given code snippet?[/INST]The POKE command is used to 'unexpand' a sprite in the Y direction, by modifying the VIC-II control register at location 53271."
"[INST]In the context of the C64, what is the function of the PEEK command in the given code snippet?[/INST]The PEEK command is used to read the current value of the VIC-II control register at location 53271, which is then modified to 'unexpand' a sprite in the Y direction."
"[INST]In the context of the C64, what is the significance of the number 255 in the given code snippet?[/INST]The number 255 is used as a mask to clear the bit corresponding to the sprite number (SN) in the VIC-II control register, effectively turning it OFF."
"[INST]In the context of the C64, what is the role of the sprite number (SN) in the given code snippet?[/INST]The sprite number (SN) is used to determine which bit in the VIC-II control register corresponds to the sprite that needs to be 'unexpanded' in the Y direction."
"[INST]In the context of the C64, what is the effect of the bitwise AND operation in the given code snippet?[/INST]The bitwise AND operation is used to clear the bit corresponding to the sprite number (SN) in the VIC-II control register, effectively turning it OFF and 'unexpanding' the sprite in the Y direction."
"[INST]In the context of the C64, what is the purpose of the code snippet POKE 53271,PEEK(53271)AND (255-2^SN)?[/INST]The code snippet POKE 53271,PEEK(53271)AND (255-2^SN) is used to 'unexpand' a sprite in the Y direction, by modifying the VIC-II control register at location 53271."
"[INST]In the context of the C64, how does the code snippet POKE 53271,PEEK(53271)AND (255-2^SN) modify the VIC-II control register?[/INST]The code snippet POKE 53271,PEEK(53271)AND (255-2^SN) modifies the VIC-II control register by clearing the bit corresponding to the sprite number (SN), effectively 'unexpanding' the sprite in the Y direction."
"[INST]In the context of the C64, what is the significance of the hexadecimal representation $D017 in the context of the VIC-II control register?[/INST]The hexadecimal representation $D017 is the memory address of the VIC-II control register, which is used to control various aspects of the Commodore 64's graphics and sound capabilities."
"[INST]In the context of the C64, what is the purpose of the RAMTAS function in a Commodore 64 program[/INST]The purpose of the RAMTAS function is to perform a RAM test and set the top and bottom of memory pointers accordingly, it also clears specific memory locations, allocates the cassette buffer, and sets the screen base to $0400."
"[INST]In the context of the C64, What is the call address of the RAMTAS function in hexadecimal[/INST]The call address of the RAMTAS function is $FF87."
"[INST]In the context of the C64, What is the decimal equivalent of the call address of the RAMTAS function[/INST]The decimal equivalent of the call address of the RAMTAS function is 65415."
"[INST]In the context of the C64, What are the communication registers used by the RAMTAS function[/INST]The communication registers used by the RAMTAS function are A, X, and Y."
"[INST]In the context of the C64, What is the stack requirement for the RAMTAS function[/INST]The stack requirement for the RAMTAS function is 2."
"[INST]In the context of the C64, What registers are affected by the RAMTAS function[/INST]The registers affected by the RAMTAS function are A, X, and Y."
"[INST]In the context of the C64, In what context is the RAMTAS function normally called[/INST]The RAMTAS function is normally called as part of the initialization process of a Commodore 64 program cartridge."
"[INST]In the context of the C64, What memory locations are cleared by the RAMTAS function[/INST]The RAMTAS function clears memory locations $0000 to $0101 and $0200 to $03FF."
"[INST]In the context of the C64, What is the screen base set to by the RAMTAS function[/INST]The screen base is set to $0400 by the RAMTAS function."
"[INST]In the context of the C64, How do you call the RAMTAS function in assembly code[/INST]You call the RAMTAS function in assembly code using the instruction JSR RAMTAS."
"[INST]In the context of the C64, what is the function of bit 4 in the MODE/VOL register[/INST]When set to a one, the Low-Pass output of the Filter is selected and sent to the audio output, for a given Filter input signal, all frequency components below the Filter Cutoff Frequency are passed unaltered, while all frequency components above the Cutoff are attenuated at a rate of 12 dB/Octave"
"[INST]In the context of the C64, what is the effect of setting bit 5 in the MODE/VOL register[/INST]Same as bit 4 for the Bandpass output, all frequency components above and below the Cutoff are attenuated at a rate of 6 dB/Octave, the Bandpass mode produces thin, open sounds"
"[INST]In the context of the C64, what is the function of bit 6 in the MODE/VOL register[/INST]Same as bit 4 for the High-Pass output, all frequency components above the Cutoff are passed unaltered, while all frequency components below the Cutoff are attenuated at a rate of 12 dB/Octave, the High-Pass mode produces tinny, buzzy sounds"
"[INST]In the context of the C64, what is the effect of setting bit 7 in the MODE/VOL register[/INST]When set to a one, the output of Voice 3 is disconnected from the direct audio path, setting Voice 3 to bypass the Filter and setting 3 OFF to a one prevents Voice 3 from reaching the audio output"
"[INST]In the context of the C64, what is the purpose of the Filter in SID[/INST]The Filter is, perhaps, the most important element in SID as it allows the generation of complex tone colors via subtractive synthesis, the Filter is used to eliminate specific frequency components from a harmonically rich input signal"
"[INST]In the context of the C64, how does the Filter output modes work[/INST]The Filter output modes ARE additive and multiple Filter modes may be selected simultaneously, for example, both LP and HP modes can be selected to produce a Notch or Band Reject Filter response"
"[INST]In the context of the C64, what is the requirement for the Filter to have an audible effect[/INST]At least one Filter output must be selected and at least one Voice must be routed through the Filter"
"[INST]In the context of the C64, what is the function of bits 0-3 in the MODE/VOL register[/INST]Bits 0-3 select 1 of 16 overall Volume levels for the final composite audio output, the output volume levels range from no output to maximum volume in 16 linear steps"
"[INST]In the context of the C64, what is the purpose of the Volume control[/INST]This control can be used as a static volume control for balancing levels in multi-chip systems or for creating dynamic volume effects, such as Tremolo"
"[INST]In the context of the C64, what is the minimum requirement for SID to produce sound[/INST]Some Volume level other than zero must be selected in order for SID to produce any sound"
"[INST]In the context of the C64, what is the effect of varying the Cutoff Frequency in real-time[/INST]The best results are achieved by varying the Cutoff Frequency in real-time"
"[INST]In the context of the C64, what is the function of the Filter in subtractive synthesis[/INST]The Filter is used to eliminate specific frequency components from a harmonically rich input signal"
"[INST]In the context of the C64, what is the result of selecting multiple Filter modes simultaneously[/INST]Multiple Filter modes can be selected simultaneously, for example, both LP and HP modes can be selected to produce a Notch or Band Reject Filter response"
"[INST]In the context of the C64, what is the purpose of the Filter in SID[/INST]The Filter is, perhaps, the most important element in SID as it allows the generation of complex tone colors via subtractive synthesis"
"[INST]In the context of the C64, what is the effect of setting Voice 3 to bypass the Filter and setting 3 OFF to a one[/INST]This allows Voice 3 to be used for modulation purposes without any undesirable output"
"[INST]In the context of the C64, what is the range of output volume levels in the MODE/VOL register[/INST]The output volume levels range from no output to maximum volume in 16 linear steps"
"[INST]In the context of the C64, what is the function of the MODE/VOL register[/INST]The MODE/VOL register selects various Filter mode and output options, and selects 1 of 16 overall Volume levels for the final composite audio output"
"[INST]In the context of the C64, What is one of the most popular graphics techniques in the computer world?[/INST]BIT MAPPING"
"[INST]In the context of the C64, What is the resolution of standard bit mapped mode?[/INST]320-dot by 200-dot"
"[INST]In the context of the C64, What is the resolution of multi-color bit mapped mode?[/INST]160-dot by 200-dot"
"[INST]In the context of the C64, How do you turn on bit map mode?[/INST]By setting bit 5 of the VIC-II control register to 1 at location 53265"
"[INST]In the context of the C64, How do you turn off bit map mode?[/INST]By setting bit 5 of the VIC-II control register to 0 at location 53265"
"[INST]In the context of the C64, What is the purpose of programmable characters in bit mapping?[/INST]To change a single dot and watch it happen"
"[INST]In the context of the C64, What controls the colors of the bits in bit map mode?[/INST]Screen memory"
"[INST]In the context of the C64, What determines the color of a bit in bit map mode?[/INST]The upper 4 bits of screen memory"
"[INST]In the context of the C64, What is the result of running the program without clearing the HI-RES screen?[/INST]Garbage appears on the screen"
"[INST]In the context of the C64, How do you clear the HI-RES screen?[/INST]By clearing out the section of memory used for programmable characters"
"[INST]In the context of the C64, What is the location of the dot where X=0 and Y=0?[/INST]The upper-left of the display"
"[INST]In the context of the C64, Screen location:What happens to the X value as you move to the right?[/INST]It increases"
"[INST]In the context of the C64, Screen location:What happens to the Y value as you move down?[/INST]It increases"
"[INST]In the context of the C64, What is the resolution of the screen in standard bit mapped mode?[/INST]320 horizontal dots by 200 vertical dots"
"[INST]In the context of the C64, How many colors can be selected in standard bit mapped mode?[/INST]2 colors in each 8-dot by 8-dot section"
"[INST]In the context of the C64, What is the purpose of the POKE command in bit map mode?[/INST]To set or unset a dot on the HI-RES screen"
"[INST]In the context of the C64, What is the location of the VIC-II control register?[/INST]53265 ($D011 in HEX)"
"[INST]In the context of the C64, What is the purpose of the BASE variable in the example program?[/INST]To set the starting address of the bit map area"
"[INST]In the context of the C64, What is the purpose of the POKE 53272,PEEK(53272)OR8 command?[/INST]To put the bit map at location 8192"
"[INST]In the context of the C64, What is the purpose of the POKE 53265,PEEK(53265)OR32 command?[/INST]To enter bit map mode"
"[INST]In the context of the C64, What is the purpose of the POKEI,0 command?[/INST]To clear a location in memory"
"[INST]In the context of the C64, What is the purpose of the POKEI,3 command?[/INST]To set the color to cyan and black"
"[INST]In the context of the C64, What is the result of running the program without clearing the HI-RES screen?[/INST]Garbage appears on the screen"
"[INST]In the context of the C64, What is the location of the dot where X=0 and Y=0?[/INST]The upper-left of the display"
"[INST]In the context of the C64, What happens to the X value as you move to the right?[/INST]It increases"
"[INST]In the context of the C64, What happens to the Y value as you move down?[/INST]It increases"
"[INST]In the context of the C64, Multi-color bit map mode is selected by setting which register to a '1'?[/INST]register 22 ($16)"
"[INST]In the context of the C64, What is the purpose of the MCM bit in register 22 ($16)?[/INST]setting the multi-color bit map mode"
"[INST]In the context of the C64, What is the memory access sequence used in multi-color mode?[/INST]the same as standard bit map mode"
"[INST]In the context of the C64, What is the dot data interpreted as in multi-color mode?[/INST]the dot data as follows"
"[INST]In the context of the C64, What is the purpose of the color nybble in multi-color bit map mode?[/INST]used for the multi-color bit map mode"
"[INST]In the context of the C64, How many colors can be displayed in each 8*8 block in multi-color bit map mode?[/INST]three independently selected colors"
"[INST]In the context of the C64, What is the screen resolution in multi-color bit map mode?[/INST]160H*200V"
"[INST]In the context of the C64, What is the horizontal dot size in multi-color bit map mode?[/INST]doubled"
"[INST]In the context of the C64, What is the purpose of the video matrix pointer in multi-color bit map mode?[/INST]used to select one dot color"
"[INST]In the context of the C64, What is the purpose of the background color in multi-color bit map mode?[/INST]used in addition to the three independently selected colors"
"[INST]In the context of the C64, What is the size of each block in multi-color bit map mode?[/INST]8*8"
"[INST]In the context of the C64, Under what conditions are the electrical characteristics of the C64 AC characteristics specified?[/INST]The electrical characteristics of the C64 AC characteristics are specified under the conditions of Vcc=5V +-5%, Vss=0V, and Ta=0-70 Celsius."
"[INST]In the context of the C64, What is the clock timing for the C64 under 1 MHz and 2 MHz conditions?[/INST]The clock timing for the C64 under 1 MHz and 2 MHz conditions is specified in the timing characteristics table, which provides the timing requirements for writing data to memory or peripherals."
"[INST]In the context of the C64, What is the significance of the 5V +-5% voltage range in the C64's electrical characteristics?[/INST]The 5V +-5% voltage range in the C64's electrical characteristics indicates that the system is designed to operate within a specific voltage tolerance, ensuring reliable operation and minimizing the risk of damage or malfunction."
"[INST]In the context of the C64, How does the temperature range of 0-70 Celsius affect the C64's electrical characteristics?[/INST]The temperature range of 0-70 Celsius affects the C64's electrical characteristics by ensuring that the system operates within a specific thermal envelope, which is critical for maintaining reliability and preventing overheating or malfunction."
"[INST]In the context of the C64, What is the relationship between the clock timing and the writing of data to memory or peripherals in the C64?[/INST]The clock timing in the C64 is critical for writing data to memory or peripherals, as it ensures that data is transferred correctly and efficiently, and that the system operates within the specified timing requirements."
"[INST]In the context of the C64, How do the electrical characteristics of the C64 vary under different operating conditions?[/INST]The electrical characteristics of the C64 vary under different operating conditions, such as temperature and voltage, which can affect the system's performance, reliability, and overall operation."
"[INST]In the context of the C64, What is the importance of considering the electrical characteristics of the C64 in system design?[/INST]Considering the electrical characteristics of the C64 is crucial in system design, as it ensures that the system operates within the specified parameters, and that the design is reliable, efficient, and meets the required performance standards."
"[INST]In the context of the C64, How do the AC characteristics of the C64 affect the system's overall performance?[/INST]The AC characteristics of the C64, including the clock timing and electrical characteristics, have a direct impact on the system's overall performance, influencing factors such as data transfer rates, processing speed, and system reliability."
"[INST]In the context of the C64, What are the implications of exceeding the specified voltage range in the C64's electrical characteristics?[/INST]Exceeding the specified voltage range in the C64's electrical characteristics can result in system malfunction, damage, or even complete failure, highlighting the importance of adhering to the specified voltage tolerances."
"[INST]In the context of the C64, What is the role of the clock timing in ensuring reliable data transfer in the C64?[/INST]The clock timing plays a critical role in ensuring reliable data transfer in the C64, as it synchronizes the transfer of data between the CPU, memory, and peripherals, ensuring that data is transferred correctly and efficiently."
"[INST]In the context of the C64, Is the serial port a buffered system?[/INST]Yes"
"[INST]In the context of the C64, What is the maximum baud rate possible?[/INST]02 divided by 4"
"[INST]In the context of the C64, What is the maximum useable baud rate?[/INST]determined by line loading and the speed at which the receiver responds to input data"
"[INST]In the context of the C64, What is the purpose of the control bit?[/INST]selects input or output mode"
"[INST]In the context of the C64, What happens to the data in the shift register after 8 CNT pulses?[/INST]dumped into the Serial Data Register and an interrupt is generated"
"[INST]In the context of the C64, What is the function of TIMER A?[/INST]used for the baud rate generator"
"[INST]In the context of the C64, What is the maximum baud rate possible in output mode?[/INST]1/2 the underflow rate of TIMER A"
"[INST]In the context of the C64, What happens to the data shifted out on the SP pin?[/INST]becomes valid on the falling edge of CNT and remains valid until the next falling edge"
"[INST]In the context of the C64, What is the purpose of the Serial Data Register?[/INST]to store data to be transmitted"
"[INST]In the context of the C64, What happens to the shift register after 8 CNT pulses?[/INST]shifts out to the SP pin"
"[INST]In the context of the C64, What is the purpose of the CNT pin?[/INST]to generate the clock signal"
"[INST]In the context of the C64, What is the purpose of the SP pin?[/INST]to transmit data"
"[INST]In the context of the C64, What is the purpose of the Serial Port?[/INST]to transmit data serially"
"[INST]In the context of the C64, What is the maximum number of bytes that can be transmitted continuously?[/INST]one byte ahead of the shift register"
"[INST]In the context of the C64, What happens to the CNT pin after 8 CNT pulses?[/INST]returns high"
"[INST]In the context of the C64, What is the purpose of the SDR data?[/INST]to transmit data serially"
"[INST]In the context of the C64, What is the format of the serial input data?[/INST]MSB first"
"[INST]In the context of the C64, What is the purpose of the 6526 devices?[/INST]to connect to a common serial communication bus"
"[INST]In the context of the C64, What is the purpose of the CNT and SP outputs?[/INST]to allow a common serial communication bus"
"[INST]In the context of the C64, What is the protocol for master/slave selection?[/INST]transmitted over the serial bus or via dedicated handshaking lines"
"[INST]In the context of the C64, What is the purpose of the TIMER A?[/INST]to generate the baud rate"
"[INST]In the context of the C64, What is the purpose of the Serial Data Register?[/INST]to store data to be transmitted"
"[INST]In the context of the C64, What happens to the data in the shift register after transmission?[/INST]dumped into the Serial Data Register"
"[INST]In the context of the C64, What is the purpose of the shift register?[/INST]to store data to be transmitted"
"[INST]In the context of the C64, What is the purpose of the CNT pin?[/INST]to generate the clock signal"
"[INST]In the context of the C64, What is the purpose of the SP pin?[/INST]to transmit data"
"[INST]In the context of the C64, What is the purpose of the Serial Port?[/INST]to transmit data serially"
"[INST]In the context of the C64, What is the maximum baud rate possible in input mode?[/INST]1/2 the underflow rate of TIMER A"
"[INST]In the context of the C64, What is the purpose of the TIMER A in output mode?[/INST]to generate the baud rate"
"[INST]In the context of the C64, What is the purpose of the Serial Data Register?[/INST]to store data to be transmitted"
"[INST]In the context of the C64, What is the purpose of the shift register?[/INST]to store data to be transmitted"
"[INST]In the context of the C64, what is the bit that indicates a result of zero in the status register?[/INST]The Zero flag (Z) is set to 1 if the result of the operation is zero, and cleared to 0 if the result is non-zero. This flag is used to test for zero results in arithmetic and logical operations."
"[INST]In the context of the C64, what does the decimal mode flag do in the status register?[/INST]The Decimal Mode flag (D) is set to 1 to indicate that the processor is in decimal mode, which affects the way the processor handles arithmetic operations. In decimal mode, the processor performs binary-coded decimal (BCD) arithmetic, which is useful for financial and monetary calculations."
"[INST]In the context of the C64, what is the function of the break command flag in the status register?[/INST]The Break Command flag (B) is set to 1 when a BRK instruction is executed, which generates an interrupt that can be used to implement a software interrupt or a debug breakpoint."
"[INST]In the context of the C64, what is the function of the interrupt disable flag in the status register?[/INST]The Interrupt Disable flag (I) is set to 1 to disable maskable interrupts, which prevents the processor from responding to interrupts until the flag is cleared to 0."
"[INST]In the context of the C64, what does the overflow flag indicate in the status register?[/INST]The Overflow flag (V) is set to 1 if the result of an arithmetic operation exceeds the range of the accumulator, indicating an overflow or underflow condition."
"[INST]In the context of the C64, what does the negative flag indicate in the status register?[/INST]The Negative flag (N) is set to 1 if the result of an arithmetic operation is negative, and cleared to 0 if the result is positive or zero."
"[INST]In the context of the C64, what does the carry flag indicate in the status register?[/INST]The Carry flag (C) is set to 1 if an arithmetic operation generates a carry or borrow, and cleared to 0 if no carry or borrow occurs."
"[INST]In the context of the C64, how do you test the status register in assembly language?[/INST]The status register can be tested using the PHP instruction, which pushes a copy of the status register onto the stack, allowing the flags to be examined and tested."
"[INST]In the context of the C64, what is the purpose of the status register in the 6510 microprocessor?[/INST]The status register, also known as the Processor Status Register (P), is a 8-bit register that holds the current status of the processor, including flags that indicate the result of arithmetic and logical operations."
"[INST]In the context of the C64, what is the format of the status register in the 6510 microprocessor?[/INST]The status register is a 8-bit register, with each bit representing a specific flag: N, V, -, B, D, I, Z, and C, which can be tested and used to control the flow of a program."
"[INST]In the context of the C64, what is the normal display size of the display window?[/INST]The normal display consists of 25 rows of 40 characters (or character regions) per row."
"[INST]In the context of the C64, What is the minimum number of rows in the reduced display window?[/INST]24 rows"
"[INST]In the context of the C64, What is the maximum number of columns in the standard display window?[/INST]40 columns"
"[INST]In the context of the C64, What is the purpose of the RSEL bit?[/INST]The RSEL bit is in register 17 ($11) and the CSEL bit is in register 22 ($16)."
"[INST]In the context of the C64, What is the default display window size?[/INST]The larger display window is normally used, while the smaller display window is normally used in conjunction with scrolling."
"[INST]In the context of the C64, What is the purpose of the CSEL bit?[/INST]The RSEL bit is in register 17 ($11) and the CSEL bit is in register 22 ($16)."
"[INST]In the context of the C64, What is the minimum number of columns in the reduced display window?[/INST]38 columns"
"[INST]In the context of the C64, What is the purpose of the reduced display window?[/INST]The display window may be reduced to 24 rows and 38 characters."
"[INST]In the context of the C64, What is the purpose of the standard display window?[/INST]For standard display the larger display window is normally used,"
"[INST]In the context of the C64, What is the purpose of the scrolling feature?[/INST]The smaller display window is normally used in conjunction with scrolling."
"[INST]In the context of the C64, what is the function of the TSX instruction in 6502 assembly language?[/INST]The TSX instruction is used to transfer the contents of the stack pointer to the X register. This is an implied addressing mode instruction, meaning that it does not require any additional memory locations or operands to be specified. The opcode for TSX is BA, and it occupies only 1 byte of memory. The instruction takes 2 cycles to complete."
"[INST]In the context of the C64, what is the addressing mode of the TSX instruction?[/INST]The addressing mode of the TSX instruction is implied, meaning that it does not require any additional memory locations or operands to be specified."
"[INST]In the context of the C64, what is the opcode for the TSX instruction?[/INST]The opcode for the TSX instruction is BA, which occupies 1 byte of memory."
"[INST]In the context of the C64, how many cycles does the TSX instruction take to complete?[/INST]The TSX instruction takes 2 cycles to complete."
"[INST]In the context of the C64, what is the purpose of transferring the stack pointer to the X register?[/INST]Transferring the stack pointer to the X register allows the programmer to manipulate the stack pointer using the X register, which can be useful in a variety of situations, such as implementing stack-based algorithms or managing memory allocation."
"[INST]In the context of the C64, can the TSX instruction be used with other addressing modes?[/INST]No, the TSX instruction can only be used with the implied addressing mode, which means that it does not require any additional memory locations or operands to be specified."
"[INST]In the context of the C64, what is the difference between the TSX instruction and the TXS instruction?[/INST]The TSX instruction transfers the stack pointer to the X register, while the TXS instruction transfers the X register to the stack pointer. These two instructions are often used together to implement stack-based algorithms or manage memory allocation."
"[INST]In the context of the C64, how does the TSX instruction affect the flags register?[/INST]The TSX instruction does not affect the flags register, as it only transfers the stack pointer to the X register without performing any arithmetic or logical operations."
"[INST]In the context of the C64, can the TSX instruction be used to implement recursive functions?[/INST]Yes, the TSX instruction can be used to implement recursive functions by transferring the stack pointer to the X register, which can then be used to manage the function call stack."
"[INST]In the context of the C64, what is the relationship between the TSX instruction and the stack pointer?[/INST]The TSX instruction transfers the contents of the stack pointer to the X register, allowing the programmer to manipulate the stack pointer using the X register, which can be useful in a variety of situations, such as implementing stack-based algorithms or managing memory allocation."
"[INST]In the context of the C64, What is the purpose of the SETLFS function?[/INST]The purpose of the SETLFS function is to set up a logical file, which includes setting the logical file number, device address, and secondary address (command number) for other KERNAL routines."
"[INST]In the context of the C64, What is the call address of the SETLFS function?[/INST]The call address of the SETLFS function is $FFBA (hex) or 65466 (decimal)."
"[INST]In the context of the C64, What are the communication registers used by the SETLFS function?[/INST]The communication registers used by the SETLFS function are A, X, and Y."
"[INST]In the context of the C64, What is the stack requirement for the SETLFS function?[/INST]The stack requirement for the SETLFS function is 2."
"[INST]In the context of the C64, How do you use the SETLFS function to set a logical file number, device number, and command?[/INST]To use the SETLFS function, load the accumulator with the logical file number, load the X index register with the device number, and load the Y index register with the command. Then, call the SETLFS function using JSR SETLFS."
"[INST]In the context of the C64, What is the range of device addresses that can be used with the SETLFS function?[/INST]The range of device addresses that can be used with the SETLFS function is 0 to 31."
"[INST]In the context of the C64, What does a device address of 0 represent in the SETLFS function?[/INST]A device address of 0 represents the Keyboard in the SETLFS function."
"[INST]In the context of the C64, What happens when a device number of 4 or greater is used with the SETLFS function?[/INST]When a device number of 4 or greater is used with the SETLFS function, it automatically refers to devices on the serial bus."
"[INST]In the context of the C64, What is the purpose of the secondary address in the SETLFS function?[/INST]The purpose of the secondary address in the SETLFS function is to send a command to the device on the serial bus after the device number is sent during the serial attention handshaking sequence."
"[INST]In the context of the C64, How do you indicate that no secondary address is to be sent with the SETLFS function?[/INST]To indicate that no secondary address is to be sent with the SETLFS function, set the Y index register to 255."
"[INST]In the context of the C64, What is the maximum number of characters that can be held in the output buffer before a full buffer hold-off occurs?[/INST]The output buffer can hold 255 characters before a full buffer hold-off occurs, at which point the system will wait in the CHROUT routine until transmission is allowed or the <RUN/STOP> and <RESTORE> keys are used to recover the system through a WARM START."
"[INST]In the context of the C64, What is the BASIC syntax for sending data to an RS-232 channel?[/INST]The BASIC syntax for sending data to an RS-232 channel is PRINT#lfn,<variable list>, where lfn is the logical file number of the channel."
"[INST]In the context of the C64, What is the purpose of the CHKOUT KERNAL entry?[/INST]The CHKOUT KERNAL entry ($FFC9) handles the x-line handshake, which follows the EIA standard (August 1979) for RS-232-C interfaces, and implements the RTS, CTS, and DCD lines as defined by the Commodore 64 as the Data Terminal Device."
"[INST]In the context of the C64, What is the purpose of the CHROUT KERNAL entry?[/INST]The CHROUT KERNAL entry ($FFD2) is responsible for transmitting data to the RS-232 channel, and will wait until transmission is allowed or the <RUN/STOP> and <RESTORE> keys are used to recover the system through a WARM START."
"[INST]In the context of the C64, Why is it important to implement a hold-off or internal buffering when sending data to an RS-232 printer?[/INST]It is important to implement a hold-off or internal buffering when sending data to an RS-232 printer because there is no carriage-return delay built into the output channel, which means that a normal RS-232 printer cannot correctly print without some form of hold-off or internal buffering."
"[INST]In the context of the C64, How can the Commodore 64 buffer be made to hold-off more output until transmission is allowed by the RS-232 device?[/INST]The Commodore 64 buffer can be made to hold-off more output until transmission is allowed by the RS-232 device by implementing a CTS (x-line) handshake, which will cause the buffer to fill and then hold-off more output until transmission is allowed."
"[INST]In the context of the C64, What is x-line handshaking, and how is it used in RS-232 communication?[/INST]X-line handshaking is a handshake routine that uses multiple lines for receiving and transmitting data, and is used in RS-232 communication to control the flow of data between devices."
"[INST]In the context of the C64, What is the EIA standard for RS-232-C interfaces, and how is it related to the Commodore 64?[/INST]The EIA standard for RS-232-C interfaces is a standard for serial communication, and the Commodore 64 implements this standard through the CHKOUT KERNAL entry, which handles the x-line handshake and implements the RTS, CTS, and DCD lines as defined by the Commodore 64 as the Data Terminal Device."
"[INST]In the context of the C64, What happens if the output buffer becomes full and transmission is not allowed by the RS-232 device?[/INST]If the output buffer becomes full and transmission is not allowed by the RS-232 device, the system will wait in the CHROUT routine until transmission is allowed or the <RUN/STOP> and <RESTORE> keys are used to recover the system through a WARM START."
"[INST]In the context of the C64, How can a program implement a hold-off to prevent the output buffer from overflowing when sending data to an RS-232 channel?[/INST]A program can implement a hold-off to prevent the output buffer from overflowing when sending data to an RS-232 channel by using a delay or wait loop to pause transmission until the buffer is empty or transmission is allowed by the RS-232 device."
"[INST]In the context of the C64, INY operation increments what by one[/INST]INY operation increments the index Y by one"
"[INST]In the context of the C64, INY operation increments what data type[/INST]INY operation increments the index Y"
"[INST]In the context of the C64, INY operation is an example of what type of operation[/INST]INY operation is an example of an implied operation"
"[INST]In the context of the C64, INY operation is used to increment what variable[/INST]INY operation is used to increment the index Y"
"[INST]In the context of the C64, INY operation is used in what addressing mode[/INST]INY operation is used in implied addressing mode"
"[INST]In the context of the C64, INY operation is used in what assembly language form[/INST]INY operation is used in assembly language form"
"[INST]In the context of the C64, INY operation is used in what number of bytes[/INST]INY operation is used in 1 byte"
"[INST]In the context of the C64, INY operation is used in what number of cycles[/INST]INY operation is used in 2 cycles"
"[INST]In the context of the C64, INY operation is used in what operation code[/INST]INY operation is used in operation code C8"
"[INST]In the context of the C64, what is the purpose of the R/W pin on the SID chip[/INST]The R/W pin is a TTL-level input that controls the direction of data transfers between the SID and the microprocessor, allowing the microprocessor to read data from the selected SID register when high and write data into the selected SID register when low."
"[INST]In the context of the C64, what happens when the R/W pin is high[/INST]When the R/W pin is high, the microprocessor is allowed to read data from the selected SID register, enabling data transfer from the SID to the microprocessor."
"[INST]In the context of the C64, what happens when the R/W pin is low[/INST]When the R/W pin is low, the microprocessor is allowed to write data into the selected SID register, enabling data transfer from the microprocessor to the SID."
"[INST]In the context of the C64, what is the relationship between the R/W pin and the chip select conditions[/INST]The R/W pin only takes effect if the chip select conditions have been met, meaning that the SID chip must be selected before the R/W pin can control the direction of data transfer."
"[INST]In the context of the C64, how is the R/W pin typically connected in a system[/INST]The R/W pin is normally connected to the system Read/Write line, allowing the SID to integrate with the system's data transfer mechanisms."
"[INST]In the context of the C64, what type of signal is used on the R/W pin[/INST]The R/W pin uses a TTL-level input signal, which is a type of digital signal that is commonly used in electronic circuits."
"[INST]In the context of the C64, what is the function of the R/W pin in relation to the SID registers[/INST]The R/W pin controls the direction of data transfer between the microprocessor and the selected SID register, allowing the microprocessor to read from or write to the register."
"[INST]In the context of the C64, in what way does the R/W pin control data transfer[/INST]The R/W pin controls data transfer by determining the direction of data flow between the microprocessor and the SID, with a high signal indicating a read operation and a low signal indicating a write operation."
"[INST]In the context of the C64, what is the significance of the R/W pin in the SID chip[/INST]The R/W pin is a critical component of the SID chip, as it enables the microprocessor to access and modify the SID registers, which is essential for generating sound and music."
"[INST]In the context of the C64, what is the relationship between the R/W pin and the microprocessor[/INST]The R/W pin is controlled by the microprocessor, which uses it to determine the direction of data transfer between the SID and the microprocessor, allowing the microprocessor to read from or write to the SID registers."
"[INST]In the context of the C64, Indirect indexed mode allows usage of which register as the index?[/INST]Y register"
"[INST]In the context of the C64, What is the mode of instruction in indirect indexed mode?[/INST]indirect"
"[INST]In the context of the C64, What is the low byte of the actual address in indirect indexed mode?[/INST]zero page"
"[INST]In the context of the C64, What is the high order byte of the actual address in indirect indexed mode?[/INST]next byte"
"[INST]In the context of the C64, What is the purpose of the instruction in indirect indexed mode?[/INST]load the accumulator"
"[INST]In the context of the C64, What is the actual address in indirect indexed mode?[/INST]$1E45 + Y"
"[INST]In the context of the C64, What is the low order byte of the actual address in indirect indexed mode?[/INST]contents of $02"
"[INST]In the context of the C64, What is the high order byte of the actual address in indirect indexed mode?[/INST]contents of $03"
"[INST]In the context of the C64, What is the Y register value in indirect indexed mode?[/INST]$00"
"[INST]In the context of the C64, What is the equivalent code for delivering a letter in indirect indexed mode?[/INST]LDA #$00, STA $02, LDA #$16, STA $03, LDY #$05, LDA ($02),Y"
"[INST]In the context of the C64, what is the purpose of the CLRCHN function?[/INST]The purpose of the CLRCHN function is to clear all open channels and restore the I/O channels to their original default values, usually called after opening other I/O channels and using them for input/output operations."
"[INST]In the context of the C64, what is the call address of the CLRCHN function?[/INST]The call address of the CLRCHN function is $FFCC (hex) or 65484 (decimal)."
"[INST]In the context of the C64, what registers are affected by the CLRCHN function?[/INST]The CLRCHN function affects the A and X registers."
"[INST]In the context of the C64, what is the default input device after calling the CLRCHN function?[/INST]The default input device after calling the CLRCHN function is 0, which is the keyboard."
"[INST]In the context of the C64, what is the default output device after calling the CLRCHN function?[/INST]The default output device after calling the CLRCHN function is 3, which is the Commodore 64 screen."
"[INST]In the context of the C64, what signal is sent to clear the input channel if one of the channels to be closed is to the serial port?[/INST]An UNTALK signal is sent to clear the input channel if one of the channels to be closed is to the serial port."
"[INST]In the context of the C64, what is sent to clear the output channel if one of the channels to be closed is to the serial port?[/INST]An UNLISTEN is sent to clear the output channel if one of the channels to be closed is to the serial port."
"[INST]In the context of the C64, how can multiple devices receive the same data from the Commodore 64 at the same time?[/INST]By not calling the CLRCHN routine and leaving listener(s) active on the serial bus, multiple devices can receive the same data from the Commodore 64 at the same time."
"[INST]In the context of the C64, what is an example of taking advantage of not calling the CLRCHN routine?[/INST]One way to take advantage of not calling the CLRCHN routine is to command the printer to TALK and the disk to LISTEN, allowing direct printing of a disk file."
"[INST]In the context of the C64, how is the CLRCHN routine typically called?[/INST]The CLRCHN routine is typically called using the JSR instruction, for example: JSR CLRCHN>"
"[INST]In the context of the C64, What is the first step in approaching a large task in machine language?[/INST]Write it out on paper and use block diagrams of memory usage, functional modules of code required, and a program flow."
"[INST]In the context of the C64, What is the purpose of writing down the task on paper?[/INST]To clarify the process and break it down into smaller, manageable parts."
"[INST]In the context of the C64, What is the benefit of breaking down a large task into smaller parts?[/INST]It makes the task seem less overwhelming and allows for a more focused approach."
"[INST]In the context of the C64, What is the main outline of a roulette game in machine language?[/INST]Display title, ask if player requires instructions, display roulette table, take in bets, spin wheel, check bets with result, inform player, and check if player has any money left."
"[INST]In the context of the C64, What is the importance of practice in approaching a large task?[/INST]It improves the process and helps to make the task seem less daunting."
"[INST]In the context of the C64, What is the key to breaking down a large indigestible problem?[/INST]To break it down into small enough pieces to be manageable."
"[INST]In the context of the C64, What is the result of approaching a large task in a step-by-step manner?[/INST]It allows the task to fall into place and become more manageable."
"[INST]In the context of the C64, What is the importance of persistence in approaching a large task?[/INST]It helps to improve the process and makes the task seem less overwhelming."
"[INST]In the context of the C64, What is the benefit of using block diagrams in approaching a large task?[/INST]It helps to clarify the process and make it more understandable."
"[INST]In the context of the C64, what is the purpose of the VIC-II control register at location 53276?[/INST]The VIC-II control register at location 53276 is used to switch a sprite into multi-color mode, by turning ON the corresponding bit for the desired sprite number (0 to 7), allowing the sprite to display multiple colors."
"[INST]In the context of the C64, how do you switch a sprite into multi-color mode?[/INST]To switch a sprite into multi-color mode, you need to turn ON the VIC-II control register at location 53276 by using the POKE command with the following syntax: POKE 53276,PEEK(53276)OR(2^SN), where SN is the sprite number (0 to 7)."
"[INST]In the context of the C64, what is the syntax to switch a sprite into multi-color mode?[/INST]The syntax to switch a sprite into multi-color mode is POKE 53276,PEEK(53276)OR(2^SN), where SN is the sprite number (0 to 7)."
"[INST]In the context of the C64, what is the purpose of the POKE command in switching a sprite into multi-color mode?[/INST]The POKE command is used to turn ON the corresponding bit for the desired sprite number (0 to 7) in the VIC-II control register at location 53276, allowing the sprite to display multiple colors."
"[INST]In the context of the C64, how do you switch a sprite out of multi-color mode?[/INST]To switch a sprite out of multi-color mode, you need to turn OFF the VIC-II control register at location 53276 by using the POKE command with the following syntax: POKE 53276,PEEK(53276)AND(255-2^SN), where SN is the sprite number (0 to 7)."
"[INST]In the context of the C64, what is the syntax to switch a sprite out of multi-color mode?[/INST]The syntax to switch a sprite out of multi-color mode is POKE 53276,PEEK(53276)AND(255-2^SN), where SN is the sprite number (0 to 7)."
"[INST]In the context of the C64, what is the purpose of the AND operator in switching a sprite out of multi-color mode?[/INST]The AND operator is used to turn OFF the corresponding bit for the desired sprite number (0 to 7) in the VIC-II control register at location 53276, removing the multi-color mode from the sprite."
"[INST]In the context of the C64, what is the purpose of the OR operator in switching a sprite into multi-color mode?[/INST]The OR operator is used to turn ON the corresponding bit for the desired sprite number (0 to 7) in the VIC-II control register at location 53276, enabling the multi-color mode for the sprite."
"[INST]In the context of the C64, what is the range of values for the sprite number (SN)?[/INST]The sprite number (SN) can take values from 0 to 7, representing the eight possible sprites that can be used in a Commodore 64 program."
"[INST]In the context of the C64, what is the significance of the location 53276 in the Commodore 64?[/INST]The location 53276 ($D01C) is a VIC-II control register that controls the multi-color mode for sprites in the Commodore 64."
"[INST]In the context of the C64, what is the instruction to call a subroutine in machine language?[/INST]The instruction to call a subroutine in machine language is JSR (Jump to Sub-Routine), followed by the specified absolute address."
"[INST]In the context of the C64, what is the address of the machine language subroutine that prints a character to the screen?[/INST]The address of the machine language subroutine that prints a character to the screen is $FFD2, and it requires the CBM ASCII code of the character to be in the accumulator before calling the subroutine."
"[INST]In the context of the C64, how do you load the CBM ASCII code of a character into the accumulator?[/INST]You load the CBM ASCII code of a character into the accumulator using the LDA instruction, for example, LDA #$48 loads the CBM ASCII code of 'H' into the accumulator."
"[INST]In the context of the C64, what is the purpose of the JSR $FFD2 instruction in the example program?[/INST]The purpose of the JSR $FFD2 instruction in the example program is to print the character in the accumulator to the screen, in this case, the characters 'H', 'I', and a carriage return."
"[INST]In the context of the C64, what is the purpose of the BRK instruction at the end of the example program?[/INST]The purpose of the BRK instruction at the end of the example program is to return to 64MON, which is a monitor program that allows you to interact with the computer."
"[INST]In the context of the C64, what is the purpose of the .G 1400 directive in the example program?[/INST]The purpose of the .G 1400 directive in the example program is to specify the starting address of the program, in this case, $1400, which is where the program will begin execution."
"[INST]In the context of the C64, how do you print a string of characters to the screen using the subroutine at $FFD2?[/INST]You print a string of characters to the screen using the subroutine at $FFD2 by loading the CBM ASCII code of each character into the accumulator and then calling the subroutine, for example, to print 'Hi', you would load the codes for 'H' and 'I' and call the subroutine twice."
"[INST]In the context of the C64, what is the advantage of using subroutines in machine language programming?[/INST]The advantage of using subroutines in machine language programming is that it allows you to reuse code and organize your program in a modular fashion, making it easier to write and maintain."
"[INST]In the context of the C64, how do you specify the address of a subroutine in machine language?[/INST]You specify the address of a subroutine in machine language by using the absolute address of the subroutine, for example, JSR $FFD2 specifies the address of the subroutine that prints a character to the screen."
"[INST]In the context of the C64, what is the relationship between the accumulator and the subroutine at $FFD2?[/INST]The accumulator must contain the CBM ASCII code of the character to be printed before calling the subroutine at $FFD2, which will then print the character to the screen."
"[INST]In the context of the C64, what is the location of the VIC-II control register to unexpand a sprite in the horizontal direction[/INST]53277"
"[INST]In the context of the C64, What is the operation to unexpand a sprite in the horizontal direction[/INST]POKE 53277,PEEK(53277)AND (255-2^SN)"
"[INST]In the context of the C64, To unexpand a sprite in the horizontal direction, the corresponding bit in the VIC-II control register at location 53277 ($D01D in HEX) must be turned OFF (set to a 0).[/INST]nan"
"[INST]In the context of the C64, What is the range of sprite numbers for unexpanding a sprite in the horizontal direction[/INST]0 to 7"
"[INST]In the context of the C64, To unexpand a sprite in the horizontal direction, the corresponding bit in the VIC-II control register at location 53277 ($D01D in HEX) must be turned OFF (set to a 0).[/INST]nan"
"[INST]In the context of the C64, What is the main difference between the 6566 and 6567 video interface chips?[/INST]The main difference between the 6566 and 6567 video interface chips lies in their address output configurations. The 6566 has thirteen fully decoded addresses for direct connection to the system address bus, whereas the 6567 has multiplexed addresses for direct connection to 64K dynamic RAMS."
"[INST]In the context of the C64, How do the 6566 and 6567 video interface chips differ in their address output configurations?[/INST]The 6566 has fully decoded addresses for direct connection to the system address bus, whereas the 6567 has multiplexed addresses for direct connection to 64K dynamic RAMS, with the least significant address bits, A06-A00, present on A06-A00 while /RAS is brought low, and the most significant bits, A13-A08, present on A05-A00 while /CAS is brought low."
"[INST]In the context of the C64, What is the purpose of pins A11-A07 on the 6567 video interface chip?[/INST]The pins A11-A07 on the 6567 video interface chip are static address outputs, allowing direct connection of these bits to a conventional 16K (2K*8) ROM."
"[INST]In the context of the C64, How does the 6567 video interface chip handle the lower order addresses?[/INST]The lower order addresses on the 6567 video interface chip require external latching."
"[INST]In the context of the C64, What is the significance of the /RAS signal in the 6567 video interface chip?[/INST]The /RAS signal is used to bring the least significant address bits, A06-A00, low, allowing them to be present on A06-A00."
"[INST]In the context of the C64, What is the significance of the /CAS signal in the 6567 video interface chip?[/INST]The /CAS signal is used to bring the most significant address bits, A13-A08, low, allowing them to be present on A05-A00."
"[INST]In the context of the C64, How does the 6567 video interface chip connect to a 64K dynamic RAM?[/INST]The 6567 video interface chip connects to a 64K dynamic RAM through its multiplexed addresses, with the least significant address bits, A06-A00, present on A06-A00 while /RAS is brought low, and the most significant bits, A13-A08, present on A05-A00 while /CAS is brought low."
"[INST]In the context of the C64, What is the advantage of using the 6567 video interface chip with a 64K dynamic RAM?[/INST]The advantage of using the 6567 video interface chip with a 64K dynamic RAM is that it allows for direct connection and efficient memory access, making it well-suited for applications that require large memory capacities."
"[INST]In the context of the C64, How does the 6566 video interface chip differ from the 6567 in terms of address decoding?[/INST]The 6566 video interface chip has fully decoded addresses, whereas the 6567 has multiplexed addresses, which affects how they connect to memory and other components."
"[INST]In the context of the C64, What is the significance of the address bus in the context of the 6566 and 6567 video interface chips?[/INST]The address bus is significant in the context of the 6566 and 6567 video interface chips because it determines how they connect to memory and other components, with the 6566 having fully decoded addresses and the 6567 having multiplexed addresses."
"[INST]In the context of the C64, what is the purpose of the OPEN statement in BASIC?[/INST]The OPEN statement in BASIC creates a channel to talk to a device other than the screen, such as a cassette deck, printer, disk drive, or modem, allowing the program to send output to that device."
"[INST]In the context of the C64, how do you send characters to a device after opening a channel?[/INST]Once the channel is OPEN, the PRINT# statement is used to send characters to that device, where the number sign (#) is replaced with the channel number specified in the OPEN statement."
"[INST]In the context of the C64, what is the format of the OPEN statement for a printer?[/INST]The format of the OPEN statement for a printer is OPEN file number, device number, for example, OPEN 4,4, as shown in the example: 100 OPEN 4,4: PRINT# 4, 'WRITING ON PRINTER'."
"[INST]In the context of the C64, what is the purpose of the PRINT# statement?[/INST]The PRINT# statement is used to send characters to a device after a channel has been opened with the OPEN statement, allowing the program to output data to devices other than the screen."
"[INST]In the context of the C64, how do you specify a file name when opening a disk file?[/INST]When opening a disk file, the file name is specified as a string in the OPEN statement, for example, OPEN 3,8,3,'0:DISK-FILE,S,W', as shown in the example: 110 OPEN 3,8,3,'0:DISK-FILE,S,W':PRINT#3,'SEND TO DISK'."
"[INST]In the context of the C64, what is the format of the OPEN statement for a cassette tape?[/INST]The format of the OPEN statement for a cassette tape is OPEN file number, device number, file name, for example, OPEN 1,1,1,'TAPE-FILE', as shown in the example: 120 OPEN 1,1,1,'TAPE-FILE': PRINT#1,'WRITE ON TAPE'."
"[INST]In the context of the C64, how do you send data to a modem?[/INST]To send data to a modem, you use the OPEN statement to open a channel to the modem, and then use the PRINT# statement to send the data, for example, OPEN 2,2,0,CHR$(10):PRINT#2,'SEND TO MODEM'."
"[INST]In the context of the C64, what are the parameters of the OPEN statement for each device?[/INST]The parameters of the OPEN statement vary for each device, and are shown in the table below for each device, including the file number, device number, and file name or other parameters specific to each device."
"[INST]In the context of the C64, can you use the OPEN statement to send output to multiple devices?[/INST]Yes, you can use the OPEN statement to send output to multiple devices by opening multiple channels, each with a unique file number, and then using the PRINT# statement to send data to each device."
"[INST]In the context of the C64, what is the difference between the OPEN statement and the PRINT# statement?[/INST]The OPEN statement is used to create a channel to a device, while the PRINT# statement is used to send characters to that device after the channel has been opened."
"[INST]In the context of the C64, What is the purpose of the data bus pins?[/INST]The eight data bus pins are the bidirectional data port, controlled by /CS, RW, and Phase 0."
"[INST]In the context of the C64, What is the condition for accessing the data bus?[/INST]The data bus can only be accessed while AEC and Phase 0 are high and /CS is low."
"[INST]In the context of the C64, What is the function of the /CS pin?[/INST]The chip select pin, /CS, is brought low to enable access to the device registers in conjunction with the address and RW pins."
"[INST]In the context of the C64, What happens when /CS is low?[/INST]/CS low is recognized only while AEC and Phase 0 are high."
"[INST]In the context of the C64, What is the condition for recognizing /CS low?[/INST]Only while AEC and Phase 0 are high."
"[INST]In the context of the C64, What is the purpose of Phase 0?[/INST]The data bus can only be accessed while AEC and Phase 0 are high and /CS is low."
"[INST]In the context of the C64, What is the purpose of AEC?[/INST]The data bus can only be accessed while AEC and Phase 0 are high and /CS is low."
"[INST]In the context of the C64, What is the condition for accessing the device registers?[/INST]The chip select pin, /CS, is brought low to enable access to the device registers in conjunction with the address and RW pins."
"[INST]In the context of the C64, What is the SID chip compatible with?[/INST]65XX and similar microprocessor families"
"[INST]In the context of the C64, What is the SID chip used for?[/INST]Electronic music synthesizer/sound effects generator"
"[INST]In the context of the C64, How many tone oscillators does the SID chip have?[/INST]3"
"[INST]In the context of the C64, What is the range of the SID chip's pitch control?[/INST]0-4 kHz"
"[INST]In the context of the C64, What are the four waveforms available per oscillator?[/INST]Triangle, Sawtooth, Variable Pulse, Noise"
"[INST]In the context of the C64, How many amplitude modulators does the SID chip have?[/INST]3"
"[INST]In the context of the C64, What is the range of the SID chip's amplitude modulation?[/INST]48 dB"
"[INST]In the context of the C64, What are the three envelope generators used for?[/INST]Attack, Decay, Sustain"
"[INST]In the context of the C64, What is the range of the SID chip's cutoff frequency?[/INST]30 Hz-12 kHz"
"[INST]In the context of the C64, What is the purpose of the SID chip's ring modulation feature?[/INST]To create unique sounds"
"[INST]In the context of the C64, what is the purpose of the SERIAL SRQ IN signal on the Commodore 64?[/INST]The SERIAL SRQ IN signal is used by devices on the serial bus to request attention from the Commodore 64, allowing the computer to take care of the device when it requires service or attention."
"[INST]In the context of the C64, what happens when a device on the serial bus brings the SERIAL SRQ IN signal LOW?[/INST]When a device on the serial bus brings the SERIAL SRQ IN signal LOW, it is indicating to the Commodore 64 that it requires attention or service, and the computer will take care of the device accordingly."
"[INST]In the context of the C64, what is the role of the Commodore 64 in response to the SERIAL SRQ IN signal?[/INST]The Commodore 64 takes care of the device that brought the SERIAL SRQ IN signal LOW, providing the necessary service or attention required by the device."
"[INST]In the context of the C64, in what scenario would a device on the serial bus bring the SERIAL SRQ IN signal LOW?[/INST]A device on the serial bus would bring the SERIAL SRQ IN signal LOW when it requires attention or service from the Commodore 64, such as when it needs to transfer data or receive instructions."
"[INST]In the context of the C64, what is the relationship between the SERIAL SRQ IN signal and the Commodore 64?[/INST]The SERIAL SRQ IN signal is used by devices on the serial bus to communicate with the Commodore 64, allowing the computer to provide service or attention to the device as needed."
"[INST]In the context of the C64, what is the significance of the SERIAL SRQ IN signal in the context of the Commodore 64?[/INST]The SERIAL SRQ IN signal is significant because it enables devices on the serial bus to request attention from the Commodore 64, allowing for efficient communication and data transfer between devices."
"[INST]In the context of the C64, how does the Commodore 64 respond to the SERIAL SRQ IN signal?[/INST]The Commodore 64 responds to the SERIAL SRQ IN signal by taking care of the device that brought the signal LOW, providing the necessary service or attention required by the device."
"[INST]In the context of the C64, what is the purpose of Figure 6-4 in the context of the SERIAL SRQ IN signal?[/INST]Figure 6-4 is likely a diagram or illustration that shows the relationship between the SERIAL SRQ IN signal and the Commodore 64, providing a visual representation of how the signal is used to request attention from the computer."
"[INST]In the context of the C64, in what way does the SERIAL SRQ IN signal facilitate communication between devices on the serial bus?[/INST]The SERIAL SRQ IN signal facilitates communication between devices on the serial bus by allowing them to request attention from the Commodore 64, enabling the computer to provide service or attention as needed."
"[INST]In the context of the C64, what is the benefit of using the SERIAL SRQ IN signal on the Commodore 64?[/INST]The benefit of using the SERIAL SRQ IN signal is that it enables efficient communication and data transfer between devices on the serial bus, allowing the Commodore 64 to provide timely and effective service or attention to devices as needed."
"[INST]In the context of the C64, Where is color memory located in the Commodore 64?[/INST]Color memory is located at fixed locations 55296 ($D800) through 56295 ($DBE7) and cannot be moved."
"[INST]In the context of the C64, What is the relationship between color memory and screen memory in the Commodore 64?[/INST]Color memory and screen memory are used differently in different graphics modes, and a picture created in one mode may look completely different when displayed in another mode."
"[INST]In the context of the C64, What happens when a picture is displayed in a different graphics mode on the Commodore 64?[/INST]When a picture is displayed in a different graphics mode, it may look completely different due to the different usage of color memory and screen memory in each mode."
"[INST]In the context of the C64, What is the starting location of screen memory in the Commodore 64?[/INST]Screen memory starts at location 1024 and spans 1000 locations."
"[INST]In the context of the C64, Can color memory be relocated to a different location in the Commodore 64?[/INST]No, color memory is fixed and cannot be moved to a different location, it is always located at locations 55296 ($D800) through 56295 ($DBE7)."
"[INST]In the context of the C64, What is the range of locations that color memory occupies in the Commodore 64?[/INST]Color memory occupies locations 55296 ($D800) through 56295 ($DBE7), a total of 1024 locations."
"[INST]In the context of the C64, How do different graphics modes affect the display of a picture on the Commodore 64?[/INST]Different graphics modes use color memory and screen memory differently, resulting in a picture looking completely different when displayed in a different mode."
"[INST]In the context of the C64, What is the significance of locations 55296 ($D800) through 56295 ($DBE7) in the Commodore 64?[/INST]These locations are reserved for color memory, which is used to store color information for graphics modes."
"[INST]In the context of the C64, Can a picture created in one graphics mode be directly displayed in another mode without modifications?[/INST]No, a picture created in one mode may need modifications to be displayed correctly in another mode due to the different usage of color memory and screen memory."
"[INST]In the context of the C64, Why do pictures look different when displayed in different graphics modes on the Commodore 64?[/INST]Pictures look different because color memory and screen memory are used differently in each graphics mode, resulting in a different display of the picture."
"[INST]In the context of the C64, what is the number of game ports on the Commodore 64[/INST]two 9-pin Game Ports"
"[INST]In the context of the C64, what can be connected to the game ports[/INST]joysticks, paddles, or a light pen"
"[INST]In the context of the C64, in which port can a light pen be plugged[/INST]Port A"
"[INST]In the context of the C64, what is the function of CIA #1[/INST]handles joystick and paddle fire buttons and keyboard scanning"
"[INST]In the context of the C64, how many registers does the 6526 CIA chip have[/INST]16"
"[INST]In the context of the C64, in which memory locations are the registers of the 6526 CIA chip found[/INST]56320 through 56335 inclusive ($DC00 to $DC0F)"
"[INST]In the context of the C64, where is Port A data found[/INST]location 56320 (DC00)"
"[INST]In the context of the C64, where is Port B data found[/INST]location 56321 ($DC01)"
"[INST]In the context of the C64, how many distinct switches does a digital joystick have[/INST]five"
"[INST]In the context of the C64, what is the function of the fifth switch on a digital joystick[/INST]fire button"
"[INST]In the context of the C64, in which bit is the fire button status stored[/INST]bit 4"
"[INST]In the context of the C64, what is the value of the bit when the fire button is pressed[/INST]0"
"[INST]In the context of the C64, what is the value of the bit when the fire button is not pressed[/INST]1"
"[INST]In the context of the C64, what is the purpose of the subroutine in the provided BASIC code[/INST]to read the joystick"
"[INST]In the context of the C64, in which line of the BASIC code is the joystick value retrieved[/INST]100"
"[INST]In the context of the C64, what is the purpose of the line 'fr=jvand16' in the BASIC code[/INST]to form fire button status"
"[INST]In the context of the C64, what is the purpose of the line 'jv=15-(jvand15)' in the BASIC code[/INST]to form direction value"
"[INST]In the context of the C64, what is the value of JV when no direction is chosen[/INST]0"
"[INST]In the context of the C64, what is the value of JV when the UP direction is chosen[/INST]1"
"[INST]In the context of the C64, what is the value of JV when the DOWN direction is chosen[/INST]2"
"[INST]In the context of the C64, what is the value of JV when the LEFT direction is chosen[/INST]4"
"[INST]In the context of the C64, what is the value of JV when the UP & LEFT direction is chosen[/INST]5"
"[INST]In the context of the C64, what is the value of JV when the DOWN & LEFT direction is chosen[/INST]6"
"[INST]In the context of the C64, what is the value of JV when the RIGHT direction is chosen[/INST]8"
"[INST]In the context of the C64, what is the value of JV when the UP & RIGHT direction is chosen[/INST]9"
"[INST]In the context of the C64, what is the value of JV when the DOWN & RIGHT direction is chosen[/INST]10"
"[INST]In the context of the C64, what is the purpose of the modem in computer communication[/INST]The modem is a simple device that can translate character codes into audio pulses and vice-versa, so that computers can communicate over telephone lines."
"[INST]In the context of the C64, what are the parameters set by the OPEN statement for the modem[/INST]The OPEN statement for the modem sets up the parameters to match the speed and format of the other computer you are communicating with, specifically the baud rate, number of data bits, and number of stop bits."
"[INST]In the context of the C64, what is the significance of the first character code in the OPEN statement[/INST]The bit positions of the first character code determine the baud rate, number of data bits, and number of stop bits."
"[INST]In the context of the C64, what is the purpose of the second character code in the OPEN statement[/INST]The second code is optional, and its bits specify the parity and duplex of the transmission."
"[INST]In the context of the C64, what is the format of the OPEN statement for modem communication[/INST]The format of the OPEN statement for modem communication is OPEN 1,2,0,CHR$(6) for 300 baud, and OPEN 2,2,0,CHR$(163) CHR$(112) for 110 baud, etc."
"[INST]In the context of the C64, what is the standard set of character codes used by most computers[/INST]Most computers use the American Standard Code for Information Interchange, known as ASCII (pronounced ASK-KEY)."
"[INST]In the context of the C64, what is the difference between Commodore 64 character codes and ASCII codes[/INST]The Commodore character codes must be translated into their ASCII counterparts when communicating with other computers."
"[INST]In the context of the C64, what is the importance of character translation in modem communication[/INST]Character translation is necessary because the Commodore character codes must be translated into their ASCII counterparts when communicating with other computers."
"[INST]In the context of the C64, what is the challenge in writing programs that communicate with other computers[/INST]The challenge is to carefully count the number of characters and RETURN characters, otherwise the computer receiving the characters won't know what to do with them."
"[INST]In the context of the C64, what is an example of a program that communicates with another computer without human intervention[/INST]An example is a terminal program that automatically types in your account number and secret password."
"[INST]In the context of the C64, What is the opcode for the ADC instruction in immediate addressing mode?[/INST]The opcode for the ADC instruction in immediate addressing mode is 69."
"[INST]In the context of the C64, What is the number of bytes required for the ADC instruction in zero page addressing mode?[/INST]The number of bytes required for the ADC instruction in zero page addressing mode is 2."
"[INST]In the context of the C64, How many cycles does the ADC instruction take in absolute addressing mode?[/INST]The ADC instruction takes 4 cycles in absolute addressing mode."
"[INST]In the context of the C64, What is the opcode for the ADC instruction in zero page addressing mode?[/INST]The opcode for the ADC instruction in zero page addressing mode is 65."
"[INST]In the context of the C64, How does the ADC instruction behave when the page boundary is crossed in absolute,X addressing mode?[/INST]When the page boundary is crossed in absolute,X addressing mode, the ADC instruction takes an additional cycle, making it a total of 5 cycles."
"[INST]In the context of the C64, What is the difference in the number of bytes required for the ADC instruction in immediate and zero page addressing modes?[/INST]The ADC instruction requires 2 bytes in both immediate and zero page addressing modes, so there is no difference."
"[INST]In the context of the C64, In which addressing modes does the ADC instruction require 3 bytes?[/INST]The ADC instruction requires 3 bytes in absolute and absolute,X addressing modes."
"[INST]In the context of the C64, What is the opcode for the ADC instruction in (indirect,X) addressing mode?[/INST]The opcode for the ADC instruction in (indirect,X) addressing mode is 61."
"[INST]In the context of the C64, How many cycles does the ADC instruction take in (indirect),Y addressing mode?[/INST]The ADC instruction takes 5 cycles in (indirect),Y addressing mode, but an additional cycle is added if the page boundary is crossed."
"[INST]In the context of the C64, What is the opcode for the ADC instruction in absolute,Y addressing mode?[/INST]The opcode for the ADC instruction in absolute,Y addressing mode is 79."
"[INST]In the context of the C64, what is the opcode for STX in zero page addressing mode?[/INST]The opcode for STX in zero page addressing mode is 86, which requires 2 bytes and 3 cycles to execute."
"[INST]In the context of the C64, what is the difference in cycles between STX in zero page and absolute addressing modes?[/INST]The difference in cycles between STX in zero page and absolute addressing modes is 0, as both modes require 4 cycles to execute."
"[INST]In the context of the C64, what is the assembly language form for STX in zero page,Y addressing mode?[/INST]The assembly language form for STX in zero page,Y addressing mode is STX Oper,Y, where Oper is the zero page address and Y is the index register."
"[INST]In the context of the C64, what is the number of bytes required for STX in absolute addressing mode?[/INST]The number of bytes required for STX in absolute addressing mode is 3, which includes the opcode and the 2-byte absolute address."
"[INST]In the context of the C64, how does the number of cycles change when using STX in zero page,Y addressing mode compared to zero page mode?[/INST]When using STX in zero page,Y addressing mode, the number of cycles increases by 1, from 3 cycles in zero page mode to 4 cycles in zero page,Y mode."
"[INST]In the context of the C64, what is the purpose of the STX instruction?[/INST]The purpose of the STX instruction is to store the value of index register X in memory at the specified address."
"[INST]In the context of the C64, in which addressing modes can the STX instruction be used?[/INST]The STX instruction can be used in zero page, zero page,Y, and absolute addressing modes."
"[INST]In the context of the C64, what is the opcode for STX in absolute addressing mode?[/INST]The opcode for STX in absolute addressing mode is 8E, which requires 3 bytes and 4 cycles to execute."
"[INST]In the context of the C64, how does the number of bytes change when using STX in absolute addressing mode compared to zero page mode?[/INST]When using STX in absolute addressing mode, the number of bytes increases by 1, from 2 bytes in zero page mode to 3 bytes in absolute mode."
"[INST]In the context of the C64, what is the difference in bytes between STX in zero page and zero page,Y addressing modes?[/INST]The difference in bytes between STX in zero page and zero page,Y addressing modes is 0, as both modes require 2 bytes to execute."
"[INST]In the context of the C64, what are the limitations of color tv sets when it comes to placing certain colors next to each other on the same line?[/INST]Color TV sets are limited in their ability to place certain colors next to each other on the same line, certain combinations of screen and character colors produce blurred images."
"[INST]In the context of the C64, what is the purpose of the chart provided in the suggested screen and character color combinations?[/INST]The chart shows which color combinations to avoid, and which work especially well together, helping programmers to choose the right color combinations for their graphics."
"[INST]In the context of the C64, what is the focus of the programming sprites section?[/INST]The programming sprites section is designed as a more elementary tutorial approach to sprites, helping those who are having trouble with graphics."
"[INST]In the context of the C64, why is it important to choose the right color combinations for graphics?[/INST]Choosing the right color combinations is important because certain combinations can produce blurred images, and the right combinations can make graphics clear and visually appealing."
"[INST]In the context of the C64, what is the relationship between screen and character colors?[/INST]The screen and character colors are related in that certain combinations of the two can produce blurred images, while other combinations work well together, making it important to choose the right combination for clear graphics."
"[INST]In the context of the C64, what is the main goal of the suggested screen and character color combinations?[/INST]The main goal is to provide a guide for programmers to choose the right color combinations that work well together and avoid those that produce blurred images."
"[INST]In the context of the C64, what is the target audience of the programming sprites section?[/INST]The target audience is those who are having trouble with graphics and need a more elementary tutorial approach to sprites."
"[INST]In the context of the C64, what is the benefit of using the suggested screen and character color combinations?[/INST]The benefit is that it helps programmers to create clear and visually appealing graphics, avoiding blurred images and producing high-quality visuals."
"[INST]In the context of the C64, how does the chart provided help programmers?[/INST]The chart helps programmers by showing which color combinations to avoid and which work especially well together, making it easier to choose the right colors for their graphics."
"[INST]In the context of the C64, what is the approach of the programming sprites section?[/INST]The approach is a more elementary tutorial approach to sprites, designed to help those who are having trouble with graphics."
"[INST]In the context of the C64, Can the 6566/6567 registers be accessed like other peripheral devices?[/INST]The 6566/6567 registers can be accessed similar to any other peripheral device."
"[INST]In the context of the C64, Are there special memory accesses for the 6566/6567 registers?[/INST]Aside from the special memory accesses described above, the 6566/6567 registers can be accessed similar to any other peripheral device."
"[INST]In the context of the C64, What signals are provided for the processor interface?[/INST]The following processor interface signals are provided:"
"[INST]In the context of the C64, Can the 6566/6567 registers be accessed like other peripheral devices?[/INST]The 6566/6567 registers can be accessed similar to any other peripheral device."
"[INST]In the context of the C64, Are the 6566/6567 registers accessed like other peripheral devices?[/INST]The 6566/6567 registers can be accessed similar to any other peripheral device."
"[INST]In the context of the C64, What is accessed similar to any other peripheral device?[/INST]The 6566/6567 registers can be accessed similar to any other peripheral device."
"[INST]In the context of the C64, Are there special memory accesses for the 6566/6567 registers?[/INST]Aside from the special memory accesses described above, the 6566/6567 registers can be accessed similar to any other peripheral device."
"[INST]In the context of the C64, What is provided for the processor interface?[/INST]The following processor interface signals are provided:"
"[INST]In the context of the C64, Can the 6566/6567 registers be accessed like other peripheral devices?[/INST]The 6566/6567 registers can be accessed similar to any other peripheral device."
"[INST]In the context of the C64, Are the 6566/6567 registers accessed like other peripheral devices?[/INST]The 6566/6567 registers can be accessed similar to any other peripheral device."
"[INST]In the context of the C64, What signals are provided for the processor interface?[/INST]The following processor interface signals are provided:"
"[INST]In the context of the C64, what is the purpose of setting the ECM bit of register 17 to 1?[/INST]The purpose of setting the ECM bit of register 17 to 1 is to select the extended color mode, which allows the selection of individual background colors for each character region with the normal 8*8 character resolution."
"[INST]In the context of the C64, How does the character dot data display in extended color mode?[/INST]In extended color mode, the character dot data is displayed as in the standard mode, where the foreground color determined by the color nybble is displayed for a '1' data bit."
"[INST]In the context of the C64, What is the role of the 2 MSB of the character pointer in extended color mode?[/INST]The 2 MSB of the character pointer are used to select the background color for each character region, where 00 corresponds to background #0 color, 01 corresponds to background #1 color, 10 corresponds to background #2 color, and 11 corresponds to background #3 color."
"[INST]In the context of the C64, What are the register addresses for the background color registers in extended color mode?[/INST]The register addresses for the background color registers in extended color mode are register 33 ($21) for background #0 color, register 34 ($22) for background #1 color, register 35 ($23) for background #2 color, and register 36 ($24) for background #3 color."
"[INST]In the context of the C64, How many different character definitions are available in extended color mode?[/INST]Only 64 different character definitions are available in extended color mode, since the two MSB of the character pointers are used for color information."
"[INST]In the context of the C64, Why are only the first 64 character definitions accessed in extended color mode?[/INST]The 6566/6567 will force CB10 and CB9 to '0' regardless of the original pointer values, so that only the first 64 character definitions will be accessed in extended color mode."
"[INST]In the context of the C64, What is the limitation of using extended color mode?[/INST]The limitation of using extended color mode is that it should not be enabled simultaneously with multi-color mode."
"[INST]In the context of the C64, How many foreground colors are available for each character in extended color mode?[/INST]Each character has one of sixteen individually defined foreground colors in extended color mode."
"[INST]In the context of the C64, How many background colors are available for each character in extended color mode?[/INST]Each character has one of the four available background colors in extended color mode."
"[INST]In the context of the C64, What is the significance of the MSB of the character pointer in extended color mode?[/INST]The MSB of the character pointer is used to select the background color for each character region in extended color mode."
"[INST]In the context of the C64, Where are the 6510 Registers located in the Commodore 64 memory map?[/INST]The 6510 Registers are located at addresses 0 and 1 in the Commodore 64 memory map."
"[INST]In the context of the C64, What is the purpose of the memory block from address 2 to 1023 in the Commodore 64?[/INST]The memory block from address 2 to 1023 is used by the operating system."
"[INST]In the context of the C64, What is stored in the memory block from address 1024 to 2039 in the Commodore 64?[/INST]The memory block from address 1024 to 2039 is used for screen memory."
"[INST]In the context of the C64, What is the purpose of the memory block from address 2040 to 2047 in the Commodore 64?[/INST]The memory block from address 2040 to 2047 is used for sprite pointers."
"[INST]In the context of the C64, Where is the user's program stored in the Commodore 64 memory map?[/INST]The user's program, whether it's a BASIC or machine language program, is stored in the memory block from address 2048 to 40959."
"[INST]In the context of the C64, What is the purpose of the memory block from address 40960 to 49151 in the Commodore 64?[/INST]The memory block from address 40960 to 49151 is used for the 8K CBM BASIC Interpreter."
"[INST]In the context of the C64, What is the purpose of the memory block from address 49152 to 53247 in the Commodore 64?[/INST]The memory block from address 49152 to 53247 is used for special programs RAM area."
"[INST]In the context of the C64, What is the purpose of the memory block from address 53248 to 53294 in the Commodore 64?[/INST]The memory block from address 53248 to 53294 is used for the VIC-II chip."
"[INST]In the context of the C64, What is the purpose of the memory block from address 55296 to 56296 in the Commodore 64?[/INST]The memory block from address 55296 to 56296 is used for Color RAM."
"[INST]In the context of the C64, What is the purpose of the memory block from address 56320 to 57343 in the Commodore 64?[/INST]The memory block from address 56320 to 57343 is used for I/O Registers, specifically the 6526 chip."
"[INST]In the context of the C64, Can a sprite be unexpanded in the vertical direction?[/INST]To unexpand a sprite in the vertical direction, the corresponding bit in the VIC-II control register at location 53271 ($D017 in HEX) must be turned OFF (set to a 0)."
"[INST]In the context of the C64, What is the location of the VIC-II control register?[/INST]$D017 in HEX"
"[INST]In the context of the C64, What is the condition to unexpand a sprite in the vertical direction?[/INST]The corresponding bit in the VIC-II control register at location 53271 ($D017 in HEX) must be turned OFF (set to a 0)."
"[INST]In the context of the C64, What is the effect of POKE 53271,PEEK(53271)AND (255-2^SN) on a sprite?[/INST]The following POKE 'unexpands' a sprite in the Y direction:"
"[INST]In the context of the C64, What is the purpose of POKE 53271,PEEK(53271)AND (255-2^SN)?[/INST]'unexpands' a sprite in the Y direction"
"[INST]In the context of the C64, What is the range of sprite numbers?[/INST]from 0 to 7"
"[INST]In the context of the C64, What is the condition for a sprite to be unexpanded in the vertical direction?[/INST]The corresponding bit in the VIC-II control register at location 53271 ($D017 in HEX) must be turned OFF (set to a 0)."
"[INST]In the context of the C64, What is the location of the sprite number?[/INST]from 0 to 7"
"[INST]In the context of the C64, What is the effect of turning OFF the corresponding bit in the VIC-II control register?[/INST]To unexpand a sprite in the vertical direction"
"[INST]In the context of the C64, What is the purpose of the POKE command?[/INST]'unexpands' a sprite in the Y direction"
"[INST]In the context of the C64, What is the default mode of the Commodore 64 when it is first turned on?[/INST]Standard character mode"
"[INST]In the context of the C64, What is the purpose of defining new character shapes in RAM?[/INST]To display special graphics characters"
"[INST]In the context of the C64, What chip is responsible for accessing screen memory and color memory?[/INST]VIC-II"
"[INST]In the context of the C64, What is the purpose of the VIC-II chip in displaying characters on the screen?[/INST]To determine the character code and color"
"[INST]In the context of the C64, What is the starting address of the 8-byte block holding the character pattern?[/INST]Translated by the VIC-II chip"
"[INST]In the context of the C64, What is the formula for calculating the character address?[/INST]SCREEN CODE*8+(CHARACTER SET*2048)+(BANK*16384)"
"[INST]In the context of the C64, What is the purpose of the Bank Select Bits in calculating the character address?[/INST]To take into account the base address"
"[INST]In the context of the C64, What is the typical use of the POKE command in character mode?[/INST]To set the character code in screen memory"
"[INST]In the context of the C64, What is the typical location of the 8-byte block holding the character pattern?[/INST]In character memory"
"[INST]In the context of the C64, what is the purpose of the AEC signal in the 6566/6567 video controller devices?[/INST]The AEC signal is used to disable the processor address bus drivers allowing the video device to access the address bus."
"[INST]In the context of the C64, what is the frequency of the clock provided by the video chips?[/INST]The video chips provide a 1-MHz clock."
"[INST]In the context of the C64, what is the duration of a memory cycle in the 6566/6567 video controller devices?[/INST]A memory cycle is 500 ns including address setup, data access and, data setup to the reading device."
"[INST]In the context of the C64, what is the purpose of the BA signal in the 6566/6567 video controller devices?[/INST]The BA signal is used to indicate that the video chip will require a Phase 2 data access."
"[INST]In the context of the C64, how many Phase-2 times are allowed after BA low for the processor to complete any current memory accesses?[/INST]Three Phase-2 times are allowed after BA low for the processor to complete any current memory accesses."
"[INST]In the context of the C64, what happens on the fourth Phase 2 after BA low?[/INST]On the fourth Phase 2 after BA low, the AEC signal will remain low during Phase 2 as the video chip fetches data."
"[INST]In the context of the C64, what is the purpose of the character pointer fetches in the 6566/6567 video controller devices?[/INST]The character pointer fetches occur every eighth raster line during the display window and require 40 consecutive Phase 2 accesses to fetch the video matrix pointers."
"[INST]In the context of the C64, how many memory accesses are required for sprite data fetches?[/INST]The sprite data fetches require 4 memory accesses."
"[INST]In the context of the C64, what is the condition for sprite Byte 1 fetch?[/INST]The sprite Byte 1 is fetched in Phase 2, each raster while sprite is displayed."
"[INST]In the context of the C64, what is the condition for sprite Byte 2 fetch?[/INST]The sprite Byte 2 is fetched in Phase 1, each raster while sprite is displayed."
"[INST]In the context of the C64, what is the condition for sprite Byte 3 fetch?[/INST]The sprite Byte 3 is fetched in Phase 2, each raster while sprite is displayed."
"[INST]In the context of the C64, when are sprite pointers fetched?[/INST]The sprite pointers are fetched every other Phase 1 at the end of each raster line."
"[INST]In the context of the C64, what is the purpose of the bus sharing"" in the 6566/6567 video controller devices?""[/INST]The bus sharing"" allows the video device to access the address bus without affecting the processor operation."""
"[INST]In the context of the C64, what is the advantage of the bus sharing"" in the 6566/6567 video controller devices?""[/INST]The bus sharing"" allows operations such as character data fetches and memory refresh to be totally transparent to the processor and do not reduce the processor throughput."""
"[INST]In the context of the C64, what is the function of the 6566/6567 video controller devices in the system?[/INST]The 6566/6567 video controller devices interact with the system data bus in a special way, allowing the video device to access the address bus without affecting the processor operation."
"[INST]In the context of the C64, what is the role of the video chips in the system?[/INST]The video chips provide the interface control signals required to maintain the bus sharing."
"[INST]In the context of the C64, what is the purpose of the Phase 1 and Phase 2 clock cycles in the 6566/6567 video controller devices?[/INST]The Phase 1 and Phase 2 clock cycles are used to access the system memory and maintain the bus sharing."
"[INST]In the context of the C64, what is the relationship between the 6566/6567 video controller devices and the 65XX system?[/INST]The 6566/6567 video controller devices are designed to work with the 65XX system, using the system buses only during the Phase 2 (clock high) portion of the cycle."
"[INST]In the context of the C64, what is the benefit of using the 6566/6567 video controller devices in the 65XX system?[/INST]The use of the 6566/6567 video controller devices in the 65XX system allows for efficient use of the system buses and minimizes the impact on the processor throughput."
"[INST]In the context of the C64, how do the 6566/6567 video controller devices access the system memory?[/INST]The 6566/6567 video controller devices access the system memory during the Phase 1 (clock low) portion of the clock cycle."
"[INST]In the context of the C64, what is the purpose of the RDY input of a 65XX processor?[/INST]The RDY input of a 65XX processor is connected to the BA line, which indicates that the video chip will require a Phase 2 data access."
"[INST]In the context of the C64, what is the function of the BA line in the 6566/6567 video controller devices?[/INST]The BA line is used to indicate that the video chip will require a Phase 2 data access."
"[INST]In the context of the C64, what is the purpose of the sprite data fetches in the 6566/6567 video controller devices?[/INST]The sprite data fetches are used to retrieve sprite data from the system memory."
"[INST]In the context of the C64, how many sprite data fetches are required?[/INST]Four sprite data fetches are required."
"[INST]In the context of the C64, what is the condition for sprite data fetches?[/INST]The sprite data fetches occur every raster while the sprite is displayed."
"[INST]In the context of the C64, Look at other peoples' machine language programs to learn[/INST]One of the best ways to learn machine language is to look at other peoples' machine language programs."
"[INST]In the context of the C64, Write your own machine language program[/INST]Having looked at other machine language programs, you MUST write your own."
"[INST]In the context of the C64, Use utilities to aid in writing machine language programs[/INST]You should also use the utilities that are available, either IN your computer, or in a program, that aid you in writing, editing, or tracking down errors in a machine language program."
"[INST]In the context of the C64, What are the advantages of writing programs in machine language[/INST]Advantages of writing programs in machine language: Speed - Machine language is hundreds, and in some cases thousands of times faster than a high level language such as BASIC."
"[INST]In the context of the C64, Can machine language programs be made totally 'watertight'[/INST]A machine language program can be made totally 'watertight,' i.e., the user can be made to do ONLY what the program allows, and no more."
"[INST]In the context of the C64, What is the KERNAL[/INST]The KERNAL is an example of a utility that allows you to check the keyboard, print text, control peripheral devices like disk drives, printers, modems, etc., manage memory and the screen."
"[INST]In the context of the C64, Why is machine language faster than high level languages[/INST]Machine language is hundreds, and in some cases thousands of times faster than a high level language such as BASIC."
"[INST]In the context of the C64, What is the importance of machine language programming[/INST]In essence, the computer can only be maximized by the machine language programmer."
"[INST]In the context of the C64, Can machine language programs crash the BASIC interpreter[/INST]With a high level language, you are relying on the user not 'crashing' the BASIC interpreter by entering, for example, a zero which later causes a: ?DIVISION BY ZERO ERROR IN LINE 830"
"[INST]In the context of the C64, Indexing plays an important part in the running of which microprocessor?[/INST]6510"
"[INST]In the context of the C64, What is indexing defined as in the context of the 6510 microprocessor?[/INST]creating an actual address from a base address plus the contents of either the X or Y index registers"
"[INST]In the context of the C64, What is the purpose of the X or Y index registers in indexing?[/INST]to create an actual address"
"[INST]In the context of the C64, What is the mnemonic format of an absolute indexed instruction?[/INST]the same as an absolute instruction except a ',X' or ',Y' denoting the index is added to the address"
"[INST]In the context of the C64, What is the result of executing an LDA instruction in the absolute X indexed mode?[/INST]the actual location that is loaded into the A register"
"[INST]In the context of the C64, What are the different modes of addressing available on the 6510 microprocessor?[/INST]absolute indexed, zero page indexed, indirect indexed, and indexed indirect"
"[INST]In the context of the C64, What is the purpose of the ',X' or ',Y' in an absolute indexed instruction?[/INST]to denote the index"
"[INST]In the context of the C64, What is the result of executing an LDA instruction in the indirect indexed mode?[/INST]the actual location that is loaded into the A register"
"[INST]In the context of the C64, what is the opcode for ROR instruction in accumulator mode?[/INST]The opcode for ROR instruction in accumulator mode is 6A, which requires 1 byte and 2 cycles to execute."
"[INST]In the context of the C64, what is the addressing mode for ROR Oper,X instruction?[/INST]The addressing mode for ROR Oper,X instruction is Zero Page,X, which requires 2 bytes and 6 cycles to execute."
"[INST]In the context of the C64, what is the opcode for ROR instruction in zero page mode?[/INST]The opcode for ROR instruction in zero page mode is 66, which requires 2 bytes and 5 cycles to execute."
"[INST]In the context of the C64, in which microprocessors is the ROR instruction available?[/INST]The ROR instruction is available on MCS650X microprocessors manufactured after June, 1976."
"[INST]In the context of the C64, what is the opcode for ROR instruction in absolute mode?[/INST]The opcode for ROR instruction in absolute mode is 6E, which requires 3 bytes and 6 cycles to execute."
"[INST]In the context of the C64, what is the addressing mode for ROR A instruction?[/INST]The addressing mode for ROR A instruction is accumulator, which requires 1 byte and 2 cycles to execute."
"[INST]In the context of the C64, what is the opcode for ROR instruction in absolute,X mode?[/INST]The opcode for ROR instruction in absolute,X mode is 7E, which requires 3 bytes and 7 cycles to execute."
"[INST]In the context of the C64, how many bytes does ROR Oper instruction require?[/INST]The ROR Oper instruction in zero page mode requires 2 bytes."
"[INST]In the context of the C64, what is the number of cycles required for ROR Oper,X instruction?[/INST]The ROR Oper,X instruction in zero page,X mode requires 6 cycles to execute."
"[INST]In the context of the C64, what is the opcode for ROR Oper instruction in zero page mode?[/INST]The opcode for ROR Oper instruction in zero page mode is 66, which requires 2 bytes and 5 cycles to execute."
"[INST]In the context of the C64, what is the operation performed by the INX instruction[/INST]Increment Index X by one"
"[INST]In the context of the C64, what is the result of the operation INX[/INST]X + 1"
"[INST]In the context of the C64, what is the assembly language form of the INX instruction[/INST]INX"
"[INST]In the context of the C64, what is the op code for the INX instruction[/INST]E8"
"[INST]In the context of the C64, how many bytes does the INX instruction occupy[/INST]1"
"[INST]In the context of the C64, how many cycles does the INX instruction take[/INST]2"
"[INST]In the context of the C64, what is the addressing mode of the INX instruction[/INST]Implied"
"[INST]In the context of the C64, what is the purpose of the INX instruction[/INST]Increment Index X"
"[INST]In the context of the C64, what is the format of the INX instruction[/INST]INX Increment Index X by one"
"[INST]In the context of the C64, what is the operation performed by the INX instruction in assembly language[/INST]X + 1"
"[INST]In the context of the C64, what is the CIA chip's bus compatibility?[/INST]The 6526 Complex Interface Adapter (CIA) is a 65XX bus compatible peripheral interface device with extremely flexible timing and I/O capabilities."
"[INST]In the context of the C64, what are the key features of the CIA chip?[/INST]The CIA chip features 16 individually programmable I/O lines, 8 or 16-Bit handshaking on read or write, 2 independent linkable 16-Bit interval timers, a 24-hour time of day clock with programmable alarm, an 8-Bit shift register for serial I/O, 2 TTL load capability, CMOS compatible I/O lines, and 1 or 2 MHz operation availability."
"[INST]In the context of the C64, what is the CIA chip's timer capability?[/INST]The CIA chip has 2 independent, linkable 16-Bit interval timers, allowing for flexible timing and I/O capabilities."
"[INST]In the context of the C64, what is the CIA chip's clock feature?[/INST]The CIA chip has a 24-hour (AM/PM) time of day clock with programmable alarm, allowing for precise time-keeping and alarm functionality."
"[INST]In the context of the C64, what is the CIA chip's serial I/O capability?[/INST]The CIA chip has an 8-Bit shift register for serial I/O, enabling efficient serial data transfer."
"[INST]In the context of the C64, what is the CIA chip's I/O line compatibility?[/INST]The CIA chip has CMOS compatible I/O lines, ensuring compatibility with CMOS devices."
"[INST]In the context of the C64, what are the CIA chip's operating frequencies?[/INST]The CIA chip can operate at 1 or 2 MHz, providing flexibility in system design."
"[INST]In the context of the C64, what is the CIA chip's handshaking capability?[/INST]The CIA chip supports 8 or 16-Bit handshaking on read or write, enabling efficient data transfer."
"[INST]In the context of the C64, what is the CIA chip's I/O line programmability?[/INST]The CIA chip has 16 individually programmable I/O lines, allowing for customized I/O configurations."
"[INST]In the context of the C64, what is the CIA chip's load capability?[/INST]The CIA chip has 2 TTL load capability, enabling it to drive multiple loads."
"[INST]In the context of the C64, Where is the Operating System of the Commodore 64 stored?[/INST]The Operating System is contained in the Read Only Memory (ROM) chips and is a combination of three separate, but interrelated, program modules."
"[INST]In the context of the C64, What are the three program modules that make up the Operating System of the Commodore 64?[/INST]The three program modules that make up the Operating System are the BASIC Interpreter, the KERNAL, and the Screen Editor."
"[INST]In the context of the C64, What is the role of the BASIC Interpreter in the Commodore 64 Operating System?[/INST]The BASIC Interpreter is responsible for analysing BASIC statement syntax and for performing the required calculations and/or data manipulation."
"[INST]In the context of the C64, How many keywords does the BASIC Interpreter have in its vocabulary?[/INST]The BASIC Interpreter has a vocabulary of 65 keywords which have special meanings."
"[INST]In the context of the C64, What characters are used to make keywords and variable names in the BASIC Interpreter?[/INST]The upper and lower case alphabet and the digits 0-9 are used to make both keywords and variable names."
"[INST]In the context of the C64, What is the role of the KERNAL in the Commodore 64 Operating System?[/INST]The KERNAL handles most of the interrupt level processing in the system and does the actual input and output of data."
"[INST]In the context of the C64, What is the function of the Screen Editor in the Commodore 64 Operating System?[/INST]The Screen Editor controls the output to the video screen (television set) and the editing of BASIC program text, and also intercepts keyboard input to decide whether characters should be acted upon immediately or passed on to the BASIC Interpreter."
"[INST]In the context of the C64, How does the Screen Editor handle keyboard input?[/INST]The Screen Editor intercepts keyboard input to decide whether the characters put in should be acted upon immediately, or passed on to the BASIC Interpreter."
"[INST]In the context of the C64, What is the purpose of the special characters and symbols in the BASIC Interpreter?[/INST]Certain punctuation characters and special symbols have meanings for the Interpreter, as listed in Table 1-1."
"[INST]In the context of the C64, What is the relationship between the three program modules of the Operating System?[/INST]The three program modules - the BASIC Interpreter, the KERNAL, and the Screen Editor - are separate but interrelated, working together to form the Operating System of the Commodore 64."
"[INST]In the context of the C64, what is the error message when string data is received from an open file but numeric data was expected?[/INST]BAD DATA"
"[INST]In the context of the C64, what happens when you hit the STOP key during program execution?[/INST]BREAK"
"[INST]In the context of the C64, why does the CONT command not work?[/INST]CAN'T CONTINUE"
"[INST]In the context of the C64, what error occurs when the required I/O device is not available?[/INST]DEVICE NOT PRESENT"
"[INST]In the context of the C64, what is the error message for division by zero?[/INST]DIVISION BY ZERO"
"[INST]In the context of the C64, what happens when too many items of data are typed in response to an INPUT statement?[/INST]EXTRA IGNORED"
"[INST]In the context of the C64, what error occurs when a file is not found on tape or disk?[/INST]FILE NOT FOUND"
"[INST]In the context of the C64, what error occurs when a file is not open?[/INST]FILE NOT OPEN"
"[INST]In the context of the C64, what error occurs when a file is already open?[/INST]FILE OPEN"
"[INST]In the context of the C64, what error occurs when a formula is too complex?[/INST]FORMULA TOO COMPLEX"
"[INST]In the context of the C64, where can the INPUT statement not be used?[/INST]ILLEGAL DIRECT"
"[INST]In the context of the C64, what error occurs when a number is out of the allowable range?[/INST]ILLEGAL QUANTITY"
"[INST]In the context of the C64, what error occurs when there is a problem with the program on tape?[/INST]LOAD"
"[INST]In the context of the C64, what error occurs when a NEXT statement does not correspond with a FOR statement?[/INST]NEXT WITHOUT FOR"
"[INST]In the context of the C64, what error occurs when trying to input data from a file specified for output only?[/INST]NOT INPUT FILE"
"[INST]In the context of the C64, what error occurs when trying to print data to a file specified for input only?[/INST]NOT OUTPUT FILE"
"[INST]In the context of the C64, what error occurs when there is no more data left to read?[/INST]OUT OF DATA"
"[INST]In the context of the C64, what error occurs when there is no more RAM available?[/INST]OUT OF MEMORY"
"[INST]In the context of the C64, what error occurs when the result of a computation is too large?[/INST]OVERFLOW"
"[INST]In the context of the C64, what error occurs when an array is dimensioned more than once?[/INST]REDIM'D ARRAY"
"[INST]In the context of the C64, what error occurs when character data is typed in during an INPUT statement expecting numeric data?[/INST]REDO FROM START"
"[INST]In the context of the C64, what error occurs when a RETURN statement is encountered without a GOSUB command?[/INST]RETURN WITHOUT GOSUB"
"[INST]In the context of the C64, what error occurs when a string contains more than 255 characters?[/INST]STRING TOO LONG"
"[INST]In the context of the C64, what error occurs when a statement is unrecognizable by the Commodore 64?[/INST]?SYNTAX ERROR"
"[INST]In the context of the C64, what error occurs when a number is used in place of a string or vice-versa?[/INST]TYPE MISMATCH"
"[INST]In the context of the C64, what error occurs when a user-defined function is referenced but not defined?[/INST]UNDEF'D FUNCTION"
"[INST]In the context of the C64, what error occurs when trying to GOTO or GOSUB or RUN a non-existent line number?[/INST]UNDEF'D STATEMENT"
"[INST]In the context of the C64, what error occurs when the program on tape or disk does not match the program in memory?[/INST]VERIFY"
"[INST]In the context of the C64, Can the display data be scrolled in both horizontal and vertical directions?[/INST]Yes, the display data may be scrolled up to one entire character space in both the horizontal and vertical direction."
"[INST]In the context of the C64, What is the purpose of scrolling in conjunction with the smaller display window?[/INST]Scrolling can be used to create a smooth panning motion of display data while updating the system memory only when a new character row (or column) is required."
"[INST]In the context of the C64, What is the effect of scrolling on the system memory?[/INST]Scrolling updates the system memory only when a new character row (or column) is required."
"[INST]In the context of the C64, What is the purpose of scrolling in centering a fixed display within the display window?[/INST]Scrolling is used to center a fixed display within the display window."
"[INST]In the context of the C64, What are the registers used for horizontal positioning?[/INST]The X2, X1, X0 registers are used for horizontal positioning."
"[INST]In the context of the C64, What are the registers used for vertical positioning?[/INST]The Y2, Y1, Y0 registers are used for vertical positioning."
"[INST]In the context of the C64, What is the function of the horizontal position register?[/INST]The horizontal position register is used to set the horizontal position."
"[INST]In the context of the C64, What is the function of the vertical position register?[/INST]The vertical position register is used to set the vertical position."
"[INST]In the context of the C64, What is the purpose of the function register?[/INST]The function register is used to specify the function of the display."
"[INST]In the context of the C64, What is the hexadecimal value of the horizontal position register?[/INST]The hexadecimal value of the horizontal position register is $16."
"[INST]In the context of the C64, What is the hexadecimal value of the vertical position register?[/INST]The hexadecimal value of the vertical position register is $11."
"[INST]In the context of the C64, How does the multi-color bit map mode differ from the standard bit map mode?[/INST]Multi-color bit map mode differs from standard bit map mode in the way it interprets the dot data, using the same memory access sequences but with a different interpretation of the bit pairs, allowing for the display of three independently selected colors in each 8*8 block in addition to the background color."
"[INST]In the context of the C64, What is the purpose of the MCM bit in register 22?[/INST]The MCM bit in register 22 is used to select the multi-color bit map mode when set to a '1' in conjunction with the BMM bit, enabling the use of multi-color mode."
"[INST]In the context of the C64, What is the significance of the bit pair '00' in multi-color bit map mode?[/INST]In multi-color bit map mode, the bit pair '00' represents the background color #0, which is set in register 33 ($21)."
"[INST]In the context of the C64, How is the video matrix pointer used in multi-color bit map mode?[/INST]The video matrix pointer is used in multi-color bit map mode, with the upper nybble of the pointer represented by the bit pair '01' and the lower nybble represented by the bit pair '10'."
"[INST]In the context of the C64, What is the resolution of the screen in multi-color bit map mode?[/INST]The screen resolution in multi-color bit map mode is 160H*200V, due to the horizontal dot size being doubled as a result of using two bits to select one dot color."
"[INST]In the context of the C64, How many colors can be displayed in each 8*8 block in multi-color bit map mode?[/INST]In multi-color bit map mode, three independently selected colors can be displayed in each 8*8 block, in addition to the background color."
"[INST]In the context of the C64, What is the role of the color nybble (DB11-DB8) in multi-color bit map mode?[/INST]The color nybble (DB11-DB8) is used in multi-color bit map mode to select the color of each dot, allowing for the display of multiple colors in each 8*8 block."
"[INST]In the context of the C64, What is the advantage of using multi-color bit map mode?[/INST]The advantage of using multi-color bit map mode is that it allows for the display of multiple colors in each 8*8 block, providing more color flexibility and detail in graphics and images."
"[INST]In the context of the C64, How is the background color set in multi-color bit map mode?[/INST]The background color is set in register 33 ($21) in multi-color bit map mode, and is represented by the bit pair '00'."
"[INST]In the context of the C64, What is the relationship between the BMM bit and the MCM bit in register 22?[/INST]The BMM bit and the MCM bit in register 22 must both be set to '1' to enable multi-color bit map mode, allowing for the display of multiple colors in each 8*8 block."
"[INST]In the context of the C64, Is there an instruction to add memory to the accumulator with carry?[/INST]ADC"
"[INST]In the context of the C64, What is the effect of the ASL instruction?[/INST]Shift left One Bit (Memory or Accumulator)"
"[INST]In the context of the C64, What is the purpose of the BCC instruction?[/INST]Branch on Carry Clear"
"[INST]In the context of the C64, What is the effect of the CLC instruction?[/INST]Clear Carry Flag"
"[INST]In the context of the C64, What is the purpose of the CMP instruction?[/INST]Compare Memory and Accumulator"
"[INST]In the context of the C64, What is the effect of the DEC instruction?[/INST]Decrement Memory by One"
"[INST]In the context of the C64, What is the purpose of the EOR instruction?[/INST]'Exclusive-OR' Memory with Accumulator"
"[INST]In the context of the C64, What is the effect of the INC instruction?[/INST]Increment Memory by One"
"[INST]In the context of the C64, What is the purpose of the JMP instruction?[/INST]Jump to New location"
"[INST]In the context of the C64, What is the effect of the LDA instruction?[/INST]Load Accumulator with Memory"
"[INST]In the context of the C64, What is the purpose of the LSR instruction?[/INST]Shift One Bit Right (Memory or Accumulator)"
"[INST]In the context of the C64, What is the effect of the ORA instruction?[/INST]'OR' Memory with Accumulator"
"[INST]In the context of the C64, What is the purpose of the PHA instruction?[/INST]Push Accumulator on Stack"
"[INST]In the context of the C64, What is the effect of the ROL instruction?[/INST]Rotate One Bit Left (Memory or Accumulator)"
"[INST]In the context of the C64, What is the purpose of the SBC instruction?[/INST]Subtract Memory from Accumulator with Borrow"
"[INST]In the context of the C64, What is the effect of the SEC instruction?[/INST]Set Carry Flag"
"[INST]In the context of the C64, What is the purpose of the STA instruction?[/INST]Store Accumulator in Memory"
"[INST]In the context of the C64, What is the effect of the TAX instruction?[/INST]Transfer Accumulator to Index X"
"[INST]In the context of the C64, What is the purpose of the TYA instruction?[/INST]Transfer Index Y to Accumulator"
"[INST]In the context of the C64, What is the effect of the TXA instruction?[/INST]Transfer Index X to Accumulator"
"[INST]In the context of the C64, What is the purpose of the RTS instruction?[/INST]Return from Subroutine"
"[INST]In the context of the C64, What is the effect of the SED instruction?[/INST]Set Decimal Mode"
"[INST]In the context of the C64, What is the purpose of the SEI instruction?[/INST]Set Interrupt Disable Status"
"[INST]In the context of the C64, What is the effect of the STX instruction?[/INST]Store Index X in Memory"
"[INST]In the context of the C64, What is the purpose of the TSX instruction?[/INST]Transfer Stack Pointer to Index X"
"[INST]In the context of the C64, What is the effect of the TYA instruction?[/INST]Transfer Index Y to Accumulator"
"[INST]In the context of the C64, What is the purpose of the TXS instruction?[/INST]Transfer Index X to Stack Register"
"[INST]In the context of the C64, What is the effect of the PLA instruction?[/INST]Pull Accumulator from Stack"
"[INST]In the context of the C64, What is the purpose of the PLP instruction?[/INST]Pull Processor Status from Stack"
"[INST]In the context of the C64, what is the number of voices in the electronic music synthesizer?[/INST]three voices, totally addressable, ATTACK/DECAY/SUSTAIN/RELEASE (ADSR), filtering, modulation, and white noise"
"[INST]In the context of the C64, what is the name of the sound and music synthesizer inside the Commodore computer?[/INST]the 6581 SID chip"
"[INST]In the context of the C64, how do you access the sound generator?[/INST]by POKEing into specified memory locations"
"[INST]In the context of the C64, where can you find the list of memory locations used?[/INST]in Appendix O"
"[INST]In the context of the C64, what is the purpose of the POKE statement?[/INST]to set the indicated memory location equal to a specified value"
"[INST]In the context of the C64, what is the starting memory location for music synthesis in the Commodore 64?[/INST]54272 ($D400)"
"[INST]In the context of the C64, what is the range of numbers you can use in a POKE statement?[/INST]between 0 and 255, inclusive"
"[INST]In the context of the C64, what is the function of the PEEK function?[/INST]to retrieve the value currently in a specified memory location"
"[INST]In the context of the C64, what is the variable set equal to when using the PEEK function?[/INST]the current contents of the memory location"
"[INST]In the context of the C64, what do you need to be to achieve exciting results from the music synthesizer?[/INST]not an experienced programmer nor a music expert"
"[INST]In the context of the C64, what is the purpose of this section of the Programmer's Reference Guide?[/INST]to help you explore all the capabilities of the 6581 SID chip"
"[INST]In the context of the C64, what is provided in each section of this chapter?[/INST]an example and a full line-by-line description of each program"
"[INST]In the context of the C64, what is the workhorse of your sound programs?[/INST]the POKE statement"
"[INST]In the context of the C64, what do you need to remember when using the 6581 (SID) chip register map?[/INST]the memory locations 54272 to 54296 inclusive"
"[INST]In the context of the C64, how can you POKE all the locations from 54272 to 54296?[/INST]by remembering only location 54272 and then adding a number from 0 through 24 to it"
"[INST]In the context of the C64, what is the POKE command to set sprite 0 to WHITE?[/INST]To set sprite 0 to WHITE, you can use the POKE command: POKE V+39,1, where V is the memory location of the sprite. This command sets the color of sprite 0 to WHITE, which has a color code of 1 according to the individual color codes chart."
"[INST]In the context of the C64, what is the color code for PURPLE?[/INST]The color code for PURPLE is 4, as shown in the individual color codes chart. This chart provides a reference for setting the colors of sprites in the Commodore 64."
"[INST]In the context of the C64, what is the purpose of reserving a 64-BYTE BLOCK of memory for each sprite?[/INST]Reserving a 64-BYTE BLOCK of memory for each sprite is necessary to store the sprite data. Out of these 64 bytes, 63 bytes will be used to store the sprite data, and the remaining byte is reserved for other purposes. This memory block is essential for defining and storing the sprite's characteristics."
"[INST]In the context of the C64, how can you make all sprites look the same?[/INST]To make all sprites look the same, you need to point the sprites you want to look the same to the same register for sprites. This means that you need to set the sprite pointer to the same memory location for all sprites that you want to have the same appearance."
"[INST]In the context of the C64, what is the memory setting for the sprite pointer?[/INST]The memory setting for the sprite pointer is not explicitly stated in the text, but it is recommended to use the memory settings shown in the chart above. These settings provide a reference for setting the sprite pointer correctly."
"[INST]In the context of the C64, what is the color code for LT. GREEN?[/INST]The color code for LT. GREEN is 13, as shown in the individual color codes chart. This chart provides a reference for setting the colors of sprites in the Commodore 64."
"[INST]In the context of the C64, what is the purpose of the individual color codes chart?[/INST]The individual color codes chart provides a reference for setting the colors of sprites in the Commodore 64. It lists the color codes for each possible color that can be used for sprites, allowing developers to easily set the desired color for their sprites."
"[INST]In the context of the C64, how many bytes are used to store sprite data?[/INST]63 bytes are used to store sprite data, with the remaining byte of the 64-BYTE BLOCK reserved for other purposes."
"[INST]In the context of the C64, what is the color code for CYAN?[/INST]The color code for CYAN is 3, as shown in the individual color codes chart. This chart provides a reference for setting the colors of sprites in the Commodore 64."
"[INST]In the context of the C64, what is the purpose of defining each sprite uniquely?[/INST]Defining each sprite uniquely allows developers to create different sprites with distinct characteristics, such as different colors, shapes, and behaviors. This is essential for creating engaging and varied graphics in Commodore 64 games and applications."
"[INST]In the context of the C64, what is the opcode for the JSR instruction?[/INST]The opcode for the JSR instruction is 20, which is used to jump to a new location while saving the return address."
"[INST]In the context of the C64, what is the addressing mode for the JSR instruction?[/INST]The addressing mode for the JSR instruction is Absolute, which means the instruction uses a 16-bit address to specify the target location."
"[INST]In the context of the C64, how many bytes does the JSR instruction occupy in memory?[/INST]The JSR instruction occupies 3 bytes in memory, which includes the opcode and the 16-bit address of the target location."
"[INST]In the context of the C64, how many cycles does the JSR instruction take to execute?[/INST]The JSR instruction takes 6 cycles to execute, which includes the time it takes to fetch the instruction, decode it, and execute the jump."
"[INST]In the context of the C64, what is the purpose of the JSR instruction?[/INST]The purpose of the JSR instruction is to jump to a new location in the program while saving the return address on the stack, allowing the program to return to the original location after executing the subroutine."
"[INST]In the context of the C64, what is the assembly language form of the JSR instruction?[/INST]The assembly language form of the JSR instruction is 'JSR Oper', where 'Oper' is the 16-bit address of the target location."
"[INST]In the context of the C64, what happens to the return address when the JSR instruction is executed?[/INST]When the JSR instruction is executed, the return address is saved on the stack, allowing the program to return to the original location after executing the subroutine."
"[INST]In the context of the C64, can the JSR instruction be used to call a subroutine?[/INST]Yes, the JSR instruction can be used to call a subroutine by jumping to the starting address of the subroutine and saving the return address on the stack."
"[INST]In the context of the C64, what is the difference between the JSR instruction and the JMP instruction?[/INST]The main difference between the JSR instruction and the JMP instruction is that the JSR instruction saves the return address on the stack, while the JMP instruction does not, allowing the program to return to the original location after executing the subroutine."
"[INST]In the context of the C64, how does the JSR instruction affect the program counter?[/INST]The JSR instruction changes the program counter to point to the new location specified in the instruction, allowing the program to execute the code at that location."
"[INST]In the context of the C64, Does the 6510 require a specific clock signal?[/INST]Yes, it requires a two-phase non-overlapping clock that runs at the Vcc voltage level."
"[INST]In the context of the C64, What is the purpose of the Address Bus?[/INST]The Address Bus is used to transfer data to and from the device and peripherals."
"[INST]In the context of the C64, What is the capacity of the Address Bus?[/INST]The Address Bus can drive one standard TTL load and 130 pf."
"[INST]In the context of the C64, What is the purpose of the Data Bus?[/INST]The Data Bus is a Bi-Directional bus, transferring data to and from the device and peripherals."
"[INST]In the context of the C64, What is the capacity of the Data Bus?[/INST]The Data Bus can drive one standard TTL load and 130 pf."
"[INST]In the context of the C64, What is the purpose of the Reset signal?[/INST]The Reset signal is used to reset or start the microprocessor from a power down condition."
"[INST]In the context of the C64, What happens when the Reset signal is held low?[/INST]Writing to or from the microprocessor is inhibited."
"[INST]In the context of the C64, What happens when the Reset signal is held low for at least two clock cycles?[/INST]The mask interrupt flag will be set and the microprocessor will load the program counter from the memory vector locations FFFC and FFFD."
"[INST]In the context of the C64, What is the purpose of the Interrupt Request signal?[/INST]The Interrupt Request signal requests that an interrupt sequence begin within the microprocessor."
"[INST]In the context of the C64, What happens when an interrupt is requested?[/INST]The microprocessor will complete the current instruction being executed before recognizing the request."
"[INST]In the context of the C64, What is the purpose of the Address Enable Control signal?[/INST]The Address Enable Control signal allows easy DMA and multiprocessor systems."
"[INST]In the context of the C64, What is the purpose of the I/O Port?[/INST]The I/O Port is used to transfer data to or from peripheral devices."
"[INST]In the context of the C64, What is the capacity of the I/O Port?[/INST]The I/O Port can drive one standard TTL load and 130 pf."
"[INST]In the context of the C64, What is the purpose of the Read/Write signal?[/INST]The Read/Write signal is used to control the direction of data transfers on the Data Bus."
"[INST]In the context of the C64, What happens when the Read/Write signal is low?[/INST]The microprocessor is writing to memory or a peripheral device."
"[INST]In the context of the C64, What is the capacity of the Read/Write signal?[/INST]The Read/Write signal is high except when the microprocessor is writing to memory or a peripheral device."
"[INST]In the context of the C64, What is the purpose of the microprocessor's clock signal?[/INST]The clock signal is used to control the timing of the microprocessor's operations."
"[INST]In the context of the C64, What is the purpose of the microprocessor's Address Bus?[/INST]The Address Bus is used to transfer data to and from the device and peripherals."
"[INST]In the context of the C64, What is the purpose of the microprocessor's Data Bus?[/INST]The Data Bus is a Bi-Directional bus, transferring data to and from the device and peripherals."
"[INST]In the context of the C64, What is the purpose of the microprocessor's Reset signal?[/INST]The Reset signal is used to reset or start the microprocessor from a power down condition."
"[INST]In the context of the C64, What is the purpose of the microprocessor's Interrupt Request signal?[/INST]The Interrupt Request signal requests that an interrupt sequence begin within the microprocessor."
"[INST]In the context of the C64, What is the purpose of the microprocessor's Address Enable Control signal?[/INST]The Address Enable Control signal allows easy DMA and multiprocessor systems."
"[INST]In the context of the C64, What is the purpose of the microprocessor's I/O Port?[/INST]The I/O Port is used to transfer data to or from peripheral devices."
"[INST]In the context of the C64, What is the purpose of the microprocessor's Read/Write signal?[/INST]The Read/Write signal is used to control the direction of data transfers on the Data Bus."
"[INST]In the context of the C64, What is the capacity of the microprocessor's clock signal?[/INST]The clock signal is used to control the timing of the microprocessor's operations."
"[INST]In the context of the C64, What is the capacity of the microprocessor's Address Bus?[/INST]The Address Bus is used to transfer data to and from the device and peripherals."
"[INST]In the context of the C64, What is the capacity of the microprocessor's Data Bus?[/INST]The Data Bus is a Bi-Directional bus, transferring data to and from the device and peripherals."
"[INST]In the context of the C64, What is the capacity of the microprocessor's Reset signal?[/INST]The Reset signal is used to reset or start the microprocessor from a power down condition."
"[INST]In the context of the C64, What is the capacity of the microprocessor's Interrupt Request signal?[/INST]The Interrupt Request signal requests that an interrupt sequence begin within the microprocessor."
"[INST]In the context of the C64, What is the capacity of the microprocessor's Address Enable Control signal?[/INST]The Address Enable Control signal allows easy DMA and multiprocessor systems."
"[INST]In the context of the C64, What is the capacity of the microprocessor's I/O Port?[/INST]The I/O Port is used to transfer data to or from peripheral devices."
"[INST]In the context of the C64, What is the capacity of the microprocessor's Read/Write signal?[/INST]The Read/Write signal is used to control the direction of data transfers on the Data Bus."
"[INST]In the context of the C64, Is the 6526 Complex Interface Adapter (CIA) a peripheral interface device?[/INST]Yes, the 6526 Complex Interface Adapter (CIA) is a 65XX bus compatible peripheral interface device with extremely flexible timing and I/O capabilities."
"[INST]In the context of the C64, What are the features of the 6526 Complex Interface Adapter (CIA)?[/INST]The 6526 Complex Interface Adapter (CIA) has 16 individually programmable 110 lines, 8 or 16-Bit handshaking on read or write, 2 independent, linkable 16-Bit interval timers, 24-hour (AM/PM) time of day clock with programmable alarm, 8-Bit shift register for serial I/O, 2 TTL load capability, CMOS compatible I/O lines, and 1 or 2 MHz operation available."
"[INST]In the context of the C64, What is the purpose of the 6526 Complex Interface Adapter (CIA)?[/INST]The purpose of the 6526 Complex Interface Adapter (CIA) is to provide a peripheral interface device with extremely flexible timing and I/O capabilities."
"[INST]In the context of the C64, Can the 6526 Complex Interface Adapter (CIA) be used for serial I/O?[/INST]Yes, the 6526 Complex Interface Adapter (CIA) has an 8-Bit shift register for serial I/O."
"[INST]In the context of the C64, Is the 6526 Complex Interface Adapter (CIA) compatible with CMOS?[/INST]Yes, the 6526 Complex Interface Adapter (CIA) has CMOS compatible I/O lines."
"[INST]In the context of the C64, Can the 6526 Complex Interface Adapter (CIA) be used for 1 or 2 MHz operation?[/INST]Yes, the 6526 Complex Interface Adapter (CIA) can operate at 1 or 2 MHz."
"[INST]In the context of the C64, What are the pin configurations of the 6526 Complex Interface Adapter (CIA)?[/INST]The 6526 Complex Interface Adapter (CIA) has a pin configuration that includes Vss, PA0-PA7, PB0-PB7, /PC, TOD, Vcc, and /IRQ."
"[INST]In the context of the C64, Is the 6526 Complex Interface Adapter (CIA) a 65XX bus compatible device?[/INST]Yes, the 6526 Complex Interface Adapter (CIA) is a 65XX bus compatible device."
"[INST]In the context of the C64, What is one way to use machine language routines from BASIC on the Commodore 64?[/INST]The BASIC SYS statement"
"[INST]In the context of the C64, How does the BASIC SYS statement work?[/INST]The BASIC statement SYS X causes a JUMP to a machine language subroutine located at address X."
"[INST]In the context of the C64, What is the purpose of the RTS instruction in a machine language routine?[/INST]The routine must end with an RTS instruction to return control back to BASIC."
"[INST]In the context of the C64, How are parameters passed between the machine language routine and the BASIC program?[/INST]Parameters are generally passed between the machine language routine and the BASIC program using the BASIC PEEK and POKE statements, and their machine language equivalents."
"[INST]In the context of the C64, What is the most useful method of combining BASIC with machine language?[/INST]The SYS command is the most useful method of combining BASIC with machine language."
"[INST]In the context of the C64, How does the BASIC function USR(X) work?[/INST]The BASIC function USR(X) transfers control to the machine language subroutine located at the address stored in locations 785 and 786."
"[INST]In the context of the C64, What is the format of the address stored in locations 785 and 786?[/INST]The address is stored in standard low-byte/high-byte format."
"[INST]In the context of the C64, How is a value passed to the machine language subroutine through the USR function?[/INST]The value X is evaluated and passed to the machine language subroutine through floating point accumulator #1, located beginning at address $61."
"[INST]In the context of the C64, How is a value returned back to the BASIC program from the machine language subroutine?[/INST]A value may be returned back to the BASIC program by placing it in the floating point accumulator."
"[INST]In the context of the C64, What is the difference between the SYS and USR statements?[/INST]The SYS statement is different from the USR function because you have to set up an indirect vector, and the format through which the variable is passed is floating point format."
"[INST]In the context of the C64, How can you replace or amend a BASIC internal routine?[/INST]Any of the input/output or BASIC internal routines accessed through the vector table located on page 3 can be replaced, or amended by user code."
"[INST]In the context of the C64, What is the purpose of the KERNAL VECTOR routine?[/INST]The KERNAL VECTOR routine is the most reliable way to change any of the vectors."
"[INST]In the context of the C64, How can you change a single vector?[/INST]A single vector can be changed by POKES."
"[INST]In the context of the C64, What happens when the user routine is executed?[/INST]When the appropriate BASIC command is executed, the user routine will be executed."
"[INST]In the context of the C64, What should the user program do after executing the user routine?[/INST]If after executing the user routine, it is necessary to execute the normal system routine, the user program must JMP to the address formerly contained in the vector."
"[INST]In the context of the C64, What should the user program do if it is not necessary to execute the normal system routine?[/INST]If not, the routine must end with a RTS to transfer control back to BASIC."
"[INST]In the context of the C64, How can you change the HARDWARE INTERRUPT (IRQ) VECTOR?[/INST]The HARDWARE INTERRUPT (IRQ) VECTOR can be changed."
"[INST]In the context of the C64, What happens when the operating system transfers control to the routine specified by this vector?[/INST]Every 1/60th of a second, the operating system transfers control to the routine specified by this vector."
"[INST]In the context of the C64, What should you always do before changing the IRQ VECTOR?[/INST]ALWAYS DISABLE INTERRUPTS BEFORE CHANGING THIS VECTOR!"
"[INST]In the context of the C64, What is the purpose of the CHRGET routine?[/INST]The CHRGET routine is used by BASIC to get each character/token."
"[INST]In the context of the C64, How can you add new BASIC commands using the CHRGET routine?[/INST]This makes it simple to add new BASIC commands."
"[INST]In the context of the C64, How does the new CHRGET routine work?[/INST]The new CHRGET routine will search for the special character, and if none is present, control is passed to the normal BASIC CHRGET routine."
"[INST]In the context of the C64, What is a common way to use this method?[/INST]A common way to use this method is to specify a character (@ for example) which will occur before any of the new commands."
"[INST]In the context of the C64, What is the advantage of this technique?[/INST]This minimizes the extra execution time added by the need to search for additional commands."
"[INST]In the context of the C64, What is this technique often called?[/INST]This technique is often called a wedge."
"[INST]In the context of the C64, What is the purpose of the machine language subroutine in the CHRGET routine?[/INST]Naturally, each new command must be executed by a user written machine language subroutine."
"[INST]In the context of the C64, How do you specify a new command in the CHRGET routine?[/INST]The new CHRGET routine will search for the special character, and if the special character is present, the new command is interpreted and executed by your machine language program."
"[INST]In the context of the C64, what is the function of the eight data bus pins on the C64[/INST]The eight data bus pins (DB7-DB0) serve as a bidirectional data port, controlled by the /CS, RW, and Phase 0 signals, allowing data to be transferred in and out of the device registers."
"[INST]In the context of the C64, what are the conditions required to access the data bus[/INST]The data bus can only be accessed when AEC and Phase 0 are high and /CS is low, ensuring that the device registers are properly selected and ready for data transfer."
"[INST]In the context of the C64, what is the purpose of the /CS pin[/INST]The chip select pin (/CS) is used to enable access to the device registers, and must be brought low in conjunction with the address and RW pins to select the desired register for data transfer."
"[INST]In the context of the C64, what is the relationship between /CS and AEC[/INST]The /CS pin is only recognized as low when AEC and Phase 0 are high, ensuring that the device registers are properly selected and ready for data transfer."
"[INST]In the context of the C64, what is the significance of Phase 0 in accessing the data bus[/INST]Phase 0 must be high to access the data bus, along with AEC and /CS, to ensure that the device registers are properly selected and ready for data transfer."
"[INST]In the context of the C64, what is the direction of data transfer on the data bus[/INST]The data bus is bidirectional, allowing data to be transferred in and out of the device registers, depending on the direction of data transfer required by the system."
"[INST]In the context of the C64, what is the role of RW in accessing the device registers[/INST]The RW pin, in conjunction with the address and /CS pins, controls the direction of data transfer on the data bus, allowing data to be written to or read from the device registers."
"[INST]In the context of the C64, what is the condition for /CS to be recognized as low[/INST]/CS is only recognized as low when AEC and Phase 0 are high, ensuring that the device registers are properly selected and ready for data transfer."
"[INST]In the context of the C64, what is the function of AEC in accessing the data bus[/INST]AEC must be high to access the data bus, along with Phase 0 and /CS, to ensure that the device registers are properly selected and ready for data transfer."
"[INST]In the context of the C64, what is the significance of the address pins in accessing the device registers[/INST]The address pins, in conjunction with the /CS and RW pins, select the desired device register for data transfer, ensuring that data is transferred to or from the correct register."
"[INST]In the context of the C64, What is the purpose of the 4-bit register in a sprite?[/INST]Each sprite has a separate 4-bit register to determine the sprite color, which determines how the sprite is displayed on the screen."
"[INST]In the context of the C64, What is the difference between STANDARD and MULTI-COLOR sprite modes?[/INST]In STANDARD mode, a '0' bit of sprite data allows background data to show through and a '1' bit is displayed as the sprite color, whereas in MULTI-COLOR mode, the sprite data is interpreted in pairs to display different colors."
"[INST]In the context of the C64, How does the MnMC bit affect the sprite display?[/INST]When the MnMC bit is '1', the corresponding sprite is displayed in the multi-color mode, where the sprite data is interpreted in pairs to display different colors."
"[INST]In the context of the C64, What is the resolution of a sprite in MULTI-COLOR mode?[/INST]In MULTI-COLOR mode, the resolution of the sprite is reduced to 12x21, with each horizontal dot expanded to twice the standard size so that the overall sprite size does not change."
"[INST]In the context of the C64, What is the purpose of the sprite Multi-color register 28 ($1C)?[/INST]The sprite Multi-color register 28 ($1C) is used to select each sprite as a multi-color sprite via the MnMC bits."
"[INST]In the context of the C64, How many colors can be displayed in a sprite in MULTI-COLOR mode?[/INST]Up to 3 colors can be displayed in each sprite in MULTI-COLOR mode, in addition to transparent, but two of the colors are shared among all the sprites in this mode."
"[INST]In the context of the C64, What is the significance of the '00' bit pair in MULTI-COLOR mode?[/INST]In MULTI-COLOR mode, the '00' bit pair represents transparent, allowing background data to show through."
"[INST]In the context of the C64, What is the significance of the '10' bit pair in MULTI-COLOR mode?[/INST]In MULTI-COLOR mode, the '10' bit pair represents the sprite Color, which is determined by the corresponding sprite Color register."
"[INST]In the context of the C64, What is the purpose of registers 39-46 ($27-$2E) in MULTI-COLOR mode?[/INST]Registers 39-46 ($27-$2E) are used to store the sprite Color, which is displayed when the '10' bit pair is encountered in MULTI-COLOR mode."
"[INST]In the context of the C64, How does the sprite size change in MULTI-COLOR mode?[/INST]In MULTI-COLOR mode, the overall sprite size does not change, despite the reduced resolution, because each horizontal dot is expanded to twice the standard size."
"[INST]In the context of the C64, PLP is used for what purpose?[/INST]Pull Processor Status from Stack"
"[INST]In the context of the C64, ROL is used for what operation?[/INST]Rotate One Bit Left (Memory or Accumulator)"
"[INST]In the context of the C64, RTI is used for what action?[/INST]Return from Interrupt"
"[INST]In the context of the C64, RTS is used for what action?[/INST]Return from Subroutine"
"[INST]In the context of the C64, SBC is used for what operation?[/INST]Subtract Memory from Accumulator with Borrow"
"[INST]In the context of the C64, SEC is used for what action?[/INST]Set Carry Flag"
"[INST]In the context of the C64, SED is used for what action?[/INST]Set Decimal Mode"
"[INST]In the context of the C64, SEI is used for what action?[/INST]Set Interrupt Disable Status"
"[INST]In the context of the C64, STA is used for what operation?[/INST]Store Accumulator in Memory"
"[INST]In the context of the C64, STX is used for what operation?[/INST]Store Index X in Memory"
"[INST]In the context of the C64, STY is used for what operation?[/INST]Store Index Y in Memory"
"[INST]In the context of the C64, TAX is used for what operation?[/INST]Transfer Accumulator to Index X"
"[INST]In the context of the C64, TAY is used for what operation?[/INST]Transfer Accumulator to Index Y"
"[INST]In the context of the C64, TSX is used for what operation?[/INST]Transfer Stack Pointer to Index X"
"[INST]In the context of the C64, TXA is used for what operation?[/INST]Transfer Index X to Accumulator"
"[INST]In the context of the C64, TXS is used for what operation?[/INST]Transfer Index X to Stack Pointer"
"[INST]In the context of the C64, TYA is used for what operation?[/INST]Transfer Index Y to Accumulator"
"[INST]In the context of the C64, what is the significance of the Y index register in machine language instructions?[/INST]The Y index register is a crucial register in machine language instructions, allowing for a range of transformations and operations that are unique to this register, including copying contents from and to memory locations, modifying its own contents, and interacting with other registers."
"[INST]In the context of the C64, what types of instructions are available for the Y register?[/INST]The Y register has a range of instructions available, including those that allow copying the contents of a memory location into the Y register, copying the contents of the Y register into a memory location, and modifying the contents of the Y register or other registers directly."
"[INST]In the context of the C64, can the accumulator be used for all transformations?[/INST]No, while there are instructions for nearly all transformations that can be made to the accumulator and the X register, there are specific instructions that are unique to the Y register, highlighting its importance in machine language programming."
"[INST]In the context of the C64, what is the relationship between the Y register and memory locations?[/INST]The Y register has a close relationship with memory locations, allowing for the copying of contents from memory locations into the Y register and vice versa, making it a crucial component in data manipulation and storage."
"[INST]In the context of the C64, how does the Y register interact with other registers?[/INST]The Y register can interact with other registers, including the accumulator and the X register, allowing for a range of operations and transformations to be performed, including modifications to the contents of these registers."
"[INST]In the context of the C64, what is the purpose of the Y register in machine language programming?[/INST]The purpose of the Y register is to provide a range of unique transformations and operations that are not available to the accumulator and X register, making it an essential component in machine language programming."
"[INST]In the context of the C64, can the Y register be used for general-purpose computations?[/INST]While the Y register is primarily used for specific transformations and operations, it can also be used for general-purpose computations, making it a versatile and valuable component in machine language programming."
"[INST]In the context of the C64, how does the Y register differ from the X register?[/INST]The Y register differs from the X register in the range of instructions available, with the Y register having unique instructions that are not available to the X register, making it a distinct and important component in machine language programming."
"[INST]In the context of the C64, is the Y register used in conjunction with other registers?[/INST]Yes, the Y register is often used in conjunction with other registers, including the accumulator and X register, to perform a range of operations and transformations, highlighting its importance in machine language programming."
"[INST]In the context of the C64, what is the significance of the Y register in data manipulation?[/INST]The Y register plays a crucial role in data manipulation, allowing for the copying of contents from and to memory locations, and modifying the contents of the Y register or other registers directly, making it an essential component in machine language programming."
"[INST]In the context of the C64, Indexed indirect only allows usage of the X register as the index.[/INST]The X register is used as the index in indexed indirect mode."
"[INST]In the context of the C64, Actual base address is the actual address because the index has already been used for the indirect.[/INST]The actual base address is the actual address because the index has already been used for the indirect."
"[INST]In the context of the C64, Indexed indirect would also be used if a table of indirect pointers were located in zero page memory.[/INST]Indexed indirect would also be used if a table of indirect pointers were located in zero page memory."
"[INST]In the context of the C64, The actual address will be: Low order = contents of ($02+X), High order = contents of ($03+X), X register = $00.[/INST]The actual address is the indirect address contained in $02 which is again $1045."
"[INST]In the context of the C64, The title of this mode does in fact imply the principle, although it may be difficult to grasp at first sight.[/INST]The title of this mode does in fact imply the principle, although it may be difficult to grasp at first sight."
"[INST]In the context of the C64, Look at it this way: I am going to deliver this letter to the fourth post office at address $01,MEMORY ST., and the address on the letter will then be delivered to $1600, MEMORY street.[/INST]Look at it this way: I am going to deliver this letter to the fourth post office at address $01,MEMORY ST., and the address on the letter will then be delivered to $1600, MEMORY street."
"[INST]In the context of the C64, The code: LDA #$00 - load low order actual base address, STA $06 - set the low byte of the indirect address, LDA #$16 - load high order indirect address, STA $07 - set the high byte of the indirect address, LDX #$05 - set the indirect index (X), LDA ($02,X) - load indirectly indexed by X.[/INST]The code: LDA #$00 - load low order actual base address, STA $06 - set the low byte of the indirect address, LDA #$16 - load high order indirect address, STA $07 - set the high byte of the indirect address, LDX #$05 - set the indirect index (X), LDA ($02,X) - load indirectly indexed by X."
"[INST]In the context of the C64, The instruction to load the accumulator in the indexed indirect mode is executed and the specified zero page address is $02.[/INST]The instruction to load the accumulator in the indexed indirect mode is executed and the specified zero page address is $02."
"[INST]In the context of the C64, what is the frequency range of the tone oscillators in the 6581 SID chip?[/INST]The frequency range of the tone oscillators in the 6581 SID chip is 0-4 kHz, allowing for a wide range of pitch control."
"[INST]In the context of the C64, what types of waveforms are available per oscillator in the 6581 SID chip?[/INST]Each oscillator in the 6581 SID chip has four waveforms available: Triangle, Sawtooth, Variable Pulse, and Noise, providing a variety of tone colors and harmonic content."
"[INST]In the context of the C64, what is the range of the amplitude modulators in the 6581 SID chip?[/INST]The amplitude modulators in the 6581 SID chip have a range of 48 dB, allowing for a wide range of dynamic control."
"[INST]In the context of the C64, what are the characteristics of the envelope generators in the 6581 SID chip?[/INST]The envelope generators in the 6581 SID chip have an exponential response, with an attack rate of 2 ms-8 s, decay rate of 6 ms-24 s, sustain level of 0-peak volume, and release rate of 6 ms-24 s, allowing for complex and nuanced dynamic control."
"[INST]In the context of the C64, what is the purpose of the oscillator synchronization feature in the 6581 SID chip?[/INST]The oscillator synchronization feature in the 6581 SID chip allows for the synchronization of the oscillators, enabling the creation of complex and interesting sound effects and timbres."
"[INST]In the context of the C64, what is the function of the programmable filter in the 6581 SID chip?[/INST]The programmable filter in the 6581 SID chip has a cutoff range of 30 Hz-12 kHz, a 12 dB/octave rolloff, and multiple outputs (low pass, bandpass, high pass, and notch), allowing for precise and flexible tone shaping and filtering."
"[INST]In the context of the C64, what is the purpose of the master volume control in the 6581 SID chip?[/INST]The master volume control in the 6581 SID chip allows for overall volume control, enabling the adjustment of the overall loudness of the sound output."
"[INST]In the context of the C64, what is the function of the A/D pot interfaces in the 6581 SID chip?[/INST]The A/D pot interfaces in the 6581 SID chip allow for the connection of external potentiometers, enabling the control of various parameters through external inputs."
"[INST]In the context of the C64, what is the purpose of the random number/modulation generator in the 6581 SID chip?[/INST]The random number/modulation generator in the 6581 SID chip provides a source of random or pseudo-random values, which can be used to create complex and interesting sound effects and timbres."
"[INST]In the context of the C64, what is the purpose of the external audio input in the 6581 SID chip?[/INST]The external audio input in the 6581 SID chip allows for the connection of external audio sources, enabling the processing and manipulation of external audio signals."
"[INST]In the context of the C64, Can you change the characters stored in ROM?[/INST]Yes, by changing the memory location that tells the VIC-II chip where to find the characters."
"[INST]In the context of the C64, Can you customize characters?[/INST]Yes, by programming the character memory pointer to point to RAM."
"[INST]In the context of the C64, What happens if you use your own character set?[/INST]The standard Commodore 64 characters become unavailable, so you must copy the ones you want to use into your own character memory in RAM."
"[INST]In the context of the C64, What happens to your BASIC program when you use your own character set?[/INST]It takes up memory space, so you must be careful to protect the character set from being overwritten."
"[INST]In the context of the C64, Can you use location 0 for your character set?[/INST]No, because the system stores important data there."
"[INST]In the context of the C64, Can you use location 2048 for your character set?[/INST]No, because that's where your BASIC program starts."
"[INST]In the context of the C64, What is the best place to put your character set for use with BASIC?[/INST]'Beginning at 12288 ($3000 in HEX) is recommended."
"[INST]In the context of the C64, Can you use the standard Commodore 64 characters with your own character set?[/INST]No, you must copy them into your own character memory in RAM."
"[INST]In the context of the C64, What happens if you don't copy the standard Commodore 64 characters?[/INST]They become unavailable."
"[INST]In the context of the C64, Can you choose which standard Commodore 64 characters to copy?[/INST]Yes, you can pick and choose which ones you want."
"[INST]In the context of the C64, Can you keep the standard Commodore 64 characters in order?[/INST]No, you don't have to keep them in order."
"[INST]In the context of the C64, Can you use the same memory for your BASIC program and character set?[/INST]No, you must protect the character set from being overwritten."
"[INST]In the context of the C64, Can you use location 53272 for your character set?[/INST]Yes, by POKEing the low 4 bits of that location."
"[INST]In the context of the C64, Can you start your character set at location 0?[/INST]No, because the system stores important data there."
"[INST]In the context of the C64, Can you start your character set at location 2048?[/INST]No, because that's where your BASIC program starts."
"[INST]In the context of the C64, Can you start your character set at location 12288?[/INST]Yes, that's a recommended starting position."
"[INST]In the context of the C64, Can you use the same memory for your character set and graphics?[/INST]No, you must copy the graphics into your own character memory in RAM."
"[INST]In the context of the C64, Can you use the same memory for your character set and letters?[/INST]No, you must copy the letters into your own character memory in RAM."
"[INST]In the context of the C64, Can you use the same memory for your character set and numbers?[/INST]No, you must copy the numbers into your own character memory in RAM."
"[INST]In the context of the C64, Can you use the same memory for your character set and standard Commodore 64 graphics?[/INST]No, you must copy the graphics into your own character memory in RAM."
"[INST]In the context of the C64, Can you use the same memory for your character set and standard Commodore 64 letters?[/INST]No, you must copy the letters into your own character memory in RAM."
"[INST]In the context of the C64, Can you use the same memory for your character set and standard Commodore 64 numbers?[/INST]No, you must copy the numbers into your own character memory in RAM."
"[INST]In the context of the C64, Can you use the same memory for your character set and standard Commodore 64 graphics, letters, and numbers?[/INST]No, you must copy them into your own character memory in RAM."
"[INST]In the context of the C64, Can you use the same memory for your character set and standard Commodore 64 characters?[/INST]No, you must copy the characters into your own character memory in RAM."
"[INST]In the context of the C64, what is the purpose of the BNE instruction in 6502 assembly language?[/INST]The BNE instruction, short for Branch on result not zero, is used to alter the program flow based on the result of a previous operation. It checks the zero flag and if it is clear, i.e., the result is not zero, the program counter is loaded with the target address, effectively branching to that location."
"[INST]In the context of the C64, What is the addressing mode used by the BNE instruction?[/INST]The BNE instruction uses the relative addressing mode, which means that the target address is specified as an offset from the current program counter."
"[INST]In the context of the C64, What is the assembly language form of the BNE instruction?[/INST]The assembly language form of the BNE instruction is BMI Oper, where Oper is the target address or label."
"[INST]In the context of the C64, What is the OP code for the BNE instruction?[/INST]The OP code for the BNE instruction is D0."
"[INST]In the context of the C64, How many bytes does the BNE instruction occupy in memory?[/INST]The BNE instruction occupies 2 bytes in memory."
"[INST]In the context of the C64, How many cycles does the BNE instruction take to execute?[/INST]The BNE instruction takes 2 cycles to execute, but this can increase to 3 or 4 cycles if the branch occurs to the same page or a different page, respectively."
"[INST]In the context of the C64, What happens to the program counter when the BNE instruction is executed?[/INST]When the BNE instruction is executed, the program counter is loaded with the target address if the zero flag is clear, effectively branching to that location."
"[INST]In the context of the C64, What is the condition for the BNE instruction to branch to a new location?[/INST]The BNE instruction branches to a new location if the zero flag is clear, i.e., the result of the previous operation is not zero."
"[INST]In the context of the C64, How does the BNE instruction handle page boundaries?[/INST]The BNE instruction adds 1 cycle to its execution time if the branch occurs to the same page, and adds 2 cycles if the branch occurs to a different page."
"[INST]In the context of the C64, What is the purpose of the zero flag in the context of the BNE instruction?[/INST]The zero flag is used by the BNE instruction to determine whether to branch to a new location or not. If the zero flag is set, the result of the previous operation is zero, and the branch is not taken."
"[INST]In the context of the C64, What is the frequency of the clock used as the 65XX processor Phase 0?[/INST]1-MHz"
"[INST]In the context of the C64, What is the clock used as the 65XX processor Phase 0?[/INST]1-MHz clock"
"[INST]In the context of the C64, What is the clock frequency generated by dividing the 8-MHz video input clock by?[/INST]eight"
"[INST]In the context of the C64, What is the clock frequency generated by dividing the 8-MHz video input clock?[/INST]1-MHz"
"[INST]In the context of the C64, What is the clock used as the 65XX processor Phase 0 in?[/INST]1-MHz clock"
"[INST]In the context of the C64, What is the clock frequency generated by dividing the 8-MHz video input clock by eight?[/INST]1-MHz"
"[INST]In the context of the C64, What is the clock frequency generated by dividing the 8-MHz video input clock?[/INST]1-MHz"
"[INST]In the context of the C64, What is the clock used as the 65XX processor Phase 0 in?[/INST]1-MHz clock"
"[INST]In the context of the C64, What is the clock frequency generated by dividing the 8-MHz video input clock?[/INST]1-MHz"
"[INST]In the context of the C64, What is the clock used as the 65XX processor Phase 0?[/INST]1-MHz clock"
"[INST]In the context of the C64, what is the maximum number of possible positions a sprite can have in the horizontal direction?[/INST]A sprite can have 512 possible positions in the left/right, X direction, which is achieved by adding an extra bit to control the X position, allowing for more possible combinations than can be seen on the visible part of the screen."
"[INST]In the context of the C64, How does the X MOST SIGNIFICANT BIT POSITION register affect the X position of a sprite?[/INST]The X MOST SIGNIFICANT BIT POSITION register must be set to 1 (turned ON) if the X position of a sprite is greater than 255 (on the right side of the screen), and set to 0 (turned OFF) if the X position of a sprite is less than 256 (on the left side of the screen)."
"[INST]In the context of the C64, What is the range of X positions that are visible on the screen?[/INST]The X positions that are visible on the screen range from 24 to 343, which is a subset of the total 512 possible positions."
"[INST]In the context of the C64, What is the purpose of the extra bit used to control the X position of a sprite?[/INST]The extra bit is used to control the X position of a sprite, allowing for 512 possible positions in the horizontal direction, which is necessary because there are more than 256 positions in the horizontal direction."
"[INST]In the context of the C64, How do the bits in the X MSB register correspond to sprites?[/INST]Bits 0 to 7 of the X MSB register correspond to sprites 0 to 7, respectively, which allows for the control of the X position of each sprite."
"[INST]In the context of the C64, What happens when the X position of a sprite is greater than 255?[/INST]When the X position of a sprite is greater than 255, the bit in the X MOST SIGNIFICANT BIT POSITION register must be set to 1 (turned ON)."
"[INST]In the context of the C64, What is the significance of the X MSB register in controlling the X position of a sprite?[/INST]The X MSB register plays a crucial role in controlling the X position of a sprite, as it determines whether the sprite is on the left or right side of the screen, and allows for the correct positioning of the sprite."
"[INST]In the context of the C64, How does the horizontal positioning of a sprite differ from the vertical positioning?[/INST]The horizontal positioning of a sprite is more complicated than the vertical positioning because it requires an extra bit to control the X position, allowing for 512 possible positions, whereas the vertical positioning only requires 256 possible positions."
"[INST]In the context of the C64, What is the range of values that a sprite's X position can take?[/INST]A sprite's X position can take values from 0 to 511, although only values between 24 and 343 are visible on the screen."
"[INST]In the context of the C64, In what way does the X MSB register affect the visibility of a sprite on the screen?[/INST]The X MSB register affects the visibility of a sprite on the screen by determining whether the sprite is on the left or right side of the screen, and thus whether it is visible or not."
"[INST]In the context of the C64, Does the 6566/6567 video controller interact with the system data bus?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the AEC signal in the 6566/6567 devices?[/INST]To disable the processor address bus drivers"
"[INST]In the context of the C64, What is the frequency of the 1-MHz clock provided by the video chips?[/INST]1 MHz"
"[INST]In the context of the C64, What is the duration of a memory cycle in the 6566/6567 devices?[/INST]500 ns"
"[INST]In the context of the C64, What is the purpose of the BA signal in the 6566/6567 devices?[/INST]To indicate that the video chip will require a Phase 2 data access"
"[INST]In the context of the C64, How many Phase-2 times are allowed after BA low for the processor to complete any current memory accesses?[/INST]Three"
"[INST]In the context of the C64, What is the purpose of the sprite data fetches in the 6566/6567 devices?[/INST]To fetch sprite data"
"[INST]In the context of the C64, How many memory accesses are required to fetch the video matrix pointers?[/INST]40"
"[INST]In the context of the C64, What is the condition for fetching sprite pointers in the 6566/6567 devices?[/INST]Every other Phase 1 at the end of each raster line"
"[INST]In the context of the C64, What is the purpose of the 6566/6567 devices in the system?[/INST]To provide the interface control signals required to maintain bus sharing"
"[INST]In the context of the C64, What is the duration of a character pointer fetch in the 6566/6567 devices?[/INST]40 consecutive Phase 2 accesses"
"[INST]In the context of the C64, What is the purpose of the 1-MHz clock in the 6566/6567 devices?[/INST]To provide a clock for the video chips"
"[INST]In the context of the C64, What is the condition for fetching sprite data in the 6566/6567 devices?[/INST]Every eighth raster line during the display window"
"[INST]In the context of the C64, what is accumulator addressing[/INST]This form of addressing is represented with a one byte instruction, implying an operation on the accumulator."
"[INST]In the context of the C64, what is immediate addressing[/INST]In immediate addressing, the operand is contained in the second byte of the instruction, with no further memory addressing required."
"[INST]In the context of the C64, what is absolute addressing[/INST]In absolute addressing, the second byte of the instruction specifies the eight low order bits of the effective address while the third byte specifies the eight high order bits."
"[INST]In the context of the C64, what is zero page addressing[/INST]The zero page instructions allow for shorter code and execution times by only fetching the second byte of the instruction and assuming a zero high address byte."
"[INST]In the context of the C64, what is indexed zero page addressing[/INST]This form of addressing is used in conjunction with the index register and is referred to as Zero Page, X or Zero Page, Y."
"[INST]In the context of the C64, what is indexed absolute addressing[/INST]This form of addressing is used in conjunction with X and Y index register and is referred to as Absolute, X, and Absolute, Y."
"[INST]In the context of the C64, what is implied addressing[/INST]In the implied addressing mode, the address containing the operand is implicitly stated in the operation code of the instruction."
"[INST]In the context of the C64, what is relative addressing[/INST]Relative addressing is used only with branch instructions and establishes a destination for the conditional branch."
"[INST]In the context of the C64, what is indexed indirect addressing[/INST]In indexed indirect addressing, the second byte of the instruction is added to the contents of the X index register, discarding the carry."
"[INST]In the context of the C64, what is indirect indexed addressing[/INST]In indirect indexed addressing, the second byte of the instruction points to a memory location in page zero."
"[INST]In the context of the C64, what is absolute indirect addressing[/INST]The second byte of the instruction contains the low order eight bits of a memory location."
"[INST]In the context of the C64, what is the advantage of zero page addressing[/INST]Careful use of the zero page can result in significant increase in code efficiency."
"[INST]In the context of the C64, in what mode does the operand is contained in the second byte of the instruction[/INST]Immediate addressing"
"[INST]In the context of the C64, in what mode the address is implicitly stated in the operation code of the instruction[/INST]Implied addressing"
"[INST]In the context of the C64, in what mode the second byte of the instruction specifies the eight low order bits of the effective address[/INST]Absolute addressing"
"[INST]In the context of the C64, in what mode the second byte of the instruction points to a memory location in page zero[/INST]Indirect indexed addressing"
"[INST]In the context of the C64, in what mode the second byte of the instruction is added to the contents of the X index register[/INST]Indexed indirect addressing"
"[INST]In the context of the C64, what is the range of the offset in relative addressing[/INST]-128 to +127 bytes from the next instruction"
"[INST]In the context of the C64, what is the effective address formed by in indexed absolute addressing[/INST]adding the contents of X and Y to the address contained in the second and third bytes of the instruction"
"[INST]In the context of the C64, what is the effective address formed by in indexed indirect addressing[/INST]the result of the addition points to a memory location on page zero whose contents is the low order eight bits of the effective address"
"[INST]In the context of the C64, what is the effective address formed by in indirect indexed addressing[/INST]the contents of this memory location is added to the contents of the Y index register, the result being the low order eight bits of the effective address"
"[INST]In the context of the C64, what is the effective address formed by in absolute indirect addressing[/INST]the contents of the fully specified memory location is the low order byte of the effective address"
"[INST]In the context of the C64, what is the advantage of indexed absolute addressing[/INST]allows the index register to contain the index or count value and the instruction to contain the base address"
"[INST]In the context of the C64, what is the advantage of indexed zero page addressing[/INST]allows for shorter code and execution times"
"[INST]In the context of the C64, in what mode the high order eight bits of the effective address is contained in the third byte of the instruction[/INST]Absolute addressing"
"[INST]In the context of the C64, in what mode the high order eight bits of the effective address is contained in the next page zero memory location[/INST]Indexed indirect addressing"
"[INST]In the context of the C64, in what mode the high order eight bits of the effective address is contained in the next memory location[/INST]Indirect indexed addressing"
"[INST]In the context of the C64, in what mode the high order eight bits of the effective address is contained in the next memory location[/INST]Absolute indirect addressing"
"[INST]In the context of the C64, what is the purpose of indexed absolute addressing[/INST]allows any location referencing and the index to modify multiple fields resulting in reduced coding and execution time"
"[INST]In the context of the C64, what is the numerical value stored in the SID Oscillator frequency control registers to produce the notes of the equal-tempered musical scale[/INST]The numerical values which must be stored in the SID Oscillator frequency control registers to produce the notes of the equal-tempered musical scale are listed in the table in Appendix E"
"[INST]In the context of the C64, what is the equal-tempered scale[/INST]The equal-tempered scale consists of an octave containing 12 semitones (notes): C,D,E,F,G,A,B and C#,D#,F#,G#,A#"
"[INST]In the context of the C64, how is the frequency of each semitone calculated[/INST]The frequency of each semitone is exactly the 12th root of 2 times the frequency of the previous semitone"
"[INST]In the context of the C64, what is the frequency of A-4 in concert pitch[/INST]440 Hz"
"[INST]In the context of the C64, what is the advantage of determining the note value algorithmically[/INST]Memory efficiency can be improved by determining the note value algorithmically"
"[INST]In the context of the C64, how can the note look-up table be reduced[/INST]The note look-up table can be reduced from 96 entries to 12 entries, as there are 12 notes per octave"
"[INST]In the context of the C64, what is the formula to derive notes in lower octaves[/INST]Notes in lower octaves can be derived by choosing the appropriate note in the eighth octave and dividing the 16-bit value by two for each octave of difference"
"[INST]In the context of the C64, why is division by two equivalent to a right-shift of the value[/INST]Division by two is nothing more than a right-shift of the value"
"[INST]In the context of the C64, what is the purpose of including note B-7 in the table[/INST]Note B-7 is included in the table for calculation purposes"
"[INST]In the context of the C64, how is the information about the semitone and octave specified[/INST]Each note must be specified in a form which indicates which of the 12 semitones is desired, and which of the eight octaves the semitone is in"
"[INST]In the context of the C64, how many bits are necessary to select 1 of 12 semitones[/INST]Four bits are necessary to select 1 of 12 semitones"
"[INST]In the context of the C64, how many bits are necessary to select 1 of 8 octaves[/INST]Three bits are necessary to select 1 of 8 octaves"
"[INST]In the context of the C64, how can the information fit in one byte[/INST]The information can fit in one byte, with the lower nybble selecting the semitone (by addressing the look-up table) and the upper nybble being used by the division routine to determine how many times the table value must be right-shifted"
"[INST]In the context of the C64, what is the purpose of the upper nybble in the byte[/INST]The upper nybble is used by the division routine to determine how many times the table value must be right-shifted"
"[INST]In the context of the C64, what is the purpose of the lower nybble in the byte[/INST]The lower nybble selects the semitone (by addressing the look-up table)"
"[INST]In the context of the C64, what is the advantage of using a software routine to calculate notes[/INST]The calculation can easily be accomplished by a simple software routine"
"[INST]In the context of the C64, what is the formula to calculate notes in higher octaves[/INST]Each note in an octave is exactly half the frequency of that note in the next octave"
"[INST]In the context of the C64, what is the range of the oscillators[/INST]The range of the oscillators is limited, and note B-7 is beyond the range of the oscillators"
"[INST]In the context of the C64, what is the purpose of the table in Appendix E[/INST]The table in Appendix E provides a simple and quick method for generating the equal-tempered scale"
"[INST]In the context of the C64, what is the disadvantage of using the table in Appendix E[/INST]The table in Appendix E is very memory inefficient as it requires 192 bytes for the table alone"
"[INST]In the context of the C64, what is the alternative to using the table in Appendix E[/INST]Determining the note value algorithmically is an alternative to using the table in Appendix E"
"[INST]In the context of the C64, what is the advantage of using a 16-bit value for each note[/INST]The 16-bit value for each note can be divided by two for each octave of difference"
"[INST]In the context of the C64, what is the purpose of the MSB of B-7[/INST]The MSB of B-7 would require a special software case, such as generating this bit in the CARRY before shifting"
"[INST]In the context of the C64, Which video interface chip has thirteen fully decoded addresses?[/INST]The 6566"
"[INST]In the context of the C64, What is the difference between the 6566 and 6567 video interface chips?[/INST]The 6566 has thirteen fully decoded addresses for direct connection to the system address bus, while the 6567 has multiplexed addresses for direct connection to 64K dynamic RAMS."
"[INST]In the context of the C64, What is the purpose of the pins A11-A07 on the 6567?[/INST]The pins A11-A07 on the 6567 are static address outputs to allow direct connection of these bits to a conventional 16K (2K*8) ROM."
"[INST]In the context of the C64, What is the significance of the /RAS signal in the 6567?[/INST]/RAS is brought low while the least significant address bits, A06-A00, are present."
"[INST]In the context of the C64, What is the significance of the /CAS signal in the 6567?[/INST]/CAS is brought low while the most significant bits, A13-A08, are present."
"[INST]In the context of the C64, What is the purpose of the address output configurations in the 6566 and 6567?[/INST]The address output configurations allow direct connection to the system address bus or 64K dynamic RAMS."
"[INST]In the context of the C64, What is the difference in address output configurations between the 6566 and 6567?[/INST]The 6566 has thirteen fully decoded addresses, while the 6567 has multiplexed addresses."
"[INST]In the context of the C64, What is the purpose of the external latching in the 6567?[/INST]The external latching is required for the lower order addresses."
"[INST]In the context of the C64, What is the purpose of the address bits A06-A00 in the 6567?[/INST]The address bits A06-A00 are present on A06-A00 while /RAS is brought low."
"[INST]In the context of the C64, What is the purpose of the address bits A13-A08 in the 6567?[/INST]The address bits A13-A08 are present on A05-A00 while /CAS is brought low."
"[INST]In the context of the C64, What is the purpose of the /IRQ output in a device?[/INST]The /IRQ output is brought low when an enabled source of interrupt occurs within the device, indicating that an interrupt has been triggered and needs to be handled."
"[INST]In the context of the C64, What is the characteristic of the /IRQ output?[/INST]The /IRQ output is open drain, which means it requires an external pull-up resistor to function properly."
"[INST]In the context of the C64, What happens when an enabled source of interrupt occurs within the device?[/INST]When an enabled source of interrupt occurs within the device, the /IRQ output is brought low, signaling that an interrupt has been triggered and needs to be handled."
"[INST]In the context of the C64, What type of resistor is required for the /IRQ output to function?[/INST]An external pull-up resistor is required for the /IRQ output to function properly, as it is an open drain output."
"[INST]In the context of the C64, What is the effect of an enabled source of interrupt on the /IRQ output?[/INST]When an enabled source of interrupt occurs, the /IRQ output is brought low, indicating that an interrupt has been triggered and needs to be handled."
"[INST]In the context of the C64, In what situation is the /IRQ output brought low?[/INST]The /IRQ output is brought low when an enabled source of interrupt occurs within the device."
"[INST]In the context of the C64, What is the significance of the /IRQ output being open drain?[/INST]The /IRQ output being open drain means that it requires an external pull-up resistor to function properly, which is an important consideration in circuit design."
"[INST]In the context of the C64, How does the /IRQ output respond to an enabled source of interrupt?[/INST]The /IRQ output responds to an enabled source of interrupt by being brought low, signaling that an interrupt has been triggered and needs to be handled."
"[INST]In the context of the C64, What is the role of the external pull-up resistor in the /IRQ output circuit?[/INST]The external pull-up resistor is required to enable the /IRQ output to function properly, as it is an open drain output."
"[INST]In the context of the C64, What is the relationship between the /IRQ output and enabled sources of interrupt?[/INST]The /IRQ output is brought low when an enabled source of interrupt occurs within the device, indicating that an interrupt has been triggered and needs to be handled."
"[INST]In the context of the C64, SID: What is the number of semitones in an octave?[/INST]12"
"[INST]In the context of the C64, SID: What is the frequency of A-4 in concert pitch?[/INST]440 Hz"
"[INST]In the context of the C64, SID: What is the formula for calculating the frequency of each semitone?[/INST]The 12th root of 2 times the frequency of the previous semitone"
"[INST]In the context of the C64, SID: What is the purpose of the table in Appendix E?[/INST]To produce the notes of the equal-tempered scale"
"[INST]In the context of the C64, SID: What is the range of the oscillators?[/INST](Not specified)"
"[INST]In the context of the C64, SID: What is the size of the note look-up table?[/INST]192 bytes"
"[INST]In the context of the C64, SID: What is the size of the optimized note look-up table?[/INST]24 bytes"
"[INST]In the context of the C64, SID: How many entries are in the optimized note look-up table?[/INST]12"
"[INST]In the context of the C64, SID: What is the purpose of dividing the 16-bit value by two?[/INST]To calculate notes in lower octaves"
"[INST]In the context of the C64, SID: What is the range of the note B-7?[/INST](Beyond the range of the oscillators)"
"[INST]In the context of the C64, SID: What is the purpose of including note B-7 in the table?[/INST]For calculation purposes"
"[INST]In the context of the C64, SID: What is the format of specifying a note?[/INST]One byte with the lower nybble selecting the semitone and the upper nybble selecting the octave"
"[INST]In the context of the C64, SID: What is the purpose of the division routine?[/INST]To determine how many times the table value must be right-shifted"
"[INST]In the context of the C64, SID: What is the number of bits necessary to select 1 of 12 semitones?[/INST]4 bits"
"[INST]In the context of the C64, SID: What is the number of bits necessary to select 1 of 8 octaves?[/INST]3 bits"
"[INST]In the context of the C64, SID: What is the total number of bits necessary to specify a note?[/INST]7 bits"
"[INST]In the context of the C64, SID: What is the purpose of the SID Oscillator frequency control registers?[/INST]To produce the notes of the equal-tempered scale"
"[INST]In the context of the C64, SID: What is the frequency of the master clock?[/INST]1.02 MHz"
"[INST]In the context of the C64, SID: What is the equation given in the Register Description?[/INST](Not specified)"
"[INST]In the context of the C64, SID: What is the purpose of the Register Description?[/INST]To provide an equation for use of other master clock frequencies"
"[INST]In the context of the C64, SID: What is the purpose of the equal-tempered scale?[/INST]To provide a simple and quick method for generating the scale"
"[INST]In the context of the C64, SID: What is the memory efficiency of the optimized note look-up table?[/INST]Improved"
"[INST]In the context of the C64, SID: What is the size of the optimized note look-up table in bytes?[/INST]24 bytes"
"[INST]In the context of the C64, SID: What is the number of notes per octave?[/INST]12"
"[INST]In the context of the C64, SID: What is the purpose of the note look-up table?[/INST]To generate the equal-tempered scale"
"[INST]In the context of the C64, SID: What is the purpose of the SID Oscillator?[/INST]To produce the notes of the equal-tempered scale"
"[INST]In the context of the C64, SID: What is the frequency of the note A-4 in concert pitch?[/INST]440 Hz"
"[INST]In the context of the C64, SID: What is the purpose of the SID Oscillator frequency control registers?[/INST]To produce the notes of the equal-tempered scale"
"[INST]In the context of the C64, SID: What is the purpose of the SID Oscillator?[/INST]To produce the notes of the equal-tempered scale"
"[INST]In the context of the C64, What is the purpose of the CINT function in Commodore 64?[/INST]The purpose of the CINT function is to initialize the screen editor and the 6567 video chip in the Commodore 64 for normal operation."
"[INST]In the context of the C64, What is the call address of the CINT function?[/INST]The call address of the CINT function is $FF81 in hexadecimal, which is equivalent to 65409 in decimal."
"[INST]In the context of the C64, What are the communication registers used by the CINT function?[/INST]The CINT function does not use any communication registers."
"[INST]In the context of the C64, What preparatory routines are required before calling the CINT function?[/INST]No preparatory routines are required before calling the CINT function."
"[INST]In the context of the C64, What error returns can be expected from the CINT function?[/INST]The CINT function does not return any errors."
"[INST]In the context of the C64, What is the stack requirement for calling the CINT function?[/INST]The stack requirement for calling the CINT function is 4 bytes."
"[INST]In the context of the C64, What registers are affected by the CINT function?[/INST]The CINT function affects the A, X, and Y registers."
"[INST]In the context of the C64, In what context should the CINT function be called?[/INST]The CINT function should be called by a Commodore 64 program cartridge."
"[INST]In the context of the C64, How do you use the CINT function in a program?[/INST]To use the CINT function, you simply need to call it using the JSR instruction, for example: JSR CINT, followed by a JMP instruction to begin execution."
"[INST]In the context of the C64, What is the role of the KERNAL screen editor in the CINT function?[/INST]The KERNAL screen editor is initialized by the CINT function, which sets up the screen editor for normal operation."
"[INST]In the context of the C64, What is the significance of the 6567 video controller chip in the CINT function?[/INST]The 6567 video controller chip is set up for normal operation by the CINT function, which is necessary for the Commodore 64 to function properly."
"[INST]In the context of the C64, How are characters formed in the Commodore 64?[/INST]Each character is formed in an 8 by 8 grid of dots, where each dot may be either on or off, and the characters are stored in the Character Generator ROM chip as a set of 8 bytes for each character, with each byte representing the dot pattern of a row in the character, and each bit representing a dot, where a zero bit means that dot is off, and a one bit means the dot is on."
"[INST]In the context of the C64, What is the starting location of the character memory in ROM?[/INST]The character memory in ROM begins at location 53248 (when the I/O is switched off)."
"[INST]In the context of the C64, What is stored in the first 8 bytes of the character memory?[/INST]The first 8 bytes from location 53248 ($D000) to 53255 ($D007) contain the pattern for the @ sign, which has a character code value of zero in the screen memory."
"[INST]In the context of the C64, What is stored in the next 8 bytes of the character memory?[/INST]The next 8 bytes, from location 53256 ($D008) to 53263 ($D00F), contain the information for forming the letter A."
"[INST]In the context of the C64, How much memory does a complete character set take up?[/INST]Each complete character set takes up 2K (2048 bits) of memory, 8 bytes per character and 256 characters."
"[INST]In the context of the C64, How much memory does the character generator ROM take up in total?[/INST]The character generator ROM takes up a total of 4K locations, since there are two character sets, one for upper case and graphics and the other with upper and lower case."
"[INST]In the context of the C64, What is the organization of character data in the ROM chip?[/INST]The characters are stored as a set of 8 bytes for each character, with each byte representing the dot pattern of a row in the character, and each bit representing a dot."
"[INST]In the context of the C64, What is the significance of a zero bit in the character data?[/INST]A zero bit means that dot is off."
"[INST]In the context of the C64, What is the significance of a one bit in the character data?[/INST]A one bit means the dot is on."
"[INST]In the context of the C64, How many characters are stored in the character generator ROM?[/INST]There are 256 characters stored in the character generator ROM."
"[INST]In the context of the C64, What is the mode in which the 6566/6567 fetches CHARACTER POINTERs from the VIDEO MATRIX area of memory?[/INST]character display mode"
"[INST]In the context of the C64, What is the size of the VIDEO MATRIX area of memory?[/INST]1000 consecutive locations"
"[INST]In the context of the C64, What is the function of VM13-VM10 in register 24?[/INST]defines the 4 MSB of the video matrix address"
"[INST]In the context of the C64, What is the purpose of the internal counter (VC9-VC0)?[/INST]steps through the 1000 character locations"
"[INST]In the context of the C64, How many address outputs does the 6566/6567 provide?[/INST]14"
"[INST]In the context of the C64, What is the maximum number of different character definitions that can be available simultaneously?[/INST]256"
"[INST]In the context of the C64, What is the size of each character in the character base?[/INST]8*8 dot matrix stored in 8 consecutive bytes"
"[INST]In the context of the C64, What defines the location of the character base?[/INST]CB13-CB11 in register 24"
"[INST]In the context of the C64, What is the function of the 8-bit character pointer?[/INST]selects a particular character"
"[INST]In the context of the C64, What is the function of the 3-bit raster counter (RC2-RC0)?[/INST]selects one of the eight character bytes"
"[INST]In the context of the C64, What is the format of the resulting characters?[/INST]25 rows of 40 characters each"
"[INST]In the context of the C64, What is associated with each video matrix location?[/INST]a 4-bit COLOR NYBBLE"
"[INST]In the context of the C64, What does the 4-bit COLOR NYBBLE define?[/INST]one of sixteen colors for each character"
"[INST]In the context of the C64, What is the width of the video matrix memory?[/INST]12 bits"
"[INST]In the context of the C64, In what mode are the 8 sequential bytes from the character base displayed directly?[/INST]standard character mode"
"[INST]In the context of the C64, What is the function of a '0' bit in the standard character mode?[/INST]causes the background #0 color to be displayed"
"[INST]In the context of the C64, What is the function of a '1' bit in the standard character mode?[/INST]displays the color selected by the color nybble"
"[INST]In the context of the C64, What is the background color determined by?[/INST]register 33 ($21)"
"[INST]In the context of the C64, What is the foreground color determined by?[/INST]the 4-bit color nybble"
"[INST]In the context of the C64, How many colors can be selected by the 4-bit color nybble?[/INST]16"
"[INST]In the context of the C64, What determines the unique color of each character?[/INST]the 4-bit color nybble"
"[INST]In the context of the C64, Do all characters share a common background color?[/INST]yes"
"[INST]In the context of the C64, What is the size of the CHARACTER BASE area of memory?[/INST]2048 bytes"
"[INST]In the context of the C64, What is the function of the VIDEO MATRIX?[/INST]stores character pointers"
"[INST]In the context of the C64, What is the size of each character pointer?[/INST]8 bits"
"[INST]In the context of the C64, How many character locations are there in the VIDEO MATRIX?[/INST]1000"
"[INST]In the context of the C64, What is the purpose of the CHARACTER POINTER ADDRESS?[/INST]defines the address of the character"
"[INST]In the context of the C64, What is the purpose of the CHARACTER DATA ADDRESS?[/INST]defines the address of the character data"
"[INST]In the context of the C64, What is another important principle in machine language?[/INST]Testing and detecting certain conditions"
"[INST]In the context of the C64, What happens to the zero result flag when an instruction has a zero result?[/INST]It is set"
"[INST]In the context of the C64, What is the purpose of the BEQ instruction?[/INST]To branch if the result is equal to zero"
"[INST]In the context of the C64, What is the opposite of the BEQ instruction?[/INST]BNE, which means Branch on result Not Equal to zero"
"[INST]In the context of the C64, What happens to the X index register when it reaches its maximum value?[/INST]It wraps around to zero"
"[INST]In the context of the C64, What is the purpose of the INX instruction?[/INST]To increment the X index register"
"[INST]In the context of the C64, What is the opposite of the INX instruction?[/INST]DEX, which is decrement the X index register"
"[INST]In the context of the C64, What are the comparison instructions used for?[/INST]To test the index registers with specific values or memory locations"
"[INST]In the context of the C64, What is the purpose of the CPX instruction?[/INST]To compare the X register with a specific value"
"[INST]In the context of the C64, What happens when the CPX instruction is used with the BEQ instruction?[/INST]The program branches to another part of the program if the condition is true"
"[INST]In the context of the C64, What is the range of a branch instruction in 64MON?[/INST]From 128 bytes backward to 127 bytes forward"
"[INST]In the context of the C64, What happens if a branch instruction goes out of range in 64MON?[/INST]The assembler refuses to assemble that instruction"
"[INST]In the context of the C64, What is the advantage of using an assembler like 64MON?[/INST]It calculates the correct offset for the branch instruction"
"[INST]In the context of the C64, Add memory to accumulator with carry[/INST]ADC operation adds the carry flag to the accumulator and the memory location"
"[INST]In the context of the C64, ADC operation[/INST]ADC operation adds the carry flag to the accumulator and the memory location"
"[INST]In the context of the C64, What is the purpose of ADC operation[/INST]ADC operation adds the carry flag to the accumulator and the memory location"
"[INST]In the context of the C64, What is the format of ADC operation[/INST]ADC operation is in the format of A + M + C -> A, C"
"[INST]In the context of the C64, What is the result of ADC operation[/INST]The result of ADC operation is the sum of the accumulator, the memory location and the carry flag"
"[INST]In the context of the C64, What is the use of ADC operation[/INST]ADC operation is used to add the carry flag to the accumulator and the memory location"
"[INST]In the context of the C64, What is the format of ADC operation[/INST]ADC operation is in the format of A + M + C -> A, C"
"[INST]In the context of the C64, What is the result of ADC operation[/INST]The result of ADC operation is the sum of the accumulator, the memory location and the carry flag"
"[INST]In the context of the C64, What is the purpose of ADC operation[/INST]ADC operation adds the carry flag to the accumulator and the memory location"
"[INST]In the context of the C64, What is the format of ADC operation[/INST]ADC operation is in the format of A + M + C -> A, C"
"[INST]In the context of the C64, What is the result of ADC operation[/INST]The result of ADC operation is the sum of the accumulator, the memory location and the carry flag"
"[INST]In the context of the C64, what is the requirement for using multi-color mode in sprites[/INST]In multi-color mode, each colored 'dot' or 'block' in the sprite consists of two pixels side by side, which means you need to use pairs of pixels instead of individual pixels in your sprite picture."
"[INST]In the context of the C64, how many colors can you choose from in multi-color mode[/INST]You can choose from 4 colors in multi-color mode: Sprite Color, Multi-Color 1, Multi-Color 2, and Background Color, which is achieved by using zero settings that let the background color show through."
"[INST]In the context of the C64, what determines the color of each pair of pixels in a sprite picture[/INST]The color of each pair of pixels in a sprite picture is determined by whether the left, right, or both pixels are solid."
"[INST]In the context of the C64, in a horizontal 8-pixel block in a sprite picture, how are the pixels arranged[/INST]In a horizontal 8-pixel block in a sprite picture, each pair of pixels is arranged side by side, with the color of each pair determined by whether the left, right, or both pixels are solid."
"[INST]In the context of the C64, what is the purpose of using zero settings in multi-color mode[/INST]Using zero settings in multi-color mode allows the background color to show through, effectively making it the background color of the sprite."
"[INST]In the context of the C64, how do you achieve a background color in multi-color mode[/INST]You achieve a background color in multi-color mode by using zero settings, which allows the background color to show through."
"[INST]In the context of the C64, in multi-color mode, what happens when both pixels in a pair are solid[/INST]When both pixels in a pair are solid in multi-color mode, the resulting color is determined by the sprite color, multi-color 1, or multi-color 2, depending on the specific configuration."
"[INST]In the context of the C64, what is the significance of pairs of pixels in multi-color mode[/INST]Pairs of pixels are significant in multi-color mode because they determine the color of each 'dot' or 'block' in the sprite picture, with the color depending on whether the left, right, or both pixels are solid."
"[INST]In the context of the C64, how does the arrangement of pixels in a sprite picture affect the color[/INST]The arrangement of pixels in a sprite picture affects the color because the color of each pair of pixels is determined by whether the left, right, or both pixels are solid, which in turn determines the overall color of the sprite."
"[INST]In the context of the C64, in multi-color mode, what is the relationship between pixel pairs and color[/INST]In multi-color mode, pixel pairs are directly related to the color of the sprite, with each pair of pixels determining the color of each 'dot' or 'block' in the sprite picture."
"[INST]In the context of the C64, Where is the INTERRUPT ENABLE REGISTER located?[/INST]The INTERRUPT ENABLE REGISTER is located at 53274 ($D01A)."
"[INST]In the context of the C64, What is the purpose of the interrupt enable register?[/INST]The purpose of the interrupt enable register is to enable or disable interrupts from specific sources, and unless the corresponding bit in the interrupt enable register is set to a 1, no interrupt from that source will take place."
"[INST]In the context of the C64, How do you enable an interrupt request?[/INST]To enable an interrupt request, the corresponding interrupt enable bit must be set to a 1."
"[INST]In the context of the C64, What is the benefit of using interrupts in split screen modes?[/INST]The benefit of using interrupts in split screen modes is that you can have half of the screen bit mapped, half text, more than 8 sprites at a time, etc."
"[INST]In the context of the C64, How can you display more than 8 sprites on the screen?[/INST]You can display more than 8 sprites by using interrupts to switch between different modes, for example, by setting the raster compare register to interrupt at the top of the screen, and then telling the VIC-II chip to get characters from RAM (bit map mode)."
"[INST]In the context of the C64, What is the role of the raster compare register in split screen modes?[/INST]The raster compare register is used to set the point at which the interrupt occurs, for example, halfway down the screen, and when the interrupt occurs, the VIC-II chip is told to get characters from ROM or RAM."
"[INST]In the context of the C64, Why is machine language preferred over BASIC for using display interrupts?[/INST]Machine language is preferred over BASIC for using display interrupts because BASIC isn't fast enough to handle the interrupts efficiently."
"[INST]In the context of the C64, What happens if the corresponding bit in the interrupt enable register is not set to a 1?[/INST]If the corresponding bit in the interrupt enable register is not set to a 1, no interrupt from that source will take place, but the interrupt status register can still be polled for information."
"[INST]In the context of the C64, How can you use interrupts to achieve complex screen modes?[/INST]You can use interrupts to achieve complex screen modes by setting the raster compare register to interrupt at specific points on the screen, and then switching between different modes, such as bit mapped and text modes."
"[INST]In the context of the C64, What is the advantage of using interrupts in graphics programming?[/INST]The advantage of using interrupts in graphics programming is that it allows for more complex and dynamic screen modes, such as split screens and multiple sprites, which would not be possible otherwise."
"[INST]In the context of the C64, what is the opcode for the PLA instruction?[/INST]The opcode for the PLA instruction is 68, which is used to pull the accumulator from the stack."
"[INST]In the context of the C64, what is the addressing mode for the PLA instruction?[/INST]The addressing mode for the PLA instruction is implied, meaning that the instruction operates on the accumulator implicitly."
"[INST]In the context of the C64, how many bytes does the PLA instruction occupy in memory?[/INST]The PLA instruction occupies 1 byte in memory."
"[INST]In the context of the C64, how many cycles does the PLA instruction take to execute?[/INST]The PLA instruction takes 4 cycles to execute."
"[INST]In the context of the C64, what is the purpose of the PLA instruction?[/INST]The purpose of the PLA instruction is to pull the accumulator from the stack, restoring the value of the accumulator from the top of the stack."
"[INST]In the context of the C64, can the PLA instruction be used with an index register?[/INST]No, the PLA instruction cannot be used with an index register because it uses the implied addressing mode."
"[INST]In the context of the C64, what is the assembly language form of the PLA instruction?[/INST]The assembly language form of the PLA instruction is simply 'PLA'."
"[INST]In the context of the C64, in what situation would you use the PLA instruction?[/INST]You would use the PLA instruction when you need to restore the value of the accumulator from the top of the stack, such as after a subroutine call or interrupt."
"[INST]In the context of the C64, how does the PLA instruction affect the flags?[/INST]The PLA instruction does not affect the flags, it only pulls the accumulator from the stack."
"[INST]In the context of the C64, can the PLA instruction be used to pull other registers from the stack?[/INST]No, the PLA instruction can only be used to pull the accumulator from the stack, not other registers."
"[INST]In the context of the C64, What is the purpose of the CHRIN function?[/INST]The purpose of the CHRIN function is to get a character from the input channel, which can be the keyboard or another device set up as the input channel by the KERNAL routine CHKIN."
"[INST]In the context of the C64, What is the call address of the CHRIN function?[/INST]The call address of the CHRIN function is $FFCF (hex) or 65487 (decimal)."
"[INST]In the context of the C64, What is the role of the CHKIN routine in relation to CHRIN?[/INST]The CHKIN routine is used to define another input channel, and if it has not been used, then all data is expected from the keyboard."
"[INST]In the context of the C64, How does the CHRIN function handle input from the keyboard?[/INST]The CHRIN function handles input from the keyboard by turning on the cursor, which blinks until a carriage return is typed, and storing all characters on the line (up to 88 characters) in the BASIC input buffer."
"[INST]In the context of the C64, What is returned in the accumulator after calling the CHRIN function?[/INST]The data byte is returned in the accumulator after calling the CHRIN function."
"[INST]In the context of the C64, What is the purpose of the preparatory routines OPEN and CHKIN?[/INST]The preparatory routines OPEN and CHKIN are used to set up a channel as the input channel before calling the CHRIN function."
"[INST]In the context of the C64, How can you retrieve multiple characters from the keyboard using the CHRIN function?[/INST]You can retrieve multiple characters from the keyboard by calling the CHRIN function once for each character, and storing each character in a buffer."
"[INST]In the context of the C64, What is the significance of the carriage return character in relation to the CHRIN function?[/INST]The carriage return character marks the end of a line of input, and when it is retrieved, the entire line has been processed, and the next call to CHRIN will start a new line of input."
"[INST]In the context of the C64, How can you use the CHRIN function to read data from a device other than the keyboard?[/INST]You can use the CHRIN function to read data from a device other than the keyboard by using the KERNAL OPEN and CHKIN routines to set up the device as the input channel."
"[INST]In the context of the C64, What is the stack requirement for the CHRIN function?[/INST]The stack requirement for the CHRIN function is 7+."
"[INST]In the context of the C64, What is the main purpose of the 64MON cartridge?[/INST]The 64MON cartridge allows users to escape from the world of CBM BASIC and enter the world of machine language, providing features such as displaying internal registers, modifying memory, and a built-in assembler and disassembler to write and edit machine language programs easily."
"[INST]In the context of the C64, What are the benefits of using an assembler when writing machine language programs?[/INST]Using an assembler makes writing machine language programs considerably easier, as it eliminates the need to 'POKE' the program into memory, which is not recommended, and allows for more efficient and organized coding."
"[INST]In the context of the C64, What is the format used in the 64MON manual for machine language examples?[/INST]The 64MON manual uses the format compatible with nearly all assemblers, making the machine language examples shown compatible with any assembler."
"[INST]In the context of the C64, What is the importance of understanding the hexadecimal numbering system in 64MON?[/INST]Understanding the hexadecimal numbering system is crucial in 64MON as it is used to display and modify memory, and is essential for writing and editing machine language programs."
"[INST]In the context of the C64, What are some of the features of the 64MON cartridge?[/INST]The 64MON cartridge features a built-in assembler and disassembler, a screen editor, and the ability to display and modify memory, as well as display the contents of internal registers in the 6510 microprocessor."
"[INST]In the context of the C64, What is the advantage of using 64MON over CBM BASIC?[/INST]Using 64MON provides more flexibility and control over machine language programming, allowing for more efficient and powerful programming compared to CBM BASIC."
"[INST]In the context of the C64, What is the role of the screen editor in 64MON?[/INST]The screen editor in 64MON allows users to display and modify portions of memory on the screen, providing a convenient and efficient way to edit machine language programs."
"[INST]In the context of the C64, What is the purpose of the built-in assembler in 64MON?[/INST]The built-in assembler in 64MON allows users to write and edit machine language programs easily, making it a crucial feature for machine language programming."
"[INST]In the context of the C64, What is the significance of the 6510 microprocessor in 64MON?[/INST]The 6510 microprocessor is the processor used in the Commodore 64, and 64MON allows users to display the contents of its internal registers, providing insight into the processor's operation."
"[INST]In the context of the C64, What is the recommended approach to writing machine language programs without an assembler?[/INST]It is strongly advised against writing machine language programs without an assembler, as it requires 'POKE'-ing the program into memory, which is not recommended, and can lead to errors and difficulties."
"[INST]In the context of the C64, What is the purpose of the ACPTR function?[/INST]The purpose of the ACPTR function is to get data from the serial bus."
"[INST]In the context of the C64, What is the call address of the ACPTR function in hexadecimal?[/INST]The call address of the ACPTR function is $FFA5."
"[INST]In the context of the C64, What is the call address of the ACPTR function in decimal?[/INST]The call address of the ACPTR function is 65445."
"[INST]In the context of the C64, What communication register is used by the ACPTR function?[/INST]The ACPTR function uses communication register A."
"[INST]In the context of the C64, What preparatory routines are required before calling the ACPTR function?[/INST]The preparatory routines TALK and TKSA are required before calling the ACPTR function."
"[INST]In the context of the C64, What error returns can be expected from the ACPTR function?[/INST]The ACPTR function returns errors according to the READST function."
"[INST]In the context of the C64, How much stack is required by the ACPTR function?[/INST]The ACPTR function requires 13 bytes of stack."
"[INST]In the context of the C64, What registers are affected by the ACPTR function?[/INST]The ACPTR function affects registers A and X."
"[INST]In the context of the C64, Can the ACPTR function be used without calling TALK and TKSA first?[/INST]No, the ACPTR function requires the preparatory routines TALK and TKSA to be called before it can be used."
"[INST]In the context of the C64, What is the primary function of the communication register A used by the ACPTR function?[/INST]The primary function of communication register A used by the ACPTR function is to facilitate data transfer over the serial bus."
"[INST]In the context of the C64, what is the purpose of the 02 clock input[/INST]The 02 clock is a TTL compatible input used for internal device operation and as a timing reference for communicating with the system data bus."
"[INST]In the context of the C64, what is the function of the /CS-Chip Select Input[/INST]The /CS input controls the activity of the 6526. A low level on /CS while 02 is high causes the device to respond to signals on the R/W and address (RS) lines."
"[INST]In the context of the C64, what is the purpose of the R/W-Read/Write Input[/INST]The R/W signal is normally supplied by the microprocessor and controls the direction of data transfers of the 6526."
"[INST]In the context of the C64, what are the functions of the RS3-RS0-Address Inputs[/INST]The address inputs select the internal registers as described by the Register Map."
"[INST]In the context of the C64, what is the purpose of the DB7-DB0-Data Bus Inputs/Outputs[/INST]The eight data bus pins transfer information between the 6526 and the system data bus."
"[INST]In the context of the C64, what is the purpose of the IRQ-Interrupt Request Output[/INST]IRQ is an open drain output normally connected to the processor interrupt input."
"[INST]In the context of the C64, what is the purpose of the /RES-Reset Input[/INST]A low on the RES pin resets all internal registers."
"[INST]In the context of the C64, what is the purpose of the 6526 interface signals[/INST]The 6526 interface signals are used for internal device operation and as a timing reference for communicating with the system data bus."
"[INST]In the context of the C64, what is the function of the /CS-Chip Select Input in the 6526 interface signals[/INST]The /CS input controls the activity of the 6526."
"[INST]In the context of the C64, what is the purpose of the R/W-Read/Write Input in the 6526 interface signals[/INST]The R/W signal is normally supplied by the microprocessor and controls the direction of data transfers of the 6526."
"[INST]In the context of the C64, Is the accumulator used in accumulator addressing?[/INST]Yes"
"[INST]In the context of the C64, What is the second byte of the instruction used for in immediate addressing?[/INST]Contains the operand"
"[INST]In the context of the C64, What is the purpose of the third byte in absolute addressing?[/INST]Specifies the eight high order bits of the effective address"
"[INST]In the context of the C64, What is the advantage of zero page addressing?[/INST]Faster execution times"
"[INST]In the context of the C64, What is the purpose of the index register in indexed zero page addressing?[/INST]To calculate the effective address"
"[INST]In the context of the C64, What is the difference between indexed zero page and absolute addressing?[/INST]Indexed zero page does not cross page boundaries"
"[INST]In the context of the C64, What is implied addressing?[/INST]The address is implicitly stated in the operation code"
"[INST]In the context of the C64, What is the purpose of the offset in relative addressing?[/INST]To establish a destination for the conditional branch"
"[INST]In the context of the C64, What is the range of the offset in relative addressing?[/INST]-128 to +127 bytes"
"[INST]In the context of the C64, What is the purpose of the X index register in indexed indirect addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the Y index register in indirect indexed addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the program counter in absolute indirect addressing?[/INST]To load the high order byte of the effective address"
"[INST]In the context of the C64, What is the purpose of the second byte in absolute indirect addressing?[/INST]Contains the low order eight bits of a memory location"
"[INST]In the context of the C64, What is the purpose of the third byte in absolute indirect addressing?[/INST]Contains the high order eight bits of a memory location"
"[INST]In the context of the C64, What is the purpose of the index register in indexed absolute addressing?[/INST]To add to the second and third bytes of the instruction"
"[INST]In the context of the C64, What is the purpose of the Y index register in indexed absolute addressing?[/INST]To add to the second and third bytes of the instruction"
"[INST]In the context of the C64, What is the purpose of the X index register in indexed absolute addressing?[/INST]To add to the second and third bytes of the instruction"
"[INST]In the context of the C64, What is the purpose of the program counter in indexed absolute addressing?[/INST]To add to the second and third bytes of the instruction"
"[INST]In the context of the C64, What is the purpose of the index register in indirect indexed addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the Y index register in indirect indexed addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the X index register in indirect indexed addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the program counter in indirect indexed addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the index register in absolute indirect addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the Y index register in absolute indirect addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the X index register in absolute indirect addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the program counter in absolute indirect addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the index register in indexed zero page addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the Y index register in indexed zero page addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, What is the purpose of the X index register in indexed zero page addressing?[/INST]To add to the second byte of the instruction"
"[INST]In the context of the C64, Call address of SCREEN function[/INST]$FFED (hex) 65517 (decimal)"
"[INST]In the context of the C64, Registers affected by SCREEN function[/INST]X, Y"
"[INST]In the context of the C64, Preparatory routines for SCREEN function[/INST]nan"
"[INST]In the context of the C64, Stack requirements for SCREEN function[/INST]2"
"[INST]In the context of the C64, Registers used for communication in SCREEN function[/INST]X, Y"
"[INST]In the context of the C64, Description of SCREEN function[/INST]This routine returns the format of the screen, e.g., 40 columns in X and 25 lines in Y."
"[INST]In the context of the C64, Machine compatibility feature of SCREEN function[/INST]This function has been implemented on the Commodore 64 to help upward compatibility of your programs."
"[INST]In the context of the C64, Usage of SCREEN function[/INST]Call this routine."
"[INST]In the context of the C64, Example of using SCREEN function[/INST]JSR SCREEN STX MAXCOL STY MAXROW"
"[INST]In the context of the C64, kernal error code: What is the meaning of error code 0?[/INST]Routine terminated by the <STOP> key"
"[INST]In the context of the C64, kernal error code: What happens when the carry bit of the accumulator is set?[/INST]The number of the error message is returned in the accumulator"
"[INST]In the context of the C64, kernal error code: What is the purpose of the KERNAL READST routine?[/INST]Errors are identified using this routine instead of the error codes"
"[INST]In the context of the C64, kernal error code: What is the meaning of error code 1?[/INST]Too many open files"
"[INST]In the context of the C64, kernal error code: What is the meaning of error code 2?[/INST]File already open"
"[INST]In the context of the C64, kernal error code: What is the meaning of error code 3?[/INST]File not open"
"[INST]In the context of the C64, kernal error code: What is the meaning of error code 4?[/INST]File not found"
"[INST]In the context of the C64, kernal error code: What is the meaning of error code 5?[/INST]Device not present"
"[INST]In the context of the C64, kernal error code: What is the meaning of error code 6?[/INST]File is not an input file"
"[INST]In the context of the C64, kernal error code: What is the meaning of error code 7?[/INST]File is not an output file"
"[INST]In the context of the C64, kernal error code: What is the meaning of error code 8?[/INST]File name is missing"
"[INST]In the context of the C64, kernal error code: What is the meaning of error code 9?[/INST]Illegal device number"
"[INST]In the context of the C64, kernal error code: What is the purpose of the KERNAL routines?[/INST]To provide a list of error messages"
"[INST]In the context of the C64, What is the first action taken by the KERNAL on power-up?[/INST]The KERNAL first resets the stack pointer, and clears decimal mode."
"[INST]In the context of the C64, What happens if an autostart ROM cartridge is present at location $8000 HEX?[/INST]Normal initialization is suspended, and control is transferred to the cartridge code."
"[INST]In the context of the C64, What is set up in the RAM TEST routine?[/INST]The top and bottom of memory pointers are set."
"[INST]In the context of the C64, What is the purpose of the RAM TEST routine?[/INST]It is a nondestructive test starting at location $0300 and working upward."
"[INST]In the context of the C64, What is used to start BASIC?[/INST]The indirect at $A000 is used to start BASIC."
"[INST]In the context of the C64, what is the purpose of the SETTMO function?[/INST]The purpose of the SETTMO function is to set the IEEE bus card timeout flag, which allows the Commodore 64 to wait for a device on the IEEE port for 64 milliseconds before recognizing an error condition and leaving the handshake sequence."
"[INST]In the context of the C64, what is the call address of the SETTMO function?[/INST]The call address of the SETTMO function is $FFA2 (hex) or 65442 (decimal)."
"[INST]In the context of the C64, what is the communication register used by the SETTMO function?[/INST]The communication register used by the SETTMO function is register A."
"[INST]In the context of the C64, are there any preparatory routines required before calling the SETTMO function?[/INST]No, there are no preparatory routines required before calling the SETTMO function."
"[INST]In the context of the C64, what is the stack requirement for the SETTMO function?[/INST]The stack requirement for the SETTMO function is 2."
"[INST]In the context of the C64, which registers are affected by the SETTMO function?[/INST]None of the registers are affected by the SETTMO function."
"[INST]In the context of the C64, what is the significance of bit 7 in the accumulator when calling the SETTMO function?[/INST]When calling the SETTMO function, a 0 in bit 7 of the accumulator enables timeouts, while a 1 in bit 7 disables timeouts."
"[INST]In the context of the C64, how do you disable the timeout flag using the SETTMO function?[/INST]To disable the timeout flag, set bit 7 of the accumulator to 1 and then call the SETTMO function."
"[INST]In the context of the C64, what is an example of how to use the SETTMO function to disable timeouts?[/INST]An example of how to use the SETTMO function to disable timeouts is: LDA #0, JSR SETTMO."
"[INST]In the context of the C64, what is a common use case for the SETTMO function?[/INST]A common use case for the SETTMO function is to communicate that a disk file is not found on an attempt to OPEN a file only with an IEEE card."
"[INST]In the context of the C64, what is the purpose of the IOBASE function in Commodore 64?[/INST]The purpose of the IOBASE function is to define the I/O memory page, which sets the X and Y registers to the address of the memory section where the memory-mapped I/O devices are located, providing compatibility between the Commodore 64, VIC-20, and future models of the Commodore 64."
"[INST]In the context of the C64, what is the call address of the IOBASE function in hexadecimal?[/INST]The call address of the IOBASE function in hexadecimal is $FFF3."
"[INST]In the context of the C64, what are the communication registers used by the IOBASE function?[/INST]The communication registers used by the IOBASE function are X and Y."
"[INST]In the context of the C64, what is the stack requirement for the IOBASE function?[/INST]The stack requirement for the IOBASE function is 2."
"[INST]In the context of the C64, what registers are affected by the IOBASE function?[/INST]The registers affected by the IOBASE function are X and Y."
"[INST]In the context of the C64, how do you use the IOBASE function to set the data direction register of the user port to 0?[/INST]You use the IOBASE function to set the data direction register of the user port to 0 by calling the function with JSR IOBASE, storing the X and Y registers in consecutive locations, loading the Y register with the offset, and accessing the I/O location, as shown in the example: JSR IOBASE, STX POINT, STY POINT+1, LDY #2, LDA #0, STA (POINT),Y."
"[INST]In the context of the C64, what is the significance of the X register in the IOBASE function?[/INST]The X register contains the low-order address byte, which is used to access the memory-mapped I/O devices in the Commodore 64."
"[INST]In the context of the C64, what is the significance of the Y register in the IOBASE function?[/INST]The Y register contains the high-order address byte, which is used to access the memory-mapped I/O devices in the Commodore 64."
"[INST]In the context of the C64, what is the purpose of the offset in the IOBASE function?[/INST]The offset is the number of locations from the beginning of the page on which the I/O register you want is located, and it is used to access the desired I/O location."
"[INST]In the context of the C64, what is the benefit of using the IOBASE function in machine language programs?[/INST]The benefit of using the IOBASE function in machine language programs is that it provides compatibility between the Commodore 64, VIC-20, and future models of the Commodore 64, ensuring that the programs remain compatible with future versions of the Commodore 64, the KERNAL, and BASIC."
"[INST]In the context of the C64, STA stands for ?[/INST]Store accumulator in memory"
"[INST]In the context of the C64, Addressing Mode[/INST]Addressing Mode"
"[INST]In the context of the C64, STA Oper[/INST]Store Accumulator"
"[INST]In the context of the C64, STA Oper,X[/INST]Store Accumulator with X"
"[INST]In the context of the C64, STA Oper[/INST]Store Accumulator"
"[INST]In the context of the C64, STA Oper,X[/INST]Store Accumulator with X"
"[INST]In the context of the C64, STA Oper, Y[/INST]Store Accumulator with Y"
"[INST]In the context of the C64, STA (Oper,X)[/INST]Store Accumulator with X"
"[INST]In the context of the C64, STA (Oper),Y[/INST]Store Accumulator with Y"
"[INST]In the context of the C64, PHA instruction pushes what on the stack?[/INST]accumulator"
"[INST]In the context of the C64, What is the operation of the PHA instruction?[/INST]A toS"
"[INST]In the context of the C64, What is the OP CODE of the PHA instruction?[/INST]48"
"[INST]In the context of the C64, How many bytes does the PHA instruction occupy?[/INST]1"
"[INST]In the context of the C64, How many cycles does the PHA instruction take?[/INST]3"
"[INST]In the context of the C64, What is the addressing mode of the PHA instruction?[/INST]Implied"
"[INST]In the context of the C64, What is the assembly language form of the PHA instruction?[/INST]PHA"
"[INST]In the context of the C64, What is the purpose of the PHA instruction?[/INST]Push accumulator on stack"
"[INST]In the context of the C64, What is the number of cycles the PHA instruction takes?[/INST]3"
"[INST]In the context of the C64, What is the number of bytes the PHA instruction occupies?[/INST]1"
"[INST]In the context of the C64, what is the purpose of the Commodore Z-80 cartridge?[/INST]The Commodore Z-80 cartridge allows you to run programs designed for a Z-80 microprocessor on your Commodore 64, providing a way to utilize the CP/M(R) operating system on your Commodore 64."
"[INST]In the context of the C64, how do you run CP/M(R) on the Commodore 64?[/INST]To run CP/M(R), you need to LOAD the CP/M(R) program from your disk drive, type RUN, and hit the <RETURN> key, which will allow you to access the 48K bytes of RAM available for the Z-80 central processor."
"[INST]In the context of the C64, what is the significance of the 64K bytes of RAM in the Commodore 64?[/INST]The 64K bytes of RAM in the Commodore 64 are accessible by the built-in 6510 central processor, and can be used separately from the 48K bytes of RAM available for the Z-80 central processor, allowing for flexibility in processing and memory management."
"[INST]In the context of the C64, how does the Commodore 64's timing mechanism enable processor switching?[/INST]The Commodore 64's sophisticated timing mechanism allows you to shift back and forth between the 6510 central processor and the Z-80 central processor, enabling you to use either processor separately, but not simultaneously, in a single program."
"[INST]In the context of the C64, what is the memory address translation performed on the Z-80 cartridge?[/INST]The memory address translation performed on the Z-80 cartridge involves adding 4096 bytes to the memory locations used in CP/M(R) $1000 (hex), which corresponds to the memory addresses of the normal Commodore 64 operating system."
"[INST]In the context of the C64, what is the relationship between Z-80 and 6510 memory addresses?[/INST]The correspondence between Z-80 and 6510 memory addresses is such that adding 4096 bytes to the memory locations used in CP/M(R) $1000 (hex) equals the memory addresses of the normal Commodore 64 operating system."
"[INST]In the context of the C64, what is the purpose of the diskette provided with the Commodore Z-80 cartridge?[/INST]The diskette provided with the Commodore Z-80 cartridge contains the Commodore CP/M(R) operating system, which is loaded onto the Commodore 64 to enable the use of CP/M(R) programs."
"[INST]In the context of the C64, how does the Commodore Z-80 cartridge enhance the capabilities of the Commodore 64?[/INST]The Commodore Z-80 cartridge enhances the capabilities of the Commodore 64 by providing access to CP/M(R) programs and allowing the use of the Z-80 central processor, expanding the range of applications and processing capabilities of the Commodore 64."
"[INST]In the context of the C64, what is the significance of the 48K bytes of RAM available for the Z-80 central processor?[/INST]The 48K bytes of RAM available for the Z-80 central processor provide a dedicated memory space for running CP/M(R) programs, allowing for efficient processing and memory management."
"[INST]In the context of the C64, what is the advantage of being able to shift between the 6510 and Z-80 processors?[/INST]The advantage of being able to shift between the 6510 and Z-80 processors is that it allows for flexibility in processing and memory management, enabling the use of different processors and operating systems depending on the specific requirements of the application."
"[INST]In the context of the C64, Can the VIC-II chip detect collisions between sprites?[/INST]Yes, it can detect collisions between sprites."
"[INST]In the context of the C64, What can the VIC-II chip detect collisions between?[/INST]The VIC-II chip can detect collisions between sprites, or between sprites and background data."
"[INST]In the context of the C64, What is a collision in the context of the VIC-II chip?[/INST]A collision occurs when a non-zero part of a sprite overlaps a non-zero portion of another sprite or characters on the screen."
"[INST]In the context of the C64, Can the VIC-II chip detect collisions between sprites and background data?[/INST]Yes, it can detect collisions between sprites and background data."
"[INST]In the context of the C64, What happens when a collision occurs in the context of the VIC-II chip?[/INST]A collision occurs when a non-zero part of a sprite overlaps a non-zero portion of another sprite or characters on the screen."
"[INST]In the context of the C64, Can the VIC-II chip detect collisions between sprites and characters?[/INST]Yes, it can detect collisions between sprites and characters."
"[INST]In the context of the C64, What is the purpose of collision detection in the VIC-II chip?[/INST]The purpose of collision detection is to detect when a non-zero part of a sprite overlaps a non-zero portion of another sprite or characters on the screen."
"[INST]In the context of the C64, Can the VIC-II chip detect collisions between sprites and sprites?[/INST]Yes, it can detect collisions between sprites."
"[INST]In the context of the C64, Can the VIC-II chip detect collisions between background data and characters?[/INST]Yes, it can detect collisions between background data and characters."
"[INST]In the context of the C64, What is the VIC-II chip's ability to detect collisions useful for?[/INST]The VIC-II chip's ability to detect collisions is useful for detecting when a non-zero part of a sprite overlaps a non-zero portion of another sprite or characters on the screen."
"[INST]In the context of the C64, what is the opcode for CPY immediate addressing mode?[/INST]The opcode for CPY immediate addressing mode is C0, which requires 2 bytes and takes 2 cycles to execute."
"[INST]In the context of the C64, what is the assembly language form for CPY zero page addressing mode?[/INST]The assembly language form for CPY zero page addressing mode is CPY Oper, where Oper is the zero page address, and the opcode is C4, requiring 2 bytes and taking 3 cycles to execute."
"[INST]In the context of the C64, what is the difference in the number of bytes required for CPY immediate and CPY zero page addressing modes?[/INST]The CPY immediate addressing mode requires 2 bytes, while the CPY zero page addressing mode also requires 2 bytes, so there is no difference in the number of bytes required for these two addressing modes."
"[INST]In the context of the C64, how many cycles does CPY absolute addressing mode take to execute?[/INST]CPY absolute addressing mode takes 4 cycles to execute, and it requires 3 bytes, with the opcode being CC."
"[INST]In the context of the C64, in what way does the addressing mode affect the number of cycles required for CPY instruction?[/INST]The addressing mode affects the number of cycles required for the CPY instruction, with immediate and zero page addressing modes taking 2 and 3 cycles respectively, while the absolute addressing mode takes 4 cycles."
"[INST]In the context of the C64, what is the opcode for CPY zero page addressing mode?[/INST]The opcode for CPY zero page addressing mode is C4, which requires 2 bytes and takes 3 cycles to execute."
"[INST]In the context of the C64, what is the assembly language form for CPY absolute addressing mode?[/INST]The assembly language form for CPY absolute addressing mode is CPY Oper, where Oper is the absolute address, and the opcode is CC, requiring 3 bytes and taking 4 cycles to execute."
"[INST]In the context of the C64, how many bytes are required for CPY absolute addressing mode?[/INST]CPY absolute addressing mode requires 3 bytes, with the opcode being CC and taking 4 cycles to execute."
"[INST]In the context of the C64, in what way does the addressing mode affect the number of bytes required for CPY instruction?[/INST]The addressing mode affects the number of bytes required for the CPY instruction, with immediate and zero page addressing modes requiring 2 bytes, while the absolute addressing mode requires 3 bytes."
"[INST]In the context of the C64, what is the opcode for CPY absolute addressing mode?[/INST]The opcode for CPY absolute addressing mode is CC, which requires 3 bytes and takes 4 cycles to execute."
"[INST]In the context of the C64, what is the purpose of the CLOSE function in C64?[/INST]The purpose of the CLOSE function is to close a logical file after all I/O operations have been completed on that file, and it is called after the accumulator is loaded with the logical file number to be closed."
"[INST]In the context of the C64, what is the call address of the CLOSE function in C64?[/INST]The call address of the CLOSE function is $FFC3 (hex) or 65475 (decimal)."
"[INST]In the context of the C64, what is the communication register used by the CLOSE function?[/INST]The communication register used by the CLOSE function is the accumulator (A)."
"[INST]In the context of the C64, what is the error return value of the CLOSE function in case of an error?[/INST]The error return value of the CLOSE function in case of an error is 0,240, which is the same as the READST error return value."
"[INST]In the context of the C64, what is the stack requirement for the CLOSE function?[/INST]The stack requirement for the CLOSE function is 2+."
"[INST]In the context of the C64, what registers are affected by the CLOSE function?[/INST]The registers affected by the CLOSE function are A, X, and Y."
"[INST]In the context of the C64, how do you use the CLOSE function to close a logical file?[/INST]To use the CLOSE function to close a logical file, you load the accumulator with the number of the logical file to be closed, and then call the CLOSE routine."
"[INST]In the context of the C64, in what situation is the CLOSE function typically called?[/INST]The CLOSE function is typically called after all I/O operations have been completed on a logical file."
"[INST]In the context of the C64, what is the relationship between the CLOSE function and the OPEN function?[/INST]The CLOSE function is used to close a logical file that was previously opened using the OPEN function, and the same logical file number is used for both functions."
"[INST]In the context of the C64, can you provide an example of how to use the CLOSE function?[/INST]Here is an example of how to use the CLOSE function: LDA #15; JSR CLOSE, which closes logical file number 15."
"[INST]In the context of the C64, what is the significance of loading the accumulator with the logical file number before calling the CLOSE function?[/INST]Loading the accumulator with the logical file number before calling the CLOSE function is necessary because the CLOSE function uses this value to determine which file to close."
"[INST]In the context of the C64, What is the Commodore computer equipped with?[/INST]an electronic music synthesizer"
"[INST]In the context of the C64, What are the three voices of the synthesizer?[/INST]totally addressable, ATTACK/DECAY/SUSTAIN/RELEASE (ADSR), filtering, modulation, and 'white noise'"
"[INST]In the context of the C64, What is the name of the sound and music synthesizer chip?[/INST]'SID' chip"
"[INST]In the context of the C64, What is the purpose of the Programmer's Reference Guide?[/INST]to help you explore all the capabilities of the 6581 'SID' chip"
"[INST]In the context of the C64, What is the minimum programming experience required to use the music synthesizer?[/INST]none, you don't need to be an experienced programmer"
"[INST]In the context of the C64, What is the way to get to the sound generator?[/INST]by POKEing into specified memory locations"
"[INST]In the context of the C64, What is the full list of memory locations used for music synthesis?[/INST]provided in Appendix O"
"[INST]In the context of the C64, What is the POKE statement used for?[/INST]sets the indicated memory location equal to a specified value"
"[INST]In the context of the C64, What is the range of numbers that can be used in a POKE statement?[/INST]between 0 and 255, inclusive"
"[INST]In the context of the C64, What is the PEEK function used for?[/INST]to get the current contents of a memory location"
"[INST]In the context of the C64, What is the purpose of the BASIC Statements section of the manual?[/INST]to explain other BASIC commands"
"[INST]In the context of the C64, What is the range of memory locations used for music synthesis?[/INST]54272 to 54296, inclusive"
"[INST]In the context of the C64, What is the starting memory location for music synthesis?[/INST]54272"
"[INST]In the context of the C64, What is the formula to calculate the memory location for music synthesis?[/INST]add a number from 0 through 24 to 54272"
"[INST]In the context of the C64, What is the purpose of the Programmer's Reference Guide?[/INST]to help you explore all the capabilities of the 6581 'SID' chip"
"[INST]In the context of the C64, What is the name of the sound and music synthesizer chip?[/INST]'SID' chip"
"[INST]In the context of the C64, What is the minimum programming experience required to use the music synthesizer?[/INST]none, you don't need to be an experienced programmer"
"[INST]In the context of the C64, what is the range of colors a sprite can be on the C64?[/INST]A sprite can be any of the 16 colors generated by the VIC-II chip, which are stored in the sprite color registers, one for each of the 8 sprites, located at memory addresses $D027 to $D02E."
"[INST]In the context of the C64, what is the purpose of the sprite color registers?[/INST]The sprite color registers, located at memory addresses $D027 to $D02E, store the color of each sprite, and all dots in the sprite will be displayed in this color, while the rest of the sprite will be transparent, showing whatever is behind the sprite."
"[INST]In the context of the C64, how many sprite color registers are there on the C64?[/INST]There are 8 sprite color registers, one for each sprite, located at memory addresses $D027 to $D02E, which store the color of each sprite."
"[INST]In the context of the C64, what is the memory address of the sprite 0 color register?[/INST]The memory address of the sprite 0 color register is $D027."
"[INST]In the context of the C64, what is the purpose of the color stored in the sprite color register?[/INST]The color stored in the sprite color register determines the color of all dots in the sprite, while the rest of the sprite remains transparent, showing whatever is behind the sprite."
"[INST]In the context of the C64, what is the range of memory addresses for the sprite color registers?[/INST]The sprite color registers are located at memory addresses $D027 to $D02E, which store the colors of the 8 sprites."
"[INST]In the context of the C64, how do the sprite color registers affect the display of the sprite?[/INST]The sprite color registers affect the display of the sprite by setting the color of all dots in the sprite, while the rest of the sprite remains transparent, showing whatever is behind the sprite."
"[INST]In the context of the C64, what is the relationship between the sprite color register and the sprite's transparency?[/INST]The sprite color register sets the color of the sprite's dots, while the rest of the sprite remains transparent, showing whatever is behind the sprite."
"[INST]In the context of the C64, what is the significance of the VIC-II chip in relation to sprite colors?[/INST]The VIC-II chip generates the 16 colors that a sprite can be, which are stored in the sprite color registers, one for each of the 8 sprites."
"[INST]In the context of the C64, how do you set the color of a sprite on the C64?[/INST]You set the color of a sprite on the C64 by storing the desired color in the corresponding sprite color register, located at memory addresses $D027 to $D02E, which determines the color of all dots in the sprite."
"[INST]In the context of the C64, what is the opcode for the PLP instruction?[/INST]The opcode for the PLP instruction is 28, which is used to pull the processor status from the stack."
"[INST]In the context of the C64, what is the addressing mode used by the PLP instruction?[/INST]The addressing mode used by the PLP instruction is implied, which means the instruction does not require a memory address as an operand."
"[INST]In the context of the C64, how many bytes does the PLP instruction occupy in memory?[/INST]The PLP instruction occupies 1 byte in memory, making it a compact and efficient instruction."
"[INST]In the context of the C64, how many cycles does the PLP instruction take to execute?[/INST]The PLP instruction takes 4 cycles to execute, which is relatively fast compared to other instructions."
"[INST]In the context of the C64, what is the purpose of the PLP instruction?[/INST]The purpose of the PLP instruction is to pull the processor status from the stack, which is useful for restoring the processor's status after an interrupt or exception."
"[INST]In the context of the C64, what is the difference between the PLP and PLA instructions?[/INST]The PLP instruction pulls the processor status from the stack, while the PLA instruction pulls the accumulator from the stack, making them distinct instructions with different purposes."
"[INST]In the context of the C64, can the PLP instruction be used to pull data from memory?[/INST]No, the PLP instruction cannot be used to pull data from memory, as its purpose is to retrieve the processor status from the stack, not to access memory locations."
"[INST]In the context of the C64, what is the relationship between the PLP instruction and the stack?[/INST]The PLP instruction is closely related to the stack, as it retrieves the processor status from the top of the stack, making it an essential instruction for managing the stack."
"[INST]In the context of the C64, how does the PLP instruction affect the processor's flags?[/INST]The PLP instruction restores the processor's flags to their previous state, which is useful for maintaining the correct status of the processor after an interrupt or exception."
"[INST]In the context of the C64, in what situations would you use the PLP instruction?[/INST]You would use the PLP instruction in situations where you need to restore the processor's status after an interrupt or exception, such as when returning from an interrupt service routine."
"[INST]In the context of the C64, For sprites: Can you POKE an X position?[/INST]To place the sprite at one of these positions, just type the X-POSITION POKE for the sprite you're using. For example, to POKE sprite I at the farthest left X position IN THE VIEWING AREA, type: POKE V+2,24."
"[INST]In the context of the C64, What are the possible values of X for Positioning sprites?[/INST]The possible values of X are 0 to 255, counting from left to right. Values 0 to 23 place all or part of the sprite OUT OF THE VIEWING AREA off the left side of the screen... values 24 to 255 place the sprite IN THE VIEWING AREA up to the 255th position."
"[INST]In the context of the C64, How do you access screen positions beyond the 255th position?[/INST]To get beyond the 255th position across the screen, you need to make a SECOND POKE using the numbers in the 'RIGHT X' row of the chart (Figure 3-5)."
"[INST]In the context of the C64, Sprite to background priority is controlled by what register?[/INST]The SPRITE-BACKGROUND priority register located at 53275 ($D01B)"
"[INST]In the context of the C64, Is the priority of each sprite controllable?[/INST]Yes"
"[INST]In the context of the C64, What happens if the bit in the SPRITE-BACKGROUND priority register is 0?[/INST]The sprite appears in front of the background data"
"[INST]In the context of the C64, What happens if the bit in the SPRITE-BACKGROUND priority register is 1?[/INST]The sprite appears behind the background data"
"[INST]In the context of the C64, Can a sprite have a higher priority than the background?[/INST]Yes"
"[INST]In the context of the C64, Can a sprite have a lower priority than the background?[/INST]Yes"
"[INST]In the context of the C64, What is the location of the SPRITE-BACKGROUND priority register?[/INST]53275 ($D01B)"
"[INST]In the context of the C64, What determines the priority of each sprite?[/INST]The bit in the SPRITE-BACKGROUND priority register"
"[INST]In the context of the C64, Is the priority of each sprite independent?[/INST]No"
"[INST]In the context of the C64, What is the memory location of the pseudo 6551 control register?[/INST]The pseudo 6551 control register is located at memory location $0293, which is labeled as M51CTR."
"[INST]In the context of the C64, What is the purpose of the two bytes at memory location $0295?[/INST]The two bytes at memory location $0295, labeled as M51AJB, contain the baud rate for the start of the bit test during interface activity, which is used to calculate the baud rate."
"[INST]In the context of the C64, What is the function of the RSSTAT register?[/INST]The RSSTAT register, located at memory location $0297, is the RS-232 status register, which provides information about the current state of the RS-232 interface."
"[INST]In the context of the C64, What is the purpose of the BITNUM register?[/INST]The BITNUM register, located at memory location $0298, holds the number of bits to be sent or received during RS-232 communication."
"[INST]In the context of the C64, What is the significance of the BAUDOF register?[/INST]The BAUDOF register, located at memory location $0299, contains two bytes that are equal to the time of one bit cell, which is calculated based on the system clock and baud rate."
"[INST]In the context of the C64, What is the purpose of the RIDBE register?[/INST]The RIDBE register, located at memory location $029B, holds the byte index to the end of the receiver FIFO buffer, which is used to manage the receiver buffer."
"[INST]In the context of the C64, What is the function of the RIDBS register?[/INST]The RIDBS register, located at memory location $029C, holds the byte index to the start of the receiver FIFO buffer, which is used to manage the receiver buffer."
"[INST]In the context of the C64, What is the purpose of the RODBS register?[/INST]The RODBS register, located at memory location $029D, holds the byte index to the start of the transmitter FIFO buffer, which is used to manage the transmitter buffer."
"[INST]In the context of the C64, What is the function of the RODBE register?[/INST]The RODBE register, located at memory location $029E, holds the byte index to the end of the transmitter FIFO buffer, which is used to manage the transmitter buffer."
"[INST]In the context of the C64, What information is stored in the ENABL register?[/INST]The ENABL register, located at memory location $02A1, holds current active interrupts in the CIA #2 ICR, including information about the system waiting for the Receiver Edge, receiving data, or transmitting data."
"[INST]In the context of the C64, PHP processor status is pushed with which opcode?[/INST]08"
"[INST]In the context of the C64, what is PHP doing ?[/INST]Push Processor Status on Stack"
"[INST]In the context of the C64, PHP processor status is pushed in which bytes?[/INST]1"
"[INST]In the context of the C64, PHP processor status is pushed in which cycles?[/INST]3"
"[INST]In the context of the C64, PHP processor status is pushed in which addressing mode?[/INST]Implied"
"[INST]In the context of the C64, PHP processor status is pushed in which assembly language form?[/INST]PHP"
"[INST]In the context of the C64, PHP processor status is pushed in which operation?[/INST]P toS"
"[INST]In the context of the C64, what does STX do?[/INST]Stores the contents of the X register into memory."
"[INST]In the context of the C64, What is the operation code for STX in Zero Page mode?[/INST]86"
"[INST]In the context of the C64, What is the number of bytes required for STX in Zero Page mode?[/INST]2"
"[INST]In the context of the C64, What is the number of cycles required for STX in Zero Page mode?[/INST]3"
"[INST]In the context of the C64, What is the operation code for STX in Absolute mode?[/INST]8E"
"[INST]In the context of the C64, What is the number of bytes required for STX in Absolute mode?[/INST]3"
"[INST]In the context of the C64, What is the number of cycles required for STX in Absolute mode?[/INST]4"
"[INST]In the context of the C64, What is the addressing mode for STX in Zero Page,Y mode?[/INST]Zero Page,Y"
"[INST]In the context of the C64, What is the operation code for STX in Zero Page,Y mode?[/INST]96"
"[INST]In the context of the C64, What is the number of bytes required for STX in Zero Page,Y mode?[/INST]2"
"[INST]In the context of the C64, What is the number of cycles required for STX in Zero Page,Y mode?[/INST]4"
"[INST]In the context of the C64, Is the KERNAL a jump table?[/INST]Yes, it is a collection of JMP instructions to many operating system routines."
"[INST]In the context of the C64, What is the purpose of the KERNAL?[/INST]To provide easy access to the operating system and speed machine language programming."
"[INST]In the context of the C64, What must you do before calling a KERNAL routine?[/INST]Make all the preparations that the routine demands."
"[INST]In the context of the C64, What happens if a KERNAL routine expects you to put a number in the accumulator?[/INST]That number must be there, otherwise your routines have little chance of working as expected."
"[INST]In the context of the C64, What instruction is used to call a KERNAL routine?[/INST]The JSR instruction."
"[INST]In the context of the C64, What happens when a KERNAL routine has finished its task?[/INST]Control is returned to your program at the instruction after the JSR."
"[INST]In the context of the C64, What should you do if a KERNAL routine returns an error code?[/INST]Handle it properly, otherwise your program might 'bomb'."
"[INST]In the context of the C64, What are the three simple steps to using the KERNAL?[/INST]Set up, call the routine, and error handling."
"[INST]In the context of the C64, What is the purpose of the COMMUNICATION REGISTERS?[/INST]To pass parameters to and from the KERNAL routines."
"[INST]In the context of the C64, What is the purpose of the PREPARATORY ROUTINES?[/INST]To set up data before the KERNAL routine can operate."
"[INST]In the context of the C64, What happens if you ignore an error return from a KERNAL routine?[/INST]The rest of your program might 'bomb'."
"[INST]In the context of the C64, What is the purpose of the STACK REQUIREMENTS?[/INST]To indicate the actual number of stack bytes used by the KERNAL routine."
"[INST]In the context of the C64, What is the purpose of the REGISTERS AFFECTED?[/INST]To list all the registers used by the KERNAL routine."
"[INST]In the context of the C64, What is the purpose of the DESCRIPTION?[/INST]To provide a short tutorial on the function of the KERNAL routine."
"[INST]In the context of the C64, What is the purpose of the USER CALLABLE KERNAL ROUTINES?[/INST]To provide a list of available KERNAL routines."
"[INST]In the context of the C64, What is the purpose of the SCNKEY routine?[/INST]To scan the keyboard."
"[INST]In the context of the C64, What is the purpose of the SCREEN routine?[/INST]To return the X,Y organization of the screen."
"[INST]In the context of the C64, What is the purpose of the SECOND routine?[/INST]To send the secondary address after LISTEN."
"[INST]In the context of the C64, What is the purpose of the SETLFS routine?[/INST]To set the logical, first, and second addresses."
"[INST]In the context of the C64, What is the purpose of the SETMSG routine?[/INST]To control KERNAL messages."
"[INST]In the context of the C64, What is the purpose of the SETNAM routine?[/INST]To set the file name."
"[INST]In the context of the C64, What is the purpose of the SETTIM routine?[/INST]To set the real time clock."
"[INST]In the context of the C64, What is the purpose of the SETTMO routine?[/INST]To set the timeout on the serial bus."
"[INST]In the context of the C64, What is the purpose of the STOP routine?[/INST]To scan the stop key."
"[INST]In the context of the C64, What is the purpose of the TALK routine?[/INST]To command the serial bus device to TALK."
"[INST]In the context of the C64, What is the purpose of the TKSA routine?[/INST]To send the secondary address after TALK."
"[INST]In the context of the C64, What is the purpose of the UDTIM routine?[/INST]To increment the real time clock."
"[INST]In the context of the C64, What is the purpose of the UNLSN routine?[/INST]To command the serial bus to UNLISTEN."
"[INST]In the context of the C64, What is the purpose of the UNTLK routine?[/INST]To command the serial bus to UNTALK."
"[INST]In the context of the C64, What is the purpose of the VECTOR routine?[/INST]To read or set vectored I/O."
"[INST]In the context of the C64, What is the purpose of the 02 clock input in the 6526 interface?[/INST]The 02 clock input is a TTL compatible input used for internal device operation and as a timing reference for communicating with the system data bus."
"[INST]In the context of the C64, What is the function of the /CS-Chip Select Input in the 6526 interface?[/INST]The /CS input controls the activity of the 6526, where a low level on /CS while 02 is high causes the device to respond to signals on the R/W and address (RS) lines, and a high on /CS prevents these lines from controlling the 6526."
"[INST]In the context of the C64, How does the R/W signal control data transfers in the 6526?[/INST]The R/W signal, normally supplied by the microprocessor, controls the direction of data transfers of the 6526, where a high on R/W indicates a read (data transfer out of the 6526), and a low indicates a write (data transfer into the 6526)."
"[INST]In the context of the C64, What is the purpose of the RS3-RS0-Address Inputs in the 6526 interface?[/INST]The address inputs select the internal registers as described by the Register Map."
"[INST]In the context of the C64, How do the DB7-DB0-Data Bus Inputs/Outputs transfer information in the 6526?[/INST]The eight data bus pins transfer information between the 6526 and the system data bus, where these pins are high impedance inputs unless CS is low and R/W and 02 are high to read the device, and during this read, the data bus output buffers are enabled, driving the data from the selected register onto the system data bus."
"[INST]In the context of the C64, What is the function of the IRQ-Interrupt Request Output in the 6526?[/INST]The IRQ output is an open drain output normally connected to the processor interrupt input, which is normally off (high impedance) and is activated low as indicated in the functional description."
"[INST]In the context of the C64, What happens when the /RES-Reset Input is low in the 6526?[/INST]A low on the RES pin resets all internal registers, where the port pins are set as inputs and port registers to zero (although a read of the ports will return all highs because of passive pullups), the timer control registers are set to zero and the timer latches to all ones, and all other registers are reset to zero."
"[INST]In the context of the C64, How does the 6526 respond to signals on the R/W and address (RS) lines?[/INST]The 6526 responds to signals on the R/W and address (RS) lines when /CS is low and 02 is high."
"[INST]In the context of the C64, What is the purpose of the address inputs in the 6526?[/INST]The address inputs select the internal registers as described by the Register Map, allowing the 6526 to access and manipulate specific registers."
"[INST]In the context of the C64, How does the 6526 handle data transfer during a read operation?[/INST]During a read operation, the data bus output buffers are enabled, driving the data from the selected register onto the system data bus, and the data bus pins are high impedance inputs unless CS is low and R/W and 02 are high to read the device."
"[INST]In the context of the C64, what is the maximum number of colors that can be displayed in each 8 by 8 section of bit map in multi-color bit map mode?[/INST]up to four different colors can be displayed in each 8 by 8 section of bit map in multi-color bit map mode, which is similar to multi-color mode characters."
"[INST]In the context of the C64, How does the horizontal resolution change when using multi-color bit map mode?[/INST]the horizontal resolution is sacrificed, decreasing from 320 dots to 160 dots, similar to multi-character mode."
"[INST]In the context of the C64, What is the size of the memory section used for the bit map in multi-color bit map mode?[/INST]an 8K section of memory is used for the bit map in multi-color bit map mode."
"[INST]In the context of the C64, Where are the colors for multi-color bit map mode selected from?[/INST]the colors for multi-color bit map mode are selected from the background color register 0 (the screen background color), the video matrix (the upper 4 bits give one possible color, the lower 4 bits another), and color memory."
"[INST]In the context of the C64, How is multi-color bit mapped mode turned ON?[/INST]multi-color bit mapped mode is turned ON by setting bit 5 of 53265 ($D011) and bit 4 at location 53270 ($D016) to a 1, which can be done using the following POKE: POKE 53265,PEEK(53625)OR 32: POKE 53270,PEEK(53270)OR 16."
"[INST]In the context of the C64, How is multi-color bit mapped mode turned OFF?[/INST]multi-color bit mapped mode is turned OFF by setting bit 5 of 53265 ($D011) and bit 4 at location 53270 ($D016) to a 0, which can be done using the following POKE: POKE 53265,PEEK(53265)AND 223: POKE 53270,PEEK(53270)AND 239."
"[INST]In the context of the C64, What is the relationship between the 8K section of memory and what is shown on the screen in multi-color bit mapped mode?[/INST]there is a one to one correspondence between the 8K section of memory being used for the display and what is shown on the screen, similar to standard (HI-RES) bit mapped mode."
"[INST]In the context of the C64, How are the horizontal dots represented in the display memory area in multi-color bit mapped mode?[/INST]each 2 bits in the display memory area form a dot, which can have one of 4 colors."
"[INST]In the context of the C64, What is the significance of the video matrix in multi-color bit map mode?[/INST]the video matrix provides two possible colors, with the upper 4 bits giving one possible color and the lower 4 bits giving another."
"[INST]In the context of the C64, What is the purpose of the background color register 0 in multi-color bit map mode?[/INST]the background color register 0 provides one of the possible colors that can be used in multi-color bit map mode, which is the screen background color."
"[INST]In the context of the C64, What is the serial bus designed for?[/INST]to let the Commodore 64 communicate with devices such as the VIC-1541 DISK DRIVE and the VIC-1525 GRAPHICS PRINTER"
"[INST]In the context of the C64, What is the advantage of the serial bus?[/INST]that more than one device can be connected to the port"
"[INST]In the context of the C64, How many devices can be connected to the serial bus at one time?[/INST]up to 5 devices"
"[INST]In the context of the C64, What are the three types of operation over a serial bus?[/INST]CONTROL, TALK, and LISTEN"
"[INST]In the context of the C64, What is a CONTROLLER device?[/INST]one which controls operation of the serial bus"
"[INST]In the context of the C64, What is a TALKER?[/INST]a device that transmits data onto the bus"
"[INST]In the context of the C64, What is a LISTENER?[/INST]a device that receives data from the bus"
"[INST]In the context of the C64, What is the role of the Commodore 64 in the serial bus?[/INST]the controller of the bus, a TALKER, and a LISTENER"
"[INST]In the context of the C64, What is the purpose of a device address on the serial bus?[/INST]to allow the Commodore 64 to route data to its intended destination"
"[INST]In the context of the C64, What is the range of addresses on the serial bus?[/INST]from 4 to 31"
"[INST]In the context of the C64, What happens when the Commodore 64 commands a device to TALK?[/INST]the device will begin putting data onto the serial bus"
"[INST]In the context of the C64, What happens when the Commodore 64 commands a device to LISTEN?[/INST]the device addressed will get ready to receive data"
"[INST]In the context of the C64, Why can only one device TALK on the bus at a time?[/INST]otherwise, the data will collide and the system will crash in confusion"
"[INST]In the context of the C64, What is the address of the VIC-1525 GRAPHIC PRINTER?[/INST]4 or 5"
"[INST]In the context of the C64, What is the address of the VIC-1541 DISK DRIVE?[/INST]8"
"[INST]In the context of the C64, What is the purpose of the SECONDARY ADDRESS?[/INST]to let the Commodore 64 transmit setup information to a device"
"[INST]In the context of the C64, What is the command to OPEN a connection on the bus to the printer?[/INST]OPEN 1,4,7"
"[INST]In the context of the C64, What are the 6 lines used in serial bus operations?[/INST]input and 3 output lines"
"[INST]In the context of the C64, What do the 3 input lines bring into the Commodore 64?[/INST]data, control, and timing signals"
"[INST]In the context of the C64, What do the 3 output lines send from the Commodore 64?[/INST]data, control, and timing signals to external devices on the serial bus"
"[INST]In the context of the C64, What is the function of Pin 1 in serial I/O?[/INST]SERIAL SRQ IN"
"[INST]In the context of the C64, What is the function of Pin 2 in serial I/O?[/INST]GND"
"[INST]In the context of the C64, What is the function of Pin 3 in serial I/O?[/INST]SERIAL ATN OUT"
"[INST]In the context of the C64, What is the function of Pin 4 in serial I/O?[/INST]SERIAL CLK IN/OUT"
"[INST]In the context of the C64, What is the function of Pin 5 in serial I/O?[/INST]SERIAL DATA IN/OUT"
"[INST]In the context of the C64, What is the function of Pin 6 in serial I/O?[/INST]/RESET"
"[INST]In the context of the C64, What is the purpose of the SCNKEY function?[/INST]The purpose of the SCNKEY function is to scan the Commodore 64 keyboard and check for pressed keys, placing the ASCII value of any pressed key in the keyboard queue."
"[INST]In the context of the C64, What is the call address of the SCNKEY function?[/INST]The call address of the SCNKEY function is $FF9F (hex) or 65439 (decimal)."
"[INST]In the context of the C64, What preparatory routine is required before calling SCNKEY?[/INST]The preparatory routine required before calling SCNKEY is IOINIT."
"[INST]In the context of the C64, What registers are affected by the SCNKEY function?[/INST]The SCNKEY function affects registers A, X, and Y."
"[INST]In the context of the C64, What is the stack requirement for the SCNKEY function?[/INST]The stack requirement for the SCNKEY function is 5 bytes."
"[INST]In the context of the C64, How is the SCNKEY function typically used?[/INST]The SCNKEY function is typically used by calling the routine, then checking the keyboard queue for any pressed keys, and if a key is found, printing it using CHROUT."
"[INST]In the context of the C64, What happens if no key is pressed when SCNKEY is called?[/INST]If no key is pressed when SCNKEY is called, the routine will return with no ASCII value in the keyboard queue."
"[INST]In the context of the C64, Can SCNKEY be used to scan the keyboard at any time?[/INST]No, SCNKEY is only called if the normal IRQ interrupt is bypassed."
"[INST]In the context of the C64, What is the relationship between SCNKEY and the interrupt handler?[/INST]The SCNKEY routine is the same routine called by the interrupt handler to scan the keyboard."
"[INST]In the context of the C64, How can you use SCNKEY to get a character from the keyboard?[/INST]You can use SCNKEY to get a character from the keyboard by calling the routine, then checking the keyboard queue for the ASCII value of the pressed key, and if a key is found, printing it using CHROUT, as shown in the example: GET  JSR SCNKEY ;SCAN KEYBOARD JSR GETIN ;GET CHARACTER CMP #0 ;IS IT NULL? BEQ GET ;YES... SCAN AGAIN JSR CHROUT ;PRINT IT"
"[INST]In the context of the C64, What is the purpose of the LISTEN function?[/INST]The purpose of the LISTEN function is to command a device on the serial bus to receive data."
"[INST]In the context of the C64, What is the call address of the LISTEN function?[/INST]The call address of the LISTEN function is $FFB1 (hex) or 65457 (decimal)."
"[INST]In the context of the C64, What register is used to store the device number in the LISTEN function?[/INST]The accumulator (A) is used to store the device number in the LISTEN function."
"[INST]In the context of the C64, What is the range of device numbers that can be used with the LISTEN function?[/INST]The range of device numbers that can be used with the LISTEN function is between 0 and 31."
"[INST]In the context of the C64, How does the LISTEN function convert the device number to a listen address?[/INST]The LISTEN function ORs the number bit by bit to convert it to a listen address."
"[INST]In the context of the C64, What happens to the specified device after calling the LISTEN function?[/INST]The specified device will go into listen mode and be ready to accept information after calling the LISTEN function."
"[INST]In the context of the C64, What is the JSR instruction used for in the LISTEN function?[/INST]The JSR instruction is used to call the LISTEN function."
"[INST]In the context of the C64, How do you load the device number before calling the LISTEN function?[/INST]You load the device number by using the LDA instruction, for example: LDA #8."
"[INST]In the context of the C64, What is the error return mechanism for the LISTEN function?[/INST]The error return mechanism for the LISTEN function is the same as the READST function."
"[INST]In the context of the C64, What is an example of how to use the LISTEN function?[/INST]An example of how to use the LISTEN function is: LDA #8; JSR LISTEN, which commands device #8 to listen."
"[INST]In the context of the C64, Can you use machine language on the Commodore 64?[/INST]Yes, there are several methods to use machine language on the Commodore 64."
"[INST]In the context of the C64, What is the SYS statement used for?[/INST]The SYS statement is used to jump to a machine language subroutine located at a specific address."
"[INST]In the context of the C64, What is the USR function used for?[/INST]The USR function is used to transfer control to a machine language subroutine located at the address stored in locations 785 and 786."
"[INST]In the context of the C64, What is the KERNAL VECTOR routine used for?[/INST]The KERNAL VECTOR routine is used to change any of the vectors in the vector table located on page 3."
"[INST]In the context of the C64, What is the HARDWARE INTERRUPT (IRQ) VECTOR used for?[/INST]The HARDWARE INTERRUPT (IRQ) VECTOR is used to change the routine that is executed every 1/60th of a second."
"[INST]In the context of the C64, Why is it important to disable interrupts before changing the IRQ vector?[/INST]It is important to disable interrupts before changing the IRQ vector to prevent unexpected behavior."
"[INST]In the context of the C64, What is the CHRGET routine used for?[/INST]The CHRGET routine is used by BASIC to get each character/token."
"[INST]In the context of the C64, How can you add new BASIC commands?[/INST]You can add new BASIC commands by specifying a special character that will occur before any of the new commands."
"[INST]In the context of the C64, What is a wedge in the context of the Commodore 64?[/INST]A wedge is a technique used to add new BASIC commands by specifying a special character that will occur before any of the new commands."
"[INST]In the context of the C64, Can you use machine language routines from BASIC?[/INST]Yes, you can use machine language routines from BASIC using the SYS statement."
"[INST]In the context of the C64, What is the difference between the SYS and USR statements?[/INST]The SYS statement jumps to a machine language subroutine located at a specific address, while the USR statement transfers control to a machine language subroutine located at the address stored in locations 785 and 786."
"[INST]In the context of the C64, How do you pass parameters between machine language routines and BASIC programs?[/INST]You can pass parameters between machine language routines and BASIC programs using the BASIC PEEK and POKE statements, and their machine language equivalents."
"[INST]In the context of the C64, What is the most useful method of combining BASIC with machine language?[/INST]The most useful method of combining BASIC with machine language is the SYS command."
"[INST]In the context of the C64, Can you have multiple SYS statements in a program?[/INST]Yes, you can have multiple SYS statements in a program, each to a different or the same machine language routine."
"[INST]In the context of the C64, What is the floating point accumulator used for?[/INST]The floating point accumulator is used to pass values between machine language routines and BASIC programs."
"[INST]In the context of the C64, What is the RTS instruction used for?[/INST]The RTS instruction is used to return control to BASIC from a machine language routine."
"[INST]In the context of the C64, What is the RTI instruction used for?[/INST]The RTI instruction is used to return control to the normal IRQ handling routine from a machine language routine."
"[INST]In the context of the C64, Can you change the KERNAL VECTOR routine?[/INST]Yes, you can change the KERNAL VECTOR routine to replace or augment the standard system routine."
"[INST]In the context of the C64, What is the KERNAL VECTOR routine used for?[/INST]The KERNAL VECTOR routine is used to change any of the vectors in the vector table located on page 3."
"[INST]In the context of the C64, Can you change the HARDWARE INTERRUPT (IRQ) VECTOR?[/INST]Yes, you can change the HARDWARE INTERRUPT (IRQ) VECTOR to replace or augment the standard system routine."
"[INST]In the context of the C64, What is the CHRGET routine used for?[/INST]The CHRGET routine is used by BASIC to get each character/token."
"[INST]In the context of the C64, How do you add new BASIC commands?[/INST]You can add new BASIC commands by specifying a special character that will occur before any of the new commands."
"[INST]In the context of the C64, What is a wedge in the context of the Commodore 64?[/INST]A wedge is a technique used to add new BASIC commands by specifying a special character that will occur before any of the new commands."
"[INST]In the context of the C64, what is the location of the VIC-II control register to unexpand a sprite in the horizontal direction?[/INST]The VIC-II control register to unexpand a sprite in the horizontal direction is located at memory location 53277 ($D01D in HEX)."
"[INST]In the context of the C64, how do you unexpand a sprite in the X direction?[/INST]To unexpand a sprite in the X direction, you need to turn off the corresponding bit in the VIC-II control register at location 53277. This can be achieved by using the following POKE command: POKE 53277,PEEK(53277)AND (255-2^SN), where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, what is the purpose of the POKE command POKE 53277,PEEK(53277)AND (255-2^SN)?[/INST]The POKE command POKE 53277,PEEK(53277)AND (255-2^SN) is used to unexpand a sprite in the X direction. It turns off the corresponding bit in the VIC-II control register at location 53277, where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, how do you expand a sprite in the vertical direction?[/INST]To expand a sprite in the vertical direction, you need to turn on the corresponding bit in the VIC-II control register at location 53271. This can be achieved by using the following POKE command: POKE 53271,PEEK(53271)OR(2^SN), where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, what is the location of the VIC-II control register to expand a sprite in the vertical direction?[/INST]The VIC-II control register to expand a sprite in the vertical direction is located at memory location 53271 ($D017 in HEX)."
"[INST]In the context of the C64, what is the purpose of the POKE command POKE 53271,PEEK(53271)OR(2^SN)?[/INST]The POKE command POKE 53271,PEEK(53271)OR(2^SN) is used to expand a sprite in the vertical direction. It turns on the corresponding bit in the VIC-II control register at location 53271, where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, how do you expand a sprite in the horizontal direction?[/INST]To expand a sprite in the horizontal direction, you need to turn on the corresponding bit in the VIC-II control register at location 53277. This can be achieved by using the following POKE command: POKE 53277,PEEK(53277)OR(2^SN), where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, what is the purpose of the POKE command POKE 53277,PEEK(53277)OR(2^SN)?[/INST]The POKE command POKE 53277,PEEK(53277)OR(2^SN) is used to expand a sprite in the horizontal direction. It turns on the corresponding bit in the VIC-II control register at location 53277, where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, what is the range of values for the sprite number SN?[/INST]The sprite number SN can take values from 0 to 7."
"[INST]In the context of the C64, in which register do you need to turn off a bit to unexpand a sprite in the horizontal direction?[/INST]You need to turn off a bit in the VIC-II control register at location 53277 ($D01D in HEX) to unexpand a sprite in the horizontal direction."
"[INST]In the context of the C64, what is the purpose of the CHKIN function?[/INST]The purpose of the CHKIN function is to open a channel for input, allowing the program to read data from a logical file that has already been opened by the KERNAL OPEN routine, as long as the device on the channel is an input device."
"[INST]In the context of the C64, What is the call address of the CHKIN function?[/INST]The call address of the CHKIN function is $FFC6 (hex) or 65478 (decimal)."
"[INST]In the context of the C64, What communication register is used by the CHKIN function?[/INST]The communication register used by the CHKIN function is X."
"[INST]In the context of the C64, What is the preparatory routine required by the CHKIN function?[/INST]The preparatory routine required by the CHKIN function is OPEN."
"[INST]In the context of the C64, What error returns can occur when using the CHKIN function?[/INST]The error returns that can occur when using the CHKIN function are #3: File not open, #5: Device not present, and #6: File not an input file."
"[INST]In the context of the C64, What registers are affected by the CHKIN function?[/INST]The registers affected by the CHKIN function are A and X."
"[INST]In the context of the C64, In what situations is the CHKIN function required?[/INST]The CHKIN function is required when getting data from anywhere other than the keyboard, and it must be called before using either the CHRIN or the GETIN KERNAL routines for data input."
"[INST]In the context of the C64, How do you use the CHKIN function with a device on the serial bus?[/INST]When the CHKIN function is used with a device on the serial bus, it automatically sends the talk address (and the secondary address if one was specified by the OPEN routine) over the bus."
"[INST]In the context of the C64, What is the procedure to use the CHKIN function?[/INST]The procedure to use the CHKIN function is to first OPEN the logical file (if necessary), load the X register with the number of the logical file to be used, and then call the CHKIN routine using a JSR command."
"[INST]In the context of the C64, What is an example of using the CHKIN function?[/INST]An example of using the CHKIN function is to prepare for input from logical file 2 by loading the X register with the value 2 and then calling the CHKIN routine, as shown in the following code snippet: LDX #2; JSR CHKIN."
"[INST]In the context of the C64, In what situations can the CHKIN function be skipped?[/INST]The CHKIN function can be skipped if you want to use the input from the keyboard, and no other input channels are opened."
"[INST]In the context of the C64, Send secondary address for LISTEN[/INST]This routine is used to send a secondary address to an I/O device after a call to the LISTEN routine is made, and the device is commanded to LISTEN."
"[INST]In the context of the C64, Call address of SECOND routine[/INST]$FF93 (hex) 65427 (decimal)"
"[INST]In the context of the C64, Registers affected by SECOND routine[/INST]A"
"[INST]In the context of the C64, Preparatory routines for SECOND routine[/INST]LISTEN"
"[INST]In the context of the C64, Error returns for SECOND routine[/INST]See READST"
"[INST]In the context of the C64, Stack requirements for SECOND routine[/INST]8"
"[INST]In the context of the C64, Description of SECOND routine[/INST]This routine is used to send a secondary address to an I/O device after a call to the LISTEN routine is made, and the device is commanded to LISTEN."
"[INST]In the context of the C64, Use of SECOND routine[/INST]The routine canNOT be used to send a secondary address after a call to the TALK routine."
"[INST]In the context of the C64, Secondary address usage[/INST]A secondary address is usually used to give setup information to a device before I/O operations begin."
"[INST]In the context of the C64, ORing secondary address with[/INST]$60"
"[INST]In the context of the C64, How to use SECOND routine[/INST]1) load the accumulator with the secondary address to be sent. 2) Call this routine."
"[INST]In the context of the C64, Example of using SECOND routine[/INST];ADDRESS DEVICE #8 WITH COMMAND (SECONDARY ADDRESS) #15 LDA #8 JSR LISTEN LDA #15 JSR SECOND"
"[INST]In the context of the C64, What is the purpose of the VECTOR routine?[/INST]Manage RAM vectors"
"[INST]In the context of the C64, What is the call address of the VECTOR routine?[/INST]$FF8D (hex) 65421 (decimal)"
"[INST]In the context of the C64, What communication registers are used by the VECTOR routine?[/INST]X, Y"
"[INST]In the context of the C64, What is the stack requirement of the VECTOR routine?[/INST]2"
"[INST]In the context of the C64, What registers are affected by the VECTOR routine?[/INST]A, X, Y"
"[INST]In the context of the C64, What happens when the accumulator carry bit is set when calling the VECTOR routine?[/INST]Stores the current contents of the RAM vectors in a list pointed to by the X and Y registers"
"[INST]In the context of the C64, What happens when the accumulator carry bit is clear when calling the VECTOR routine?[/INST]Transfers the user list pointed to by the X and Y registers to the system RAM vectors"
"[INST]In the context of the C64, What is the recommended way to use the VECTOR routine?[/INST]Read the entire vector contents into the user area, alter the desired vectors, and then copy the contents back to the system vectors"
"[INST]In the context of the C64, How do you read the system RAM vectors?[/INST]Set the carry, set the X and Y registers to the address to put the vectors, and call the VECTOR routine"
"[INST]In the context of the C64, How do you load the system RAM vectors?[/INST]Clear the carry bit, set the X and Y registers to the address of the vector list in RAM that must be loaded, and call the VECTOR routine"
"[INST]In the context of the C64, What is the purpose of the SCNKEY function?[/INST]Scan the keyboard"
"[INST]In the context of the C64, What is the call address of the SCNKEY function?[/INST]$FF9F (hex) 65439 (decimal)"
"[INST]In the context of the C64, What is the purpose of the IOINIT preparatory routine?[/INST]Preparatory routines: IOINIT"
"[INST]In the context of the C64, What registers are affected by the SCNKEY function?[/INST]Registers affected: A, X, Y"
"[INST]In the context of the C64, What is the stack requirement for the SCNKEY function?[/INST]Stack requirements: 5"
"[INST]In the context of the C64, What happens if a key is down when the SCNKEY function is called?[/INST]If a key is down, its ASCII value is placed in the keyboard queue"
"[INST]In the context of the C64, What is the purpose of the interrupt handler in the SCNKEY function?[/INST]This routine is called only if the normal IRQ interrupt is bypassed"
"[INST]In the context of the C64, What is the purpose of the GETIN and CHROUT routines in the SCNKEY function?[/INST]GETIN: GET CHARACTER, CHROUT: PRINT IT"
"[INST]In the context of the C64, What is the return value of the SCNKEY function?[/INST]nan"
"[INST]In the context of the C64, Can the Commodore 64 have more than one joystick connected?[/INST]Yes, the Commodore 64 has two 9-pin Game Ports which allow the use of joysticks, paddies, or a light pen."
"[INST]In the context of the C64, What is the purpose of the 6526 CIA chip?[/INST]The 6526 CIA chip is used to handle the paddle fire buttons and keyboard scanning."
"[INST]In the context of the C64, What are the five distinct switches on a digital joystick?[/INST]The five distinct switches on a digital joystick are used for direction and the fire button. The switches are arranged as shown: (Top) FIRE (Switch 4), UP (Switch 0), LEFT (Switch 2), RIGHT (Switch 3), and DOWN (Switch 1)."
"[INST]In the context of the C64, How are the joystick switches represented in memory?[/INST]The joystick switches are represented in memory locations 56320 and 56321."
"[INST]In the context of the C64, What is the purpose of the fire button on a joystick?[/INST]The fire button is used to change the bit (bit 4 in this case) to a 0 when pressed."
"[INST]In the context of the C64, What is the purpose of the subroutine in BASIC?[/INST]The subroutine is used to read the joystick from BASIC."
"[INST]In the context of the C64, what is the default mode of the Commodore 64 when you first turn it on?[/INST]The default mode of the Commodore 64 when you first turn it on is the Standard Character Mode, which is the mode you will generally program in, where characters can be taken from ROM or RAM, but normally they are taken from ROM."
"[INST]In the context of the C64, how do you define special graphics characters for a program?[/INST]To define special graphics characters for a program, you need to define the new character shapes in RAM, and tell the VIC-II chip to get its character information from there instead of the character ROM."
"[INST]In the context of the C64, what does the VIC-II chip access to display characters on the screen in color?[/INST]The VIC-II chip accesses the screen memory to determine the character code for that location on the screen, and at the same time, it accesses the color memory to determine what color you want for the character displayed."
"[INST]In the context of the C64, how does the VIC-II chip translate the character code?[/INST]The VIC-II chip translates the character code into the starting address of the 8-byte block holding the character pattern, which is located in character memory."
"[INST]In the context of the C64, what is the formula to calculate the character address?[/INST]The formula to calculate the character address is: CHARACTER ADDRESS = SCREEN CODE*8+(CHARACTER SET*2048)+(BANK*16384)."
"[INST]In the context of the C64, what is the purpose of the Bank Select Bits in the character address calculation?[/INST]The Bank Select Bits are taken into account by adding in the base address, which is necessary for the video bank selection."
"[INST]In the context of the C64, what is the significance of the character set in the character address calculation?[/INST]The character set is multiplied by 2048 and added to the screen code multiplied by 8 to calculate the character address, which determines the starting address of the 8-byte block holding the character pattern."
"[INST]In the context of the C64, where are the 8-byte blocks holding the character patterns located?[/INST]The 8-byte blocks holding the character patterns are located in character memory."
"[INST]In the context of the C64, what is the role of the screen code in the character address calculation?[/INST]The screen code is multiplied by 8 and added to the character set and bank values to calculate the character address, which determines the starting address of the 8-byte block holding the character pattern."
"[INST]In the context of the C64, can characters be taken from RAM or ROM in standard character mode?[/INST]In standard character mode, characters can be taken from ROM or RAM, but normally they are taken from ROM."
"[INST]In the context of the C64, what is the purpose of the POTX register?[/INST]The POTX register allows the microprocessor to read the position of the potentiometer tied to POTX (pin 24), with values ranging from 0 at minimum resistance, to 255 ($FF) at maximum resistance."
"[INST]In the context of the C64, what is the range of values that can be read from the POTX register?[/INST]The range of values that can be read from the POTX register is from 0 at minimum resistance, to 255 ($FF) at maximum resistance."
"[INST]In the context of the C64, how often is the value in the POTX register updated?[/INST]The value in the POTX register is updated every 512 clock cycles."
"[INST]In the context of the C64, what is the pin number that the potentiometer is tied to?[/INST]The potentiometer is tied to pin 24."
"[INST]In the context of the C64, what is the significance of the value 0 in the POTX register?[/INST]The value 0 in the POTX register indicates minimum resistance."
"[INST]In the context of the C64, what is the significance of the value 255 ($FF) in the POTX register?[/INST]The value 255 ($FF) in the POTX register indicates maximum resistance."
"[INST]In the context of the C64, where can you find more information on pot and capacitor values?[/INST]You can find more information on pot and capacitor values in the Pin Description section."
"[INST]In the context of the C64, is the value in the POTX register always valid?[/INST]Yes, the value in the POTX register is always valid."
"[INST]In the context of the C64, what is the clock cycle period for updating the POTX register value?[/INST]The clock cycle period for updating the POTX register value is 512 clock cycles."
"[INST]In the context of the C64, what type of device is tied to pin 24?[/INST]A potentiometer is tied to pin 24."
"[INST]In the context of the C64, what is the main limitation of writing machine language programs on a Commodore 64?[/INST]The main limitation of writing machine language programs on a Commodore 64 is that there is no facility in the computer for writing and editing machine language programs, requiring the use of a program or a BASIC program to facilitate the process."
"[INST]In the context of the C64, what is the purpose of an assembler in machine language programming?[/INST]The purpose of an assembler in machine language programming is to allow the writing of machine language instructions in a standardized mnemonic format, making the program more readable than a stream of numbers."
"[INST]In the context of the C64, what is a disassembler in machine language programming?[/INST]A disassembler in machine language programming is a program that displays a machine language program in mnemonic format, allowing for easier understanding and analysis of the program."
"[INST]In the context of the C64, what is the advantage of using an assembler in machine language programming?[/INST]The advantage of using an assembler in machine language programming is that it makes the machine language program more readable, as it allows the programmer to write machine language instructions in a standardized mnemonic format rather than a stream of numbers."
"[INST]In the context of the C64, what is the difference between an assembler and a disassembler?[/INST]The difference between an assembler and a disassembler is that an assembler is a program that allows you to write machine language programs in mnemonic format, while a disassembler is a program that displays a machine language program in mnemonic format."
"[INST]In the context of the C64, what is the name of the cartridge available for Commodore 64 that provides an assembler and disassembler?[/INST]The name of the cartridge available for Commodore 64 that provides an assembler and disassembler is the machine language monitor cartridge made by Commodore."
"[INST]In the context of the C64, why is it necessary to use a program or BASIC program to write machine language programs on a Commodore 64?[/INST]It is necessary to use a program or BASIC program to write machine language programs on a Commodore 64 because the computer does not have a built-in facility for writing and editing machine language programs."
"[INST]In the context of the C64, what is the benefit of using a machine language monitor cartridge on a Commodore 64?[/INST]The benefit of using a machine language monitor cartridge on a Commodore 64 is that it provides an assembler and disassembler, allowing for easier development and analysis of machine language programs."
"[INST]In the context of the C64, what is the format of machine language instructions when written using an assembler?[/INST]The format of machine language instructions when written using an assembler is a standardized mnemonic format, making the program more readable than a stream of numbers."
"[INST]In the context of the C64, what is the purpose of a machine language monitor cartridge on a Commodore 64?[/INST]The purpose of a machine language monitor cartridge on a Commodore 64 is to provide a facility for writing, editing, and analyzing machine language programs, including an assembler and disassembler."
"[INST]In the context of the C64, what is the range of x positions on the c64 screen?[/INST]The range of X positions on the C64 screen runs from 0 to 255 and then wraps around to 0 again, allowing sprites to be placed beyond the initial 255 positions on the far right side of the screen."
"[INST]In the context of the C64, how do you place a sprite beyond x position 255 on the c64 screen?[/INST]To place a sprite beyond X position 255 on the far right side of the screen, you must first POKE V+16, and then POKE a new X value from 0 to 63, which will place the sprite in one of the X positions at the right side of the screen."
"[INST]In the context of the C64, what is the purpose of poking v+16 on the c64?[/INST]Poking V+16 on the C64 allows you to access X positions beyond 255, enabling you to place sprites on the far right side of the screen by poking a new X value from 0 to 63."
"[INST]In the context of the C64, how do you reset the x position range on the c64?[/INST]To reset the X position range on the C64, you need to POKE V+16,0 and then POKE in an X value from 0 to 255, which will allow you to access the standard X position range of 0 to 255."
"[INST]In the context of the C64, what is the range of y positions on the c64 screen?[/INST]The range of Y positions on the C64 screen runs from 0 to 255, with 0 to 49 being off the top of the viewing area, 50 to 229 being within the viewing area, and 230 to 255 being off the bottom of the viewing area."
"[INST]In the context of the C64, what is the significance of y position 50 on the c64 screen?[/INST]Y position 50 marks the start of the visible viewing area on the C64 screen, with Y positions 0 to 49 being off the top of the screen and Y positions 50 to 229 being within the visible area."
"[INST]In the context of the C64, what is the significance of y position 229 on the c64 screen?[/INST]Y position 229 marks the end of the visible viewing area on the C64 screen, with Y positions 230 to 255 being off the bottom of the screen."
"[INST]In the context of the C64, how do you determine the y position of a sprite on the c64 screen?[/INST]To determine the Y position of a sprite on the C64 screen, you need to consider the range of Y positions, which runs from 0 to 255, and take into account the visible viewing area, which spans from Y position 50 to 229."
"[INST]In the context of the C64, what happens when you poke a y value beyond 255 on the c64?[/INST]When you poke a Y value beyond 255 on the C64, it will wrap around to 0, allowing you to access Y positions at the top of the screen again."
"[INST]In the context of the C64, can you use poke v+16 to access y positions beyond 255 on the c64?[/INST]No, poking V+16 on the C64 only allows you to access X positions beyond 255, and does not affect the Y position range, which remains fixed from 0 to 255."
"[INST]In the context of the C64, what is the purpose of the carry bit in the accumulator when a KERNAL routine encounters an error?[/INST]The carry bit in the accumulator is set when a KERNAL routine encounters an error, and the error code is returned in the accumulator, allowing the program to identify and handle the error accordingly."
"[INST]In the context of the C64, what is the purpose of the KERNAL READST routine?[/INST]The KERNAL READST routine is used to identify errors in some KERNAL I/O routines, instead of using the standard error codes, providing an alternative method for error handling."
"[INST]In the context of the C64, what does error code 0 indicate?[/INST]Error code 0 indicates that the routine was terminated by the <STOP> key, allowing the program to respond to user intervention."
"[INST]In the context of the C64, what is the meaning of error code 1?[/INST]Error code 1 indicates that there are too many open files, implying that the program has exceeded the maximum number of allowed open files."
"[INST]In the context of the C64, what does error code 4 indicate?[/INST]Error code 4 indicates that the file was not found, implying that the file specified in the operation does not exist or cannot be accessed."
"[INST]In the context of the C64, what is the purpose of error codes in KERNAL routines?[/INST]Error codes in KERNAL routines provide a way to identify and handle errors that occur during the execution of KERNAL routines, allowing programs to respond to errors in a controlled manner."
"[INST]In the context of the C64, what is the significance of error code 240?[/INST]Error code 240 indicates a top-of-memory change in RS-232 buffer allocation/deallocation, implying a change in the memory allocation for RS-232 operations."
"[INST]In the context of the C64, how do KERNAL routines indicate an error?[/INST]KERNAL routines indicate an error by setting the carry bit in the accumulator and returning the error code in the accumulator, allowing the program to identify and respond to the error."
"[INST]In the context of the C64, what is the meaning of error code 9?[/INST]Error code 9 indicates an illegal device number, implying that the device number specified in the operation is invalid or not recognized."
"[INST]In the context of the C64, what is the purpose of the error code list in KERNAL routines?[/INST]The error code list in KERNAL routines provides a standardized way to identify and handle errors, allowing programs to respond to errors in a consistent and controlled manner."
"[INST]In the context of the C64, what is the operation being performed by TAX?[/INST]The operation being performed is a transfer of the accumulator to index X"
"[INST]In the context of the C64, TAX: what is the accumulator being transferred to[/INST]Index X"
"[INST]In the context of the C64, TAX: what is the instruction being performed on[/INST]The accumulator"
"[INST]In the context of the C64, TAX: what is the assembly language form of the instruction[/INST]TAX"
"[INST]In the context of the C64, TAX: what is the op code of the instruction[/INST]AA"
"[INST]In the context of the C64, TAX: how many bytes does the instruction occupy[/INST]1"
"[INST]In the context of the C64, TAX: how many cycles does the instruction take[/INST]2"
"[INST]In the context of the C64, TAX: what is the addressing mode of the instruction[/INST]Implied"
"[INST]In the context of the C64, TAX: what is the purpose of the instruction[/INST]To transfer the accumulator to index X"
"[INST]In the context of the C64, What is the purpose of the PEEK and POKE commands in CBM BASIC?[/INST]changing memory locations"
"[INST]In the context of the C64, What is the term for the unique number that identifies each memory location?[/INST]address"
"[INST]In the context of the C64, What is the analogy used to describe the memory in the Commodore 64?[/INST]street of buildings"
"[INST]In the context of the C64, What is the purpose of the PEEK command?[/INST]changing memory locations"
"[INST]In the context of the C64, What is the purpose of the POKE command?[/INST]changing memory locations"
"[INST]In the context of the C64, What is the term for the number on each door in the memory street analogy?[/INST]address"
"[INST]In the context of the C64, What is the purpose of the street of buildings analogy in describing memory?[/INST]to explain how memory is used"
"[INST]In the context of the C64, What is the purpose of the PEEK command in graphics on the screen?[/INST]changing memory locations"
"[INST]In the context of the C64, What is the purpose of the POKE command in sound effects?[/INST]changing memory locations"
"[INST]In the context of the C64, What is the term for the number that identifies each memory location in the street of buildings analogy?[/INST]address"
"[INST]In the context of the C64, what is the purpose of this routine in the context of serial bus communication?[/INST]This routine is used to get information from a device on the serial bus, like a disk, by retrieving a byte of data using full handshaking, and returning it in the accumulator."
"[INST]In the context of the C64, what is the prerequisite to calling this routine?[/INST]The TALK routine must be called first to command the device on the serial bus to send data through the bus, and if necessary, the TKSA KERNAL routine must be used to send a secondary command to the input device."
"[INST]In the context of the C64, how do you use this routine?[/INST]To use this routine, first command a device on the serial bus to prepare to send data to the Commodore 64 using the TALK and TKSA KERNAL routines, then call this routine using JSR, and finally store or use the retrieved data."
"[INST]In the context of the C64, what happens to the retrieved data?[/INST]The retrieved data is returned in the accumulator, and can be stored or used as needed, for example by storing it in a memory location, such as 'DATA>'."
"[INST]In the context of the C64, what if the input device needs a secondary command?[/INST]If the input device needs a secondary command, it must be sent using the TKSA KERNAL routine before calling this routine."
"[INST]In the context of the C64, how are errors handled in this routine?[/INST]Errors are returned in the status word, which can be read using the READST routine."
"[INST]In the context of the C64, in what context is this routine used?[/INST]This routine is used in the context of serial bus communication, specifically to retrieve data from a device on the serial bus, such as a disk."
"[INST]In the context of the C64, what is the role of the TALK routine in this process?[/INST]The TALK routine is used to command a device on the serial bus to prepare to send data to the Commodore 64, which is a prerequisite to calling this routine."
"[INST]In the context of the C64, can you provide an example of how to use this routine?[/INST]Yes, here is an example: JSR ACPTR, STA DATA>, which gets a byte from the bus and stores it in the 'DATA>' memory location."
"[INST]In the context of the C64, what is the significance of full handshaking in this routine?[/INST]Full handshaking is used to ensure reliable data transfer between the Commodore 64 and the device on the serial bus, by providing a mechanism for the device to signal when it is ready to send data."
"[INST]In the context of the C64, what is the function of POTY register in C64?[/INST]POTY register is a special register in the Commodore 64 that is tied to pin 23 of the CIA (Complex Interface Adapter) chip, and is used to read the state of the potentiometer connected to it, allowing the C64 to sense the position of the potentiometer and use it as an input device, commonly used in games and demos to read the position of a joystick or a paddle controller."
"[INST]In the context of the C64, what is the purpose of POTY register in relation to POTX?[/INST]The POTY register serves the same purpose as the POTX register, but is tied to a different pin on the CIA chip, specifically pin 23, allowing the C64 to read the state of a second potentiometer, providing an additional input channel for the system."
"[INST]In the context of the C64, how does POTY register interact with the CIA chip?[/INST]The POTY register interacts with the CIA chip by being connected to pin 23, which allows it to read the state of the potentiometer connected to it, and provide the system with an analog input, which can then be used to control games, demos, or other applications that utilize the potentiometer as an input device."
"[INST]In the context of the C64, what is the significance of pin 23 in relation to POTY?[/INST]Pin 23 of the CIA chip is significant because it is the pin that the POTY register is tied to, allowing the C64 to read the state of the potentiometer connected to it, and use it as an input device, providing an additional input channel for the system."
"[INST]In the context of the C64, how does the POTY register enable joystick control in games?[/INST]The POTY register enables joystick control in games by allowing the system to read the position of the joystick, which is connected to a potentiometer, and use that information to control the game, providing a more immersive and interactive experience for the user."
"[INST]In the context of the C64, what is the relationship between POTY and POTX registers?[/INST]The POTY and POTX registers are related in that they both serve the same purpose, which is to read the state of a potentiometer, but they are tied to different pins on the CIA chip, with POTX tied to pin 22 and POTY tied to pin 23, providing two separate input channels for the system."
"[INST]In the context of the C64, how does the POTY register provide analog input to the system?[/INST]The POTY register provides analog input to the system by reading the state of the potentiometer connected to pin 23 of the CIA chip, and providing that information to the system, which can then use it to control games, demos, or other applications that utilize the potentiometer as an input device."
"[INST]In the context of the C64, what is the role of POTY register in reading joystick position?[/INST]The POTY register plays a crucial role in reading the position of a joystick, which is connected to a potentiometer, by providing the system with an analog input that corresponds to the position of the joystick, allowing the system to accurately track the joystick's movement and respond accordingly."
"[INST]In the context of the C64, how does the POTY register enhance gameplay experience?[/INST]The POTY register enhances the gameplay experience by providing a more immersive and interactive experience for the user, by allowing the system to accurately track the movement of a joystick or paddle controller, and respond accordingly, creating a more engaging and realistic experience for the user."
"[INST]In the context of the C64, what is the significance of POTY register in C64 hardware?[/INST]The POTY register is significant in C64 hardware because it provides an additional input channel for the system, allowing the C64 to read the state of a second potentiometer, and use it as an input device, expanding the system's capabilities and providing more options for game developers and users alike."
"[INST]In the context of the C64, what is the opcode for LSR in accumulator mode?[/INST]The opcode for LSR in accumulator mode is 4A, which takes 1 byte and 2 cycles to execute."
"[INST]In the context of the C64, what is the addressing mode for LSR Oper,X?[/INST]The addressing mode for LSR Oper,X is Zero Page,X, which has an opcode of 56, takes 2 bytes, and executes in 6 cycles."
"[INST]In the context of the C64, what is the difference in cycles between LSR Oper and LSR Oper,X?[/INST]The difference in cycles between LSR Oper and LSR Oper,X is 1 cycle, with LSR Oper taking 5 cycles and LSR Oper,X taking 6 cycles."
"[INST]In the context of the C64, what is the opcode for LSR in absolute mode?[/INST]The opcode for LSR in absolute mode is 4E, which takes 3 bytes and 6 cycles to execute."
"[INST]In the context of the C64, how many bytes does LSR Oper,X take?[/INST]LSR Oper,X takes 2 bytes."
"[INST]In the context of the C64, what is the addressing mode for LSR Oper?[/INST]The addressing mode for LSR Oper is Zero Page, which has an opcode of 46, takes 2 bytes, and executes in 5 cycles."
"[INST]In the context of the C64, what is the opcode for LSR A?[/INST]The opcode for LSR A is 4A, which takes 1 byte and 2 cycles to execute."
"[INST]In the context of the C64, what is the difference in bytes between LSR Oper and LSR Oper,X?[/INST]The difference in bytes between LSR Oper and LSR Oper,X is 0 bytes, as both take 2 bytes."
"[INST]In the context of the C64, what is the addressing mode for LSR Oper,X?[/INST]The addressing mode for LSR Oper,X is Zero Page,X, which has an opcode of 56, takes 2 bytes, and executes in 6 cycles."
"[INST]In the context of the C64, what is the opcode for LSR Oper in absolute mode?[/INST]The opcode for LSR Oper in absolute mode is 4E, which takes 3 bytes and 6 cycles to execute."
"[INST]In the context of the C64, what is the addressing mode of the BRK instruction?[/INST]The addressing mode of the BRK instruction is implied, which means that the instruction does not require any additional memory locations to be specified."
"[INST]In the context of the C64, what is the assembly language form of the BRK instruction?[/INST]The assembly language form of the BRK instruction is simply 'BRK', which is used to force a break in the program flow."
"[INST]In the context of the C64, what is the OP code for the BRK instruction?[/INST]The OP code for the BRK instruction is 00, which is a single byte that represents the instruction."
"[INST]In the context of the C64, how many bytes does the BRK instruction occupy in memory?[/INST]The BRK instruction occupies only 1 byte in memory, making it a very compact instruction."
"[INST]In the context of the C64, how many cycles does the BRK instruction take to execute?[/INST]The BRK instruction takes 7 cycles to execute, which is relatively fast compared to other instructions."
"[INST]In the context of the C64, can the BRK instruction be masked by setting the I flag?[/INST]No, the BRK instruction cannot be masked by setting the I flag, which means that it will always cause an interrupt when executed."
"[INST]In the context of the C64, what is the purpose of the BRK instruction?[/INST]The purpose of the BRK instruction is to force a break in the program flow, which can be useful for debugging or error handling purposes."
"[INST]In the context of the C64, can the BRK instruction be used to implement a software interrupt?[/INST]Yes, the BRK instruction can be used to implement a software interrupt, which can be used to invoke an interrupt service routine."
"[INST]In the context of the C64, what happens when the BRK instruction is executed?[/INST]When the BRK instruction is executed, it generates an interrupt request, which causes the CPU to interrupt its normal operation and execute an interrupt service routine."
"[INST]In the context of the C64, is the BRK instruction a conditional instruction?[/INST]No, the BRK instruction is not a conditional instruction, it always causes a break in the program flow regardless of the current state of the flags."
"[INST]In the context of the C64, Displaying a sprite beyond the 255th X position requires a special POKE which sets the most significant bit of the X position and starts over at the 256th pixel position across the screen.[/INST]True"
"[INST]In the context of the C64, What is the starting point for the X counter when displaying a sprite beyond the 255th X position?[/INST]The 256th pixel position across the screen"
"[INST]In the context of the C64, Chip register 24 contains the overall volume control.[/INST]The volume can be set anywhere between 0 and 15."
"[INST]In the context of the C64, Volume control is set between what values?[/INST]The volume can be set anywhere between 0 and 15."
"[INST]In the context of the C64, What is the range of volume control?[/INST]The volume can be set anywhere between 0 and 15."
"[INST]In the context of the C64, What is the purpose of chip register 24?[/INST]Chip register 24 contains the overall volume control."
"[INST]In the context of the C64, What is the range of volume control in chip register 24?[/INST]The volume can be set anywhere between 0 and 15."
"[INST]In the context of the C64, What is the function of chip register 24?[/INST]Chip register 24 contains the overall volume control."
"[INST]In the context of the C64, What is the range of volume control?[/INST]The volume can be set anywhere between 0 and 15."
"[INST]In the context of the C64, What is the purpose of the IOBASE routine?[/INST]Define I/O memory page"
"[INST]In the context of the C64, What is the call address of the IOBASE routine?[/INST]$FFF3 (hex) 65523 (decimal)"
"[INST]In the context of the C64, What registers are affected by the IOBASE routine?[/INST]X, Y"
"[INST]In the context of the C64, What is the stack requirement for the IOBASE routine?[/INST]2"
"[INST]In the context of the C64, What is the purpose of the X register in the IOBASE routine?[/INST]contains the low order address byte"
"[INST]In the context of the C64, What is the purpose of the Y register in the IOBASE routine?[/INST]contains the high order address byte"
"[INST]In the context of the C64, How do you access the I/O location after calling the IOBASE routine?[/INST]Load the Y register with the offset and access that I/O location"
"[INST]In the context of the C64, What is the benefit of using the IOBASE routine?[/INST]provide compatibility between Commodore 64, VIC-20, and future models"
"[INST]In the context of the C64, What is the instruction used to call the IOBASE routine?[/INST]JSR"
"[INST]In the context of the C64, What is the purpose of storing the X and Y registers in consecutive locations?[/INST]to set the base registers"
"[INST]In the context of the C64, what is the purpose of setting bit 6 of the VIC-II register to 1 at location 53265?[/INST]Extended color mode is turned ON by setting bit 6 of the VIC-II register to 1 at location 53265, which enables the use of additional colors in Commodore 64 graphics."
"[INST]In the context of the C64, how do you turn on extended color mode using a POKE command?[/INST]The POKE command 'POKE 53265,PEEK(53265)OR 64' is used to turn on extended color mode by setting bit 6 of the VIC-II register to 1 at location 53265."
"[INST]In the context of the C64, what is the hexadecimal equivalent of memory location 53265?[/INST]The hexadecimal equivalent of memory location 53265 is $D011."
"[INST]In the context of the C64, in what memory location is the VIC-II register that controls extended color mode found?[/INST]The VIC-II register that controls extended color mode is found at memory location 53265 ($D011 in HEX)."
"[INST]In the context of the C64, what is the effect of setting bit 6 of the VIC-II register to 1?[/INST]Setting bit 6 of the VIC-II register to 1 enables extended color mode, allowing the use of additional colors in Commodore 64 graphics."
"[INST]In the context of the C64, what is the purpose of the POKE command 'POKE 53265,PEEK(53265)OR 64'?[/INST]The POKE command 'POKE 53265,PEEK(53265)OR 64' is used to turn on extended color mode by setting bit 6 of the VIC-II register to 1 at location 53265."
"[INST]In the context of the C64, what is the significance of the number 64 in the POKE command 'POKE 53265,PEEK(53265)OR 64'?[/INST]The number 64 in the POKE command 'POKE 53265,PEEK(53265)OR 64' represents the binary value that sets bit 6 of the VIC-II register to 1, enabling extended color mode."
"[INST]In the context of the C64, what is the function of the PEEK command in the POKE command 'POKE 53265,PEEK(53265)OR 64'?[/INST]The PEEK command in the POKE command 'POKE 53265,PEEK(53265)OR 64' is used to read the current value of the VIC-II register at location 53265, which is then modified by setting bit 6 to 1 using the OR 64 operation."
"[INST]In the context of the C64, in what way does the POKE command 'POKE 53265,PEEK(53265)OR 64' modify the VIC-II register?[/INST]The POKE command 'POKE 53265,PEEK(53265)OR 64' modifies the VIC-II register by setting bit 6 to 1, enabling extended color mode, while preserving the other bits of the register."
"[INST]In the context of the C64, what is the relationship between the VIC-II register and the Commodore 64's graphics capabilities?[/INST]The VIC-II register controls the Commodore 64's graphics capabilities, and setting bit 6 of the register to 1 enables extended color mode, allowing the use of additional colors in graphics."
"[INST]In the context of the C64, What characters are available in SET 1 without pressing the <SHIFT> key?[/INST]In SET 1, the upper case alphabet and the numbers 0-9 are available without pressing the <SHIFT> key."
"[INST]In the context of the C64, How do you access the graphics characters on the RIGHT side of the front of the keys in SET 1?[/INST]If you hold down the <SHIFT> key while typing, the graphics characters on the RIGHT side of the front of the keys are used."
"[INST]In the context of the C64, What happens when you hold down the <C=> key while typing in SET 1?[/INST]If you hold down the <C=> key while typing, the graphics characters on the LEFT side of the front of the key are used."
"[INST]In the context of the C64, What characters are available in SET 2 without pressing the <SHIFT> key?[/INST]In SET 2, the lower case alphabet and the numbers 0-9 are available without pressing the <SHIFT> key."
"[INST]In the context of the C64, How do you access the upper case alphabet in SET 2?[/INST]The upper case alphabet is available when you hold down the <SHIFT> key while typing in SET 2."
"[INST]In the context of the C64, What is the function of the <C=> key in SET 2?[/INST]The graphic symbols on the LEFT side of the front of the keys are displayed by pressing the <C=> key in SET 2."
"[INST]In the context of the C64, How do you access the symbols on the top most part of a key in SET 2?[/INST]The symbols on the top most part of any key without graphics characters are selected when you hold down the <SHIFT> key while typing in SET 2."
"[INST]In the context of the C64, How do you switch between SET 1 and SET 2?[/INST]To switch from one character set to the other, press the <C=> and the <SHIFT> keys together."
"[INST]In the context of the C64, What is the difference between SET 1 and SET 2?[/INST]SET 1 has upper case alphabet and numbers 0-9 available without pressing the <SHIFT> key, while SET 2 has lower case alphabet and numbers 0-9 available without pressing the <SHIFT> key."
"[INST]In the context of the C64, What is the purpose of the <SHIFT> key in both SET 1 and SET 2?[/INST]The <SHIFT> key is used to access additional characters and symbols in both SET 1 and SET 2."
"[INST]In the context of the C64, What is the purpose of the RESTOR function in the Commodore 64 KERNAL?[/INST]The purpose of the RESTOR function is to restore the default values of all system vectors used in KERNAL and BASIC routines and interrupts, which can be found in the Memory Map."
"[INST]In the context of the C64, What is the call address of the RESTOR function?[/INST]The call address of the RESTOR function is $FF8A (hex) or 65418 (decimal)."
"[INST]In the context of the C64, What is the effect of calling the RESTOR function on the system vectors?[/INST]Calling the RESTOR function restores the default values of all system vectors used in KERNAL and BASIC routines and interrupts, as specified in the Memory Map."
"[INST]In the context of the C64, How many bytes are required on the stack when calling the RESTOR function?[/INST]The RESTOR function requires 2 bytes on the stack."
"[INST]In the context of the C64, Which registers are affected when calling the RESTOR function?[/INST]The RESTOR function affects the A, X, and Y registers."
"[INST]In the context of the C64, What is the relationship between the RESTOR function and the KERNAL VECTOR routine?[/INST]The KERNAL VECTOR routine is used to read and alter individual system vectors, whereas the RESTOR function restores the default values of all system vectors."
"[INST]In the context of the C64, How do you use the RESTOR function?[/INST]To use the RESTOR function, simply call it using the JSR instruction, as shown in the example: JSR RESTOR."
"[INST]In the context of the C64, What is the significance of the Memory Map in relation to the RESTOR function?[/INST]The Memory Map provides the default vector contents that are restored by the RESTOR function."
"[INST]In the context of the C64, Can the RESTOR function return an error?[/INST]No, the RESTOR function does not return an error."
"[INST]In the context of the C64, What is the preparatory routine required to call the RESTOR function?[/INST]There are no preparatory routines required to call the RESTOR function."
"[INST]In the context of the C64, How many different dot positions can be individually programmed onto a TV screen in the Y direction?[/INST]There are 200 different dot positions that can be individually programmed onto a TV screen in the Y direction."
"[INST]In the context of the C64, What is the range of numbers that the sprite Y position registers can handle?[/INST]The sprite Y position registers can handle numbers up to 255."
"[INST]In the context of the C64, What is the first on-screen value from the top of the screen for an unexpanded sprite in the Y direction?[/INST]The first on-screen value from the top of the screen for an unexpanded sprite in the Y direction is 30."
"[INST]In the context of the C64, What is the first on-screen value from the top of the screen for a sprite expanded in the Y direction?[/INST]The first on-screen value from the top of the screen for a sprite expanded in the Y direction is 9."
"[INST]In the context of the C64, What is the first Y value in which a sprite (expanded or not) is fully on the screen?[/INST]The first Y value in which a sprite (expanded or not) is fully on the screen is 50."
"[INST]In the context of the C64, What is the last Y value in which an unexpanded sprite is fully on the screen?[/INST]The last Y value in which an unexpanded sprite is fully on the screen is 229."
"[INST]In the context of the C64, What is the last Y value in which an expanded sprite is fully on the screen?[/INST]The last Y value in which an expanded sprite is fully on the screen is 208."
"[INST]In the context of the C64, What is the first Y value in which a sprite is fully off the screen?[/INST]The first Y value in which a sprite is fully off the screen is 250."
"[INST]In the context of the C64, Why do expanded sprites have a different first on-screen value than unexpanded sprites?[/INST]Expanded sprites have a different first on-screen value than unexpanded sprites because each dot is twice as tall, so the initial position is still calculated from the top left corner of the sprite."
"[INST]In the context of the C64, How do the sprite Y position registers handle moving a sprite up and down?[/INST]The sprite Y position registers can handle moving a sprite up and down because they can handle numbers up to 255, which is more than enough to handle moving a sprite on and off the screen smoothly."
"[INST]In the context of the C64, Sound is created by the movement of what in waves?[/INST]air"
"[INST]In the context of the C64, What is the time between one peak of a wave and the next?[/INST]number of seconds"
"[INST]In the context of the C64, What is the reciprocal of the number of seconds?[/INST]cycles per second"
"[INST]In the context of the C64, What determines the highness or lowness of a sound?[/INST]frequency of the sound waves produced"
"[INST]In the context of the C64, What uses two locations to determine the frequency?[/INST]sound generator in your Commodore computer"
"[INST]In the context of the C64, What is the formula to represent the frequency?[/INST]Fn = Fout/.06097"
"[INST]In the context of the C64, What is the next step after figuring out what Fn is?[/INST]create the high and low frequency values for that note"
"[INST]In the context of the C64, What is the formula to set the high frequency location?[/INST]Fhi=INT(Fn/256)"
"[INST]In the context of the C64, What is the formula to set the low frequency location?[/INST]Flo=Fn-(256*Fhi)"
"[INST]In the context of the C64, What can you do with your computer after playing with one voice?[/INST]become the maestro conducting your own computer orchestra"
"[INST]In the context of the C64, What is the purpose of the IOINIT function?[/INST]Initialize I/O devices"
"[INST]In the context of the C64, What is the call address of the IOINIT function?[/INST]$FF84 (hex) 65412 (decimal)"
"[INST]In the context of the C64, What registers are affected by the IOINIT function?[/INST]A, X, Y"
"[INST]In the context of the C64, What is the description of the IOINIT function?[/INST]This routine initializes all input/output devices and routines."
"[INST]In the context of the C64, What is the normal use of the IOINIT function?[/INST]It is normally called as part of the initialization procedure of a Commodore 64 program cartridge."
"[INST]In the context of the C64, What is the result of not initializing I/O devices?[/INST]Error returns"
"[INST]In the context of the C64, What is the stack requirement of the IOINIT function?[/INST]nan"
"[INST]In the context of the C64, What are the preparatory routines of the IOINIT function?[/INST]nan"
"[INST]In the context of the C64, What are the communication registers of the IOINIT function?[/INST]nan"
"[INST]In the context of the C64, what is the clock output phase 0 used for in the 65xx processor[/INST]The clock output Phase 0 is used as the 1-MHz clock input for the 65xx processor, and all system bus activity is referenced to this clock, providing a timing reference for the processor's operations."
"[INST]In the context of the C64, what is the clock frequency generated from[/INST]The clock frequency is generated by dividing the 8-MHz video input clock by eight, resulting in a 1-MHz clock signal."
"[INST]In the context of the C64, what is the purpose of the clock output phase 0 in the system bus[/INST]The clock output Phase 0 provides a timing reference for all system bus activity, ensuring that all components in the system operate in synchronization with the processor."
"[INST]In the context of the C64, what is the relationship between the clock output phase 0 and the system bus[/INST]The clock output Phase 0 is the timing reference for all system bus activity, and all system bus activity is referenced to this clock, ensuring that all components in the system operate in synchronization with the processor."
"[INST]In the context of the C64, what is the frequency of the clock output phase 0[/INST]The frequency of the clock output Phase 0 is 1-MHz, which is generated by dividing the 8-MHz video input clock by eight."
"[INST]In the context of the C64, what is the source of the clock frequency[/INST]The source of the clock frequency is the 8-MHz video input clock, which is divided by eight to generate the 1-MHz clock signal."
"[INST]In the context of the C64, what is the role of the clock output phase 0 in the system[/INST]The clock output Phase 0 plays a crucial role in the system by providing a timing reference for all system bus activity, ensuring that all components in the system operate in synchronization with the processor."
"[INST]In the context of the C64, what is the significance of the clock output phase 0 in the 65xx processor[/INST]The clock output Phase 0 is significant in the 65xx processor as it provides the timing reference for the processor's operations, ensuring that the processor operates correctly and efficiently."
"[INST]In the context of the C64, how is the clock frequency generated in the system[/INST]The clock frequency is generated by dividing the 8-MHz video input clock by eight, resulting in a 1-MHz clock signal that is used as the timing reference for the system."
"[INST]In the context of the C64, what is the relationship between the clock output phase 0 and the processor[/INST]The clock output Phase 0 is the timing reference for the processor, providing the clock signal that drives the processor's operations, and the processor operates in synchronization with this clock signal."
"[INST]In the context of the C64, Can sprites appear to move in front of or behind each other on the screen?[/INST]Sprites can actually make different sprites seem to move in front of or behind each other on the screen."
"[INST]In the context of the C64, What determines which sprites have priority over others when they overlap on the screen?[/INST]The built-in SPRITE PRIORITIES determine which sprites have priority over others when 2 or more sprites overlap on the screen."
"[INST]In the context of the C64, What is the rule for determining sprite priorities?[/INST]The rule is 'first come, first served' which means lower-numbered sprites automatically have priority over higher-numbered sprites."
"[INST]In the context of the C64, What happens when two sprites overlap on the screen?[/INST]The sprite with the lower number will appear to be in front of the sprite with the higher number."
"[INST]In the context of the C64, What is the priority of sprite 0?[/INST]Sprite 0 always supersedes all the other sprites because it's the lowest numbered sprite."
"[INST]In the context of the C64, What is the priority of sprite 7?[/INST]Sprite 7 has less priority than any of the other sprites, and will always appear to be displayed behind any other sprites which overlap its position."
"[INST]In the context of the C64, How do sprite priorities work?[/INST]The priority of a sprite is determined by its number, with lower-numbered sprites having priority over higher-numbered sprites."
"[INST]In the context of the C64, Can you move sprites and take advantage of their priorities in your animation?[/INST]Of course, now that you see how priorities work, you can also move sprites and take advantage of these priorities in your animation."
"[INST]In the context of the C64, what is the opcode for the TYA instruction?[/INST]The opcode for the TYA instruction is 98, which is used to transfer the index Y to the accumulator."
"[INST]In the context of the C64, what is the addressing mode for the TYA instruction?[/INST]The addressing mode for the TYA instruction is implied, which means the instruction operates on the accumulator and index registers without requiring a memory address."
"[INST]In the context of the C64, how many bytes does the TYA instruction occupy in memory?[/INST]The TYA instruction occupies 1 byte in memory, which is the opcode 98."
"[INST]In the context of the C64, how many cycles does the TYA instruction take to execute?[/INST]The TYA instruction takes 2 cycles to execute, which is the time it takes for the CPU to complete the operation."
"[INST]In the context of the C64, what is the purpose of the TYA instruction?[/INST]The purpose of the TYA instruction is to transfer the index Y to the accumulator, which allows the programmer to manipulate the value of Y and use it in further calculations."
"[INST]In the context of the C64, what is the assembly language form of the TYA instruction?[/INST]The assembly language form of the TYA instruction is simply 'TYA', which is used to represent the instruction in assembly language programming."
"[INST]In the context of the C64, in what situation would you use the TYA instruction?[/INST]You would use the TYA instruction when you need to transfer the value of the index Y to the accumulator, such as when you need to perform calculations or comparisons involving the value of Y."
"[INST]In the context of the C64, what is the difference between the TYA instruction and the TAY instruction?[/INST]The TYA instruction transfers the value of Y to the accumulator, whereas the TAY instruction transfers the value of the accumulator to Y, making them complementary instructions."
"[INST]In the context of the C64, can you give an example of a situation where the TYA instruction is necessary?[/INST]For example, if you need to compare the value of Y with a constant, you would use the TYA instruction to transfer the value of Y to the accumulator, and then use a comparison instruction to compare the value with the constant."
"[INST]In the context of the C64, what is the relationship between the TYA instruction and the Y register?[/INST]The TYA instruction is used to transfer the value of the Y register to the accumulator, which allows the programmer to manipulate and use the value of Y in further calculations and operations."
"[INST]In the context of the C64, what is the function of the DEY instruction in 6502 assembly language?[/INST]The DEY instruction in 6502 assembly language is used to decrement the value of the Y register by one. It is an implied addressing mode instruction, which means it operates on the Y register directly without requiring a memory address. The opcode for DEY is 88, and it takes 1 byte of memory and 2 clock cycles to execute."
"[INST]In the context of the C64, what is the addressing mode of the DEY instruction?[/INST]The addressing mode of the DEY instruction is implied, which means it operates on the Y register directly without requiring a memory address."
"[INST]In the context of the C64, what is the opcode for the DEY instruction?[/INST]The opcode for the DEY instruction is 88."
"[INST]In the context of the C64, how many bytes of memory does the DEY instruction require?[/INST]The DEY instruction requires 1 byte of memory."
"[INST]In the context of the C64, how many clock cycles does the DEY instruction take to execute?[/INST]The DEY instruction takes 2 clock cycles to execute."
"[INST]In the context of the C64, what is the purpose of the DEY instruction in a program?[/INST]The purpose of the DEY instruction in a program is to decrement the value of the Y register by one, which can be used to implement loops, counters, and other control structures."
"[INST]In the context of the C64, can the DEY instruction be used with an index register other than Y?[/INST]No, the DEY instruction can only be used with the Y register, it is not possible to use it with the X register or any other index register."
"[INST]In the context of the C64, what happens to the flags when the DEY instruction is executed?[/INST]The DEY instruction affects the N and Z flags, setting them according to the result of the decrement operation."
"[INST]In the context of the C64, in what situation would you use the DEY instruction in a program?[/INST]You would use the DEY instruction in a program when you need to decrement a counter or index variable, such as in a loop that iterates a certain number of times."
"[INST]In the context of the C64, how does the DEY instruction differ from the INY instruction?[/INST]The DEY instruction decrements the Y register, while the INY instruction increments the Y register, the two instructions are complementary and can be used together to implement loops and counters."
"[INST]In the context of the C64, What is the primary function of the Commodore 64's keyboard?[/INST]allows you to type on the keyboard"
"[INST]In the context of the C64, What is the built-in editor on the Commodore 64?[/INST]SCREEN EDITOR"
"[INST]In the context of the C64, What are some of the basic functions of the SCREEN EDITOR?[/INST]move the cursor, DELete, INSert, etc."
"[INST]In the context of the C64, What is the purpose of the BASIC INTERPRETER?[/INST]interprets each command, one by one"
"[INST]In the context of the C64, What happens if the BASIC INTERPRETER encounters a command it does not understand?[/INST]the familiar message appears: ?SYNTAX ERROR"
"[INST]In the context of the C64, What is the name of the program that runs the appropriate machine language depending on the CBM BASIC command?[/INST]BASIC INTERPRETER"
"[INST]In the context of the C64, What is the name of the huge machine language program that runs the CBM BASIC commands?[/INST]huge machine language program"
"[INST]In the context of the C64, What is the purpose of the SCREEN EDITOR in the Commodore 64?[/INST]allows you to move the cursor, DELete, INSert, etc."
"[INST]In the context of the C64, What is the name of the message that appears when the BASIC INTERPRETER encounters an unknown command?[/INST]?SYNTAX ERROR"
"[INST]In the context of the C64, What is the purpose of the READY message in the Commodore 64?[/INST]indicates the system is ready for the next command"
"[INST]In the context of the C64, Get data from the serial bus?[/INST]The purpose of the ACPTR function is to get data from the serial bus."
"[INST]In the context of the C64, ACPTR function call address?[/INST]$FFA5 (hex) 65445 (decimal) is the call address of the ACPTR function."
"[INST]In the context of the C64, What communication registers are used?[/INST]The A communication register is used by the ACPTR function."
"[INST]In the context of the C64, How many stack requirements does ACPTR have?[/INST]The ACPTR function has a stack requirement of 13."
"[INST]In the context of the C64, What registers are affected by ACPTR?[/INST]The ACPTR function affects the A and X registers."
"[INST]In the context of the C64, what does STY stand for?[/INST]Store Y"
"[INST]In the context of the C64, What is the purpose of the STY operation?[/INST]to store index Y in memory"
"[INST]In the context of the C64, What is the abbreviation for the STY operation?[/INST]STY"
"[INST]In the context of the C64, What is the assembly language form of the STY operation?[/INST]STY Oper"
"[INST]In the context of the C64, What is the OP CODE for the STY operation in Zero Page mode?[/INST]84"
"[INST]In the context of the C64, How many bytes does the STY operation in Zero Page mode use?[/INST]2"
"[INST]In the context of the C64, How many cycles does the STY operation in Zero Page mode take?[/INST]3"
"[INST]In the context of the C64, What is the OP CODE for the STY operation in Absolute mode?[/INST]8C"
"[INST]In the context of the C64, How many bytes does the STY operation in Absolute mode use?[/INST]3"
"[INST]In the context of the C64, How many cycles does the STY operation in Absolute mode take?[/INST]4"
"[INST]In the context of the C64, What is the addressing mode for the STY operation in Zero Page,X mode?[/INST]Zero Page,X"
"[INST]In the context of the C64, what is the serial port system[/INST]a buffered, 8-bit synchronous shift register system"
"[INST]In the context of the C64, what determines the mode of the serial port[/INST]a control bit"
"[INST]In the context of the C64, in input mode, what triggers the shift of data into the shift register[/INST]the rising edge of the signal applied to the CNT pin"
"[INST]In the context of the C64, how many CNT pulses are required to dump data into the Serial Data Register[/INST]8"
"[INST]In the context of the C64, in output mode, what is used for the baud rate generator[/INST]TIMER A"
"[INST]In the context of the C64, what determines the maximum useable baud rate[/INST]line loading and the speed at which the receiver responds to input data"
"[INST]In the context of the C64, what triggers the start of transmission[/INST]a write to the Serial Data Register"
"[INST]In the context of the C64, what appears as an output on the CNT pin[/INST]the clock signal derived from TIMER A"
"[INST]In the context of the C64, when does data shifted out become valid[/INST]on the falling edge of CNT"
"[INST]In the context of the C64, how often is an interrupt generated[/INST]after 8 CNT pulses"
"[INST]In the context of the C64, what happens if the Serial Data Register is loaded with new information prior to the interrupt[/INST]the new data will automatically be loaded into the shift register and transmission will continue"
"[INST]In the context of the C64, what is required for continuous transmission[/INST]the microprocessor staying one byte ahead of the shift register"
"[INST]In the context of the C64, what happens to CNT and SP if no further data is to be transmitted[/INST]CNT will return high and SP will remain at the level of the last data bit transmitted"
"[INST]In the context of the C64, in what format is SDR data shifted out[/INST]MSB first"
"[INST]In the context of the C64, what is the capability of the Serial Port and CNT clock[/INST]bidirectional"
"[INST]In the context of the C64, how can multiple 6526 devices be connected[/INST]to a common serial communication bus"
"[INST]In the context of the C64, what is the role of one 6526 device in a common bus[/INST]master, sourcing data and shift clock"
"[INST]In the context of the C64, what is the role of other 6526 devices in a common bus[/INST]slaves"
"[INST]In the context of the C64, why are CNT and SP outputs open drain[/INST]to allow a common bus"
"[INST]In the context of the C64, how can protocol for master/slave selection be transmitted[/INST]over the serial bus, or via dedicated handshaking lines"
"[INST]In the context of the C64, what is the memory range for the VIC (Video Controller)?[/INST]The memory range for the VIC (Video Controller) is D000-D3FF, which is 1 K Bytes."
"[INST]In the context of the C64, What is the memory range for the SID (Sound Synthesizer)?[/INST]The memory range for the SID (Sound Synthesizer) is D400-D7FF, which is 1 K Bytes."
"[INST]In the context of the C64, What is the memory range for the Color RAM?[/INST]The memory range for the Color RAM is D800-DBFF, which is 1 K Nybbles."
"[INST]In the context of the C64, What is the memory range for the CIA1 (Keyboard)?[/INST]The memory range for the CIA1 (Keyboard) is DC00-DCFF, which is 256 Bytes."
"[INST]In the context of the C64, What is the memory range for the CIA2 (Serial Bus, User Port/RS-232)?[/INST]The memory range for the CIA2 (Serial Bus, User Port/RS-232) is DD00-DDFF, which is 256 Bytes."
"[INST]In the context of the C64, What is the memory range for the Open I/O slot #1 (CP/M Enable)?[/INST]The memory range for the Open I/O slot #1 (CP/M Enable) is DE00-DEFF, which is 256 Bytes."
"[INST]In the context of the C64, What is the memory range for the Open I/O slot #2 (Disk)?[/INST]The memory range for the Open I/O slot #2 (Disk) is DF00-DFFF, which is 256 Bytes."
"[INST]In the context of the C64, What is the purpose of the two open I/O slots?[/INST]The two open I/O slots are for general purpose user I/O, special purpose I/O cartridges (such as IEEE), and have been tentatively designated for enabling the Z-80 cartridge (CP/M option) and for interfacing to a low-cost high-speed disk system."
"[INST]In the context of the C64, What is the condition for the auto-start of a program in a Commodore 64 Expansion Cartridge?[/INST]The program in a Commodore 64 Expansion Cartridge will auto-start if the first nine bytes of the cartridge ROM starting at location 32768 ($8000) contain specific data, including the Cold Start vector, Warm Start vector, the letters 'CBM' with bit 7 set in each letter, and the digits '80' in PET ASCII."
"[INST]In the context of the C64, What is the significance of the first two bytes at location 32768 ($8000) in a Commodore 64 Expansion Cartridge?[/INST]The first two bytes at location 32768 ($8000) in a Commodore 64 Expansion Cartridge must hold the Cold Start vector to be used by the cartridge program."
"[INST]In the context of the C64, What is the purpose of the UDTIM function?[/INST]The purpose of the UDTIM function is to update the system clock, which is typically called by the normal KERNAL interrupt routine every 1/60th of a second."
"[INST]In the context of the C64, What is the call address of the UDTIM function?[/INST]The call address of the UDTIM function is $FFEA in hexadecimal, which is equivalent to 65514 in decimal."
"[INST]In the context of the C64, What are the communication registers used by the UDTIM function?[/INST]The UDTIM function does not use any communication registers."
"[INST]In the context of the C64, Are there any preparatory routines required before calling the UDTIM function?[/INST]No, there are no preparatory routines required before calling the UDTIM function."
"[INST]In the context of the C64, What is the error return value of the UDTIM function?[/INST]The UDTIM function does not return any error values."
"[INST]In the context of the C64, What is the stack requirement of the UDTIM function?[/INST]The UDTIM function requires 2 bytes of stack space."
"[INST]In the context of the C64, Which registers are affected by the UDTIM function?[/INST]The UDTIM function affects the A and X registers."
"[INST]In the context of the C64, Why is it necessary to call the UDTIM function in a user program?[/INST]It is necessary to call the UDTIM function in a user program if the program processes its own interrupts, in order to update the system clock and keep the STOP key functional."
"[INST]In the context of the C64, How often is the UDTIM function typically called by the KERNAL interrupt routine?[/INST]The UDTIM function is typically called by the KERNAL interrupt routine every 1/60th of a second."
"[INST]In the context of the C64, What is an example of how to use the UDTIM function?[/INST]An example of how to use the UDTIM function is to simply call it using the JSR instruction, like this: JSR UDTIM>."
"[INST]In the context of the C64, What is the relationship between the UDTIM function and the STOP key?[/INST]The UDTIM function must be called in order to keep the STOP key functional, in addition to calling the STOP key routine itself."
"[INST]In the context of the C64, what is the purpose of the BIT instruction in 6502 assembly language?[/INST]The BIT instruction is used to test bits in memory with the accumulator. It transfers bits 6 and 7 to the status register, and sets the zero flag if the result of A /\ M is zero, where A is the accumulator and M is the memory location."
"[INST]In the context of the C64, what happens to bits 6 and 7 during a BIT instruction?[/INST]During a BIT instruction, bits 6 and 7 are transferred to the status register, which affects the status flags N, Z, C, I, D, and V."
"[INST]In the context of the C64, what is the effect of the result of A /\ M on the zero flag?[/INST]If the result of A /\ M is zero, then the zero flag Z is set to 1, otherwise it is set to 0."
"[INST]In the context of the C64, what is the opcode for the BIT instruction in zero page addressing mode?[/INST]The opcode for the BIT instruction in zero page addressing mode is 24."
"[INST]In the context of the C64, what is the number of bytes required for the BIT instruction in absolute addressing mode?[/INST]The BIT instruction in absolute addressing mode requires 3 bytes."
"[INST]In the context of the C64, what is the number of cycles required for the BIT instruction in zero page addressing mode?[/INST]The BIT instruction in zero page addressing mode requires 3 cycles."
"[INST]In the context of the C64, what is the assembly language form for the BIT instruction in zero page addressing mode?[/INST]The assembly language form for the BIT instruction in zero page addressing mode is BIT Oper, where Oper is the zero page address."
"[INST]In the context of the C64, what is the difference in the number of bytes required for the BIT instruction between zero page and absolute addressing modes?[/INST]The BIT instruction in zero page addressing mode requires 2 bytes, whereas in absolute addressing mode it requires 3 bytes."
"[INST]In the context of the C64, what is the purpose of the status register in the BIT instruction?[/INST]The status register is used to store the result of the BIT instruction, specifically bits 6 and 7, which affect the status flags N, Z, C, I, D, and V."
"[INST]In the context of the C64, what is the relationship between the accumulator and memory location M in the BIT instruction?[/INST]In the BIT instruction, the accumulator A is logically ANDed with the memory location M, and the result affects the status flags."
"[INST]In the context of the C64, What are the three forms of data storage on floppy diskettes?[/INST]Sequential files, relative files, and random files are the three forms of data storage on floppy diskettes, each with its own unique characteristics and uses."
"[INST]In the context of the C64, How do relative files organize data on floppy diskettes?[/INST]Relative files organize data into records, allowing individual records to be read and replaced within the file, providing a structured approach to data storage."
"[INST]In the context of the C64, What is the purpose of the command channel in relative and random files?[/INST]The command channel is used to send commands to the drive, specifying where to store the data, and once the record or block is complete, the entire buffer is written to the disk."
"[INST]In the context of the C64, What is the role of the data channel in relative and random files?[/INST]The data channel is used to store data in a temporary buffer in the disk's RAM, where it is held until the record or block is complete, and then written to the disk."
"[INST]In the context of the C64, What is the advantage of using relative disk files for applications that require large amounts of data processing?[/INST]Relative disk files use the least amount of time and provide the best flexibility for the programmer, making them ideal for applications that require large amounts of data processing."
"[INST]In the context of the C64, How do you separate data when using the PRINT# statement on floppy diskettes?[/INST]When using the PRINT# statement on floppy diskettes, RETURNs or commas are needed to separate the data, similar to the limitations on cassette tape."
"[INST]In the context of the C64, What is the significance of CHR$(0) when using the GET# statement on floppy diskettes?[/INST]CHR$(0) is read by the GET# statement as an empty string, which is important to consider when working with data on floppy diskettes."
"[INST]In the context of the C64, What is a block in the context of random files on floppy diskettes?[/INST]A block is a 256-byte section of data in a random file on a floppy diskette, which is the basic unit of data storage and retrieval."
"[INST]In the context of the C64, What is the purpose of the disk drive manual in relation to disk files?[/INST]The disk drive manual provides a complete programming guide for using disk files, which is an essential resource for programmers working with floppy diskettes."
"[INST]In the context of the C64, How do sequential files on floppy diskettes compare to those on tape?[/INST]Sequential files on floppy diskettes are similar to those on tape, but multiple files can be used at the same time, providing more flexibility and convenience."
"[INST]In the context of the C64, what is the opcode for loading index X with immediate value[/INST]The opcode for loading index X with an immediate value is A2, which requires 2 bytes and takes 2 cycles to execute."
"[INST]In the context of the C64, What is the addressing mode used in the instruction LDX Oper[/INST]The addressing mode used in the instruction LDX Oper is Zero Page, which uses the opcode A6, requires 2 bytes, and takes 3 cycles to execute."
"[INST]In the context of the C64, How many bytes are required to execute the instruction LDX Oper,Y[/INST]The instruction LDX Oper,Y requires 2 bytes and takes 4 cycles to execute, using the opcode B6 and the Zero Page,Y addressing mode."
"[INST]In the context of the C64, What is the opcode for loading index X with an absolute value[/INST]The opcode for loading index X with an absolute value is AE, which requires 3 bytes and takes 4 cycles to execute."
"[INST]In the context of the C64, What is the addressing mode used in the instruction LDX Oper,Y with absolute addressing[/INST]The addressing mode used in the instruction LDX Oper,Y with absolute addressing is Absolute,Y, which uses the opcode BE, requires 3 bytes, and takes 4 cycles to execute, with an additional cycle added if a page boundary is crossed."
"[INST]In the context of the C64, How many cycles does it take to execute the instruction LDX #Oper[/INST]The instruction LDX #Oper takes 2 cycles to execute."
"[INST]In the context of the C64, What is the difference in cycles between LDX Oper and LDX Oper,Y[/INST]The instruction LDX Oper takes 3 cycles to execute, while the instruction LDX Oper,Y takes 4 cycles to execute, making a difference of 1 cycle."
"[INST]In the context of the C64, How many bytes are required to execute the instruction LDX #Oper[/INST]The instruction LDX #Oper requires 2 bytes."
"[INST]In the context of the C64, What is the opcode for loading index X with a zero page value[/INST]The opcode for loading index X with a zero page value is A6, which requires 2 bytes and takes 3 cycles to execute."
"[INST]In the context of the C64, What is the addressing mode used in the instruction LDX Oper with absolute addressing[/INST]The addressing mode used in the instruction LDX Oper with absolute addressing is Absolute, which uses the opcode AE, requires 3 bytes, and takes 4 cycles to execute."
"[INST]In the context of the C64, What is the purpose of the SAVE function?[/INST]The purpose of the SAVE function is to save memory to a device."
"[INST]In the context of the C64, What is the call address of the SAVE function?[/INST]The call address of the SAVE function is $FFD8 (hex) or 65496 (decimal)."
"[INST]In the context of the C64, What are the communication registers used by the SAVE function?[/INST]The communication registers used by the SAVE function are A, X, and Y."
"[INST]In the context of the C64, What are the preparatory routines required by the SAVE function?[/INST]The preparatory routines required by the SAVE function are SETLFS and SETNAM."
"[INST]In the context of the C64, What error returns can occur when using the SAVE function?[/INST]The error returns that can occur when using the SAVE function are 5, 8, 9, and READST."
"[INST]In the context of the C64, What are the stack requirements for the SAVE function?[/INST]The SAVE function has no stack requirements."
"[INST]In the context of the C64, What registers are affected by the SAVE function?[/INST]The registers affected by the SAVE function are A, X, and Y."
"[INST]In the context of the C64, What is the memory saved from when using the SAVE function?[/INST]The memory saved from when using the SAVE function is an indirect address on page 0 specified by the accumulator."
"[INST]In the context of the C64, What is the memory saved to when using the SAVE function?[/INST]The memory saved to when using the SAVE function is a logical file on an input/output device."
"[INST]In the context of the C64, What is required to be used before calling the SAVE function?[/INST]The SETLFS and SETNAM routines must be used before calling the SAVE function."
"[INST]In the context of the C64, Is a file name required to save to device 1?[/INST]No, a file name is not required to save to device 1 (the Datassette recorder)."
"[INST]In the context of the C64, What happens if you try to save to devices 0, 2, or 3?[/INST]If you try to save to devices 0 (the keyboard), 2 (RS-232), or 3 (the screen), an error occurs and the SAVE is stopped."
"[INST]In the context of the C64, How do you use the SAVE function?[/INST]You use the SAVE function by calling the SETLFS and SETNAM routines, loading the accumulator and registers with the correct values, and then calling the SAVE routine."
"[INST]In the context of the C64, What is the format of the pointer to the start of the save?[/INST]The format of the pointer to the start of the save is standard 6502 low byte first, high byte next."
"[INST]In the context of the C64, What is the purpose of the SETLFS routine?[/INST]The purpose of the SETLFS routine is to set the file system before calling the SAVE function."
"[INST]In the context of the C64, What is the purpose of the SETNAM routine?[/INST]The purpose of the SETNAM routine is to set the file name before calling the SAVE function, unless saving to device 1."
"[INST]In the context of the C64, What is the device number for the cassette recorder?[/INST]The device number for the cassette recorder is 1."
"[INST]In the context of the C64, What is the error that occurs if you try to save to devices 0, 2, or 3?[/INST]The error that occurs if you try to save to devices 0, 2, or 3 is an error return."
"[INST]In the context of the C64, what is the most important register in the 6510 microprocessor?[/INST]This is the accumulator, which is the central register that plays a crucial role in executing machine language instructions, allowing data to be copied from memory locations, modified, and performing mathematical operations."
"[INST]In the context of the C64, what are some of the operations that can be performed on the accumulator?[/INST]The accumulator can be loaded with data from memory locations, its contents can be copied into memory locations, and it can be modified directly without affecting memory, and it is the only register that has instructions for performing mathematical operations."
"[INST]In the context of the C64, what is unique about the accumulator compared to other registers?[/INST]The accumulator is the only register that has instructions for performing mathematical operations, making it a critical component in the execution of machine language instructions."
"[INST]In the context of the C64, can the accumulator interact with memory locations?[/INST]Yes, the accumulator can interact with memory locations by copying data from memory into the accumulator and vice versa, allowing for data manipulation and processing."
"[INST]In the context of the C64, what is the significance of the accumulator in machine language instructions?[/INST]The accumulator is the central register that enables the execution of machine language instructions, allowing for data manipulation, modification, and mathematical operations to be performed."
"[INST]In the context of the C64, can the accumulator be modified directly?[/INST]Yes, the accumulator can be modified directly without affecting memory, allowing for efficient data processing and manipulation."
"[INST]In the context of the C64, what is the role of the accumulator in data processing?[/INST]The accumulator plays a crucial role in data processing by enabling the execution of machine language instructions, allowing data to be manipulated, modified, and processed."
"[INST]In the context of the C64, is the accumulator the only register that can perform mathematical operations?[/INST]Yes, the accumulator is the only register that has instructions for performing mathematical operations, making it a unique and critical component of the 6510 microprocessor."
"[INST]In the context of the C64, can the accumulator copy data from memory locations?[/INST]Yes, the accumulator can copy data from memory locations, allowing for data to be retrieved and processed."
"[INST]In the context of the C64, what is the relationship between the accumulator and memory locations?[/INST]The accumulator can interact with memory locations, allowing for data to be copied, modified, and processed, enabling the execution of machine language instructions."
"[INST]In the context of the C64, What is the call address of the UNTLK function?[/INST]$FFAB (hex) 65451 (decimal)"
"[INST]In the context of the C64, What is the purpose of the UNTLK function?[/INST]Send an UNTALK command"
"[INST]In the context of the C64, What registers are affected by the UNTLK function?[/INST]Registers affected: A"
"[INST]In the context of the C64, What is the stack requirement for the UNTLK function?[/INST]8"
"[INST]In the context of the C64, What is the error return for the UNTLK function?[/INST]See READST"
"[INST]In the context of the C64, What is the description of the UNTLK function?[/INST]This routine transmits an UNTALK command on the serial bus."
"[INST]In the context of the C64, What devices will stop sending data when the UNTLK command is received?[/INST]All devices previously set to TALK"
"[INST]In the context of the C64, What is the preparatory routine for the UNTLK function?[/INST]nan"
"[INST]In the context of the C64, What is the communication register for the UNTLK function?[/INST]nan"
"[INST]In the context of the C64, RS232: Closing an RS-232 data channel discards all data in the buffers at the time of execution[/INST]True"
"[INST]In the context of the C64, RS232: What happens to the RTS and transmitted data lines when closing an RS-232 channel?[/INST]Sets the RTS and transmitted data (Sout) lines high"
"[INST]In the context of the C64, RS232: What is the purpose of the CLOSE command in RS-232?[/INST]To discard all data in the buffers and stop transmitting and receiving"
"[INST]In the context of the C64, RS232: What happens to the RS-232 buffers when closing an RS-232 channel?[/INST]Removes both RS-232 buffers"
"[INST]In the context of the C64, RS232: What is the syntax for closing an RS-232 channel?[/INST]CLOSE lfn"
"[INST]In the context of the C64, RS232: What is the KERNAL entry for closing an RS-232 channel?[/INST]$FFC3"
"[INST]In the context of the C64, RS232: What should be done before closing an RS-232 channel?[/INST]Ensure all data is transmitted"
"[INST]In the context of the C64, RS232: What is the purpose of the check in BASIC to ensure all data is transmitted?[/INST]To check if SS=0 or SS=8"
"[INST]In the context of the C64, RS232: What happens if the data is not transmitted before closing an RS-232 channel?[/INST]Data loss"
"[INST]In the context of the C64, RS232: What is the purpose of the 6526 device?[/INST]To provide a 3-line interface"
"[INST]In the context of the C64, RS232: What is the purpose of the RTS line?[/INST]To request to send data"
"[INST]In the context of the C64, RS232: What is the purpose of the DTR line?[/INST]To indicate data terminal ready"
"[INST]In the context of the C64, RS232: What is the purpose of the RI line?[/INST]To indicate ring indicator"
"[INST]In the context of the C64, RS232: What is the purpose of the DCD line?[/INST]To indicate received line signal"
"[INST]In the context of the C64, RS232: What is the purpose of the CTS line?[/INST]To indicate clear to send"
"[INST]In the context of the C64, RS232: What is the purpose of the DSR line?[/INST]To indicate data set ready"
"[INST]In the context of the C64, RS232: What is the purpose of the Sout line?[/INST]To transmit data"
"[INST]In the context of the C64, RS232: What is the purpose of the Sin line?[/INST]To receive data"
"[INST]In the context of the C64, RS232: What is the purpose of the GND line?[/INST]To provide a protective ground"
"[INST]In the context of the C64, RS232: What is the purpose of the PA2 line?[/INST]To transmit data"
"[INST]In the context of the C64, RS232: What is the purpose of the PB0 line?[/INST]To receive data"
"[INST]In the context of the C64, RS232: What is the purpose of the PB1 line?[/INST]To request to send data"
"[INST]In the context of the C64, RS232: What is the purpose of the PB2 line?[/INST]To indicate data terminal ready"
"[INST]In the context of the C64, RS232: What is the purpose of the PB3 line?[/INST]To indicate ring indicator"
"[INST]In the context of the C64, RS232: What is the purpose of the PB4 line?[/INST]To indicate received line signal"
"[INST]In the context of the C64, RS232: What is the purpose of the PB5 line?[/INST]Unused"
"[INST]In the context of the C64, RS232: What is the purpose of the PB6 line?[/INST]To clear to send"
"[INST]In the context of the C64, RS232: What is the purpose of the PB7 line?[/INST]To indicate data set ready"
"[INST]In the context of the C64, RS232: What is the purpose of the ST variable?[/INST]To read the RS-232 status word"
"[INST]In the context of the C64, RS232: What is the purpose of the SR variable?[/INST]To assign the ST variable to another variable"
"[INST]In the context of the C64, RS232: What happens to the RS-232 status word when the RS-232 channel is closed?[/INST]It is cleared"
"[INST]In the context of the C64, Command a device on the serial bus to what?[/INST]TALK"
"[INST]In the context of the C64, What is the call address of the TALK function?[/INST]$FFB4 (hex) 65460 (decimal)"
"[INST]In the context of the C64, What communication registers are used by the TALK function?[/INST]A"
"[INST]In the context of the C64, What is the purpose of the TALK function?[/INST]Command a device on the serial bus to TALK"
"[INST]In the context of the C64, What is the stack requirement for the TALK function?[/INST]8"
"[INST]In the context of the C64, What registers are affected by the TALK function?[/INST]A"
"[INST]In the context of the C64, How do you use the TALK function?[/INST]Load the accumulator with the device number, then call this routine"
"[INST]In the context of the C64, What is the range of device numbers that can be loaded into the accumulator?[/INST]0 to 31"
"[INST]In the context of the C64, What happens when the TALK function is called?[/INST]The data is transmitted as a command on the serial bus"
"[INST]In the context of the C64, what is a sprite in the context of the C64?[/INST]A sprite is a special type of user definable character which can be displayed anywhere on the screen, maintained directly by the VIC-II chip, and can be customized to have a specific appearance, color, and position."
"[INST]In the context of the C64, how many colors can a sprite be?[/INST]A sprite can be any of the 16 colors available."
"[INST]In the context of the C64, can sprites be used with other graphics modes?[/INST]Yes, sprites can be used with any of the other graphics modes, including bit mapped, character, multi-color, etc., and they'll keep their shape in all of them."
"[INST]In the context of the C64, how many sprites can be maintained by the VIC-II chip at a time?[/INST]Up to 8 sprites at a time can be maintained by the VIC-II chip automatically."
"[INST]In the context of the C64, what is the size of a sprite?[/INST]A sprite is 24 horizontal dots by 21 vertical dots in size."
"[INST]In the context of the C64, can sprites have individual colors?[/INST]Yes, each sprite has individual color control."
"[INST]In the context of the C64, what is sprite multi-color mode?[/INST]Sprite multi-color mode is one of the features of sprites, allowing them to have multiple colors."
"[INST]In the context of the C64, can sprites be magnified?[/INST]Yes, sprites can be magnified (2x) in horizontal, vertical, or both directions."
"[INST]In the context of the C64, how do sprites interact with the background?[/INST]Sprites have selectable sprite to background priority, and can also detect collisions with the background."
"[INST]In the context of the C64, can sprites detect collisions with each other?[/INST]Yes, sprites can detect collisions with each other, allowing for more complex interactions."
"[INST]In the context of the C64, What is the purpose of the SETLFS routine?[/INST]Set up a logical file"
"[INST]In the context of the C64, What is the call address of the SETLFS routine?[/INST]$FFBA (hex) 65466 (decimal)"
"[INST]In the context of the C64, What communication registers are used by the SETLFS routine?[/INST]A, X, Y"
"[INST]In the context of the C64, What is the stack requirement of the SETLFS routine?[/INST]2"
"[INST]In the context of the C64, What is the purpose of the logical file number?[/INST]used by the system as a key to the file table created by the OPEN file routine"
"[INST]In the context of the C64, What are the possible device addresses?[/INST]0 to 31"
"[INST]In the context of the C64, What is the meaning of device number 4 or greater?[/INST]devices on the serial bus"
"[INST]In the context of the C64, What is the purpose of the Y index register?[/INST]to send a secondary address on the serial bus"
"[INST]In the context of the C64, How do you load the Y index register?[/INST]set to 255"
"[INST]In the context of the C64, What is the purpose of the SETLFS routine?[/INST]sets the logical file number, device address, and secondary address for other KERNAL routines"
"[INST]In the context of the C64, What is the purpose of the video matrix counter outputs denoted by VCx?[/INST]The video matrix counter outputs denoted by VCx are used to step through the same 40 locations for eight raster lines, continuing to the next 40 locations every eighth line, resulting in each eight sequential memory locations being formatted as an 8*8 dot block on the video display."
"[INST]In the context of the C64, What is the function of the 3-bit raster line counter denoted by RCx?[/INST]The 3-bit raster line counter denoted by RCx increments once for each horizontal video line, also known as a raster line, and is used in conjunction with the video matrix counter to generate the video display."
"[INST]In the context of the C64, What is the significance of register 24 ($18) in the context of the video display?[/INST]Register 24 ($18) is used to store the value of CB13, which is used in the video display generation process, specifically in conjunction with the video matrix counter and raster line counter to generate the 8*8 dot blocks on the video display."
"[INST]In the context of the C64, How does the video matrix counter address memory locations?[/INST]The video matrix counter addresses memory locations by stepping through the same 40 locations for eight raster lines, continuing to the next 40 locations every eighth line, resulting in each eight sequential memory locations being formatted as an 8*8 dot block on the video display."
"[INST]In the context of the C64, What is the relationship between the video matrix counter and the raster line counter?[/INST]The video matrix counter and the raster line counter work together to generate the video display, with the video matrix counter stepping through memory locations and the raster line counter incrementing for each horizontal video line, resulting in the formation of 8*8 dot blocks on the video display."
"[INST]In the context of the C64, What is the purpose of the 8*8 dot blocks on the video display?[/INST]The 8*8 dot blocks on the video display are the result of the video matrix counter and raster line counter working together to format each eight sequential memory locations into a visually coherent block on the screen."
"[INST]In the context of the C64, How does the video matrix counter step through memory locations?[/INST]The video matrix counter steps through memory locations by continuing to the next 40 locations every eighth line, resulting in each eight sequential memory locations being formatted as an 8*8 dot block on the video display."
"[INST]In the context of the C64, What is the significance of the eighth line in the video display generation process?[/INST]The eighth line is significant because it marks the point at which the video matrix counter continues to the next 40 locations, resulting in each eight sequential memory locations being formatted as an 8*8 dot block on the video display."
"[INST]In the context of the C64, How do the video matrix counter and raster line counter interact to generate the video display?[/INST]The video matrix counter steps through memory locations, while the raster line counter increments for each horizontal video line, resulting in the formation of 8*8 dot blocks on the video display, which are then displayed on the screen."
"[INST]In the context of the C64, What is the result of the video matrix counter and raster line counter working together?[/INST]The result of the video matrix counter and raster line counter working together is the formation of 8*8 dot blocks on the video display, which are then displayed on the screen, resulting in a visually coherent image."
"[INST]In the context of the C64, what is the opcode for decrement memory by one in zero page addressing mode?[/INST]The opcode for decrement memory by one in zero page addressing mode is C6, which requires 2 bytes and takes 5 cycles to execute."
"[INST]In the context of the C64, what is the assembly language form for decrement memory by one in zero page,X addressing mode?[/INST]The assembly language form for decrement memory by one in zero page,X addressing mode is DEC Oper,X, which has an opcode of D6, requires 2 bytes, and takes 6 cycles to execute."
"[INST]In the context of the C64, what is the opcode for decrement memory by one in absolute addressing mode?[/INST]The opcode for decrement memory by one in absolute addressing mode is CE, which requires 3 bytes and takes 6 cycles to execute."
"[INST]In the context of the C64, what is the assembly language form for decrement memory by one in absolute,X addressing mode?[/INST]The assembly language form for decrement memory by one in absolute,X addressing mode is DEC Oper,X, which has an opcode of DE, requires 3 bytes, and takes 7 cycles to execute."
"[INST]In the context of the C64, what is the difference in the number of bytes required between zero page and absolute addressing modes for the DEC instruction?[/INST]The zero page addressing mode requires 2 bytes, while the absolute addressing mode requires 3 bytes, making the absolute addressing mode require 1 more byte than the zero page addressing mode."
"[INST]In the context of the C64, how many cycles does it take to execute the DEC instruction in zero page addressing mode?[/INST]It takes 5 cycles to execute the DEC instruction in zero page addressing mode."
"[INST]In the context of the C64, what is the opcode for the DEC instruction in zero page,X addressing mode?[/INST]The opcode for the DEC instruction in zero page,X addressing mode is D6."
"[INST]In the context of the C64, in which addressing modes can the DEC instruction be used?[/INST]The DEC instruction can be used in zero page, zero page,X, absolute, and absolute,X addressing modes."
"[INST]In the context of the C64, what is the difference in the number of cycles required between the DEC instruction in zero page and absolute addressing modes?[/INST]The DEC instruction in zero page addressing mode requires 5 cycles, while in absolute addressing mode it requires 6 cycles, making the absolute addressing mode require 1 more cycle than the zero page addressing mode."
"[INST]In the context of the C64, what is the assembly language form for the DEC instruction in absolute addressing mode?[/INST]The assembly language form for the DEC instruction in absolute addressing mode is DEC Oper, which has an opcode of CE, requires 3 bytes, and takes 6 cycles to execute."
"[INST]In the context of the C64, Where is the sprite definition block located if sprite pointer #0 at location 2040 contains the number 14?[/INST]The sprite definition block is located at location 896, which is in the cassette buffer, calculated using the formula LOCATION = (BANK * 16384) + (SPRITE POINTER VALUE * 64), where BANK is the 16K segment of memory that the VIC-II chip is looking at and is from 0 to 3."
"[INST]In the context of the C64, What is the formula to calculate the start of the 64 bytes of the sprite definition block?[/INST]The formula is LOCATION = (BANK * 16384) + (SPRITE POINTER VALUE * 64), where BANK is the 16K segment of memory that the VIC-II chip is looking at and is from 0 to 3, and SPRITE POINTER VALUE is the value stored in the sprite pointer."
"[INST]In the context of the C64, Why can't sprite definitions be placed in BANK 0 or BANK 2?[/INST]Because in BANK 0 or BANK 2, there is a ROM IMAGE of the character set present in certain locations, and sprite definitions cannot be placed there."
"[INST]In the context of the C64, What should you do if you need more than 128 different sprite definitions?[/INST]You should use one of the banks without the ROM IMAGE, which are BANK 1 or BANK 3, to place your sprite definitions."
"[INST]In the context of the C64, What is the purpose of the sprite pointer value?[/INST]The sprite pointer value is used to calculate the location of the sprite definition block, which is a 64-byte block that defines the sprite."
"[INST]In the context of the C64, What is the significance of the number 14 in the sprite pointer #0 at location 2040?[/INST]The number 14 is the sprite pointer value, which is used to calculate the location of the sprite definition block, which is 896 in this case."
"[INST]In the context of the C64, How many bytes are in a sprite definition block?[/INST]A sprite definition block is 64 bytes long."
"[INST]In the context of the C64, What is the range of values for the BANK in the formula LOCATION = (BANK * 16384) + (SPRITE POINTER VALUE * 64)?[/INST]The range of values for the BANK is from 0 to 3."
"[INST]In the context of the C64, What is the purpose of the formula LOCATION = (BANK * 16384) + (SPRITE POINTER VALUE * 64)?[/INST]The formula is used to calculate the start of the 64 bytes of the sprite definition block."
"[INST]In the context of the C64, In which banks can sprite definitions be placed?[/INST]Sprite definitions can be placed in BANK 1 or BANK 3, which do not have a ROM IMAGE of the character set."
"[INST]In the context of the C64, What is the simplest form of output in BASIC?[/INST]The simplest form of output in BASIC is the PRINT statement."
"[INST]In the context of the C64, What is the purpose of formatting information on the screen?[/INST]To make it easy to read."
"[INST]In the context of the C64, What is the role of the eyes in using the information on the screen?[/INST]They are the input device."
"[INST]In the context of the C64, What is the purpose of using colors, placement of letters, and capital and lower case letters?[/INST]To best communicate the information."
"[INST]In the context of the C64, What is the function of the <CRSR> key?[/INST]It makes the cursor change position."
"[INST]In the context of the C64, What is the character code number of the <RETURN> key?[/INST]13."
"[INST]In the context of the C64, What is the purpose of the TAB function?[/INST]To position the cursor on the given position from the left edge of the screen."
"[INST]In the context of the C64, What is the purpose of the SPC function?[/INST]To move the cursor right a given number of spaces from the current position."
"[INST]In the context of the C64, What is the purpose of punctuation marks in the PRINT statement?[/INST]To separate and format information."
"[INST]In the context of the C64, What is the function of the semicolon in the PRINT statement?[/INST]It separates 2 items without any spaces in between."
"[INST]In the context of the C64, What happens when a semicolon is the last thing on a line?[/INST]The cursor remains after the last thing PRINTed instead of going down to the next line."
"[INST]In the context of the C64, What is the purpose of the comma in the PRINT statement?[/INST]It separates items into columns."
"[INST]In the context of the C64, How many columns are on the Commodore 64 screen?[/INST]4 columns of 10 characters each."
"[INST]In the context of the C64, What happens when the computer PRINTs a comma?[/INST]It moves the cursor right to the start of the next column."
"[INST]In the context of the C64, What is the purpose of quote marks in the PRINT statement?[/INST]To separate literal text from variables."
"[INST]In the context of the C64, What is the function of the RETURN code?[/INST]It makes the cursor go to the next logical line on the screen."
"[INST]In the context of the C64, What is a logical line on the screen?[/INST]It can be 1 or 2 screen lines long, depending on what was typed or PRINTed."
"[INST]In the context of the C64, How does the computer know that two lines are really one long line?[/INST]The links are held in the line link table."
"[INST]In the context of the C64, What determines where the <RETURN> key sends the cursor?[/INST]The logical line the cursor is on."
"[INST]In the context of the C64, What determines if the screen scrolls 1 or 2 lines at a time?[/INST]The logical line at the top of the screen."
"[INST]In the context of the C64, What are some other ways to use the TV as an output device?[/INST]Graphics, changing screen and border colors and sizes, and creating music and special effects."
"[INST]In the context of the C64, What chapter describes how to create objects that move across the screen?[/INST]The chapter on graphics."
"[INST]In the context of the C64, What section tells how the screen and border colors and sizes are changed?[/INST]The VIC chip section."
"[INST]In the context of the C64, What chapter tells how the TV speaker creates music and special effects?[/INST]The sound chapter."
"[INST]In the context of the C64, How do you write machine language programs?[/INST]You must use either a program to do this, or write for yourself a BASIC program that allows you to write machine language."
"[INST]In the context of the C64, What is the most common method used to write machine language programs?[/INST]Assembler programs are the most common method used to write machine language programs."
"[INST]In the context of the C64, What is an assembler?[/INST]An assembler is a program that allows you to write machine language instructions in a standardized mnemonic format."
"[INST]In the context of the C64, What is the purpose of an assembler?[/INST]The purpose of an assembler is to make machine language programs more readable by allowing you to write machine language instructions in a standardized mnemonic format."
"[INST]In the context of the C64, What is the difference between an assembler and a disassembler?[/INST]An assembler is a program that allows you to write machine language instructions in a standardized mnemonic format, while a disassembler is a program that displays a machine language program in mnemonic format."
"[INST]In the context of the C64, What is a machine language monitor cartridge?[/INST]A machine language monitor cartridge is a cartridge made by Commodore that includes an assembler and disassembler, among other features."
"[INST]In the context of the C64, What is the purpose of a machine language monitor cartridge?[/INST]The purpose of a machine language monitor cartridge is to provide a tool for writing and editing machine language programs."
"[INST]In the context of the C64, What is the importance of using a program to write machine language programs?[/INST]Using a program to write machine language programs is important because it allows you to write machine language instructions in a standardized mnemonic format."
"[INST]In the context of the C64, What are the benefits of using an assembler?[/INST]The benefits of using an assembler include making machine language programs more readable and allowing you to write machine language instructions in a standardized mnemonic format."
"[INST]In the context of the C64, What are the limitations of writing machine language programs without an assembler?[/INST]Writing machine language programs without an assembler can be difficult and may result in a stream of numbers that is hard to read."
"[INST]In the context of the C64, What is the operation of TXA?[/INST]TXA Transfer index X to accumulator"
"[INST]In the context of the C64, What is the purpose of TXA?[/INST]TXA Transfer index X to accumulator"
"[INST]In the context of the C64, What is the assembly language form of TXA?[/INST]Assembly Language Form: TXA"
"[INST]In the context of the C64, What is the OP CODE of TXA?[/INST]OP CODE: 8A"
"[INST]In the context of the C64, How many bytes does TXA take?[/INST]No. Bytes: 1"
"[INST]In the context of the C64, How many cycles does TXA take?[/INST]No. Cycles: 2"
"[INST]In the context of the C64, VIC is located at which memory range[/INST]D000-D3FF"
"[INST]In the context of the C64, The Commodore 64 has how many open I/O slots[/INST]2"
"[INST]In the context of the C64, What is the purpose of the two open I/O slots[/INST]General purpose user I/O, special purpose I/O cartridges"
"[INST]In the context of the C64, What is the purpose of the Z-80 cartridge[/INST]Enabling the CP/M option"
"[INST]In the context of the C64, What is the auto-start feature of the Commodore 64[/INST]Starting the program in a Commodore 64 Expansion Cartridge"
"[INST]In the context of the C64, What are the specific data required for auto-start[/INST]First nine bytes of the cartridge ROM starting at location 32768"
"[INST]In the context of the C64, What are the two vectors required for the cartridge program[/INST]Cold Start and Warm Start vectors"
"[INST]In the context of the C64, What are the letters required in the cartridge ROM[/INST]CBM"
"[INST]In the context of the C64, What are the last two bytes required in the cartridge ROM[/INST]80"
"[INST]In the context of the C64, What is the purpose of the CIA1 and CIA2[/INST]Keyboard and Serial Bus/RS-232"
"[INST]In the context of the C64, Can you turn on individual sprites?[/INST]Yes, you can turn on any individual sprite by using POKE V+21 and the number from the chart."
"[INST]In the context of the C64, What happens when you turn on just one sprite?[/INST]When you turn on just one sprite, it will turn off any others."
"[INST]In the context of the C64, How do you turn on two or more sprites?[/INST]You can turn on two or more sprites by adding together the numbers of the sprites you want to turn on."
"[INST]In the context of the C64, What is the method to turn one sprite off and on without affecting others?[/INST]The method is to use POKE V+21, PEEK V+21 AND (255-1) to turn off a sprite, and POKE V+21, PEEK(V+21) OR 1 to re-enable the sprite."
"[INST]In the context of the C64, What is the range of memory locations for more than 3 sprites?[/INST]The range is from 12288 to 12798."
"[INST]In the context of the C64, What is the range of memory locations for 1 to 3 sprites?[/INST]The range is from 832 to 1023."
"[INST]In the context of the C64, what is the purpose of crunching a sprite program[/INST]Crunching a sprite program is a technique used to make the program shorter and more efficient, allowing it to fit in less memory and run faster. This is achieved by combining multiple lines of code into fewer lines, making the program more compact and optimized."
"[INST]In the context of the C64, how can you make a sprite program shorter[/INST]By combining multiple lines of code into fewer lines, a programmer can make a sprite program shorter and more efficient. For example, a program can be condensed into a two-line program by combining the key sprite settings into a single line, as shown in the example."
"[INST]In the context of the C64, what is the benefit of crunching a sprite program[/INST]The benefit of crunching a sprite program is that it allows the program to fit in less memory and run more efficiently. This is particularly important for the Commodore 64, which has limited memory, and crunching a program can help to ensure that it runs smoothly and quickly."
"[INST]In the context of the C64, what is the recommended way to write a sprite program[/INST]A good programmer would typically write a sprite program as a condensed version, combining multiple lines of code into fewer lines, in order to make the program shorter and more efficient."
"[INST]In the context of the C64, what is the purpose of the POKE command in the crunched program[/INST]The POKE command is used in the crunched program to store values in specific memory locations, in this case, to set up the sprite settings and configure the graphics."
"[INST]In the context of the C64, what is the significance of the memory location 53248 in the crunched program[/INST]The memory location 53248 is significant in the crunched program because it is the starting address of the VIC-II chip, which is responsible for handling graphics and sound on the Commodore 64."
"[INST]In the context of the C64, what is the purpose of the FOR loop in the crunched program[/INST]The FOR loop in the crunched program is used to initialize the sprite data, setting the values of the sprite pixels to 255, which is the maximum brightness."
"[INST]In the context of the C64, how can you optimize a sprite program for memory usage[/INST]A sprite program can be optimized for memory usage by crunching it, combining multiple lines of code into fewer lines, and using efficient programming techniques to minimize memory usage."
"[INST]In the context of the C64, what is the recommended resource for learning more about crunching sprite programs[/INST]For more tips on how to crunch sprite programs, see the 'crunching guide' on Page 24, which provides additional guidance and techniques for optimizing sprite programs."
"[INST]In the context of the C64, what is the advantage of using a two-line program[/INST]The advantage of using a two-line program is that it is more compact and efficient, making it ideal for use on the Commodore 64, which has limited memory."
"[INST]In the context of the C64, What is the purpose of the RESTOR function?[/INST]Restore default system and interrupt vectors"
"[INST]In the context of the C64, What is the call address of the RESTOR function?[/INST]$FF8A (hex) 65418 (decimal)"
"[INST]In the context of the C64, What is the number of preparatory routines for the RESTOR function?[/INST]nan"
"[INST]In the context of the C64, What is the error return for the RESTOR function?[/INST]nan"
"[INST]In the context of the C64, What is the stack requirement for the RESTOR function?[/INST]2"
"[INST]In the context of the C64, What registers are affected by the RESTOR function?[/INST]A, X, Y"
"[INST]In the context of the C64, What does the RESTOR function restore?[/INST]default values of all system vectors used in KERNAL and BASIC routines and interrupts"
"[INST]In the context of the C64, What is the KERNAL VECTOR routine used for?[/INST]to read and alter individual system vectors"
"[INST]In the context of the C64, What is the purpose of the KERNAL VECTOR routine?[/INST]to read and alter individual system vectors"
"[INST]In the context of the C64, How do you use the RESTOR function?[/INST]Call this routine"
"[INST]In the context of the C64, What is an example of using the RESTOR function?[/INST]JSR RESTOR"
"[INST]In the context of the C64, Can you detect sprite collisions using a specific line of code?[/INST]Yes, you can detect sprite collisions using the line IF PEEK(V+30)ANDX=XTHEN [insert action here]."
"[INST]In the context of the C64, What does the value of X represent in the line IF PEEK(V+30)ANDX=XTHEN [insert action here]?[/INST]X equals 1 for sprite 0, 2 for sprite 1, 4 for sprite 2, 8 for sprite 3, 16 for sprite 4, 32 for sprite 5, 64 for sprite 6, and 128 for sprite 7."
"[INST]In the context of the C64, How do you check if a sprite has collided with a 'BACKGROUND CHARACTER'?[/INST]You use the line IF PEEK(V+31)ANDX=XTHEN [insert action here]."
"[INST]In the context of the C64, what is the function of the GATE bit in the control register[/INST]The GATE bit controls the Envelope Generator for Voice 1, when set to a one, the Envelope Generator is Gated (triggered) and the ATTACK/DECAY/SUSTAIN cycle is initiated, and when reset to a zero, the RELEASE cycle begins."
"[INST]In the context of the C64, what happens when the SYNC bit is set to a one[/INST]The SYNC bit synchronizes the fundamental frequency of Oscillator 1 with the fundamental frequency of Oscillator 3, producing 'Hard Sync' effects."
"[INST]In the context of the C64, what is the function of the RING MOD bit[/INST]The RING MOD bit replaces the Triangle waveform output of Oscillator 1 with a 'Ring Modulated' combination of Oscillators 1 and 3, producing a wide range of non-harmonic overtone structures for creating bell or gong sounds and for special effects."
"[INST]In the context of the C64, what is the function of the TEST bit[/INST]The TEST bit resets and locks Oscillator 1 at zero until the TEST bit is cleared, the Noise waveform output of Oscillator 1 is also reset and the Pulse waveform output is held at a DC level."
"[INST]In the context of the C64, what waveform is selected when bit 4 is set to a one[/INST]The Triangle waveform output of Oscillator 1 is selected, which is low in harmonics and has a mellow, flute-like quality."
"[INST]In the context of the C64, what waveform is selected when bit 5 is set to a one[/INST]The Sawtooth waveform output of Oscillator 1 is selected, which is rich in even and odd harmonics and has a bright, brassy quality."
"[INST]In the context of the C64, what waveform is selected when bit 6 is set to a one[/INST]The Pulse waveform output of Oscillator 1 is selected, the harmonic content of which can be adjusted by the Pulse Width registers, producing tone qualities ranging from a bright, hollow square wave to a nasal, reedy pulse."
"[INST]In the context of the C64, what waveform is selected when bit 7 is set to a one[/INST]The Noise output waveform of Oscillator 1 is selected, which is a random signal that changes at the frequency of Oscillator 1 and can be varied from a low rumbling to hissing white noise via the Oscillator 1 Frequency registers."
"[INST]In the context of the C64, what is the purpose of the Envelope Generator[/INST]The Envelope Generator controls the amplitude of Oscillator 1 appearing at the audio output, and the GATE bit must be set (along with suitable envelope parameters) for the selected output of Oscillator 1 to be audible."
"[INST]In the context of the C64, what happens when more than one output waveform is selected simultaneously[/INST]The result will be a logical ANDing of the waveforms, although this technique can be used to generate additional waveforms beyond the four listed above, it must be used with care."
"[INST]In the context of the C64, what happens if any other waveform is selected while Noise is on[/INST]The Noise output can 'lock up', and will remain silent until reset by the TEST bit or by bringing RES (pin 5) low."
"[INST]In the context of the C64, what is the condition for sync to occur[/INST]Oscillator 3 must be set to some frequency other than zero but preferably lower than the frequency of Oscillator 1."
"[INST]In the context of the C64, what is the condition for ring modulation to be audible[/INST]The Triangle waveform of Oscillator 1 must be selected and Oscillator 3 must be set to some frequency other than zero."
"[INST]In the context of the C64, what is the effect of varying the frequency of Oscillator 1 with respect to Oscillator 3[/INST]A wide range of complex harmonic structures from Voice 1 at the frequency of Oscillator 3 is produced."
"[INST]In the context of the C64, what is the effect of varying the frequency of Oscillator 1 with respect to Oscillator 3 in ring modulation[/INST]A wide range of non-harmonic overtone structures for creating bell or gong sounds and for special effects is produced."
"[INST]In the context of the C64, what is the purpose of the TEST bit in normal operation[/INST]The TEST bit is normally used for testing purposes, however, it can be used to synchronize Oscillator 1 to external events, allowing the generation of highly complex waveforms under real-time software control."
"[INST]In the context of the C64, what is the effect of sweeping the pulse width in real-time[/INST]A dynamic 'phasing' effect which adds a sense of motion to the sound is produced."
"[INST]In the context of the C64, what is the effect of rapidly jumping between different pulse widths[/INST]Interesting harmonic sequences are produced."
"[INST]In the context of the C64, what is the use of Noise in sound creation[/INST]Noise is useful in creating explosions, gunshots, jet engines, wind, surf and other unpitched sounds, as well as snore drums and cymbals."
"[INST]In the context of the C64, what is the effect of sweeping the oscillator frequency with Noise selected[/INST]A dramatic rushing effect is produced."
"[INST]In the context of the C64, What is the opcode for the INC instruction in zero page addressing mode?[/INST]The opcode for the INC instruction in zero page addressing mode is E6, which increments the memory location by one."
"[INST]In the context of the C64, What is the difference in the number of bytes and cycles between the INC instruction in zero page and absolute addressing modes?[/INST]The INC instruction in zero page addressing mode uses 2 bytes and takes 5 cycles, whereas in absolute addressing mode it uses 3 bytes and takes 6 cycles."
"[INST]In the context of the C64, How does the INC instruction behave when used with the X register in zero page addressing mode?[/INST]When used with the X register in zero page addressing mode, the INC instruction increments the memory location specified by the X register, and the opcode is F6, using 2 bytes and taking 6 cycles."
"[INST]In the context of the C64, What is the purpose of the INC instruction in assembly language programming on the Commodore 64?[/INST]The INC instruction increments the value of a memory location by one, which is useful for counting, indexing, and other applications where a variable needs to be incremented."
"[INST]In the context of the C64, What is the opcode for the INC instruction in absolute addressing mode?[/INST]The opcode for the INC instruction in absolute addressing mode is EE, which increments the memory location specified by the absolute address."
"[INST]In the context of the C64, How does the INC instruction affect the flags on the Commodore 64?[/INST]The INC instruction affects the N and Z flags on the Commodore 64, setting them according to the result of the increment operation."
"[INST]In the context of the C64, What is the difference in the number of cycles between the INC instruction in zero page and zero page,X addressing modes?[/INST]The INC instruction in zero page addressing mode takes 5 cycles, whereas in zero page,X addressing mode it takes 6 cycles, due to the additional cycle required to access the memory location specified by the X register."
"[INST]In the context of the C64, What is the purpose of the X register in the INC instruction in zero page,X addressing mode?[/INST]The X register in the INC instruction in zero page,X addressing mode specifies the memory location to be incremented, allowing for flexible and efficient indexing and counting operations."
"[INST]In the context of the C64, How does the INC instruction interact with the memory architecture of the Commodore 64?[/INST]The INC instruction interacts with the memory architecture of the Commodore 64 by incrementing the value of a memory location, which can be used to implement counters, pointers, and other data structures."
"[INST]In the context of the C64, What is the relationship between the INC instruction and the DEC instruction on the Commodore 64?[/INST]The INC instruction and the DEC instruction are complementary, with the INC instruction incrementing a memory location and the DEC instruction decrementing it, allowing for flexible and efficient implementation of counters and other data structures."
"[INST]In the context of the C64, Where are the sprite pointers located in the video matrix?[/INST]The sprite pointers are located at the end of the video matrix, with locations 1016-1023 (VM base+$3F8 to VM base+$3FF) used for sprite pointers 0-7, respectively."
"[INST]In the context of the C64, How many bytes of memory are used to store the data for each sprite?[/INST]The data for each sprite is stored in 63 consecutive bytes of memory."
"[INST]In the context of the C64, What is the purpose of the sprite byte counter?[/INST]The sprite byte counter provides six bits that, together with the eight-bit sprite pointer from the video matrix, define the entire 14-bit address field to access the sprite data."
"[INST]In the context of the C64, How many bits are used to address the sprite data?[/INST]A total of 14 bits are used to address the sprite data, consisting of the eight-bit sprite pointer from the video matrix and the six bits from the sprite byte counter."
"[INST]In the context of the C64, What triggers the fetches of sprite data?[/INST]The fetches of sprite data begin when the Y position register of a sprite matches the current raster line count."
"[INST]In the context of the C64, How many bytes of sprite data are displayed on each raster line?[/INST]Three bytes of sprite data are displayed on each raster line."
"[INST]In the context of the C64, What is the role of the internal counters in sprite data access?[/INST]The internal counters automatically step through the 63 bytes of sprite data, displaying three bytes on each raster line."
"[INST]In the context of the C64, How are the sprite pointers read from the video matrix?[/INST]The sprite pointers are read from the video matrix at the end of every raster line."
"[INST]In the context of the C64, What is the relationship between the sprite pointer and the sprite byte counter in addressing sprite data?[/INST]The sprite pointer from the video matrix and the sprite byte counter together define the entire 14-bit address field to access the sprite data."
"[INST]In the context of the C64, What is the significance of the video matrix locations 1016-1023?[/INST]The video matrix locations 1016-1023 (VM base+$3F8 to VM base+$3FF) are used for sprite pointers 0-7, respectively."
"[INST]In the context of the C64, Color memory can move?[/INST]No"
"[INST]In the context of the C64, Where is color memory located?[/INST]Locations 55296 through 56295 ($D800 through $DBE7)"
"[INST]In the context of the C64, What is the range of screen memory?[/INST]The 1000 locations starting at 1024"
"[INST]In the context of the C64, What happens to a picture when displayed in a different graphics mode?[/INST]It will often look completely different"
"[INST]In the context of the C64, What is the purpose of color memory?[/INST]It is used to store colors"
"[INST]In the context of the C64, Can color memory be moved?[/INST]No"
"[INST]In the context of the C64, What is the range of color memory?[/INST]Locations 55296 through 56295 ($D800 through $DBE7)"
"[INST]In the context of the C64, What is the difference between color memory and screen memory?[/INST]They are used differently in different graphics modes"
"[INST]In the context of the C64, What happens to a picture when created in one graphics mode?[/INST]It will often look different when displayed in another graphics mode"
"[INST]In the context of the C64, Can you create multi-colored sprites?[/INST]Yes, you can create multi-colored sprites, but you need to use pairs of pixels instead of individual pixels."
"[INST]In the context of the C64, What is the requirement for using multi-color mode?[/INST]Using multi-color mode requires that you use pairs of pixels instead of individual pixels in your sprite picture."
"[INST]In the context of the C64, What are the colors you can choose from in multi-color mode?[/INST]You have 4 colors to choose from: Sprite Color, Multi-Color 1, Multi-Color 2, and Background Color."
"[INST]In the context of the C64, How do you determine the color of each pair of pixels?[/INST]The color of each pair of pixels is determined according to whether the left, right, or both pixels are solid."
"[INST]In the context of the C64, What happens when you make both pixels in a pair blank?[/INST]When you make both pixels in a pair blank, the inner screen color (background) shows through."
"[INST]In the context of the C64, What happens when you make the right pixel in a pair solid?[/INST]When you make the right pixel in a pair solid, both pixels in the pair are set to Multi-Color 1."
"[INST]In the context of the C64, What happens when you make the left pixel in a pair solid?[/INST]When you make the left pixel in a pair solid, both pixels in the pair are set to Sprite Color."
"[INST]In the context of the C64, What happens when you make both pixels in a pair solid?[/INST]When you make both pixels in a pair solid, both pixels in the pair are set to Multi-Color 2."
"[INST]In the context of the C64, How do you set the color of each pair of pixels?[/INST]You set the color of each pair of pixels by determining which bits in each pair are solid and which are blank."
"[INST]In the context of the C64, What is the purpose of adding the values of the solid pixels?[/INST]The purpose of adding the values of the solid pixels is to get the total value to POKE into the proper memory location."
"[INST]In the context of the C64, What is the memory location for the first block in a sprite?[/INST]The memory location for the first block in a sprite is 832."
"[INST]In the context of the C64, What is the purpose of using pairs of pixels in multi-color mode?[/INST]The purpose of using pairs of pixels in multi-color mode is to create multi-colored sprites."
"[INST]In the context of the C64, What are the advantages of using multi-color mode?[/INST]The advantages of using multi-color mode are that it allows you to create multi-colored sprites and adds visual appeal to your game."
"[INST]In the context of the C64, What are the limitations of using multi-color mode?[/INST]The limitations of using multi-color mode are that it requires the use of pairs of pixels instead of individual pixels."
"[INST]In the context of the C64, What is the most important thing to remember when using multi-color mode?[/INST]The most important thing to remember when using multi-color mode is to use pairs of pixels instead of individual pixels."
"[INST]In the context of the C64, What happens when you don't use pairs of pixels in multi-color mode?[/INST]When you don't use pairs of pixels in multi-color mode, your sprite will not be multi-colored."
"[INST]In the context of the C64, What is the best way to create a multi-colored sprite?[/INST]The best way to create a multi-colored sprite is to use pairs of pixels in multi-color mode."
"[INST]In the context of the C64, What are the benefits of using multi-color mode?[/INST]The benefits of using multi-color mode are that it adds visual appeal to your game and allows you to create multi-colored sprites."
"[INST]In the context of the C64, What is the most common mistake when using multi-color mode?[/INST]The most common mistake when using multi-color mode is not using pairs of pixels instead of individual pixels."
"[INST]In the context of the C64, What is the easiest way to create a multi-colored sprite?[/INST]The easiest way to create a multi-colored sprite is to use pairs of pixels in multi-color mode."
"[INST]In the context of the C64, What are the common challenges when using multi-color mode?[/INST]The common challenges when using multi-color mode are that it requires the use of pairs of pixels instead of individual pixels."
"[INST]In the context of the C64, What is the most important thing to consider when using multi-color mode?[/INST]The most important thing to consider when using multi-color mode is to use pairs of pixels instead of individual pixels."
"[INST]In the context of the C64, What are the common mistakes when using multi-color mode?[/INST]The common mistakes when using multi-color mode are not using pairs of pixels instead of individual pixels."
"[INST]In the context of the C64, What is the best way to avoid mistakes when using multi-color mode?[/INST]The best way to avoid mistakes when using multi-color mode is to use pairs of pixels instead of individual pixels."
"[INST]In the context of the C64, What are the benefits of using multi-color mode in a game?[/INST]The benefits of using multi-color mode in a game are that it adds visual appeal and allows you to create multi-colored sprites."
"[INST]In the context of the C64, What is the most important thing to remember when using multi-color mode in a game?[/INST]The most important thing to remember when using multi-color mode in a game is to use pairs of pixels instead of individual pixels."
"[INST]In the context of the C64, What are the common challenges when using multi-color mode in a game?[/INST]The common challenges when using multi-color mode in a game are that it requires the use of pairs of pixels instead of individual pixels."
"[INST]In the context of the C64, What is the best way to overcome these challenges?[/INST]The best way to overcome these challenges is to use pairs of pixels instead of individual pixels."
"[INST]In the context of the C64, What are the benefits of using multi-color mode in a game?[/INST]The benefits of using multi-color mode in a game are that it adds visual appeal and allows you to create multi-colored sprites."
"[INST]In the context of the C64, Is the KERNAL a standardized JUMP TABLE to the input, output, and memory management routines in the operating system?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the KERNAL in the Commodore 64 computer?[/INST]To simplify machine language programs and make them compatible with future operating system updates"
"[INST]In the context of the C64, What is the KERNAL jump table used for?[/INST]To provide a standardized interface to the operating system's input, output, and memory management routines"
"[INST]In the context of the C64, Is the KERNAL jump table located in ROM?[/INST]Yes"
"[INST]In the context of the C64, What is the advantage of using the KERNAL jump table?[/INST]It makes it easier to translate machine language programs from one Commodore computer to another"
"[INST]In the context of the C64, What is the purpose of setting up parameters before using the KERNAL jump table?[/INST]To prepare the KERNAL routine for execution"
"[INST]In the context of the C64, What happens after the KERNAL routine is executed?[/INST]Control is transferred back to the machine language program"
"[INST]In the context of the C64, Can the KERNAL routine pass parameters back to the machine language program?[/INST]Yes"
"[INST]In the context of the C64, What is the benefit of using the KERNAL jump table?[/INST]It allows machine language programs to work with future operating system updates"
"[INST]In the context of the C64, Why is the KERNAL jump table used instead of directly JSR-ing to the KERNAL subroutine?[/INST]So that the jump table can adapt to changes in the KERNAL or BASIC"
"[INST]In the context of the C64, What is the KERNAL in the Commodore 64 computer?[/INST]The operating system"
"[INST]In the context of the C64, What is the purpose of the KERNAL in the Commodore 64 computer?[/INST]To control input, output, and memory management"
"[INST]In the context of the C64, Is the KERNAL jump table located at the end of the memory?[/INST]Yes"
"[INST]In the context of the C64, What is the advantage of using the KERNAL jump table in machine language programs?[/INST]It saves time and makes it easier to modify programs"
"[INST]In the context of the C64, Can the KERNAL routine be used to access the operating system's routines?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the 39 input/output routines in the KERNAL jump table?[/INST]To provide utilities for machine language programs"
"[INST]In the context of the C64, Is the KERNAL jump table used to simplify machine language programs?[/INST]Yes"
"[INST]In the context of the C64, What is the benefit of using the KERNAL jump table in machine language programs?[/INST]It makes it easier to translate programs from one Commodore computer to another"
"[INST]In the context of the C64, Can the KERNAL routine be used to access the memory management routines?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the memory management routines in the KERNAL?[/INST]To manage memory allocation and deallocation"
"[INST]In the context of the C64, Is the KERNAL jump table used to simplify machine language programs?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the input/output routines in the KERNAL?[/INST]To provide utilities for input and output operations"
"[INST]In the context of the C64, Can the KERNAL routine be used to access the input/output routines?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the output routines in the KERNAL?[/INST]To provide utilities for output operations"
"[INST]In the context of the C64, Is the KERNAL jump table used to simplify machine language programs?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the input routines in the KERNAL?[/INST]To provide utilities for input operations"
"[INST]In the context of the C64, Can the KERNAL routine be used to access the input routines?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the KERNAL in the Commodore 64 computer?[/INST]To control input, output, and memory management"
"[INST]In the context of the C64, Is the KERNAL jump table used to simplify machine language programs?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the KERNAL jump table?[/INST]To provide a standardized interface to the operating system's routines"
"[INST]In the context of the C64, Can the KERNAL routine be used to access the operating system's routines?[/INST]Yes"
"[INST]In the context of the C64, What is the purpose of the KERNAL in the Commodore 64 computer?[/INST]To control input, output, and memory management"
"[INST]In the context of the C64, What is the 64MON cartridge used for?[/INST]allows you to escape from the world of CBM BASIC, into the land of machine language."
"[INST]In the context of the C64, What can the 64MON cartridge display?[/INST]the contents of the internal registers in the 6510 microprocessor, and it allows you to display portions of memory, and change them on the screen, using the screen editor."
"[INST]In the context of the C64, What features does the 64MON cartridge have?[/INST]a built-in assembler and disassembler, as well as many other features that allow you to write and edit machine language programs easily."
"[INST]In the context of the C64, Is an assembler necessary to write machine language programs?[/INST]no, but it is strongly suggested that you purchase an assembler of some sort."
"[INST]In the context of the C64, What is the recommended way to write machine language programs?[/INST]using an assembler, which is considerably easier than writing them without an assembler."
"[INST]In the context of the C64, What is the format of the machine language examples in this manual?[/INST]the format that 64MON uses, from now on."
"[INST]In the context of the C64, Are the machine language examples compatible with any assembler?[/INST]almost certainly, since nearly all assembler formats are the same."
"[INST]In the context of the C64, What is the importance of explaining the hexadecimal numbering system?[/INST]it must be explained before explaining any of the other features of 64MON."
"[INST]In the context of the C64, What is the 64MON cartridge used for in relation to CBM BASIC?[/INST]it allows you to escape from the world of CBM BASIC, into the land of machine language."
"[INST]In the context of the C64, What are the internal registers in the 6510 microprocessor?[/INST]the contents of which can be displayed by the 64MON cartridge."
"[INST]In the context of the C64, What is the purpose of the screen editor in the 64MON cartridge?[/INST]to display and change portions of memory on the screen."
"[INST]In the context of the C64, What does TXS do?[/INST]TXS Transfer index X to stack pointer"
"[INST]In the context of the C64, What is the operation of TXS?[/INST]X -> S"
"[INST]In the context of the C64, What is the assembly language form of TXS?[/INST]TXS"
"[INST]In the context of the C64, What is the OP CODE of TXS?[/INST]9A"
"[INST]In the context of the C64, What is the number of bytes of TXS?[/INST]1"
"[INST]In the context of the C64, What is the number of cycles of TXS?[/INST]2"
"[INST]In the context of the C64, What is the addressing mode of TXS?[/INST]Implied"
"[INST]In the context of the C64, What is the assembly language form of the operation?[/INST]TXS"
"[INST]In the context of the C64, What is the operation of TXS in assembly language?[/INST]X -> S"
"[INST]In the context of the C64, what is the central component of a microcomputer[/INST]The central component of a microcomputer is the central microprocessor, which is a very special microchip that serves as the 'brain' of the computer."
"[INST]In the context of the C64, what is machine language[/INST]Machine language is the native language of the machine, and it is the only programming language that the Commodore 64 understands, comprising a set of instructions that the microprocessor can execute directly."
"[INST]In the context of the C64, what is the relationship between machine language and CBM BASIC[/INST]Machine language is the native language of the Commodore 64, whereas CBM BASIC is a higher-level language that is translated into machine language by the operating system, allowing the Commodore 64 to understand CBM BASIC instructions like PRINT and GOTO."
"[INST]In the context of the C64, what is the operating system of the Commodore 64[/INST]The operating system of the Commodore 64 is a machine language program stored in a special type of memory that cannot be changed and does not disappear when the computer is turned off, and it is automatically 'run' when the Commodore 64 is turned on."
"[INST]In the context of the C64, how does the Commodore 64 understand CBM BASIC instructions[/INST]The Commodore 64 understands CBM BASIC instructions because the operating system translates them into machine language instructions that the microprocessor can execute directly."
"[INST]In the context of the C64, what is the significance of the operating system in the Commodore 64[/INST]The operating system plays a crucial role in the Commodore 64, as it enables the computer to understand CBM BASIC instructions and provides a layer of abstraction between the user and the machine language, making it possible to write programs in a higher-level language."
"[INST]In the context of the C64, what happens when the Commodore 64 is turned on[/INST]When the Commodore 64 is turned on, its operating system is automatically 'run', which enables the computer to understand CBM BASIC instructions and perform tasks according to the user's program."
"[INST]In the context of the C64, what is the difference between machine language and CBM BASIC[/INST]Machine language is the native language of the Commodore 64, consisting of instructions that the microprocessor can execute directly, whereas CBM BASIC is a higher-level language that requires translation into machine language by the operating system."
"[INST]In the context of the C64, what is the role of the microprocessor in the Commodore 64[/INST]The microprocessor is the 'brain' of the Commodore 64, executing machine language instructions and performing calculations and operations according to the user's program."
"[INST]In the context of the C64, what is the purpose of the operating system in the Commodore 64[/INST]The purpose of the operating system in the Commodore 64 is to provide a layer of abstraction between the user and the machine language, enabling the computer to understand CBM BASIC instructions and perform tasks according to the user's program."
"[INST]In the context of the C64, what is the opcode for the immediate addressing mode of the CMP instruction?[/INST]The opcode for the immediate addressing mode of the CMP instruction is C9, which requires 2 bytes and takes 2 cycles to execute."
"[INST]In the context of the C64, what is the difference in cycles between the zero page and absolute addressing modes of the CMP instruction?[/INST]The zero page addressing mode of the CMP instruction takes 3 cycles, while the absolute addressing mode takes 4 cycles, so the difference is 1 cycle."
"[INST]In the context of the C64, how does the CMP instruction with the (Indirect,X) addressing mode work?[/INST]The CMP instruction with the (Indirect,X) addressing mode works by first loading the value at the memory location specified by the operand plus the X register, and then comparing the accumulator with that value; this operation requires 2 bytes and takes 6 cycles to execute."
"[INST]In the context of the C64, what is the opcode for the absolute,Y addressing mode of the CMP instruction?[/INST]The opcode for the absolute,Y addressing mode of the CMP instruction is D9, which requires 3 bytes and takes 4 cycles to execute, plus an additional cycle if a page boundary is crossed."
"[INST]In the context of the C64, what is the purpose of the CMP instruction?[/INST]The purpose of the CMP instruction is to compare the value in the accumulator with the value in memory, setting the flags accordingly, but not changing the accumulator's value."
"[INST]In the context of the C64, how many bytes are required for the zero page addressing mode of the CMP instruction?[/INST]The zero page addressing mode of the CMP instruction requires 2 bytes."
"[INST]In the context of the C64, in what situations does the CMP instruction take an additional cycle to execute?[/INST]The CMP instruction takes an additional cycle to execute when a page boundary is crossed in the absolute,X and absolute,Y addressing modes."
"[INST]In the context of the C64, what is the opcode for the zero page addressing mode of the CMP instruction?[/INST]The opcode for the zero page addressing mode of the CMP instruction is C5, which requires 2 bytes and takes 3 cycles to execute."
"[INST]In the context of the C64, what is the difference between the CMP #Oper and CMP Oper instructions?[/INST]The CMP #Oper instruction compares the accumulator with an immediate value, while the CMP Oper instruction compares the accumulator with a value in memory; the former uses the immediate addressing mode, while the latter uses the zero page addressing mode."
"[INST]In the context of the C64, how does the CMP instruction affect the flags?[/INST]The CMP instruction sets the flags based on the result of the comparison, including the N, V, and C flags, but does not change the accumulator's value."
"[INST]In the context of the C64, Control system message output is controlled by which routine?[/INST]SETMSG"
"[INST]In the context of the C64, What is the purpose of the SETMSG routine?[/INST]Control system message output"
"[INST]In the context of the C64, What is the call address of the SETMSG routine?[/INST]$FF90 (hex) 65424 (decimal)"
"[INST]In the context of the C64, What communication registers are affected by the SETMSG routine?[/INST]A"
"[INST]In the context of the C64, What is the stack requirement for the SETMSG routine?[/INST]2"
"[INST]In the context of the C64, What registers are affected by the SETMSG routine?[/INST]A"
"[INST]In the context of the C64, What are the two types of messages that can be printed by the SETMSG routine?[/INST]error and control"
"[INST]In the context of the C64, What determines where the message will come from in the SETMSG routine?[/INST]bits 6 and 7 of the accumulator value"
"[INST]In the context of the C64, What is an example of an error message?[/INST]FILE NOT FOUND"
"[INST]In the context of the C64, What is an example of a control message?[/INST]PRESS PLAY ON CASSETTE"
"[INST]In the context of the C64, What is the purpose of the TKSA function?[/INST]Send a secondary address to a device commanded to TALK"
"[INST]In the context of the C64, What is the call address of the TKSA function?[/INST]$FF96 (hex) 65430 (decimal)"
"[INST]In the context of the C64, What communication registers are affected by the TKSA function?[/INST]A"
"[INST]In the context of the C64, What preparatory routines must be performed before calling the TKSA function?[/INST]TALK"
"[INST]In the context of the C64, What error returns can occur when calling the TKSA function?[/INST]See READST"
"[INST]In the context of the C64, What is the stack requirement for the TKSA function?[/INST]8"
"[INST]In the context of the C64, What registers are affected by the TKSA function?[/INST]A"
"[INST]In the context of the C64, What is the range of numbers that can be loaded into the accumulator for the TKSA function?[/INST]0 and 31"
"[INST]In the context of the C64, What is the purpose of the TALK routine in relation to the TKSA function?[/INST]It must be called before the TKSA function"
"[INST]In the context of the C64, What is the consequence of calling the TKSA function after a LISTEN routine?[/INST]It will not work"
"[INST]In the context of the C64, What is an example of how to use the TKSA function?[/INST];TELL DEVICE #4 TO TALK WITH COMMAND #7"
"[INST]In the context of the C64, what is the purpose of multi-color mode in c64?[/INST]Multi-color mode provides additional color flexibility allowing up to four colors within each character but with reduced resolution, which is selected by setting the MCM bit in register 22 ($16) to '1'."
"[INST]In the context of the C64, how does the multi-color mode interpret the dot data stored in the character base?[/INST]In multi-color mode, the dot data stored in the character base is interpreted differently, where if the MSB of the color nybble is a '0', the character will be displayed as described in standard character mode, and if the MSB of the color nybble is a '1', the character bits are interpreted in the multi-color mode."
"[INST]In the context of the C64, what is the function of the MSB of the color nybble in multi-color mode?[/INST]The MSB of the color nybble determines the mode of interpretation, where if it's '0', the character is displayed in standard mode, and if it's '1', the character is displayed in multi-color mode."
"[INST]In the context of the C64, how many colors can be displayed in each character region in multi-color mode?[/INST]Each character region can now contain 4 different colors, two as foreground and two as background, which is achieved by using two bits to specify one dot color."
"[INST]In the context of the C64, what is the resolution of the character in multi-color mode?[/INST]The character is displayed as a 4*8 matrix with each dot twice the horizontal size as in standard mode, resulting in reduced resolution."
"[INST]In the context of the C64, what is the purpose of registers 33, 34, and 35 in multi-color mode?[/INST]Registers 33, 34, and 35 specify the colors for background #0, background #1, and background #2, respectively, in multi-color mode."
"[INST]In the context of the C64, how does the sprite priority work in multi-color mode?[/INST]The sprite priority is affected by the multi-color mode, where each character region can now contain 4 different colors, two as foreground and two as background, which is important to consider when working with sprites."
"[INST]In the context of the C64, what is the advantage of using multi-color mode over standard character mode?[/INST]The advantage of using multi-color mode is that it provides additional color flexibility, allowing up to four colors within each character, although at the cost of reduced resolution."
"[INST]In the context of the C64, can standard character mode and multi-color mode be inter-mixed?[/INST]Yes, standard character mode and multi-color mode can be inter-mixed, as the MSB of the color nybble determines the mode of interpretation, allowing for a mix of both modes."
"[INST]In the context of the C64, what is the significance of the MCM bit in register 22 ($16) in multi-color mode?[/INST]The MCM bit in register 22 ($16) is used to select the multi-color mode, where setting it to '1' enables multi-color mode and setting it to '0' enables standard character mode."
"[INST]In the context of the C64, what is the purpose of the two-byte pointer $00F7?[/INST]a two-byte pointer to the Receiver Buffer base location."
"[INST]In the context of the C64, what is the purpose of the two-byte pointer $00F9?[/INST]a two-byte pointer to the Transmitter Buffer base location."
"[INST]In the context of the C64, what are the two locations set up by the OPEN KERNAL routine?[/INST]the Receiver Buffer base location and the Transmitter Buffer base location"
"[INST]In the context of the C64, what are the two locations pointing to?[/INST]different 256-byte buffers"
"[INST]In the context of the C64, what happens when a zero is written into the high order bytes $00F8 and $00FA?[/INST]the locations are de-allocated"
"[INST]In the context of the C64, who can de-allocate the buffer(s) for their own purposes?[/INST]the machine language programmer"
"[INST]In the context of the C64, what must be taken care of when using a machine language program that allocates these buffers?[/INST]the top of memory pointers"
"[INST]In the context of the C64, what is the importance of the two-byte pointers $00F7 and $00F9?[/INST]they point to different buffer locations"
"[INST]In the context of the C64, what happens to the buffer(s) when the CLOSE KERNAL entry is called?[/INST]they are de-allocated"
"[INST]In the context of the C64, Where is the best place to put machine language routines on the Commodore 64?[/INST]The best place for machine language routines on the Commodore 64 is from $C000-$CFFF, assuming the routines are smaller than 4K bytes long. This section of memory is not disturbed by BASIC."
"[INST]In the context of the C64, What happens if a machine language routine is larger than 4K bytes?[/INST]If a machine language routine is larger than 4K bytes, it then becomes necessary to reserve an area at the top of memory from BASIC for the routine."
"[INST]In the context of the C64, How can the top of memory be changed on the Commodore 64?[/INST]The top of memory can be changed through the KERNAL routine MEMTOP, or by using the following BASIC statements: POKE51,L:POKE52,H:POKE55,1:POKE56,H:CLR, where H and L are the high and low portions, respectively, of the new top of memory."
"[INST]In the context of the C64, What are the high and low portions in the BASIC statements to change the top of memory?[/INST]The high and low portions, H and L, are the high and low bytes of the new top of memory address, respectively."
"[INST]In the context of the C64, How do you reserve an area from $9000 to $9FFF for a machine language routine?[/INST]To reserve an area from $9000 to $9FFF for a machine language routine, use the following BASIC statements: POKE5110:POKE52,144:POKE5510:POKE56,144:CLR."
"[INST]In the context of the C64, What is the purpose of the CLR command in the BASIC statements to change the top of memory?[/INST]The CLR command is used to clear the BASIC program and variables, ensuring that the new top of memory setting takes effect."
"[INST]In the context of the C64, Why is it important to reserve an area for machine language routines?[/INST]It is important to reserve an area for machine language routines to ensure that they do not interfere with BASIC and to prevent memory conflicts."
"[INST]In the context of the C64, What is the default top of memory on the Commodore 64?[/INST]The default top of memory on the Commodore 64 is $9FFF."
"[INST]In the context of the C64, How does the KERNAL routine MEMTOP change the top of memory?[/INST]The KERNAL routine MEMTOP changes the top of memory by modifying the memory allocation, allowing for the reservation of an area for machine language routines."
"[INST]In the context of the C64, What is the advantage of placing machine language routines from $C000-$CFFF?[/INST]The advantage of placing machine language routines from $C000-$CFFF is that this section of memory is not disturbed by BASIC, ensuring that the routines are not overwritten or affected by BASIC operations."
"[INST]In the context of the C64, What is the purpose of the SETTIM function?[/INST]Set the system clock"
"[INST]In the context of the C64, What is the call address of the SETTIM function?[/INST]$FFDB (hex) 65499 (decimal)"
"[INST]In the context of the C64, What registers are used for communication in the SETTIM function?[/INST]A, X, Y"
"[INST]In the context of the C64, What is the stack requirement for the SETTIM function?[/INST]2"
"[INST]In the context of the C64, What is the maximum time that the SETTIM clock can count up to?[/INST]5,184,000 jiffies"
"[INST]In the context of the C64, What is the unit of time that the SETTIM clock updates every?[/INST]1/60th of a second"
"[INST]In the context of the C64, What is the term for one 1/60th of a second"" in the SETTIM clock?""[/INST]'jiffy'"
"[INST]In the context of the C64, What are the three bytes used to set the initial time setting in the SETTIM function?[/INST]most significant byte, next most significant byte, least significant byte"
"[INST]In the context of the C64, How many bytes are used to set the initial time setting in the SETTIM function?[/INST]3"
"[INST]In the context of the C64, What is the example of setting the clock to 10 minutes in the SETTIM function?[/INST];SET THE CLOCK TO 10 MINUTES = 3600 JIFFIES"
"[INST]In the context of the C64, What is the purpose of the UNLSN routine?[/INST]Send an UNLISTEN command"
"[INST]In the context of the C64, What is the call address of the UNLSN routine?[/INST]$FFAE (hex) 65454 (decimal)"
"[INST]In the context of the C64, What communication registers are used by the UNLSN routine?[/INST]nan"
"[INST]In the context of the C64, What is the stack requirement for the UNLSN routine?[/INST]8"
"[INST]In the context of the C64, What registers are affected by the UNLSN routine?[/INST]A"
"[INST]In the context of the C64, What is the effect of calling the UNLSN routine?[/INST]Commands all devices on the serial bus to stop receiving data from the Commodore 64"
"[INST]In the context of the C64, What is the purpose of sending the UNLISTEN command?[/INST]To get off the serial bus so it can be used for other purposes"
"[INST]In the context of the C64, What devices are affected by the UNLISTEN command?[/INST]Only devices previously commanded to listen"
"[INST]In the context of the C64, What is the normal use of the UNLSN routine?[/INST]After the Commodore 64 is finished sending data to external devices"
"[INST]In the context of the C64, What is the result of sending the UNLISTEN command?[/INST]The listening devices get off the serial bus"
"[INST]In the context of the C64, what is the purpose of separating the ground line between SID and the power supply[/INST]Separating the ground line between SID and the power supply is crucial to minimize digital noise at the audio output, ensuring the best possible audio quality. This is because digital circuitry can introduce electromagnetic interference (EMI) that can couple into the audio signal, causing unwanted noise and distortion. By keeping the ground line separate, you can reduce the impact of EMI and ensure a cleaner, more stable audio signal."
"[INST]In the context of the C64, what is the effect of not separating the ground line on the audio output[/INST]If the ground line is not separated, digital noise from the digital circuitry can bleed into the audio signal, causing unwanted noise, distortion, and degradation of the audio quality. This can result in a poor listening experience, with audible hum, hiss, or other unwanted artifacts. In extreme cases, it can even cause the audio circuitry to malfunction or become unstable."
"[INST]In the context of the C64, why is it important to minimize digital noise in audio circuits[/INST]Minimizing digital noise in audio circuits is essential to ensure high-quality audio reproduction. Digital noise can introduce unwanted artifacts, such as hiss, hum, or distortion, which can degrade the overall audio quality. By minimizing digital noise, you can preserve the integrity of the audio signal, ensuring a clear, clean, and accurate reproduction of the original sound."
"[INST]In the context of the C64, what is the role of the ground line in audio circuits[/INST]The ground line plays a critical role in audio circuits, serving as a reference point for the audio signal. It provides a return path for the audio current, allowing the signal to flow smoothly and efficiently. A well-designed ground line is essential to ensure that the audio signal remains clean, stable, and free from noise and interference."
"[INST]In the context of the C64, how does digital noise affect audio quality[/INST]Digital noise can have a profound impact on audio quality, introducing unwanted artifacts and degrading the overall listening experience. It can cause the audio signal to become distorted, noisy, or unstable, leading to a poor listening experience. In extreme cases, digital noise can even cause the audio circuitry to malfunction or become unstable."
"[INST]In the context of the C64, what is the relationship between the SID and the power supply[/INST]The SID (Sound Interface Device) is a critical component of the Commodore 64's audio system, responsible for generating the audio signal. The power supply provides the necessary power to the SID, allowing it to function properly. A stable and clean power supply is essential to ensure that the SID operates correctly, producing a high-quality audio signal."
"[INST]In the context of the C64, why is it important to keep the ground line separate from digital circuitry[/INST]Keeping the ground line separate from digital circuitry is crucial to minimize digital noise and ensure high-quality audio reproduction. Digital circuitry can introduce electromagnetic interference (EMI) that can couple into the audio signal, causing unwanted noise and distortion. By keeping the ground line separate, you can reduce the impact of EMI and ensure a cleaner, more stable audio signal."
"[INST]In the context of the C64, what is the impact of electromagnetic interference on audio quality[/INST]Electromagnetic interference (EMI) can have a significant impact on audio quality, introducing unwanted noise and distortion into the audio signal. EMI can cause the audio signal to become unstable, noisy, or distorted, leading to a poor listening experience. In extreme cases, EMI can even cause the audio circuitry to malfunction or become unstable."
"[INST]In the context of the C64, how can you reduce electromagnetic interference in audio circuits[/INST]Reducing electromagnetic interference (EMI) in audio circuits requires careful design and layout considerations. This includes keeping the ground line separate from digital circuitry, using shielded cables, and minimizing the length of the audio signal path. Additionally, using EMI-filtering components, such as ferrite beads or chokes, can help to reduce EMI and ensure a cleaner, more stable audio signal."
"[INST]In the context of the C64, what is the role of the power supply in audio circuits[/INST]The power supply plays a critical role in audio circuits, providing the necessary power to the audio components. A stable and clean power supply is essential to ensure that the audio signal remains clean, stable, and free from noise and interference. A poorly designed power supply can introduce unwanted noise and distortion, degrading the overall audio quality."
"[INST]In the context of the C64, what is the purpose of the PHA instruction in 6502 assembly language?[/INST]The PHA instruction is used to push the contents of the accumulator onto the stack. This is useful for temporarily storing the value of the accumulator for later use, allowing the accumulator to be used for other calculations or operations without losing its original value. The PHA instruction is often used in conjunction with the PLA instruction, which pulls the top value from the stack back into the accumulator."
"[INST]In the context of the C64, what is the addressing mode of the PHA instruction?[/INST]The addressing mode of the PHA instruction is implied, meaning that it does not require a memory address or operand. The PHA instruction operates solely on the accumulator, pushing its contents onto the stack."
"[INST]In the context of the C64, what is the opcode of the PHA instruction?[/INST]The opcode of the PHA instruction is 48 in hexadecimal notation."
"[INST]In the context of the C64, how many bytes does the PHA instruction occupy in memory?[/INST]The PHA instruction occupies 1 byte in memory."
"[INST]In the context of the C64, how many cycles does the PHA instruction take to execute?[/INST]The PHA instruction takes 3 cycles to execute."
"[INST]In the context of the C64, in what situations would you use the PHA instruction?[/INST]The PHA instruction is useful in situations where you need to temporarily store the value of the accumulator, such as when you need to perform a calculation that modifies the accumulator, but you want to preserve the original value for later use. It's also useful for creating a snapshot of the accumulator's value at a particular point in the program."
"[INST]In the context of the C64, can you give an example of using PHA in a program?[/INST]Here is an example of using PHA in a program: `LDA #10; PHA; LDX #20; ...; PLA; STA result`. In this example, the value 10 is loaded into the accumulator, then pushed onto the stack using PHA. The value 20 is then loaded into the X register, and some other operations are performed. Finally, the value is pulled back from the stack into the accumulator using PLA, and stored in a memory location labeled `result`."
"[INST]In the context of the C64, what is the difference between PHA and PLA?[/INST]PHA pushes the accumulator onto the stack, while PLA pulls the top value from the stack back into the accumulator. PHA is used to store the accumulator's value, while PLA is used to retrieve a previously stored value."
"[INST]In the context of the C64, how does the PHA instruction affect the stack pointer?[/INST]The PHA instruction decrements the stack pointer by 1, as it pushes a value onto the stack."
"[INST]In the context of the C64, can you explain the implications of using PHA in a recursive subroutine?[/INST]In a recursive subroutine, PHA can be used to store the return address on the stack, allowing the subroutine to recursively call itself. However, care must be taken to ensure that the stack does not overflow, as each recursive call will push another return address onto the stack."
"[INST]In the context of the C64, SEI stands for?[/INST]SEI Set interrupt disable status"
"[INST]In the context of the C64, SEI OP CODE?[/INST]OP CODE 78"
"[INST]In the context of the C64, SEI No. Bytes ?[/INST]No. Bytes 1"
"[INST]In the context of the C64, SEI No. Cycles ?[/INST]No. Cycles 2"
"[INST]In the context of the C64, TSX instruction is used for what purpose?[/INST]Transfer stack pointer to index X"
"[INST]In the context of the C64, TSX is an abbreviation for what?[/INST]TSX Transfer stack pointer to index X"
"[INST]In the context of the C64, What is the operation of TSX?[/INST]S -> X"
"[INST]In the context of the C64, What is the abbreviation for the instruction TSX?[/INST]TSX"
"[INST]In the context of the C64, What is the purpose of the TSX instruction?[/INST]Transfer stack pointer to index X"
"[INST]In the context of the C64, What is the assembly language form of the TSX instruction?[/INST]TSX"
"[INST]In the context of the C64, What is the OP CODE of the TSX instruction?[/INST]BA"
"[INST]In the context of the C64, What is the number of bytes required for the TSX instruction?[/INST]1"
"[INST]In the context of the C64, What is the number of cycles required for the TSX instruction?[/INST]2"
"[INST]In the context of the C64, What is the addressing mode of the TSX instruction?[/INST]Implied"
"[INST]In the context of the C64, What is the purpose of the TALK function?[/INST]The purpose of the TALK function is to command a device on the serial bus to TALK."
"[INST]In the context of the C64, What is the call address of the TALK function in hexadecimal?[/INST]The call address of the TALK function in hexadecimal is $FFB4."
"[INST]In the context of the C64, What is the decimal equivalent of the call address of the TALK function?[/INST]The decimal equivalent of the call address of the TALK function is 65460."
"[INST]In the context of the C64, What register is used for communication in the TALK function?[/INST]The accumulator (A) is used for communication in the TALK function."
"[INST]In the context of the C64, What is the preparatory routine required for the TALK function?[/INST]There is no preparatory routine required for the TALK function."
"[INST]In the context of the C64, What is the error return mechanism for the TALK function?[/INST]The error return mechanism for the TALK function is the same as the READST function."
"[INST]In the context of the C64, How much stack is required for the TALK function?[/INST]The TALK function requires 8 bytes of stack."
"[INST]In the context of the C64, What register is affected by the TALK function?[/INST]The accumulator (A) is affected by the TALK function."
"[INST]In the context of the C64, How do you use the TALK function to command a device?[/INST]To use the TALK function, load the accumulator with the device number and then call the TALK function."
"[INST]In the context of the C64, What is an example of using the TALK function to command device #4?[/INST]An example of using the TALK function to command device #4 is: LDA #4, JSR TALK."
"[INST]In the context of the C64, Can you set sprite pointers anywhere in RAM memory?[/INST]Yes, but be cautious of long BASIC programs overwriting sprite data."
"[INST]In the context of the C64, What happens if you set sprite pointers too low in memory?[/INST]A long BASIC program may overwrite your sprite data."
"[INST]In the context of the C64, Why might you want to set sprite pointers at a higher area of memory?[/INST]To protect an especially long BASIC program from overwriting sprite data."
"[INST]In the context of the C64, How many different sprites can you define with sprite pointers?[/INST]Up to 64 different sprites plus a sizable BASIC program."
"[INST]In the context of the C64, What is the purpose of redefining a particular sprite by changing its pointer?[/INST]To point the sprite at different areas of memory containing different sprite picture data."
"[INST]In the context of the C64, Can you use the same sprite pointer for multiple sprites?[/INST]Yes, to make multiple sprites have the same shape."
"[INST]In the context of the C64, What is the advantage of using the same sprite pointer for multiple sprites?[/INST]You can make multiple sprites have the same shape."
"[INST]In the context of the C64, How do you make multiple sprites have the same shape?[/INST]By using the same sprite pointer and memory location for the sprites."
"[INST]In the context of the C64, Can you use the same sprite pointer for sprites with different positions and colors?[/INST]Yes, as long as you use the same sprite pointer and memory location."
"[INST]In the context of the C64, Drawing a Commodore sprite is like coloring the empty spaces in a coloring book.[/INST]Drawing a Commodore sprite is like coloring the empty spaces in a coloring book."
"[INST]In the context of the C64, What is drawing a Commodore sprite similar to?[/INST]Drawing a Commodore sprite is similar to coloring the empty spaces in a coloring book."
"[INST]In the context of the C64, What are the tiny dots that make up a sprite?[/INST]The tiny dots that make up a sprite are called pixels."
"[INST]In the context of the C64, What do you have to do to draw a sprite?[/INST]You have to color in"" some of the pixels."""
"[INST]In the context of the C64, What is the spritemaking grid in Figure 3-6?[/INST]The spritemaking grid in Figure 3-6 is what a blank sprite looks like."
"[INST]In the context of the C64, What is a blank sprite like?[/INST]A blank sprite looks like the spritemaking grid in Figure 3-6."
"[INST]In the context of the C64, What are the small squares that make up a sprite?[/INST]The small squares that make up a sprite are called pixels."
"[INST]In the context of the C64, What is the purpose of coloring in pixels?[/INST]The purpose of coloring in pixels is to draw a sprite."
"[INST]In the context of the C64, What is the process of drawing a sprite?[/INST]The process of drawing a sprite is to color in"" some of the pixels."""
"[INST]In the context of the C64, Where is the overall volume control located in the C64 chip?[/INST]The overall volume control is located in chip register 24."
"[INST]In the context of the C64, What is the range of values that can be set for the volume control?[/INST]The volume can be set anywhere between 0 and 15."
"[INST]In the context of the C64, What are the remaining four bits in chip register 24 used for?[/INST]The remaining four bits are used for purposes that will be discussed later."
"[INST]In the context of the C64, How is the volume control set in Example Program 1?[/INST]The volume control is set in Example Program 1 on line 30."
"[INST]In the context of the C64, What is the purpose of chip register 24?[/INST]Chip register 24 contains the overall volume control, which allows the volume to be set between 0 and 15."
"[INST]In the context of the C64, What is the significance of the value 15 in relation to the volume control?[/INST]The value 15 is the maximum value that can be set for the volume control in chip register 24."
"[INST]In the context of the C64, Can the volume control be set to a value higher than 15?[/INST]No, the volume control cannot be set to a value higher than 15, as the maximum value is 15."
"[INST]In the context of the C64, What is the minimum value that can be set for the volume control?[/INST]The minimum value that can be set for the volume control is 0."
"[INST]In the context of the C64, In which program can an example of setting the volume control be found?[/INST]An example of setting the volume control can be found in Example Program 1."
"[INST]In the context of the C64, What is the relevance of line 30 in Example Program 1?[/INST]Line 30 in Example Program 1 shows how the volume control is set."
"[INST]In the context of the C64, how do I turn on multiple sprites at once?[/INST]You can turn on multiple sprites at once by adding together the numbers of the sprites you want to turn on. For example, POKE V+21, 6 turns on sprites 1 and 2. This method allows you to control multiple sprites simultaneously without affecting each other."
"[INST]In the context of the C64, what is the purpose of using POKE V+21 and a number?[/INST]The purpose of using POKE V+21 and a number is to turn on individual sprites. The number corresponds to the sprite you want to turn on, and using POKE V+21 with that number will activate the sprite. However, turning on just one sprite will turn off any others, so you need to add the numbers together to turn on multiple sprites."
"[INST]In the context of the C64, how do I turn off a single sprite without affecting others?[/INST]To turn off a single sprite without affecting others, you can use the following method: POKE V+21, PEEK V+21 AND (255-1), where 1 corresponds to sprite 0. You can change the number 1 to 2, 4, 8, 16, 32, 64, or 128 to turn off sprites 0-7 respectively."
"[INST]In the context of the C64, what is the difference between POKE V+21, PEEK V+21 AND (255-1) and POKE V+21, PEEK(V+21)OR 1?[/INST]The difference between POKE V+21, PEEK V+21 AND (255-1) and POKE V+21, PEEK(V+21)OR 1 is that the first command turns off a sprite, while the second command turns on a sprite. The first command uses the AND operator to mask out the bit corresponding to the sprite you want to turn off, while the second command uses the OR operator to set the bit corresponding to the sprite you want to turn on."
"[INST]In the context of the C64, can I use POKE V+21 to turn on and off sprites simultaneously?[/INST]No, you cannot use POKE V+21 to turn on and off sprites simultaneously. Turning on one sprite will turn off any others. To turn on multiple sprites, you need to add their numbers together. To turn off a sprite without affecting others, you need to use the method described above."
"[INST]In the context of the C64, what is the significance of the number 255 in the command POKE V+21, PEEK V+21 AND (255-1)?[/INST]The number 255 in the command POKE V+21, PEEK V+21 AND (255-1) is a binary number that represents all bits set to 1. Subtracting 1 from it will give you a binary number with all bits set to 1 except for the bit corresponding to the sprite you want to turn off. The AND operator is then used to mask out that bit, effectively turning off the sprite."
"[INST]In the context of the C64, how do I re-enable a sprite that I previously turned off?[/INST]To re-enable a sprite that you previously turned off, you can use the command POKE V+21, PEEK(V+21)OR 1, where 1 corresponds to sprite 0. You can change the number 1 to 2, 4, 8, 16, 32, 64, or 128 to re-enable sprites 0-7 respectively."
"[INST]In the context of the C64, what is the purpose of the V+21 address in the POKE command?[/INST]The purpose of the V+21 address in the POKE command is to access the sprite control register. This register controls the state of the sprites, and by using POKE to modify this register, you can turn on and off individual sprites."
"[INST]In the context of the C64, can I use this method to control sprites in a game or animation?[/INST]Yes, this method can be used to control sprites in a game or animation. By carefully using the POKE command to turn on and off individual sprites, you can create the illusion of movement and animation. This is especially useful in games where you need to control multiple sprites simultaneously."
"[INST]In the context of the C64, how does the method of turning on and off sprites affect other graphics on the screen?[/INST]The method of turning on and off sprites using POKE V+21 does not affect other graphics on the screen. It only controls the state of the sprites, and does not interfere with other graphical elements such as characters, backgrounds, or text."
"[INST]In the context of the C64, Can a program be made shorter?[/INST]Yes, it can be made even shorter by 'crunching' it smaller."
"[INST]In the context of the C64, How can a program be made more efficient?[/INST]By 'crunching' it as follows: 10 PRINTCHR$(147):V=53248:POKEV+21,1:POKE2040.13:POKEV+39,1"
"[INST]In the context of the C64, What is the purpose of 'crunching' a program?[/INST]To make it fit in less memory and run more efficiently."
"[INST]In the context of the C64, What is the key to writing a short program?[/INST]Listing the key sprite settings on separate program lines."
"[INST]In the context of the C64, Can a program be made to run faster?[/INST]Yes, by 'crunching' it as follows: 10 PRINTCHR$(147):V=53248:POKEV+21,1:POKE2040.13:POKEV+39,1"
"[INST]In the context of the C64, What is the benefit of 'crunching' a program?[/INST]It makes the program fit in less memory and run more efficiently."
"[INST]In the context of the C64, Can a program be made to use less memory?[/INST]Yes, by 'crunching' it smaller."
"[INST]In the context of the C64, Can a program be made to use less memory and run faster?[/INST]Yes, by 'crunching' it as follows: 10 PRINTCHR$(147):V=53248:POKEV+21,1:POKE2040.13:POKEV+39,1"
"[INST]In the context of the C64, what is the opcode for CPX in immediate addressing mode?[/INST]The opcode for CPX in immediate addressing mode is E0, which requires 2 bytes and takes 2 cycles to execute."
"[INST]In the context of the C64, what is the difference in cycle count between CPX in zero page and absolute addressing modes?[/INST]The cycle count for CPX in zero page addressing mode is 3, whereas in absolute addressing mode it is 4, resulting in a difference of 1 cycle."
"[INST]In the context of the C64, what is the assembly language form for CPX in immediate addressing mode?[/INST]The assembly language form for CPX in immediate addressing mode is CPX *Oper, where *Oper is the immediate operand."
"[INST]In the context of the C64, what is the number of bytes required for CPX in absolute addressing mode?[/INST]CPX in absolute addressing mode requires 3 bytes."
"[INST]In the context of the C64, in which addressing modes can CPX be used?[/INST]CPX can be used in three addressing modes: Immediate, Zero Page, and Absolute."
"[INST]In the context of the C64, what is the opcode for CPX in zero page addressing mode?[/INST]The opcode for CPX in zero page addressing mode is E4, which requires 2 bytes and takes 3 cycles to execute."
"[INST]In the context of the C64, what is the purpose of the CPX instruction?[/INST]The purpose of the CPX instruction is to compare the value of the X register with the value of the operand, setting the flags accordingly."
"[INST]In the context of the C64, what is the assembly language form for CPX in zero page addressing mode?[/INST]The assembly language form for CPX in zero page addressing mode is CPX Oper, where Oper is the zero page address."
"[INST]In the context of the C64, how many cycles does CPX take in immediate addressing mode?[/INST]CPX takes 2 cycles to execute in immediate addressing mode."
"[INST]In the context of the C64, what is the opcode for CPX in absolute addressing mode?[/INST]The opcode for CPX in absolute addressing mode is EC, which requires 3 bytes and takes 4 cycles to execute."
"[INST]In the context of the C64, What does the PLP instruction do?[/INST]The PLP instruction pulls the processor status from the stack, which means it retrieves the status flags from the top of the stack and sets the processor flags accordingly."
"[INST]In the context of the C64, What is the purpose of the ROL instruction?[/INST]The ROL instruction rotates the bits of the accumulator or memory location one position to the left, effectively multiplying the value by 2, and sets the carry flag if the most significant bit is shifted out."
"[INST]In the context of the C64, What is the difference between ROL and ROR instructions?[/INST]The ROL instruction rotates the bits one position to the left, while the ROR instruction rotates the bits one position to the right, effectively dividing the value by 2, and sets the carry flag if the least significant bit is shifted out."
"[INST]In the context of the C64, What happens when the RTI instruction is executed?[/INST]When the RTI instruction is executed, the processor returns from an interrupt, popping the processor status and program counter from the stack, and resumes normal execution."
"[INST]In the context of the C64, What is the purpose of the RTS instruction?[/INST]The RTS instruction returns from a subroutine, popping the return address from the stack and transferring control to the caller."
"[INST]In the context of the C64, How does the SBC instruction handle borrowing?[/INST]The SBC instruction subtracts the memory value from the accumulator, borrowing from the next higher byte if the result is negative, and sets the carry flag accordingly."
"[INST]In the context of the C64, What is the effect of the SEC instruction?[/INST]The SEC instruction sets the carry flag, which can affect the result of subsequent arithmetic and logical operations."
"[INST]In the context of the C64, What is the purpose of the SED instruction?[/INST]The SED instruction sets the decimal mode, which affects the way arithmetic operations are performed, using binary-coded decimal (BCD) arithmetic."
"[INST]In the context of the C64, What happens when the SEI instruction is executed?[/INST]When the SEI instruction is executed, the interrupt disable status is set, preventing the processor from responding to interrupts until the CLI instruction is executed."
"[INST]In the context of the C64, What is the purpose of the STA instruction?[/INST]The STA instruction stores the value of the accumulator in a memory location, allowing the programmer to save the result of a calculation or operation."
"[INST]In the context of the C64, what is the opcode for LDA in immediate addressing mode?[/INST]The opcode for LDA in immediate addressing mode is A9, which loads the accumulator with the immediate value specified in the operand."
"[INST]In the context of the C64, What is the difference in the number of cycles between the zero page and absolute addressing modes for the LDA instruction?[/INST]The zero page addressing mode for the LDA instruction takes 3 cycles, while the absolute addressing mode takes 4 cycles, resulting in a difference of 1 cycle."
"[INST]In the context of the C64, How many bytes are required to encode the LDA instruction in absolute addressing mode?[/INST]The LDA instruction in absolute addressing mode requires 3 bytes, which include the opcode and the 2-byte absolute address."
"[INST]In the context of the C64, What is the purpose of the LDA instruction in the context of the C64?[/INST]The LDA instruction loads the accumulator with the value stored in memory at the specified address, which is essential for performing arithmetic and logical operations in the C64."
"[INST]In the context of the C64, What is the opcode for LDA in zero page addressing mode?[/INST]The opcode for LDA in zero page addressing mode is A5, which loads the accumulator with the value stored in the zero page address specified in the operand."
"[INST]In the context of the C64, How does the LDA instruction handle page boundaries in absolute addressing mode?[/INST]When the LDA instruction accesses memory across a page boundary in absolute addressing mode, it takes an additional cycle, resulting in a total of 5 cycles."
"[INST]In the context of the C64, What is the difference between the LDA instructions with X and Y indexing?[/INST]The LDA instruction with X indexing loads the accumulator with the value stored in memory at the address specified in the operand plus the value of the X register, whereas the LDA instruction with Y indexing loads the accumulator with the value stored in memory at the address specified in the operand plus the value of the Y register."
"[INST]In the context of the C64, What is the opcode for LDA in indirect addressing mode?[/INST]The opcode for LDA in indirect addressing mode is A1, which loads the accumulator with the value stored in memory at the address specified in the operand plus the value of the X register."
"[INST]In the context of the C64, How many cycles does the LDA instruction take in indirect addressing mode?[/INST]The LDA instruction in indirect addressing mode takes 6 cycles, which includes the time required to access the memory location specified in the operand."
"[INST]In the context of the C64, What is the purpose of the LDA instruction with Y indexing?[/INST]The LDA instruction with Y indexing loads the accumulator with the value stored in memory at the address specified in the operand plus the value of the Y register, which is useful for accessing data structures such as arrays and tables."
"[INST]In the context of the C64, what is the purpose of the FREQ LO and FREQ HI registers in the SID chip?[/INST]These registers form a 16-bit number that linearly controls the frequency of Oscillator 1, with the frequency determined by the equation Fout = (Fn*Fclk/16777216) Hz, where Fn is the 16-bit number in the Frequency registers and Fclk is the system clock applied to the 02 input (pin 6)."
"[INST]In the context of the C64, what is the frequency of Oscillator 1 when using a standard 1.0-MHz clock?[/INST]The frequency of Oscillator 1 is given by the equation Fout = (Fn*0.059604645) Hz, where Fn is the 16-bit number in the Frequency registers."
"[INST]In the context of the C64, what is the significance of the equation Fout = (Fn*Fclk/16777216) Hz?[/INST]This equation determines the frequency of Oscillator 1, where Fn is the 16-bit number in the Frequency registers and Fclk is the system clock applied to the 02 input (pin 6)."
"[INST]In the context of the C64, what is the purpose of Appendix E in the SID documentation?[/INST]Appendix E provides a complete table of values for generating 8 octaves of the equally tempered musical scale with concert A (440 Hz) tuning."
"[INST]In the context of the C64, what is the advantage of the SID chip's frequency resolution?[/INST]The SID chip's frequency resolution is sufficient for any tuning scale and allows sweeping from note to note (portamento) with no discernable frequency steps."
"[INST]In the context of the C64, how does the SID chip's frequency resolution affect music generation?[/INST]The SID chip's frequency resolution allows for smooth sweeping between notes, enabling portamento effects and making it suitable for generating a wide range of musical scales and tunings."
"[INST]In the context of the C64, what is the relationship between the FREQ LO and FREQ HI registers and the system clock?[/INST]The FREQ LO and FREQ HI registers, which form a 16-bit number, are used in conjunction with the system clock (Fclk) to determine the frequency of Oscillator 1."
"[INST]In the context of the C64, what is the significance of the 1.0-MHz clock in the SID chip?[/INST]The 1.0-MHz clock is a standard clock frequency used in the SID chip, and is used in conjunction with the FREQ LO and FREQ HI registers to determine the frequency of Oscillator 1."
"[INST]In the context of the C64, how does the SID chip's frequency control differ from other synthesizers?[/INST]The SID chip's frequency control allows for a high degree of precision and flexibility, enabling the generation of a wide range of frequencies and musical scales, and allowing for smooth sweeping between notes."
"[INST]In the context of the C64, what is the advantage of using a 16-bit number to control the frequency of Oscillator 1?[/INST]Using a 16-bit number to control the frequency of Oscillator 1 provides a high degree of precision and allows for a wide range of frequencies to be generated, making it suitable for generating a wide range of musical scales and tunings."
"[INST]In the context of the C64, what is the maximum amount of memory that the VIC-II chip can access at a time?[/INST]The VIC-II chip can access 16K of memory at a time, which is a limitation that requires bank selection to access the entire 64K of memory in the Commodore 64."
"[INST]In the context of the C64, How many banks of memory are there in the Commodore 64?[/INST]There are 4 possible banks of 16K memory in the Commodore 64, which can be accessed by controlling the bank select bits in the CIA#2 chip."
"[INST]In the context of the C64, What is the purpose of the bank select bits in the CIA#2 chip?[/INST]The bank select bits in the CIA#2 chip are used to control which 16K bank of memory the VIC-II chip looks at, allowing access to the entire 64K of memory."
"[INST]In the context of the C64, How are the bank select bits controlled?[/INST]The bank select bits are controlled using the POKE and PEEK BASIC statements (or their machine language versions) to set bits 0 and 1 of PORT A of CIA#2 (location 56576) and setting bits 0 and 1 of location 56578 ($DD02,HEX) to change banks."
"[INST]In the context of the C64, What is the default bank setting when the Commodore 64 is powered on?[/INST]When the Commodore 64 is powered on, bits 0 and 1 of location 56576 are automatically set to BANK 0 ($0000-$3FFF) for all display information."
"[INST]In the context of the C64, What is the significance of the bank concept in the VIC-II chip?[/INST]The 16K bank concept is crucial in the VIC-II chip, as it affects where character data patterns come from, where the screen is, where sprites come from, etc. and it's essential to be aware of which bank the VIC-II chip is pointing at."
"[INST]In the context of the C64, How do you set bits 0 and 1 of PORT A of CIA#2 to outputs?[/INST]You set bits 0 and 1 of PORT A of CIA#2 to outputs by setting bits 0 and 1 of location 56578 ($DD02,HEX) using the POKE statement, for example: POKE 56578,PEEK(56578)OR 3."
"[INST]In the context of the C64, What is the purpose of the POKE statement in the bank selection process?[/INST]The POKE statement is used to change banks by setting the bank select bits in the CIA#2 chip, for example: POKE 56576,(PEEK(56576)AND 252)OR A."
"[INST]In the context of the C64, In which banks is the Commodore 64 character set not available to the VIC-II chip?[/INST]The Commodore 64 character set is not available to the VIC-II chip in BANKS 1 and 3."
"[INST]In the context of the C64, How do you change banks using machine language?[/INST]You change banks using machine language by controlling bits 0 and 1 of PORT A of CIA#2 (location 56576) and setting bits 0 and 1 of location 56578 ($DD02,HEX) to outputs, similar to the POKE statement."
"[INST]In the context of the C64, what is the purpose of the VIC-II control register at location 53269?[/INST]The VIC-II control register at location 53269 is known as the SPRITE ENABLE register, which controls whether each of the sprites is ON or OFF, with each sprite having a bit in this register that determines its state."
"[INST]In the context of the C64, what does the bit in the SPRITE ENABLE register control?[/INST]The bit in the SPRITE ENABLE register controls whether a sprite is ON or OFF, with a 1 turning the sprite on and a 0 turning it off."
"[INST]In the context of the C64, how do you turn on sprite 1 using a POKE command?[/INST]To turn on sprite 1, you can use the following POKE command: POKE 53269,PEEK(53269)OR 2, which sets the bit for sprite 1 to 1, turning it on."
"[INST]In the context of the C64, what is the general statement to turn on a sprite using a POKE command?[/INST]The general statement to turn on a sprite using a POKE command is: POKE 53269,PEEK(53269)OR (2^SN), where SN is the sprite number, from 0 to 7."
"[INST]In the context of the C64, what is the significance of the SPRITE ENABLE register?[/INST]The SPRITE ENABLE register is significant because a sprite must be turned ON before it can be seen, and this register controls whether each sprite is ON or OFF."
"[INST]In the context of the C64, what is the format of the SPRITE ENABLE register?[/INST]The SPRITE ENABLE register is formatted as a byte, with each bit representing a sprite, from 7 to 0, with a 1 indicating the sprite is ON and a 0 indicating it is OFF."
"[INST]In the context of the C64, what is the hexadecimal representation of the SPRITE ENABLE register location?[/INST]The hexadecimal representation of the SPRITE ENABLE register location is $D015."
"[INST]In the context of the C64, what is the decimal representation of the SPRITE ENABLE register location?[/INST]The decimal representation of the SPRITE ENABLE register location is 53269."
"[INST]In the context of the C64, why is it important to turn on a sprite before using it?[/INST]It is important to turn on a sprite before using it because a sprite must be turned ON before it can be seen, and if it is not turned on, it will not be visible."
"[INST]In the context of the C64, what is the purpose of the OR operator in the POKE command?[/INST]The purpose of the OR operator in the POKE command is to set the bit for the desired sprite to 1, turning it on, while leaving the other bits unchanged."
"[INST]In the context of the C64, What are the two settings that must be poked to position a sprite on the screen?[/INST]The X position and the Y position"
"[INST]In the context of the C64, What is the purpose of the X coordinate in positioning a sprite?[/INST]The horizontal position across the screen"
"[INST]In the context of the C64, What is the purpose of the Y coordinate in positioning a sprite?[/INST]The vertical position up and down"
"[INST]In the context of the C64, What is the size of a sprite in pixels?[/INST]24 across by 21 down"
"[INST]In the context of the C64, What is the area of the sprite that is displayed when positioning a sprite?[/INST]The upper left corner of the entire sprite"
"[INST]In the context of the C64, what is indexing in the context of the 6510 microprocessor?[/INST]Indexing is the process of creating an actual address from a base address plus the contents of either the X or Y index registers, allowing for more flexible and efficient memory access."
"[INST]In the context of the C64, what is the result of executing an LDA instruction in absolute X indexed mode with a base address of $9000 and X containing $05?[/INST]The result would be loading the value from memory location $9000 + $05 = $9005 into the A register."
"[INST]In the context of the C64, what is the mnemonic format of an absolute indexed instruction?[/INST]The mnemonic format of an absolute indexed instruction is the same as an absolute instruction, with the addition of ',X' or ',Y' to denote the index, for example, LDA $9000,X."
"[INST]In the context of the C64, what are the different modes of addressing available on the 6510 microprocessor?[/INST]The 6510 microprocessor supports absolute indexed, zero page indexed, indirect indexed, and indexed indirect modes of addressing."
"[INST]In the context of the C64, how does the 6510 microprocessor calculate the actual memory address in indexed mode?[/INST]The 6510 microprocessor calculates the actual memory address by adding the contents of either the X or Y index register to the base address."
"[INST]In the context of the C64, what is the purpose of the index registers X and Y in the 6510 microprocessor?[/INST]The purpose of the index registers X and Y is to hold a value that is added to a base address to create an actual memory address, allowing for flexible and efficient memory access."
"[INST]In the context of the C64, what is the difference between an absolute instruction and an absolute indexed instruction?[/INST]The difference is that an absolute indexed instruction has a ',X' or ',Y' added to the address, denoting that the index register is used to calculate the actual memory address."
"[INST]In the context of the C64, can you give an example of an absolute indexed instruction?[/INST]Yes, an example is LDA $9000,X, which loads the value from memory location $9000 + X into the A register."
"[INST]In the context of the C64, what is the advantage of using indexed addressing modes on the 6510 microprocessor?[/INST]The advantage is that it allows for more flexible and efficient memory access, as the index registers can be used to dynamically calculate memory addresses."
"[INST]In the context of the C64, how many index registers are available on the 6510 microprocessor?[/INST]There are two index registers available on the 6510 microprocessor, X and Y."
"[INST]In the context of the C64, what is the purpose of the spritemaking program?[/INST]to help you draw your own sprites"
"[INST]In the context of the C64, what do you need to write down in step 1?[/INST]the spritemaking program shown on a piece of paper"
"[INST]In the context of the C64, how many squares are across in the spritemaking grid?[/INST]24"
"[INST]In the context of the C64, how many squares are down in the spritemaking grid?[/INST]21"
"[INST]In the context of the C64, what do you use to draw on the grid?[/INST]a pencil"
"[INST]In the context of the C64, why do you draw lightly on the grid?[/INST]so you can reuse this grid"
"[INST]In the context of the C64, what type of arithmetic is used in step 3?[/INST]binary arithmetic"
"[INST]In the context of the C64, what do you add up in step 4?[/INST]the numbers of the solid pixels"
"[INST]In the context of the C64, what is the total number for the first group of eight pixels?[/INST]255"
"[INST]In the context of the C64, where do you enter the total number in step 5?[/INST]as the first data statement in line 100"
"[INST]In the context of the C64, what do you do in step 6?[/INST]look at the first eight pixels in the second row of the sprite"
"[INST]In the context of the C64, what is the total value of the first eight pixels in the second row?[/INST]128"
"[INST]In the context of the C64, where do you enter the total value in step 6?[/INST]as the first data number in line 101"
"[INST]In the context of the C64, what do you do in step 7?[/INST]add up the values of the next group of eight pixels"
"[INST]In the context of the C64, how many groups of eight pixels are there in each row?[/INST]3"
"[INST]In the context of the C64, how many rows are there in the sprite?[/INST]21"
"[INST]In the context of the C64, what is the total number of individual pixels?[/INST]504"
"[INST]In the context of the C64, what do you do in step 8?[/INST]crunch your program into a smaller space"
"[INST]In the context of the C64, why did we ask you to write your sprite program on paper?[/INST]to help you see which numbers relate to which groups of pixels"
"[INST]In the context of the C64, what is the purpose of the data statement lines 100-120?[/INST]to help you see which numbers relate to which groups of pixels"
"[INST]In the context of the C64, what is the final program supposed to look like?[/INST]crunched together"
"[INST]In the context of the C64, what is the command to clear the screen in the sample program?[/INST]print{clear}"
"[INST]In the context of the C64, what is the value of the variable v in the sample program?[/INST]53248"
"[INST]In the context of the C64, what is the purpose of the for loop in the sample program?[/INST]to poke the data into memory"
"[INST]In the context of the C64, Which sprite has priority over all other sprites?[/INST]Sprite 0"
"[INST]In the context of the C64, What happens to a sprite with lower priority when two sprites are in the same position?[/INST]The sprite with lower priority will be obscured or show through"
"[INST]In the context of the C64, What is the rule for determining sprite priority?[/INST]Lower numbered sprites have priority over higher numbered sprites"
"[INST]In the context of the C64, What happens to a sprite with higher priority when two sprites are in the same position?[/INST]The sprite with higher priority will appear in front of the sprite with lower priority"
"[INST]In the context of the C64, What is the priority of Sprite 7?[/INST]Sprite 7 has no priority in relation to the other sprites"
"[INST]In the context of the C64, What happens to a sprite with higher priority when it is in front of a sprite with lower priority?[/INST]The sprite with higher priority will appear in front of the sprite with lower priority"
"[INST]In the context of the C64, What is the priority of Sprite 1?[/INST]Sprite 1 has priority over sprites 2-7"
"[INST]In the context of the C64, What happens to a sprite with lower priority when it is behind a sprite with higher priority?[/INST]The sprite with lower priority will be obscured or show through"
"[INST]In the context of the C64, What is the rule for determining which sprite appears in front of the other?[/INST]The sprite with higher priority will appear in front of the sprite with lower priority"
"[INST]In the context of the C64, What happens to a sprite with lower priority when it is in front of a sprite with higher priority?[/INST]The sprite with lower priority will be obscured or show through"
"[INST]In the context of the C64, TAY: Operation: A -> Y[/INST]The operation is A -> Y, which is a transfer operation."
"[INST]In the context of the C64, TAY: Assembly Language Form[/INST]The assembly language form is TAY."
"[INST]In the context of the C64, TAY: OP CODE[/INST]The OP code is A8."
"[INST]In the context of the C64, TAY: No. Bytes[/INST]The number of bytes is 1."
"[INST]In the context of the C64, TAY: No. Cycles[/INST]The number of cycles is 2."
"[INST]In the context of the C64, TAY: Addressing Mode[/INST]The addressing mode is Implied."
"[INST]In the context of the C64, TAY[/INST]The operation is TAY, which is a transfer operation."
"[INST]In the context of the C64, how to move the accumulator to index Y[/INST]The operation is transferring the accumulator to index Y."
"[INST]In the context of the C64, Is the Commodore 64 a 16-bit computer?[/INST]No, it has a 16-bit address bus but can address more than 64K bytes of memory."
"[INST]In the context of the C64, What is the total amount of RAM in the Commodore 64?[/INST]64K bytes"
"[INST]In the context of the C64, What is the purpose of the 6510 processor chip?[/INST]It controls whether RAM or ROM or I/O will appear in certain portions of the system's memory."
"[INST]In the context of the C64, What is the input/output port used for?[/INST]To control whether RAM or ROM or I/O will appear in certain portions of the system's memory."
"[INST]In the context of the C64, What is the data direction register used for?[/INST]To control whether a given bit will be an input or an output."
"[INST]In the context of the C64, What is the purpose of the LORAM bit?[/INST]To bank the 8K byte BASIC ROM in and out of the microprocessor address space."
"[INST]In the context of the C64, What is the purpose of the HIRAM bit?[/INST]To bank the 8K byte KERNAL ROM in and out of the microprocessor address space."
"[INST]In the context of the C64, What is the purpose of the CHAREN bit?[/INST]To bank the 4K byte character generator ROM in or out of the microprocessor address space."
"[INST]In the context of the C64, What happens when the LORAM bit is programmed LOW?[/INST]The BASIC ROM will disappear from the memory map and be replaced by 8K bytes of RAM."
"[INST]In the context of the C64, What happens when the HIRAM bit is programmed LOW?[/INST]The KERNAL ROM will disappear from the memory map and be replaced by 8K bytes of RAM."
"[INST]In the context of the C64, What happens when the CHAREN bit is set to 1?[/INST]The I/O devices appear in the microprocessor address space, and the character ROM is not accessible."
"[INST]In the context of the C64, What happens when the CHAREN bit is cleared to 0?[/INST]The character ROM appears in the processor address space, and the I/O devices are not accessible."
"[INST]In the context of the C64, What is the purpose of the WRITE operation in ROM?[/INST]To store data in the RAM 'under' the ROM."
"[INST]In the context of the C64, What happens when a WRITE operation is performed on a ROM location?[/INST]Data is stored in the RAM 'under' the ROM."
"[INST]In the context of the C64, What is the purpose of the READ operation in ROM?[/INST]To return the contents of the ROM."
"[INST]In the context of the C64, What happens when a READ operation is performed on a ROM location?[/INST]The contents of the ROM are returned, not the 'hidden' RAM."
"[INST]In the context of the C64, What is the total amount of ROM in the Commodore 64?[/INST]20K bytes"
"[INST]In the context of the C64, What is the purpose of the 20K bytes of ROM?[/INST]To contain BASIC, the operating system, and the standard character set."
"[INST]In the context of the C64, What is the purpose of the 4K chunk of memory?[/INST]To access input/output devices"
"[INST]In the context of the C64, What is the secret to addressing more than 64K bytes of memory?[/INST]The 6510 processor chip itself"
"[INST]In the context of the C64, What is the purpose of the input/output port?[/INST]To control whether RAM or ROM or I/O will appear in certain portions of the system's memory"
"[INST]In the context of the C64, What is the purpose of the data direction register?[/INST]To control whether a given bit will be an input or an output"
"[INST]In the context of the C64, What is the purpose of the LORAM bit?[/INST]To bank the 8K byte BASIC ROM in and out of the microprocessor address space"
"[INST]In the context of the C64, What is the purpose of the HIRAM bit?[/INST]To bank the 8K byte KERNAL ROM in and out of the microprocessor address space"
"[INST]In the context of the C64, What is the purpose of the CHAREN bit?[/INST]To bank the 4K byte character generator ROM in or out of the microprocessor address space"
"[INST]In the context of the C64, SED stands for?[/INST]The SED command is used to set the decimal mode."
"[INST]In the context of the C64, SED command[/INST]The SED command is used to set the decimal mode."
"[INST]In the context of the C64, What is the purpose of SED?[/INST]The purpose of SED is to set the decimal mode."
"[INST]In the context of the C64, What is the function of SED?[/INST]The function of SED is to set the decimal mode."
"[INST]In the context of the C64, What does SED do?[/INST]SED sets the decimal mode."
"[INST]In the context of the C64, What is the operation of SED?[/INST]The operation of SED is to set the decimal mode."
"[INST]In the context of the C64, What is the purpose of SED operation?[/INST]The purpose of SED operation is to set the decimal mode."
"[INST]In the context of the C64, What is the function of SED operation?[/INST]The function of SED operation is to set the decimal mode."
"[INST]In the context of the C64, What is the operation of SED mode?[/INST]The operation of SED mode is to set the decimal mode."
"[INST]In the context of the C64, What is the purpose of SED mode?[/INST]The purpose of SED mode is to set the decimal mode."
"[INST]In the context of the C64, what is the resolution of the Time of Day Clock (TOD)[/INST]The Time of Day Clock (TOD) has a resolution of 1/10th of a second, allowing for precise time-keeping applications."
"[INST]In the context of the C64, what is the organization of the TOD clock registers[/INST]The TOD clock consists of 4 registers: 10ths of seconds, Seconds, Minutes, and Hours, each reading out in BCD format to simplify conversion for driving displays."
"[INST]In the context of the C64, what is the purpose of the AM/PM flag in the Hours register[/INST]The AM/PM flag is located in the MSB of the Hours register, allowing for easy bit testing to determine whether the time is in the morning or afternoon."
"[INST]In the context of the C64, what is required for accurate time-keeping in the TOD clock[/INST]The TOD clock requires an external 60 Hz or 50 Hz (programmable) TTL level input on the TOD pin for accurate time-keeping."
"[INST]In the context of the C64, what is the purpose of the ALARM registers in the TOD clock[/INST]The ALARM registers, located at the same addresses as the corresponding TOD registers, allow for generating an interrupt at a desired time, and are write-only, with access governed by a Control Register bit."
"[INST]In the context of the C64, what is the sequence of events required for proper setting and reading of the TOD clock[/INST]A specific sequence of events must be followed for proper setting and reading of the TOD clock, including stopping the clock when writing to the Hours register, and starting it again after writing to the 10ths of seconds register."
"[INST]In the context of the C64, what is the purpose of the latching function in the TOD clock[/INST]The latching function is included to keep all Time Of Day information constant during a read sequence, ensuring that all four TOD registers latch on a read of Hours and remain latched until after a read of 10ths of seconds."
"[INST]In the context of the C64, how does the TOD clock handle carry from one stage to the next during a read operation[/INST]The TOD clock handles carry from one stage to the next during a read operation by including a latching function, which keeps all Time Of Day information constant during a read sequence."
"[INST]In the context of the C64, what is the effect of writing to the Hours register on the TOD clock[/INST]Writing to the Hours register automatically stops the TOD clock, and it will not start again until after a write to the 10ths of seconds register."
"[INST]In the context of the C64, how can a single TOD register be read without affecting the clock's operation[/INST]A single TOD register can be read 'on the fly' without affecting the clock's operation, provided that any read of Hours is followed by a read of 10ths of seconds to disable the latching."
"[INST]In the context of the C64, what is the addressing mode of the NOP instruction?[/INST]The addressing mode of the NOP instruction is implied, which means that the instruction does not require any additional memory locations or registers to be specified."
"[INST]In the context of the C64, what is the assembly language form of the NOP instruction?[/INST]The assembly language form of the NOP instruction is simply 'NOP', which is a single keyword that represents the no-operation instruction."
"[INST]In the context of the C64, what is the OP CODE for the NOP instruction?[/INST]The OP CODE for the NOP instruction is EA, which is the hexadecimal code that the CPU recognizes as the NOP instruction."
"[INST]In the context of the C64, how many bytes does the NOP instruction occupy in memory?[/INST]The NOP instruction occupies only 1 byte in memory, making it a very compact instruction."
"[INST]In the context of the C64, how many cycles does the NOP instruction take to execute?[/INST]The NOP instruction takes 2 cycles to execute, which is a relatively short execution time."
"[INST]In the context of the C64, what is the purpose of the NOP instruction?[/INST]The purpose of the NOP instruction is to do nothing, hence the name 'no operation', and is often used as a placeholder or filler in code."
"[INST]In the context of the C64, can the NOP instruction be used as a delay in a program?[/INST]Yes, the NOP instruction can be used as a delay in a program, as it takes 2 cycles to execute, which can be useful in certain timing-critical situations."
"[INST]In the context of the C64, what is the difference between the NOP instruction and other instructions?[/INST]The main difference between the NOP instruction and other instructions is that it does not perform any operation, whereas other instructions perform specific operations such as loading, storing, or arithmetic operations."
"[INST]In the context of the C64, in what situations would you use the NOP instruction?[/INST]You would use the NOP instruction in situations where you need to fill a gap in code, or to create a delay in a program, or to reserve space for future code additions."
"[INST]In the context of the C64, can the NOP instruction be used to align code in memory?[/INST]Yes, the NOP instruction can be used to align code in memory, by filling gaps between code segments, ensuring proper alignment and avoiding misalignment issues."
"[INST]In the context of the C64, what is the purpose of scrolling in the context of display data?[/INST]Scrolling allows for the display data to be moved up to one entire character space in both the horizontal and vertical direction, enabling a smooth panning motion of display data while only updating the system memory when a new character row or column is required."
"[INST]In the context of the C64, what is the advantage of using scrolling in conjunction with a smaller display window?[/INST]When used in conjunction with a smaller display window, scrolling enables a smooth panning motion of display data while only updating the system memory when a new character row or column is required, reducing the amount of memory updates needed."
"[INST]In the context of the C64, how does scrolling help in centering a fixed display within the display window?[/INST]Scrolling is used to center a fixed display within the display window by adjusting the horizontal and vertical position of the display data to ensure it is centered within the window."
"[INST]In the context of the C64, what is the function of the X2,X1,X0 bits in the register 22 ($16)?[/INST]The X2,X1,X0 bits in the register 22 ($16) control the horizontal position of the display data, allowing for precise control over the horizontal scrolling of the display."
"[INST]In the context of the C64, what is the function of the Y2,Y1,Y0 bits in the register 17 ($11)?[/INST]The Y2,Y1,Y0 bits in the register 17 ($11) control the vertical position of the display data, allowing for precise control over the vertical scrolling of the display."
"[INST]In the context of the C64, in what way does scrolling reduce the amount of memory updates needed?[/INST]Scrolling reduces the amount of memory updates needed by only updating the system memory when a new character row or column is required, reducing the frequency of memory updates and improving system performance."
"[INST]In the context of the C64, what is the relationship between scrolling and the display window?[/INST]The display window determines the area of the display data that is visible, and scrolling allows for the display data to be moved within this window, enabling the display of a larger area of data than can be displayed at once."
"[INST]In the context of the C64, how does scrolling improve the user experience?[/INST]Scrolling improves the user experience by enabling a smooth panning motion of display data, allowing the user to easily view and interact with a larger area of data than can be displayed at once."
"[INST]In the context of the C64, what is the advantage of using scrolling in conjunction with a fixed display?[/INST]Using scrolling in conjunction with a fixed display enables the display to be centered within the display window, improving the user experience and making it easier to view and interact with the display data."
"[INST]In the context of the C64, in what way does scrolling enable the display of a larger area of data?[/INST]Scrolling enables the display of a larger area of data by allowing the display data to be moved within the display window, enabling the user to view and interact with a larger area of data than can be displayed at once."
"[INST]In the context of the C64, what is the purpose of the program counter in a commodore 64?[/INST]The program counter contains the address of the current machine language instruction being executed, and it is constantly changing as the operating system is always running in the Commodore 64, unless the microprocessor is halted in some way."
"[INST]In the context of the C64, what happens to the program counter when the operating system is running?[/INST]When the operating system is running, the program counter is always changing, as it contains the address of the current machine language instruction being executed, and it would only stop changing if the microprocessor is halted in some way."
"[INST]In the context of the C64, what would happen if the microprocessor is halted?[/INST]If the microprocessor is halted, the program counter would stop changing, and it would retain the address of the current machine language instruction being executed, allowing for a snapshot of the current state of the program."
"[INST]In the context of the C64, what is the significance of the program counter in a commodore 64?[/INST]The program counter is significant in a Commodore 64 because it contains the address of the current machine language instruction being executed, and it is constantly changing as the operating system runs, making it a crucial component of the computer's operation."
"[INST]In the context of the C64, how does the program counter relate to the operating system?[/INST]The program counter is closely related to the operating system, as it contains the address of the current machine language instruction being executed, and it is always changing as the operating system runs, making it an integral part of the operating system's functionality."
"[INST]In the context of the C64, what is the relationship between the program counter and the microprocessor?[/INST]The program counter is closely related to the microprocessor, as it contains the address of the current machine language instruction being executed, and it would only stop changing if the microprocessor is halted in some way, highlighting the interdependence of the two components."
"[INST]In the context of the C64, what is the role of the program counter in the commodore 64's operation?[/INST]The program counter plays a crucial role in the Commodore 64's operation, as it contains the address of the current machine language instruction being executed, and it is constantly changing as the operating system runs, making it a vital component of the computer's functionality."
"[INST]In the context of the C64, how does the program counter affect the execution of machine language instructions?[/INST]The program counter affects the execution of machine language instructions by containing the address of the current instruction being executed, and it is constantly changing as the operating system runs, allowing for the sequential execution of machine language instructions."
"[INST]In the context of the C64, what is the significance of the program counter in understanding the commodore 64's architecture?[/INST]The program counter is significant in understanding the Commodore 64's architecture, as it provides insight into the computer's operation, highlighting the dynamic nature of the program counter and its relationship with the microprocessor and operating system."
"[INST]In the context of the C64, how does the program counter relate to the concept of 'RUN'ning in the commodore 64?[/INST]The program counter relates to the concept of 'RUN'ning in the Commodore 64, as it contains the address of the current machine language instruction being executed, and it is constantly changing as the operating system runs, highlighting the dynamic nature of the program counter in the 'RUN' state."
"[INST]In the context of the C64, What is the purpose of the UDTIM function?[/INST]Update the system clock"
"[INST]In the context of the C64, What is the call address of the UDTIM function?[/INST]$FFEA (hex) 65514 (decimal)"
"[INST]In the context of the C64, What registers are affected by the UDTIM function?[/INST]A, X"
"[INST]In the context of the C64, How often is the UDTIM function normally called?[/INST]every 1/60th of a second"
"[INST]In the context of the C64, What is the stack requirement for the UDTIM function?[/INST]2"
"[INST]In the context of the C64, What is the purpose of calling the UDTIM function in user programs?[/INST]to update the time"
"[INST]In the context of the C64, What is the consequence of not calling the UDTIM function in user programs?[/INST]<STOP> key routine must be called"
"[INST]In the context of the C64, What is the recommended way to use the UDTIM function?[/INST]Call this routine"
"[INST]In the context of the C64, What is the example of how to use the UDTIM function?[/INST]JSR UDTIM"
"[INST]In the context of the C64, What is the importance of calling the UDTIM function in user programs?[/INST]to remain functional"
"[INST]In the context of the C64, What is the purpose of the UDTIM function in the KERNAL interrupt routine?[/INST]to update the system clock"
"[INST]In the context of the C64, SETNAM[/INST]This routine is used to set up the file name for the OPEN, SAVE, or LOAD routines."
"[INST]In the context of the C64, SETNAM: Length of file name[/INST]The accumulator must be loaded with the length of the file name."
"[INST]In the context of the C64, SETNAM: Registers affected[/INST]Registers A, X, and Y are affected."
"[INST]In the context of the C64, SETNAM: Preparatory routines[/INST]The routine requires 2 stack requirements."
"[INST]In the context of the C64, SETNAM: Call address[/INST]The call address is $FFBD (hex) or 65469 (decimal)."
"[INST]In the context of the C64, SETNAM: Registers used[/INST]Registers A, X, and Y are used."
"[INST]In the context of the C64, SETNAM: File name address[/INST]The X and Y registers must be loaded with the address of the file name."
"[INST]In the context of the C64, SETNAM: File name length[/INST]The accumulator must be loaded with the length of the file name."
"[INST]In the context of the C64, SETNAM: Memory address[/INST]The address can be any valid memory address in the system."
"[INST]In the context of the C64, SETNAM: No file name[/INST]If no file name is desired, the accumulator must be set to 0."
"[INST]In the context of the C64, Cursor jumps back to home position.[/INST]possible cause: 6510"
"[INST]In the context of the C64, Abnormal colours appear in the letters.[/INST]possible cause: PLA"
"[INST]In the context of the C64, Different characters are displayed and cursor is locked when turned on and off.[/INST]possible cause: 6510, 6567"
"[INST]In the context of the C64, System does not reset and the 'RESTORE' key does not work.[/INST]possible cause: 6510,PLA, ROM 227"
"[INST]In the context of the C64, Cursor disappears after the system warms up.[/INST]possible cause: 6526"
"[INST]In the context of the C64, SYNTAX ERROR displayed after system warms up.[/INST]possible cause: ROM 226"
"[INST]In the context of the C64, The system resets when it warms up and long programs do not load.[/INST]possible cause: 6510, ROM 226"
"[INST]In the context of the C64, Keyboard does not operate correctly when the system warms up.[/INST]possible cause: 6526,ROM 226"
"[INST]In the context of the C64, Cassette motor keeps running.[/INST]possible cause: 6510"
"[INST]In the context of the C64, The cursor disappears when the cassette is plugged in.[/INST]possible cause: 6510"
"[INST]In the context of the C64, Cassette runs extremely slow. The program seems to load but willnot run.[/INST]possible cause: 6510"
"[INST]In the context of the C64, Blank screen on power up.[/INST]possible cause: 6510, 6567, PLA, 8701 [, RAM ]"
"[INST]In the context of the C64, No cursor displayed. Intermittent blank screen. Intermittent graphics.[/INST]possible cause: 6510"
"[INST]In the context of the C64, Powers up with 'PRESS PLAY ON TAPE' message and the display blanks.[/INST]possible cause: 6510"
"[INST]In the context of the C64, On power up the cursor locks up.[/INST]possible cause: 6510"
"[INST]In the context of the C64, When 'RETURN' is pressed after a run command, the cursor goes back to home position.[/INST]possible cause: ROM 226"
"[INST]In the context of the C64, Poke command does not work.[/INST]possible cause: ROM 226"
"[INST]In the context of the C64, Joystick does not operate correctly.[/INST]possible cause: 6526"
"[INST]In the context of the C64, No character lettering is displayed on the screen.[/INST]possible cause: 6526, 6567,PLA, ROM 225"
"[INST]In the context of the C64, Graphic characters instead of letters displayed.[/INST]possible cause: 6526, 6567"
"[INST]In the context of the C64, Power up message appears but no cursor.[/INST]possible cause: 6526, ROM 226"
"[INST]In the context of the C64, DEVICE NOT PRESENT ERROR is displayed when disk is used.[/INST]possible cause: 6510,6526"
"[INST]In the context of the C64, Disk drives continue to search when trying to load.[/INST]possible cause: 6526"
"[INST]In the context of the C64, Incorrect screen colours or no colour at all.[/INST]possible cause: 6567, PLA"
"[INST]In the context of the C64, Keyboard does not function.[/INST]possible cause: 6526"
"[INST]In the context of the C64, Cassette recorder problem.[/INST]possible cause: 6510, 6526"
"[INST]In the context of the C64, Flashing colour or blocks.[/INST]possible cause: PLA"
"[INST]In the context of the C64, Game Cartridge does not function.[/INST]possible cause: PLA, ROM 227"
"[INST]In the context of the C64, Unit dead (30-40% possibility PLA).[/INST]possible cause: PLA"
"[INST]In the context of the C64, User port does not function (eg. modem).[/INST]possible cause: 6526"
"[INST]In the context of the C64, No sound.[/INST]possible cause: 6581 [, Bad RF Modulator ]"
"[INST]In the context of the C64, Missing notes.[/INST]possible cause: 6581"
"[INST]In the context of the C64, Game paddles do not function.[/INST]possible cause: 6526, 6581"
"[INST]In the context of the C64, White band scrolls down the screen (60 HZ HUM).[/INST]possible cause: Check power supply and VR2 regulator."
"[INST]In the context of the C64, Wavy screen after the system warms up.[/INST]Check external power supply and 6567 chip."
"[INST]In the context of the C64, Black band scrolls through screen when system warms up.[/INST]Check external power supply and VR2 regulator."
"[INST]In the context of the C64, Out of memory error on power up.[/INST]Check Rams 4146 U1-U12,U21-U24. [ May be Hot! ]"
"[INST]In the context of the C64, Powers up with graphic display and blinking cursor.[/INST]Check U14."
"[INST]In the context of the C64, Powers up with all the characters displayed as blocks.[/INST]Check U26."
"[INST]In the context of the C64, Unit completely dead.[/INST]Possible power supply failure."
"[INST]In the context of the C64, After a few minutes, characters are all over the screen, then the unit locks up.[/INST]Possible power supply problem."
"[INST]In the context of the C64, Error LED stays on all the time.""[/INST]possible cause: 6501,ROM 32530201, ROM 90122905"
"[INST]In the context of the C64, Drive motor runs continuously and red LED stays on.[/INST]possible cause: 6522 [, LED Flashes: UC7 ]"
"[INST]In the context of the C64, Drive motor runs continuously and red LED stays off.[/INST]possible cause: 6502, ROM 90122905"
"[INST]In the context of the C64, After the drive warms up the motor runs continuously.[/INST]possible cause: 6522"
"[INST]In the context of the C64, Does not load when hot or LED flashed 3 times.[/INST]possible cause: ROM 90122905, LM311"
"[INST]In the context of the C64, Searches with LED flashing continuously.[/INST]possible cause: ROM 90122905"
"[INST]In the context of the C64, Searching with no red LED.[/INST]possible cause: ROM 3253021"
"[INST]In the context of the C64, Drive fails to read.[/INST]possible cause: LM311, 592, 9602"
"[INST]In the context of the C64, Fails to format disk.[/INST]possible cause: 6522, ROM 32557201"
"[INST]In the context of the C64, Stepper Motor does not step forward.[/INST]possible cause: 6502, 6522"
"[INST]In the context of the C64, Will not save when the drive heats up.[/INST]possible cause: 6502"
"[INST]In the context of the C64, Lights stay on, motor runs continuously.[/INST]Is Power cord plugged into wall outlet correctly? Is Power cord plugged into disk drive correctly?  Check line fuse and power switch.  Check +5/12 volt lines."
"[INST]In the context of the C64, No LED's on power up.[/INST]Check all RAM and ROM locations."
"[INST]In the context of the C64, Drive motor runs continuously with no red or green LED'S.[/INST]Check VR2. Check Power Transformer. [ Hint: No Reg. +5V ]"
"[INST]In the context of the C64, Loads programs with red LED flashing. Check drive speed.[/INST]Check stepper motor."
"[INST]In the context of the C64, Loading is intermittent.[/INST]Check ROM's and drive alignment."
"[INST]In the context of the C64, Message of 'FILE NOT FOUND' is displayed.[/INST]Clean drive head w/alcohol. Check 0 stop adjustment. Check alignment. [ Check for sticky slide rails. 1571: Check head lifter release mech. ]"
"[INST]In the context of the C64, Drive speed will not stabilize.[/INST]Check DC motor. [ Check belt (oldVdrives)] Locks-up when loading. Check serial port components. CheckV 901229-05."
"[INST]In the context of the C64, Fails the performance test and displays a 21 read error.[/INST]Check test diskette. Check Drive Motor."
"[INST]In the context of the C64, Fails the performance test and displays a 27 read error.[/INST]Check stop adjust."
"[INST]In the context of the C64, Passes performance test to track 18 then displays 21 read errors.[/INST]Check read/write head."
"[INST]In the context of the C64, Passes the performance test but will not load certain programs.[/INST]Check stepper motor."
"[INST]In the context of the C64, Flashing light on and off during loading.[/INST]An alignment problem or bad diskette."
"[INST]In the context of the C64, What is the function of the bit 0 of the I/O address $DD0D?[/INST]address $DD0D bit 0 is:	Timer A Interrupt"
"[INST]In the context of the C64, What is the purpose of the memory range $DE00-DEFF?[/INST]address $DE00-DEFF are: 	Reserved for Future I/O Expansion"
"[INST]In the context of the C64, What is tat address $DC01 bit 1?[/INST]address $DC01 bit 7	Timer B Toggle/Pulse Output"
"[INST]In the context of the C64, What is the description of address $D41A in the Commodore 64 memory map?[/INST]address $D41A	is:	Analog/Digital Converter Game Paddle 2 (0-255)"
"[INST]In the context of the C64, What is the description of the register located at address $DC0D?[/INST]address $DC0D	is: CIA Interrupt Control Register (ReadIRQs/Write Mask)"
"[INST]In the context of the C64, What is the description of the register at address $4283?[/INST]address $4283	bits		6	is: Select Pulse Waveform, 1 = On"
"[INST]In the context of the C64, What is the function of bit 1 at address $4276?[/INST]address $4276	bit 1 is 	Synchronize Osc. 1 with Osc. 3 Frequency, 1 = On"
"[INST]In the context of the C64, What is the function of the bit 2 at address $DD00 in a Commodore 64?[/INST]address $DD00 bit 2 is: 	RS-232 Data Output (User Port)"
"[INST]In the context of the C64, What is the description of memory address $3291?[/INST]address $3291		is:			Sprite 4 Color"
"[INST]In the context of the C64, What is the function of bit 2 of the $DC0E address ?[/INST]address $DC0E bit 2 is:	Timer A Output Mode to PB6: 1 = Toggle,0 = Pulse"
"[INST]In the context of the C64, What is the description of the address $0001 bit 4 in a c64?[/INST]address $0001 bit 4	is: Cassette Switch Sense: 1 = Switch Closed"
"[INST]In the context of the C64, What is the description of memory address $3277?[/INST]address $3277		is:			Sprites 0-7 Expand 2x Horizontal (X)"
"[INST]In the context of the C64, What is the function of address D016 bit 2-0?[/INST]address D016 bit 2-0 is:	Smooth Scroll to X Pos"
"[INST]In the context of the C64, What is the description of the USRADD command?[/INST]USRADD    address $0311-0312   is: USR Address ($LB,$MB)."
"[INST]In the context of the C64, What is the description of SFDX  with the address $00CB?[/INST]SFDX      address $00CB        is: Flag: Print shifted Characters."
"[INST]In the context of the C64, What is the description of the address $00B9?[/INST]SA        address $00B9        is: Current File - Secondary Address."
"[INST]In the context of the C64, What is the description of the memory address range $030A-030B in the Commodore 64?[/INST]IEVAL     address $030A-030B   is: Vector: Indirect entry to BASIC Token  evaluation ($AE86)."
"[INST]In the context of the C64, What is the purpose and usage of the memory address range $02C0-$02FE in Commodore 64 programming?[/INST]SPR11     address $02C0-02FE   is: Sprite #11 Data Area.  (SCREEN + $03F8 + SPR number) POKE 1024+1016+0,11  to use Sprite#0 DATA from ($02C0-$02FE)."
"[INST]In the context of the C64, What is the description of the memory location $028B?[/INST]KOUNT     address $028B        is: Repeat Key: Speed Counter ($04)."
"[INST]In the context of the C64, What is the purpose of the memory region from address $013F to $01FF ?[/INST]BSTACK    address $013F-01FF   is: BASIC Stack Area."
"[INST]In the context of the C64, What is the function of the memory address range $0200-0258 in a Commodore 64 computer?[/INST]BUF       address $0200-0258   is: BASIC Input Buffer (Input Line from Screen)."
"[INST]In the context of the C64, What is the description of the memory location $028C?[/INST]DELAY     address $028C        is: Repeat Key: First repeat delay Counter ($10)."
"[INST]In the context of the C64, What is the description of the memory region from address $02A7 to $02FF?[/INST]TEMP      address $02A7-02FF   is: Unused."
"[INST]In the context of the C64, What is the description of the memory location $00B8?[/INST]LA        address $00B8        is: Current File - Logical File number."
"[INST]In the context of the C64, What is the description of the memory location $0308-0309 in the Commodore 64?[/INST]IGONE     address $0308-0309   is: Vector: Indirect entry to BASIC Character dispatch Routine ($A7E4)."
"[INST]In the context of the C64, What is the description of the USRPOK at address $0310?[/INST]USRPOK    address $0310        is: USR Function JMP Instruction ($4C)."
"[INST]In the context of the C64, What is stored at memory address $00C9-00CA?[/INST]LXSP      address $00C9-00CA   is: Cursor X/Y (Line/Column) position at start of  Input."
"[INST]In the context of the C64, What is the description of memory address $D017 in the C64 memory map?[/INST]address $D017	is:		Sprites 0-7 Expand 2x Vertical (Y)"
"[INST]In the context of the C64, What is the description of the address $0001 bit 5 in the C64?[/INST]address $0001 bit 5	is: Cassette Motor Control O = ON, 1 = OFF"
"[INST]In the context of the C64, What is stored at memory address $3278?[/INST]address $3278		is:			Sprite to Sprite Collision Detect"
"[INST]In the context of the C64, What is the function of bit 1 at address $DC0E ?[/INST]address $DC0E bit 1 is:	Timer A Output on PB6: 1 = Yes, 0 = No"
"[INST]In the context of the C64, What is the function of address $DD00 bits 1-0 ?[/INST]address $DD00 bit 1-0 is:	VIC Chip System Memory Bank Select (Default = 11)"
"[INST]In the context of the C64, What is the description of memory address $3292?[/INST]address $3292		is:			Sprite 5 Color"
"[INST]In the context of the C64, What does bit 2 of address $4276 control ?[/INST]address $4276	bit 2 is 	Ring Modulate Osc. 1 with Osc. 3 Output, 1 = On"
"[INST]In the context of the C64, What is the description of the memory location $DC0C ?[/INST]address $DC0C	is: Synchronous Serial I/O Data Buffer"
"[INST]In the context of the C64, What is the function of address $4283 ?[/INST]address $4283	bits		7	Select Random Noise Waveform, 1 = On"
"[INST]In the context of the C64, What is the description of memory address $D419 in the Commodore 64?[/INST]address $D419	is:	Analog/Digital Converter: Game Paddle 1 (0-255)"
"[INST]In the context of the C64, What is the description of the address $DC01?[/INST]address $DC01 bits 7-0	Read Keyboard Row Values for Keyboard Scan"
"[INST]In the context of the C64, What is at address $DD0F bits 6-5?[/INST]address $DD0F bits 6-5	is: Timer B Mode Select:
00 = Count System 02 Clock Pulses
01 = Count Positive CNT Transitions
10 = Count Timer A Underflow Pulses
11 = Count Timer A Underflows While CNT Positive"
"[INST]In the context of the C64, What is the function of the bit 1 of the I/O address $DD0D?[/INST]address $DD0D bit 1 is:	Timer B Interrupt"
"[INST]In the context of the C64, What does bit 7 of address $DD0F represent ?[/INST]address $DD0F bit 7 is:	Set Alarm/TOD-Clock: 1 = Alarm, 0 = Clock"
"[INST]In the context of the C64, What is the function of bit 4 at address $DD0D?[/INST]address $DD0D bit 4 is:	FLAG1 NMI (User/RS-232 Received Data Input)"
"[INST]In the context of the C64, What is the function of the memory location $DD03 ?[/INST]address $DD03 is:	Data Direction Register - Port B"
"[INST]In the context of the C64, What is the description of memory location $D41B?[/INST]address $D41B	is:	Oscillator 3 Random Number Generator"
"[INST]In the context of the C64, What is the description of the bit 6 of the $DC01 register ?[/INST]address $DC01 bit 6	Timer A: Toggle/Pulse Output"
"[INST]In the context of the C64, What is the function of bit 4 at address $4276?[/INST]address $4276	bit 4 is 	Select Triangle Waveform, 1 = On"
"[INST]In the context of the C64, What is the description of the address $4282 bits 7-4?[/INST]address $4282	bits	7-4	is: Unused"
"[INST]In the context of the C64, What does bit 3 of address $DC0E represent ?[/INST]address $DC0E bit 3 is:	Timer A Run Mode: 1 = One-Shot,0 = Continuous"
"[INST]In the context of the C64, What is the function of the bit 3 of the I/O address $DD00 in a Commodore 64?[/INST]address $DD00 bit 3 is: 	Serial Bus ATN Signal Output"
"[INST]In the context of the C64, What is the function of bits 3-1 at address $D018 ?[/INST]address $D018 bits 3-1 is: Character Dot-Data Base	Address (inside VIC)"
"[INST]In the context of the C64, What is the description of the memory address $3280 in the Commodore 64?[/INST]address $3280		is:			Border Color"
"[INST]In the context of the C64, What is the description of the address $0001 bit 3 in a Commodore 64 computer?[/INST]address $0001 bit 3	is: Cassette Data Output Line"
"[INST]In the context of the C64, What is the purpose of the memory location $030C in a Commodore 64 computer?[/INST]SAREG     address $030C        is: Storage for 6510 Accumulator during SYS."
"[INST]In the context of the C64, What is the description of the memory location at address $00B6?[/INST]RODATA    address $00B6        is: RS232 Output Byte Buffer/Tape Read Error Flag."
"[INST]In the context of the C64, What is the function and possible values of the flag located at address $00C7?[/INST]RVS       address $00C7        is: Flag: Reverse On/Off; On = $01, Off = $00."
"[INST]In the context of the C64, What is the description of the memory location at address $0313?[/INST]TEMP      address $0313        is: Unused."
"[INST]In the context of the C64, What is the function of the memory location at address $00D7 ?[/INST]SCHAR     address $00D7        is: Screen value of current Input Character/Last Character Output."
"[INST]In the context of the C64, What is the description of the FAT address $0263-026C in the Kernal Table?[/INST]FAT       address $0263-026C   is: Kernal Table: Active File First Addresses  (Device numbers)."
"[INST]In the context of the C64, What is the purpose of the register located at address $028E ?[/INST]LSTSHF    address $028E        is: Last Shift Key used for debouncing."
"[INST]In the context of the C64, What is the description of the SHFLAG at memory address $028D?[/INST]SHFLAG    address $028D        is: Flag: Shift Keys: Bit 1 = Shift, Bit 2 = CBM, Bit 3 = CTRL; ($00 = None, $01 = Shift, etc.)."
"[INST]In the context of the C64, What is the description of the memory address range $0259-0262 in the Commodore 64 Kernal?[/INST]LAT       address $0259-0262   is: Kernal Table: Active logical File numbers."
"[INST]In the context of the C64, What is the purpose of the memory location at address $00D8?[/INST]INSRT     address $00D8        is: Count of number of inserts outstanding."
"[INST]In the context of the C64, What is the purpose of the INDX address $00C8 ?[/INST]INDX      address $00C8        is: Pointer: End of Line for Input (Used to suppress trailing spaces)."
"[INST]In the context of the C64, What is the description of the CINV address $0314-0315?[/INST]CINV      address $0314-0315   is: Vector: Hardware IRQ Interrupt Address ($EA31)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $030D in a Commodore 64 computer?[/INST]SXREG     address $030D        is: Storage for 6510 X-Register during SYS."
"[INST]In the context of the C64, What does the FNLEN at address $00B7?[/INST]FNLEN     address $00B7        is: Number of Characters in Filename."
"[INST]In the context of the C64, What is the description of memory address $3279?[/INST]address $3279		is:			Sprite to Background Collision Detect"
"[INST]In the context of the C64, What is the description of the memory address $0001 bit 2?[/INST]address $0001 bit 2	is: /CHAREN Signal (0=Swith Char. ROM In)"
"[INST]In the context of the C64, What is the function of bits 7-4 at address $D018?[/INST]address $D018 bits 7-4 is: Video Matrix Base Address (inside VIC)"
"[INST]In the context of the C64, What is the function of the bit 4 at address $DD00?[/INST]address $DD00 bit 4 is: 	Serial Bus Clock Pulse Output"
"[INST]In the context of the C64, What does bit 4 of address $DC0E represent ?[/INST]address $DC0E bit 4 is:	Force Load Timer A: 1 = Yes"
"[INST]In the context of the C64, What is the description of the register located at address $4283 ?[/INST]address $4283	bits 3-0 is: Voice 2: Pulse Waveform Width - High-Nybble


address $4283			Voice 2: Control Register"
"[INST]In the context of the C64, What is the function of bit 3 at address $4276?[/INST]address $4276	bit 3 is 	Test Bit: 1 = Disable Oscillator 1"
"[INST]In the context of the C64, What is the description of the address $DC01 ?[/INST]address $DC01 bit 4	Joystick 1 Fire Button: 1 = Fire 3-2	Paddle Fire Buttons 3-0	Joystick 1 Direction"
"[INST]In the context of the C64, What is the description of memory location $D41C?[/INST]address $D41C	is:	Envelope Generator 3 Output"
"[INST]In the context of the C64, What is the description of memory address $DD04 in the Commodore 64?[/INST]address $DD04 is:	Timer A: Low-Byte"
"[INST]In the context of the C64, What is the function of bit 3 of the I/O address $DD0D?[/INST]address $DD0D bit 3 is:	Serial Port Interrupt"
"[INST]In the context of the C64, What is the function of bits 4-0 of address $DD0F?[/INST]address $DD0F bits 4-0 is:	Same as CIA Control Reg. A - for Timer B"
"[INST]In the context of the C64, What is the function of bit 7 in the address $DD0D?[/INST]address $DD0D bit 7 is:	NMI Flag (1 = NMI Occurred) / Set-Clear Flag"
"[INST]In the context of the C64, What is the function of bit 1 at address $DD0E ?[/INST]address $DD0E bit 1 is:	Timer A Output on PB6: 1 = Yes, 0 = No"
"[INST]In the context of the C64, What does bit 7 of address $DD0E represent?[/INST]address $DD0E bit 7 is:	Time-of-Day Clock Frequency: 1 = 50 Hz, 0 = 60 Hz"
"[INST]In the context of the C64, What is the function of memory address $4277 ?[/INST]Address $4277		is:	Envelope Generator 1: Attack / Decay Cycle Control"
"[INST]In the context of the C64, What is the description of memory address $4279 ?[/INST]address $4279	is:		Voice 2: Frequency Control - Low-Byte"
"[INST]In the context of the C64, What is the function of memory address $DC00 in a Commodore 64 computer?[/INST]address $DC00 is:	Data Port A (Keyboard, Joystick, Paddles,Light-Pen)"
"[INST]In the context of the C64, What is the description of address $DC01 in a Commodore 64 system?[/INST]address $DC01 is:	Data Port B (Keyboard, Joystick, Paddles): Game Port 1"
"[INST]In the context of the C64, What is the function of bit 7 at memory address $D019?[/INST]address $D019 Bit 7	is: Set on Any Enabled VIC IRQ Condition"
"[INST]In the context of the C64, What is the description of the MOS 6510 Data Direction Register at address $0000?[/INST]address - BITS - DESCRIPTION
$0000	0		7-0	MOS 6510 Data Direction
Register (xx101111) Bit= 1: Output, Bit=0: Input, x=Don't Care"
"[INST]In the context of the C64, What is the function of the address $3275?[/INST]address $3275		is:			Sprite to Background Display Priority:	1 = Sprite"
"[INST]In the context of the C64, What is the function of bit 0 at address $DC0E ?[/INST]address $DC0E bit 0 is:	Start/Stop Timer A: 1 = Start, 0 = Stop"
"[INST]In the context of the C64, What is the function of the address $DD00 in the Commodore 64?[/INST]address $DD00 is: Data Port A (Serial Bus, RS-232, VIC Memory Control)"
"[INST]In the context of the C64, What is the purpose of the memory region from address $0100 to $01FF?[/INST]STACK     address $0100-01FF   is: 6510 Hardware Stack Area."
"[INST]In the context of the C64, What is the function of the address range $00BB-00BC?[/INST]FNADR     address $00BB-00BC   is: Pointer: Current File name Address."
"[INST]In the context of the C64, What is the description of the memory location $0306-0307 in the Commodore 64?[/INST]IQPLOP    address $0306-0307   is: Vector: Indirect entry to BASIC LIST  Routine ($A71A)."
"[INST]In the context of the C64, What is the description of the ICLOSE vector at address $031C-031D in the Kernal?[/INST]ICLOSE    address $031C-031D   is: Vector: Indirect entry to Kernal CLOSE Routine ($F291)."
"[INST]In the context of the C64, What is the description of the memory location $00C3-00C4?[/INST]MEMUSS    address $00C3-00C4   is: Pointer: Type 3 Tape LOAD and general use."
"[INST]In the context of the C64, What is the description of the memory location at address $0281-0282?[/INST]MEMSTR    address $0281-0282   is: Pointer: Bottom of Memory for Operating System ($0800)."
"[INST]In the context of the C64, What is the function of the XMAX address $0289?[/INST]XMAX      address $0289        is: Maximum number of Bytes in Keyboard Buffer ($0A)."
"[INST]In the context of the C64, What is the function and behavior of the RPTFLG at address $028A?[/INST]RPTFLG    address $028A        is: Flag: Repeat keys; $00 = Cursors, INST/DEL &  Space repeat, $40 no Keys repeat, $80 all  Keys repeat ($00)."
"[INST]In the context of the C64, What is the description of the memory location at address $0283-0284?[/INST]MEMSIZ    address $0283-0284   is: Pointer: Top of Memory for Operating   System ($A000)."
"[INST]In the context of the C64, What is the description of the memory location $031A-031B in the Commodore 64 Kernal?[/INST]IOPEN     address $031A-031B   is: Vector: Indirect entry to Kernal OPEN Routine ($F34A)."
"[INST]In the context of the C64, What is the function of the memory address $00C1-00C2 ?[/INST]STAL      address $00C1-00C2   is: Start Address for LOAD and Cassette Write."
"[INST]In the context of the C64, What is at address $00BA[/INST]FA        address $00BA        is: Current File - First Address (Device number). OPEN LA,FA,SA;  OPEN 1,8,15,'I0':CLOSE 1"
"[INST]In the context of the C64, What is the description of the memory location $0304-0305 in the Commodore 64?[/INST]ICRNCH    address $0304-0305   is: Vector: Indirect entry to BASIC Tokenise Routine ($A57C)."
"[INST]In the context of the C64, What is the purpose of the memory location $0100-013E?[/INST]BAD       address $0100-013E   is: Tape Input Error log."
"[INST]In the context of the C64, What is the function of the bit 7 of the I/O register at address $DD00 in the Commodore 64?[/INST]address $DD00 bit 7is	Serial Bus Data Input"
"[INST]In the context of the C64, What is the description of the memory address $DC0F in the Commodore 64?[/INST]address $DC0F	is:		CIA Control Register B"
"[INST]In the context of the C64, What is the description of the memory location $0001 in the Commodore 64?[/INST]address $0001 bit	1			MOS 6510 Micro-Processor On-Chip I/O Port"
"[INST]In the context of the C64, What is the description of memory address $3276 in the Commodore 64?[/INST]address $3276		is:			Sprites 0-7 Multi-Color Mode Select:1 = M.C.M."
"[INST]In the context of the C64, What is the description of the flag located at address $D019 Bit 3?[/INST]address $D019 Bit 3	is: Light-Pen Triggered IRQ Flag"
"[INST]In the context of the C64, What is the function of bits 3-0 at address $DC00?[/INST]address $DC00 bits 3-0	is: Joystick A Direction (0-15)"
"[INST]In the context of the C64, What is the function of the addresses DC00-DCFF in a Commodore 64 computer?[/INST]addesszq DC00-DCFF	are 	MOS 6526 Complex Interface Adapter (CIA) #1"
"[INST]In the context of the C64, What is the description of the address $4278 in the context of a microcontroller's configuration?[/INST]address $4278      bits        3-0  is:   Select Release Cycle Duration: 0-15"
"[INST]In the context of the C64, What is the function of bit 0 at address $4276?[/INST]address $4276	bit 0 is 	Gate Bit: 1 = Start Att/Dec/Sus, 0 = Start Release"
"[INST]In the context of the C64, What is the description of the memory location $DD0E in the Commodore 64?[/INST]address $DD0E	is:		CIA Control Register A"
"[INST]In the context of the C64, What is the function of bit 2 of the $DD0E address ?[/INST]address $DD0E bit 2 is:	Timer A Output Mode to PB6: 1 = Toggle,0 = Pulse"
"[INST]In the context of the C64, What is the function of the memory address $DD0D in the Commodore 64?[/INST]address $DD0D is:	CIA Interrupt Control Register (Read NMls/Write Mask)"
"[INST]In the context of the C64, What is the function of bit 6 of the address $DD0E ?[/INST]address $DD0E bit 6 is:	Serial Port I/O Mode Output, 0 = Input"
"[INST]In the context of the C64, What is the function of bit 0 at address $DD0E ?[/INST]address $DD0E bit 0 is:	Start/Stop Timer A: 1 = Start, 0 = Stop"
"[INST]In the context of the C64, What is the description of the memory address $4280 ?[/INST]address $4280	is:		Voice 2: Frequency Control - High-Byte"
"[INST]In the context of the C64, What is the function of bit 6 in the $DC0E address ?[/INST]address $DC0E bit 6 is:	Serial Port I/O Mode Output, 0 = Input"
"[INST]In the context of the C64, What is the function of bits 7-4 at address $4277?[/INST]Address $4277    bits          7-4  is:   Select Attack Cycle Duration: 0-15"
"[INST]In the context of the C64, What is the description of the memory address $DC00 bits 4 in a Commodore 64?[/INST]address $DC00 bits 4	is: Joystick A Fire Button: 1 = Fire"
"[INST]In the context of the C64, What is at addresses D500-D7FF[/INST]addresses D500-D7FF	are 	SID IMAGES"
"[INST]In the context of the C64, What is the description of the register located at address $D01A?[/INST]address $D01A	is:			IRQ Mask Register: 1 = Interrupt Enabled"
"[INST]In the context of the C64, What is the description of the memory address $0001 bit 1 in the Commodore 64?[/INST]is: /HIRAM Signal (0=Switch Kernal ROM Out)"
"[INST]In the context of the C64, What is the function of the bit at memory address $D019?[/INST]address $D019 Bit 1 is: VIC Interrupt Flag Register (Bit = 1: IRQ Occurred)"
"[INST]In the context of the C64, What is the function of the bit 5 at address $DD00 in the Commodore 64?[/INST]address $DD00 bit 5 is: 	Serial Bus Data Output"
"[INST]In the context of the C64, What does the Timer B Mode Select bits 6-5 in the $DC0F address control?[/INST]address $DC0F bits 6-5	is: Timer B Mode Select: 00 = Count System 02 Clock Pulses, 01 = Count Positive CNT Transitions, 10 = Count Timer A Underflow Pulses, 11 = Count Timer A Underflows While CNT Positive"
"[INST]In the context of the C64, What is the function of bit 5 at address $4276 ?[/INST]address $4276	bit 5 is 	Select Sawtooth Waveform, 1 = On"
"[INST]In the context of the C64, What is the function of the RIDBS register at address $029C ?[/INST]RIDBS     address $029C        is: RS232 Pointer: High Byte of Address of Input Buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $00C5 in a keyboard matrix?[/INST]LSTX      address $00C5        is: Matrix value of last Key pressed; No Key = $40."
"[INST]In the context of the C64, What is the description of the memory location at address $0316-0317?[/INST]CNBINV    address $0316-0317   is: Vector: BRK Instruction Interrupt Address  ($FE66)."
"[INST]In the context of the C64, What is the description of the IERROR vector at address $0300-0301 in a Commodore 64 computer?[/INST]IERROR    address $0300-0301   is: Vector: Indirect entry to BASIC Error Message, (X) points to Message ($E38B)."
"[INST]In the context of the C64, What is the function of the ROPRTY register at address $00BD?[/INST]ROPRTY    address $00BD        is: RS232 Output Parity/Tape Byte to be Input or Output."
"[INST]In the context of the C64, What is the description of the HIBASE address $0288 in the context of Commodore 64 memory layout?[/INST]HIBASE    address $0288        is: High Byte of Screen Memory Address ($04)."
"[INST]In the context of the C64, What is the function of the memory location $0277-0280 ?[/INST]KEYD      address $0277-0280   is: Keyboard Buffer Queue (FIFO)."
"[INST]In the context of the C64, What is the description of the memory address range $026D-0276 in the Commodore 64's Kernal?[/INST]SAT       address $026D-0276   is: Kernal Table: Active File Secondary Addresses."
"[INST]In the context of the C64, What is the function of the memory location at address $0287?[/INST]GDCOL     address $0287        is: Background Colour under Cursor."
"[INST]In the context of the C64, What is the description of the IMAIN address $0302-0303 in a Commodore 64 computer?[/INST]IMAIN     address $0302-0303   is: Vector: Indirect entry to BASIC Input Line and Decode ($A483)."
"[INST]In the context of the C64, What is the function of the FSBLK at address $00BE?[/INST]FSBLK     address $00BE        is: Tape Input/Output Block count."
"[INST]In the context of the C64, What is stored at memory address $00C6 in the C64?[/INST]NDX       address $00C6        is: Number of Characters in Keyboard Buffer queue."
"[INST]In the context of the C64, What is the description of the memory address range $0318-0319?[/INST]NMINV     address $0318-0319   is: Vector: Hardware NMI Interrupt Address ($FE47)."
"[INST]In the context of the C64, What is the function of the RODBS register at address $029D ?[/INST]RODBS     address $029D        is: RS232 Pointer: High Byte of Address of Output  Buffer."
"[INST]In the context of the C64, What does the bit 7 of address $DC0F represent?[/INST]address $DC0F bits 7	is: Set Alarm/TOD-Clock: 1 = Alarm, 0 = Clock"
"[INST]In the context of the C64, What is the function of bit 6 at address $4276?[/INST]address $4276	bit 6 is 	Select Pulse Waveform, 1 = On"
"[INST]In the context of the C64, What is the function of the bit 6 of the address $DD00?[/INST]address $DD00 bit 6 is: 	Serial Bus Clock Pulse Input"
"[INST]In the context of the C64, What is the function of bit 0 at memory address $D018?[/INST]address $D018 bits 0 is:	Select upper/lower Character Set"
"[INST]In the context of the C64, What is the function of Bit 0 at memory address $D019?[/INST]address $D019 Bit 0	is: Raster Compare IRQ Flag"
"[INST]In the context of the C64, What is the function of bit 0 at address $0001?[/INST]address $0001 bit 0	is: /LORAM Signal (0=Switch	BASIC ROM Out)"
"[INST]In the context of the C64, What type of memory is stored in the address range D800-DBFF?[/INST]addresses D800-DBFF	are	Color RAM (Nybbles)"
"[INST]In the context of the C64, What is the description of the address $DC00 bits 3-2 in aC64controller?[/INST]address $DC00 bits 3-2	is: Paddle Fire Buttons"
"[INST]In the context of the C64, What is the function of bit 5 at address $DC0E?[/INST]address $DC0E bit 5 is:	Timer A Counts: 1 = CNT Signals, 0 = System 02 Clock"
"[INST]In the context of the C64, What is the function of the bits 3-0 at address $4277?[/INST]Address $4277 bits	3-0	is: Select Decay Cycle Duration: 0-15"
"[INST]In the context of the C64, What is the description of the address $4281 ?[/INST]address $4281	is		Voice 2: Pulse Waveform Width - Low-Byte"
"[INST]In the context of the C64, What is the description of the memory location $DD0F in the Commodore 64?[/INST]address $DD0F	is: CIA Control Register B"
"[INST]In the context of the C64, What is the function of bit 5 at address $DD0E?[/INST]address $DD0E bit 5 is:	Timer A Counts: 1 = CNT Signals, 0 = System 02 Clock"
"[INST]In the context of the C64, What is the description of the register located at address $0001?[/INST]R6510  address  $0001       is:   6510 On-chip 8-bit Input/Output Register."
"[INST]In the context of the C64, What is the description of the SUBFLG directive with address $0010?[/INST]SUBFLG address  $0010       is:   Flag: Subscript reference/User Function call."
"[INST]In the context of the C64, What is the description of the memory address range $002F-0030 in a Commodore 64 computer?[/INST]ARYTAB address  $002F-0030  is:   Pointer: Start of BASIC Arrays."
"[INST]In the context of the C64, What is the purpose of the OPMASK at address $004D?[/INST]OPMASK address  $004D       is:   Mask used during FRMEVL."
"[INST]In the context of the C64, What is the description of the address range $006A-006D?[/INST]ARGHO  address  $006A-006D  is:   AFAC Mantissa."
"[INST]In the context of the C64, What does bit 6 of address $D418 control in a device?[/INST]address $D418 bit 6	is: Select Filter High-Pass Mode: 1 = On"
"[INST]In the context of the C64, What is the function of memory address $D413 ?[/INST]address $D413 is:	Envelope Generator 3: Attac/Decay Cycle Control"
"[INST]In the context of the C64, What is the recommended setting for bit 5 of address D016?[/INST]address D016 bit 5 is	ALWAYS SET THIS BIT TO 0 !"
"[INST]In the context of the C64, What is the description of the memory address $D00E in the C64 memory map?[/INST]address $D00E is Sprite 7 X Pos"
"[INST]In the context of the C64, What is the function of the memory address $00AC-00AD?[/INST]SAL       address $00AC-00AD   is: Pointer: Tape Buffer/Screen scrolling."
"[INST]In the context of the C64, What is the description of the sprite located at address $0380-03BE?[/INST]SPR14     address $0380-03BE   is: Sprite #14."
"[INST]In the context of the C64, What is the description of the User Defined Vector located at address $032E-032F?[/INST]USRCMD    address $032E-032F   is: User Defined Vector ($FE66)."
"[INST]In the context of the C64, What does the MSGFLG at address $009D control in a program?[/INST]MSGFLG    address $009D        is: Flag: $00 = Program mode: Suppress Error  Messages, $40 = Kernal Error Messages only, $80 = Direct mode: Full Error Messages."
"[INST]In the context of the C64, What is the description of the memory location $0092?[/INST]SVXT      address $0092        is: Timing Constant for Tape."
"[INST]In the context of the C64, What is the memory address of the kernel routine for the TALK command in Commodore 64 BASIC?[/INST]kernal routine address for talk	= $ffb4"
"[INST]In the context of the C64, What is the kernel routine address for the SETLFS command in Commodore 64 BASIC?[/INST]kernal routine address for setlfs	= $ffba"
"[INST]In the context of the C64, What is the kernel routine address for the second interrupt vector in the 6502 microprocessor?[/INST]kernal routine address for second	= $ff93"
"[INST]In the context of the C64, What is the address of the kernel routine for stopping the computer in the Commodore 64?[/INST]kernal routine address for stop	= $ffe1"
"[INST]In the context of the C64, What is the format and description of the VERCKK command?[/INST]VERCKK    address $0093        is: Flag: 0 = Load, 1 = Verify."
"[INST]In the context of the C64, What is the description of the ILOAD instruction at address $0330-0331 in the Commodore 64 Kernal?[/INST]ILOAD     address $0330-0331   is: Vector: Indirect entry to Kernal LOAD    Routine ($F4A5)."
"[INST]In the context of the C64, What is the purpose of the FNMIDX address $009E?[/INST]FNMIDX    address $009E        is: Index to Cassette File name/Header ID for Tape write."
"[INST]In the context of the C64, What is the function of the address $00AE-00AF?[/INST]EAL       address $00AE-00AF   is: Tape End Address/End of Program."
"[INST]In the context of the C64, What is the description of the memory range $03C0-03FE?[/INST]SPR15     address $03C0-03FE   is: Sprite #15."
"[INST]In the context of the C64, What is the description of the address $D00D in the memory map of C64?[/INST]address $D00D is Sprite 6 Y Pos"
"[INST]In the context of the C64, What is the purpose of bits 7-6 in address D016?[/INST]address D016 bit 7-6 is	Unused"
"[INST]In the context of the C64, What does the $D413 bits 7-4 register control ?[/INST]address $D413 bits 7-4 is:	Select Attack Cycle Duration: 0-15"
"[INST]In the context of the C64, What is the function of bit 5 at address $D418?[/INST]address $D418 bit 5	is: Select Filter Band-Pass Mode: 1 = On"
"[INST]In the context of the C64, What is the explanation for the address $0069?[/INST]ARGEXP address  $0069       is:   AFAC Exponent."
"[INST]In the context of the C64, What is the purpose of the memory address $004B-004C ?[/INST]VARTXT address  $004B-004C  is:   Temporary storage for TXTPTR during READ, INPUT and GET."
"[INST]In the context of the C64, What is the description of the memory address range $0031-0032 in a Commodore 64 computer?[/INST]STREND address  $0031-0032  is:   Pointer: End of BASIC Arrays + 1."
"[INST]In the context of the C64, What does the INPFLG address $0011 represent ?[/INST]INPFLG address  $0011       is:   Input Flag: $00 = INPUT, $40 = GET, $98 = READ."
"[INST]In the context of the C64, What is the description of the memory location $0002?[/INST]TEMP   address  $0002       is:   Unused. Free for user programs."
"[INST]In the context of the C64, What is the purpose of the CHANNL address $0013 ?[/INST]CHANNL address  $0013       is:   File number of current Input Device."
"[INST]In the context of the C64, What is the function of the ADRAY2 address $0005-0006 in the CPU?[/INST]ADRAY2 address  $0005-0006  is:   Jump Vector: Convert Integer in (A/Y) to Floating point in (FAC); ($B391)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $0068?[/INST]BITS   address  $0068       is:   Bit Overflow Area during normalisation Routine."
"[INST]In the context of the C64, What does the VARPNT address $0047-0048 contain?[/INST]VARPNT address  $0047-0048  is:   Pointer: to value of (VARNAM) if Integer, to descriptor if String."
"[INST]In the context of the C64, What is the description of the address $D40D in a MIDI controller?[/INST]address $D40D	bits			0 is	Gate Bit: 1 = Start Att/Dec/Sus, 0 = Start Release"
"[INST]In the context of the C64, What is the function of bit 7 at address $D418?[/INST]address $D418 bit 7	is: Cut-Off Voice 3 Output: 1 = Off, 0 = On"
"[INST]In the context of the C64, What is the description of memory address $D40E ?[/INST]address $D40E	is 			Voice 3: Frequency Control - Low-Byte"
"[INST]In the context of the C64, What is the description of the memory address $D00B in the C64 memory map?[/INST]address $D00B is Sprite 5 Y Pos"
"[INST]In the context of the C64, What is the description of address D014?[/INST]address D014 is:	Light-Pen Latch Y Pos"
"[INST]In the context of the C64, What is the description of the PTR2 address $009F?[/INST]PTR2      address $009F        is: Tape Error log pass 2."
"[INST]In the context of the C64, What is the description of the memory location $032C-032D?[/INST]ICLALL    address $032C-032D   is: Vector: Indirect entry to Kernal CLALL     Routine ($F32F)."
"[INST]In the context of the C64, What is the description of the memory block located at addresses $0340-037E?[/INST]SPR13     address $0340-037E   is: Sprite #13."
"[INST]In the context of the C64, What is the description of the memory location $00B2-00B3?[/INST]TAPE1     address $00B2-00B3   is: Pointer: Start Address of Tape Buffer ($033C)."
"[INST]In the context of the C64, What is the address of the kernel routine for the readst function in a Commodore 64?[/INST]kernal routine address for readst	= $ffb7"
"[INST]In the context of the C64, What is the kernel routine address for the setmsg function in a certain computer system?[/INST]kernal routine address for setmsg	= $ff90"
"[INST]In the context of the C64, What is the kernel routine address for TKS-A?[/INST]kernal routine address for tksa	= $ff96"
"[INST]In the context of the C64, What is the kernel routine address for UDTIM in the Commodore 64?[/INST]kernal routine address for udtim	= $ffea"
"[INST]In the context of the C64, What is the memory address of the kernel routine for setting the filename in Commodore 64?[/INST]kernal routine address for setnam	= $ffbd"
"[INST]In the context of the C64, What is the kernel routine address for RDTIM?[/INST]kernal routine address for rdtim	= $ffde"
"[INST]In the context of the C64, What is the function of the memory region located at address $033C-03FB?[/INST]TBUFFR    address $033C-03FB   is: Tape I/O Buffer."
"[INST]In the context of the C64, What is the function of the memory address $00B0-00B1?[/INST]CMPO      address $00B0-00B1   is: Tape timing Constants."
"[INST]In the context of the C64, What is the description of the PTR1 address $009E?[/INST]PTR1      address $009E        is: Tape Error log pass 1."
"[INST]In the context of the C64, What is the description of the IGETIN vector in the Commodore 64 Kernal?[/INST]IGETIN    address $032A-032B   is: Vector: Indirect entry to Kernal GETIN     Routine ($F13E)."
"[INST]In the context of the C64, What does address D015 control on a C64?[/INST]address D015 is:	Sprite display Enable: 1 = Enable"
"[INST]In the context of the C64, What is the description of the memory address $D00C in the C64 memory map?[/INST]address $D00C is Sprite 6 X Pos"
"[INST]In the context of the C64, What does the address $D40D bits 3-0 control in a device?[/INST]address $D40D	bits 3-0 is:	Select Release Cycle Duration: O-15"
"[INST]In the context of the C64, What is the instruction associated with memory address $D418?[/INST]address $D418	Select Filter Mode and Volume"
"[INST]In the context of the C64, What is the function of bit $D40D in the device's configuration?[/INST]address $D40D	bits			1 is	Synchronize Osc. 3 with Osc. 2 Frequency, 1 = On"
"[INST]In the context of the C64, What is the purpose of the address $0049-004A?[/INST]FORPNT address  $0049-004A  is:   Pointer: Index Variable for FOR/NEXT loop."
"[INST]In the context of the C64, What is the description of the memory address range $0069-006E ?[/INST]AFAC   address  $0069-006E  is:   Auxiliary Floating point Accumulator."
"[INST]In the context of the C64, What is the description of the memory address $0003-0004?[/INST]ADRAY1 address  $0003-0004  is:   Jump Vector: Convert FAC to Integer in (A/Y) ($B1AA)."
"[INST]In the context of the C64, What is the description of the TANSGN address $0012?[/INST]TANSGN address  $0012       is:   Flag: TAN sign/Comparative result."
"[INST]In the context of the C64, What does the INTFLG at address $000E represent in a data type?[/INST]INTFLG address  $000E       is:   Data type Flag: $00 = Floating point, $80 = Integer."
"[INST]In the context of the C64, What is the purpose of the memory address $0007-0008 ?[/INST]INTEGR address  $0007-0008  is:   Temporary Integer during OR/AND."
"[INST]In the context of the C64, What is the description of the FACHO address $0062-0065?[/INST]FACHO  address  $0062-0065  is:   FAC Mantissa."
"[INST]In the context of the C64, What does the FOUR6 address $0053 represents?[/INST]FOUR6  address  $0053       is:   Length of String Variable during Garbege collection."
"[INST]In the context of the C64, What is the description of the address $D40D?[/INST]address $D40D	bits			3 is	Test Bit: 1 = Disable Oscillator 1"
"[INST]In the context of the C64, What does the $D413 address bits 3-0 control ?[/INST]address $D413 bits 3-0 is:	Select Decay Cycle Duration: 0-15"
"[INST]In the context of the C64, What is the function of bits 7-4 at address $D417 ?[/INST]address $D417	bits 7-4 is	Select Filter Resonance: 0-15"
"[INST]In the context of the C64, What is the function of memory address $D010 in the context of Commodore 64 graphics?[/INST]address $D010 is Sprites 0-7 X Pos (msb of X coord.)"
"[INST]In the context of the C64, What is the function of the D011 register bits 2-0?[/INST]Address	D011	BIT 2-0	is Smooth Scroll to Y Dot-Position (0-7)"
"[INST]In the context of the C64, What is the description of the memory address $D00A in the C64 memory map?[/INST]address $D00A is Sprite 5 X Pos"
"[INST]In the context of the C64, What is the memory address of the kernel routine for the GETIN function in the Commodore 64?[/INST]kernal routine address for getin	= $ffe4"
"[INST]In the context of the C64, What is the description of the ICLCHR address $0322-0323 in the Kernal routine?[/INST]ICLRCH    address $0322-0323   is: Vector: Indirect entry to Kernal CLRCHN     Routine ($F333)."
"[INST]In the context of the C64, What is the function of the TBTCNT at address $00A4?[/INST]TBTCNT    address $00A4        is: Pulse Counter Tape Read or Write/Serial Bus shift Counter."
"[INST]In the context of the C64, What is the description of the memory location at address $00AA?[/INST]RIDATA    address $00AA        is: RS232 Input Byte Buffer/Tape temporary."
"[INST]In the context of the C64, What is the description of the memory address range $03FC-03FF?[/INST]TEMP      address $03FC-03FF   is: Unused."
"[INST]In the context of the C64, What is the address of the kernel routine for the screen in a Commodore 64?[/INST]kernal routine address for screen	= $ffed"
"[INST]In the context of the C64, What is the address of the kernel routine for the vector table in a typical 6502-based system?[/INST]kernal routine address for vector	= $ff8d"
"[INST]In the context of the C64, What is the kernel routine address for SCNKEY?[/INST]kernal routine address for scnkey	= $ff9f"
"[INST]In the context of the C64, What is the function of the RIPRTY register at address $00AB?[/INST]RIPRTY    address $00AB        is: RS232 Input parity/Tape temporary."
"[INST]In the context of the C64, What is the description of the memory range $0400-07E7 ?[/INST]VICSCN    address $0400-07E7   is: Default Screen Video Matrix."
"[INST]In the context of the C64, What is the description of the memory location $0324-0325 in the Commodore 64 Kernal?[/INST]IBASIN    address $0324-0325   is: Vector: Indirect entry to Kernal CHRIN     Routine ($F157)."
"[INST]In the context of the C64, What is the function of the CNTDN at address $00A5?[/INST]CNTDN     address $00A5        is: Tape Synchronising count down."
"[INST]In the context of the C64, What is the address of the kernel routine for I/O base in hexadecimal notation?[/INST]kernal routine address for iobase	= $fff3"
"[INST]In the context of the C64, What is the description of memory address $D009 in the C64 memory map?[/INST]address $D009 is Sprite 4 Y Pos"
"[INST]In the context of the C64, What is the function of BIT 3 at Address D011?[/INST]Address	D011	BIT 3 is Select 24/25 Row Text Display: 1 = 25 Rows"
"[INST]In the context of the C64, What is the description of the memory address $D00F in the C64 memory map?[/INST]address $D00F is Sprite 7 Y Pos"
"[INST]In the context of the C64, What does the bit 3 of address $D417 represent in the device configuration?[/INST]address $D417	bits 3 is: 	Filter External Input: 1 = Yes, 0 = No"
"[INST]In the context of the C64, What is the function of memory address $D414 ?[/INST]address $D414 is			Envelope Generator 3: Sustain / Release Cycle Control"
"[INST]In the context of the C64, What does the address $D40D control ?[/INST]address $D40D	bits			2 is	Ring Modulate Osc. 3 with Osc. 2 Output, 1 = On"
"[INST]In the context of the C64, What is the purpose of the memory address $004E-0052?[/INST]TEMPF3 address  $004E-0052  is:   Temporary storage for FLPT value."
"[INST]In the context of the C64, What is the description of the FACEXP address $0061?[/INST]FACEXP address  $0061       is:   FAC Exponent."
"[INST]In the context of the C64, What is the purpose of the TRMPOS address $0009?[/INST]TRMPOS address  $0009       is:   Screen Column for last TAB."
"[INST]In the context of the C64, What is the description of the memory address $000F?[/INST]GARBFL address  $000F       is:   Flag: DATA scan/List Quote/Garbage collection."
"[INST]In the context of the C64, What is the address of VARNAM?[/INST]VARNAM address  $0045-0046  is:   Name of Variable being sought in Variable Table."
"[INST]In the context of the C64, What is the description of the ENDCHR address $0008?[/INST]ENDCHR address  $0008       is:   Flag: Scan for Quote at end of String."
"[INST]In the context of the C64, What is the format of the Valtyp address $000D?[/INST]VALTYP address  $000D       is:   Data type Flag: $00 = Numeric, $FF = String."
"[INST]In the context of the C64, What is the purpose of the JMPER address $0054-0056?[/INST]JMPER  address  $0054-0056  is:   Jump Vector used in Function Evaluation -  JMP followed by Address ($4C,$LB,$MB)."
"[INST]In the context of the C64, What is the description of the address $0066 in the FACSGN?[/INST]FACSGN address  $0066       is:   FAC Sign."
"[INST]In the context of the C64, What is the description of the register at address $D417?[/INST]address $D417	bits 0	is Filter Voice 1 Output: 1 = Yes, 0 = No"
"[INST]In the context of the C64, What are the functions of memory addresses $D414 and $D415 ?[/INST]address $D414  bits 3-0	is: Select Release Cycle Duration: 0-15


address $D415 is Filter Cutoff Frequency: Low-Nybble (Bits 2-0)"
"[INST]In the context of the C64, What is the description of address D012 on C64?[/INST]address D012 is:	Read Raster / Write Raster Value for Compare IRQ"
"[INST]In the context of the C64, What is the function of bit 7 in address D011?[/INST]Address	D011	BIT 7 is Raster Compare: (Bit 8)	See 53266"
"[INST]In the context of the C64, What is the description of the DPSW at address $009C?[/INST]DPSW      address $009C        is: Flag: Byte received from Tape."
"[INST]In the context of the C64, What is the purpose of the memory address range $07F8-07FF?[/INST]SPNTRS    address $07F8-07FF   is: Default Sprite Data Pointers."
"[INST]In the context of the C64, What is the description of the RINONE address $00A9?[/INST]RINONE    address $00A9        is: RS232 Flag: Start Bit check/Tape temporary."
"[INST]In the context of the C64, What is the function of the TSFCNT at address $00A3?[/INST]TSFCNT    address $00A3        is: Bit Counter Tape Read or Write/Serial Bus EOI (End Of Input) Flag."
"[INST]In the context of the C64, What is the description of the ISTOP vector in the Commodore 64 Kernal?[/INST]ISTOP     address $0328-0329   is: Vector: Indirect entry to Kernal STOP     Routine ($F6ED)."
"[INST]In the context of the C64, What is the address of the kernel routine for unloading the system nucleus in Commodore 64?[/INST]kernal routine address for unlsn	= $ffae"
"[INST]In the context of the C64, What is the address of the kernel routine that restores the system?[/INST]kernal routine address for restor	= $ff8a"
"[INST]In the context of the C64, What is the address of the kernel routine for saving in a Commodore 64?[/INST]kernal routine address for save	= $ffd8"
"[INST]In the context of the C64, What is the address of the kernel routine for untalking in Commodore 64?[/INST]kernal routine address for untlk	= $ffab"
"[INST]In the context of the C64, What is the description of the memory address $00A0-00A2?[/INST]TIME      address $00A0-00A2   is: Real-time jiffy Clock (Updated by IRQ Interrupt approx. every 1/60 of Second);  Update Routine: UDTIMK ($F69B)."
"[INST]In the context of the C64, What is the description of the memory location $0326-0327 in the Commodore 64's Kernal ROM?[/INST]IBSOUT    address $0326-0327   is: Vector: Indirect entry to Kernal CHROUT     Routine ($F1CA)."
"[INST]In the context of the C64, What is the description of the memory range $07E8-07F7?[/INST]TEMP      address $07E8-07F7   is: Unused."
"[INST]In the context of the C64, What is the description of the BITC1 register located at address $00A8?[/INST]BITC1     address $00A8        is: RS232 Input Bit count/Tape temporary."
"[INST]In the context of the C64, What is the function of the PRTY address $009B?[/INST]PRTY      address $009B        is: Parity of Byte Output to Tape."
"[INST]In the context of the C64, What does BIT 6 of address D011 control in a Commodore 64 computer?[/INST]Address	D011	BIT 6 is Extended Color Text Mode 1 = Enable"
"[INST]In the context of the C64, What is the description of address D013?[/INST]address D013 is:	Light-Pen Latch X Pos"
"[INST]In the context of the C64, What does the address $D414 bits 7-4 control in a device?[/INST]address $D414 bits 7-4	is: Select Sustain Cycle Duration: 0-15"
"[INST]In the context of the C64, What is the description of the register at address $D417?[/INST]address $D417	bits 2 is:	Filter Voice 3 Output: 1 = Yes, 0 = No Filter Voice 2 Output: 1 = Yes, 0 = No"
"[INST]In the context of the C64, What is the description of memory address $0067?[/INST]SGNFLG address  $0067       is:   Pointer: Series Evaluation Constant."
"[INST]In the context of the C64, What is the purpose of the memory address $0057-005B?[/INST]TEMPF1 address  $0057-005B  is:   Temporary storage for FLPT value."
"[INST]In the context of the C64, What is the description of the DIMFLG at address $000C?[/INST]DIMFLG address  $000C       is:   Flag: Default Array dimension."
"[INST]In the context of the C64, What is role of the CHARAC routine?[/INST]CHARAC address  $0007       is:   Search Character/Temporary Integer during INT."
"[INST]In the context of the C64, What is the purpose of the INPPTR address $0043-0044?[/INST]INPPTR address  $0043-0044  is:   Pointer: Temporary storage of Pointer during  INPUT Routine."
"[INST]In the context of the C64, What is the purpose of the memory address range $0019-0021 ?[/INST]TEMPST address  $0019-0021  is:   Stack for temporary Strings."
"[INST]In the context of the C64, What is the description of the memory location $003D-$003E in a Commodore 64 computer?[/INST]OLDTXT address  $003D-003E  is:   Pointer: BASIC Statement for CONT."
"[INST]In the context of the C64, What is the function of the address $000B ?[/INST]COUNT  address  $000B       is:   Input Buffer Pointer/Number of Subscripts."
"[INST]In the context of the C64, What is the function of the address $D40D ?[/INST]address $D40D	bits			4 is	Select Triangle Waveform, 1 = On"
"[INST]In the context of the C64, What is the function of memory location $D40C?[/INST]address $D40C	is		Envelope Generator 2: Attack / Decay Cycle Control"
"[INST]In the context of the C64, What is the description of the memory address $D007 in the C64 memory map?[/INST]address $D007 is Sprite 3 Y Pos"
"[INST]In the context of the C64, What is stored at memory address $0098 ?[/INST]LDTND     address $0098        is: Number of Open Files/Index to File Table."
"[INST]In the context of the C64, What is the address of the kernel routine for the memory bot in the Commodore 64?[/INST]kernal routine address for membot	= $ff9c"
"[INST]In the context of the C64, What is the kernel routine address for the CLRCHN function in the Commodore 64?[/INST]kernal routine address for clrchn	= $ffcc"
"[INST]In the context of the C64, What is the purpose of the FBUFPT address $0071-0072?[/INST]FBUFPT address  $0071-0072  is:   Pointer: Used during CRUNCH/ASCII conversion."
"[INST]In the context of the C64, What is the description of the INBIT register at address $00A7?[/INST]INBIT     address $00A7        is: RS232 temporary for received Bit/Tape temporary."
"[INST]In the context of the C64, What is the purpose of the memory location at address $00A6 in a Commodore 64 computer?[/INST]BUFPNT    address $00A6        is: Pointer: Tape I/O buffer."
"[INST]In the context of the C64, What is the kernel routine address for the close function in the Commodore 64?[/INST]kernal routine address for close	= $ffc3"
"[INST]In the context of the C64, What is the description of the FACOV address $0070 ?[/INST]FACOV  address  $0070       is:   FAC low-order rounding."
"[INST]In the context of the C64, What is the purpose of the memory location at address $0097?[/INST]TEMPY     address $0097        is: Temporary storage of Y Register during RS232 fetch."
"[INST]In the context of the C64, What is the memory address of the Commodore 64's kernal routine for loading?[/INST]kernal routine address for load	= $ffd5"
"[INST]In the context of the C64, What is the description of the memory address $D008 in the Commodore 64?[/INST]address $D008 is Sprite 4 X Pos"
"[INST]In the context of the C64, What is the function of the bits1"" parameter at memory address $4283 ?""[/INST]address $4283	bits1 = On is:	Synchronize Osc. 2 with Osc. 1 Frequency,"
"[INST]In the context of the C64, What is the function of address $D40D ?[/INST]address $D40D	bits			5 is	Select Sawtooth Waveform, 1 = On"
"[INST]In the context of the C64, What is the format and description of the VERCK command ?[/INST]VERCK  address  $000A       is:   Flag: 0 = Load, 1 = Verify."
"[INST]In the context of the C64, What does the OLDLIN address $003B-003C?[/INST]OLDLIN address  $003B-003C  is:   Previous BASIC Line number."
"[INST]In the context of the C64, What is the description of the LASTPT address $0017-0018?[/INST]LASTPT address  $0017-0018  is:   Last temporary String Address."
"[INST]In the context of the C64, What is the description of the DATLIN address $003F-0040?[/INST]DATLIN address  $003F-0040  is:   Current DATA Line number."
"[INST]In the context of the C64, What is the description of the memory address range $0022-0025?[/INST]INDEX  address  $0022-0025  is:   Utility Pointer Area."
"[INST]In the context of the C64, What is the function of the address $0061-0066 ?[/INST]FAC    address  $0061-0066  is:   Main Floating point Accumulator."
"[INST]In the context of the C64, What is the description of the address $4283 bits3?[/INST]address $4283	bits3 is:	Test Bit: 1 = Disable Oscillator 1"
"[INST]In the context of the C64, What is the function of address $D40D ?[/INST]address $D40D	bits			7 is	Select Random Noise Waveform, 1 = On"
"[INST]In the context of the C64, What is the description of the address $D416 in a MIDI synthesizer?[/INST]address $D416	is:	Filter Cutoff Frequency: High-Byte"
"[INST]In the context of the C64, What does BIT 4 of address D011 control in a Commodore 64?[/INST]Address	D011	BIT 4 is Blank Screen to Border Color: 0 = Blank"
"[INST]In the context of the C64, What is the description of the memory address $D006 in the Commodore 64?[/INST]address $D006 is Sprite 3 X Pos"
"[INST]In the context of the C64, What is the function of the CHRGET routine?[/INST]CHRGET address  $0073-008A  is:   Subroutine: Get next Byte of BASIC Text."
"[INST]In the context of the C64, What is the kernel routine address for CINT in a Commodore 64?[/INST]kernal routine address for cint	= $ff81"
"[INST]In the context of the C64, What is the address of the kernel routine for ioinit in the Commodore 64?[/INST]kernal routine address for ioinit	= $ff84"
"[INST]In the context of the C64, What is the configuration of the default input device at address $0099?[/INST]DFLTN     address $0099        is: Default Input Device (0)."
"[INST]In the context of the C64, What is the kernel routine address for ACPTR in a Commodore 64?[/INST]kernal routine address for acptr	= $ffa5"
"[INST]In the context of the C64, What is the address of the kernel routine for the CHKin vector in a Commodore 64?[/INST]kernal routine address for chkin	= $ffc6"
"[INST]In the context of the C64, What is the address of the kernel routine for the 'listen' function in a Commodore 64?[/INST]kernal routine address for listen	= $ffb1"
"[INST]In the context of the C64, What is the description of the address $009A?[/INST]DFLTO     address $009A        is: Default Output Device (3)."
"[INST]In the context of the C64, What is the description of the CHRGOT instruction with address $0079?[/INST]CHRGOT    address $0079        is: Entry to Get same Byte again."
"[INST]In the context of the C64, What is the address of the kernel routine that handles the CLALL instruction?[/INST]kernal routine address for clall	= $ffe7"
"[INST]In the context of the C64, What is the description of the memory address $D005 in the C64 memory map?[/INST]address $D005 is Sprite 2 Y Pos"
"[INST]In the context of the C64, What does BIT 5 of address D011 control in bit map mode?[/INST]Address	D011	BIT 5 is Bit Map Mode. 1 = Enable"
"[INST]In the context of the C64, What is the description of the address $D417 ?[/INST]address $D417	is:	Filter Resonance Control / Voice Input Control"
"[INST]In the context of the C64, What is the function of address $D40D in a pulse waveform controller?[/INST]address $D40D	bits			6 is	Select Pulse Waveform, 1 = On"
"[INST]In the context of the C64, What is the function of address $4283 ?[/INST]address $4283	bits2 is:	Ring Modulate Osc. 2 with Osc. 1 Output,"
"[INST]In the context of the C64, What is the purpose of the memory location at address $005C-0060?[/INST]TEMPF2 address  $005C-0060  is:   Temporary storage for FLPT value."
"[INST]In the context of the C64, What is the description of the memory address range $0022-0023?[/INST]INDEX1 address  $0022-0023  is:   First Utility Pointer."
"[INST]In the context of the C64, What is the function of the DATPTR address $0041-0042?[/INST]DATPTR address  $0041-0042  is:   Pointer: Used by READ - current DATA Item Address."
"[INST]In the context of the C64, What does the CURLIN address $0039-003A represents?[/INST]CURLIN address  $0039-003A  is:   Current BASIC Line number."
"[INST]In the context of the C64, What is the description of the memory address range $002D-$002E in a typical Commodore 64 system?[/INST]VARTAB address  $002D-002E  is:   Pointer: Start of BASIC Variables."
"[INST]In the context of the C64, What is the description of the address $006E?[/INST]ARGSGN address  $006E       is:   AFAC Sign."
"[INST]In the context of the C64, What do the lower 4 bits of address $D418 control?[/INST]address $D418 bits 3-0 are	Select Output Volume: 0-15"
"[INST]In the context of the C64, What is the function of the bits 3-0 at address $D40C?[/INST]address $D40C bits 3-0	is: Select Decay Cycle Duration: 0-15"
"[INST]In the context of the C64, What is the description of memory address $D410 ?[/INST]address $D410	is 			Voice 3: Pulse Waveform Width - Low-Byte"
"[INST]In the context of the C64, What is the description of the memory address $D001 in the C64 memory map?[/INST]address $D001 is Sprite 0 Y Pos"
"[INST]In the context of the C64, What does bit 4 of address D016 control?[/INST]address D016 bit 4	is Multi-Color Mode: 1 = Enable (Text or Bit-Map)"
"[INST]In the context of the C64, What is the description of the memory region located at addresses $0334-$033B?[/INST]TEMP      address $0334-033B   is: Unused."
"[INST]In the context of the C64, What is the address of the kernel routine for CHRIN in the Commodore 64?[/INST]kernal routine address for chrin	= $ffcf"
"[INST]In the context of the C64, What is the description of the STKEY at address $0091?[/INST]STKEY     address $0091        is: Flag: $7F = STOP key."
"[INST]In the context of the C64, What is the purpose of the memory location at address $0097?[/INST]TEMPX     address $0097        is: Temporary storage of X Register during CHRIN."
"[INST]In the context of the C64, What is the address of the kernel routine for the open function in a Commodore 64?[/INST]kernal routine address for open	= $ffc0"
"[INST]In the context of the C64, What is the description of the address $0096?[/INST]SYNO      address $0096        is: Cassette Sync. number."
"[INST]In the context of the C64, What is the kernel routine address for memtop?[/INST]kernal routine address for memtop	= $ff99"
"[INST]In the context of the C64, What is the kernel routine address for the CHKOUT function in a Commodore 64?[/INST]kernal routine address for chkout	= $ffc9"
"[INST]In the context of the C64, What is the description of the memory location $0090 in the Commodore 64?[/INST]STATUS    address $0090        is: Kernal I/O Status Word  ST."
"[INST]In the context of the C64, What is the description of the ISAVE vector in the Commodore 64 Kernal?[/INST]ISAVE     address $0332-0333   is: Vector: Indirect entry to Kernal SAVE     Routine ($F5ED)."
"[INST]In the context of the C64, What does address D016 bit 3 control?[/INST]address D016 bit 3 is Select 38/40 Column Text Display: 1 = 40 Cols"
"[INST]In the context of the C64, What is the description of the memory address $D002 in the Commodore 64?[/INST]address $D002 is Sprite 1 X Pos"
"[INST]In the context of the C64, What is the description of memory address $D40F ?[/INST]address $D40F	is 			Voice 3: Frequency Control - High-Byte"
"[INST]In the context of the C64, What does the address $D40C bits 7-4 control in a game?[/INST]address $D40C bits 7-4	is: Select Attack Cycle Duration: O-15"
"[INST]In the context of the C64, What is the function of bit 4 at address $D418?[/INST]address $D418 bit 4	is: Select Filter Low-Pass Mode: 1 = On"
"[INST]In the context of the C64, What is the purpose of the ARISGN address $006F?[/INST]ARISGN address  $006F       is:   Sign of result of Arithmetic Evaluation."
"[INST]In the context of the C64, What is the description of the memory address range $002B-$002C in a Commodore 64 computer?[/INST]TXTTAB address  $002B-002C  is:   Pointer: Start of BASIC Text Area ($0801)."
"[INST]In the context of the C64, What is the description of the memory location $0037-0038 in a Commodore 64 computer?[/INST]MEMSIZ address  $0037-0038  is:   Pointer: Highest Address available to BASIC ($A000)."
"[INST]In the context of the C64, What is the description of the LINNUM address $0014-0015?[/INST]LINNUM address  $0014-0015  is:   Temporary: Integer value."
"[INST]In the context of the C64, What is the description of the memory location at address $0024-0025?[/INST]INDEX2 address  $0024-0025  is:   Secong Utility Pointer."
"[INST]In the context of the C64, What is the description of the FRETOP address $0033-0034?[/INST]FRETOP address  $0033-0034  is:   Pointer: Bottom of String space."
"[INST]In the context of the C64, What is the description of register $D411 in a certain microcontroller?[/INST]address $D411	is 		7-4	Unused 3-0	Voice 3: Pulse Waveform Width - High-Nybble"
"[INST]In the context of the C64, What is the function of the address $D40D ?[/INST]address $D40D	is:	Envelope Generator 2: Sustain / Release Cycle Control"
"[INST]In the context of the C64, What is the description of the memory address $D004 in the Commodore 64?[/INST]address $D004 is Sprite 2 X Pos"
"[INST]In the context of the C64, What is the function of the BITTS register located at address $00B4?[/INST]BITTS     address $00B4        is: RS232 Write bit count/Tape Read timing Flag."
"[INST]In the context of the C64, What is the address of the kernel routine for plotting in the Commodore 64?[/INST]kernal routine address for plot	= $fff0"
"[INST]In the context of the C64, What is the description of the memory location $0094?[/INST]C3PO      address $0094        is: Flag: Serial Bus - Output Character buffered."
"[INST]In the context of the C64, What is the function of the memory location $007A-007B in Commodore BASIC?[/INST]TXTPTR    address $007A-007B   is: Pointer: Current Byte of BASIC Text."
"[INST]In the context of the C64, What is the memory address of the KERNAL routine for outputting a character to the default output device in a Commodore 64?[/INST]kernal routine address for chrout	= $ffd2"
"[INST]In the context of the C64, What is the kernel routine address for the SETMO instruction in a Commodore 64?[/INST]kernal routine address for settmo	= $ffa2"
"[INST]In the context of the C64, What is the address of the kernel routine for setting the time in the Commodore 64?[/INST]kernal routine address for settim	= $ffdb"
"[INST]In the context of the C64, What is the purpose of the memory location $008B-008F?[/INST]RNDX      address $008B-008F   is: Floating RND Function Seed Value."
"[INST]In the context of the C64, What is the address of the kernel routine for CIOUT in a Commodore 64?[/INST]kernal routine address for ciout	= $ffa8"
"[INST]In the context of the C64, What is the kernel routine address for RAMTAS?[/INST]kernal routine address for ramtas	= $ff87"
"[INST]In the context of the C64, What is the description of the BSOUR address $0095 ?[/INST]BSOUR     address $0095        is: Buffered Character for Serial Bus."
"[INST]In the context of the C64, What is the function of the NXTBIT register located at address $00B5?[/INST]NXTBIT    address $00B5        is: RS232 Next Bit to send/Tape Read - End of Tape."
"[INST]In the context of the C64, What is the description of the memory address $D003 in the Commodore 64?[/INST]address $D003 is Sprite 1 Y Pos"
"[INST]In the context of the C64, What does the bits 7-4 of address $D40D represent ?[/INST]address $D40D	bits 7-4 is:	Select Sustain Cycle Duration: O-15"
"[INST]In the context of the C64, What is the description of the memory location $D40D-$D412 ?[/INST]address $D40D	 $D412 is:			Voice 3: Control Register"
"[INST]In the context of the C64, What is the description of the FRESPC address $0035-0036?[/INST]FRESPC address  $0035-0036  is:   Utility String Pointer."
"[INST]In the context of the C64, What is the description of the RESHO address $0026-002A?[/INST]RESHO  address  $0026-002A  is:   Floating point product of Multiply and Divide."
"[INST]In the context of the C64, What is the description of the memory address $0016 in a Commodore 64 computer?[/INST]TEMPPT address  $0016       is:   Pointer: Temporary String Stack."
"[INST]In the context of the C64, What is the function of the bit 4 of the I/O port address $DD01 in a Commodore 64?[/INST]address $DD01 bit 4 is	User / RS-232 Carrier Detect"
"[INST]In the context of the C64, What is stored at memory address $DD0B?[/INST]address $DD0B is:	Time-of-Day Clock: Hours + AM/PM Flag (Bit 7)"
"[INST]In the context of the C64, What is the function of the bit 1 in the $DC0D address?[/INST]address $DC0D bit 1 is	Timer B Interrupt"
"[INST]In the context of the C64, What is the description of the memory location $DC04 ?[/INST]address $DC04	is: Timer A: Low-Byte"
"[INST]In the context of the C64, What is the function of the address $DC00 bits 7-0 in a keyboard scan?[/INST]address $DC00 bits 7-0	is: Write Keyboard Column Values for Keyboard Scan"
"[INST]In the context of the C64, What is the description of the flag located at address $D019 Bit 1?[/INST]address $D019 Bit 1	is: Sprite to Background Collision IRQ Flag"
"[INST]In the context of the C64, What is the description of the address $4275 ?[/INST]address $4275			is:	    bits 7-4	Unused 3-0	Voice 1: Pulse Waveform Width - High-Nybble"
"[INST]In the context of the C64, What is the description of the address $3284?[/INST]address $3284		is:			Background Color 3"
"[INST]In the context of the C64, What is the function of the register located at address $029E?[/INST]RODBE     address $029E        is: RS232 Index to End of Output Buffer."
"[INST]In the context of the C64, What is the purpose of the memory location addressed by $00FF?[/INST]BASZPT    address $00FF        is: BASIC temporary Data Area."
"[INST]In the context of the C64, What is the description of the CRSW address $00D0?[/INST]CRSW      address $00D0        is: Flag: Input from Screen = $03, or Keyboard =  $00."
"[INST]In the context of the C64, What is the description of the RSSTAT at address $0297?[/INST]RSSTAT    address $0297        is: RS232 Pseudo 6551 Status Register Image."
"[INST]In the context of the C64, What is the description of the ICHKIN vector at address $031E-031F?[/INST]ICHKIN    address $031E-031F   is: Vector: Indirect entry to Kernal CHKIN  Routine ($F20E)."
"[INST]In the context of the C64, What is stored at memory address $0286?[/INST]COLOR     address $0286        is: Current Character Colour code."
"[INST]In the context of the C64, What is the function of the flag located at address $0285?[/INST]TIMOUT    address $0285        is: Serial IEEE Bus timeout defeat Flag."
"[INST]In the context of the C64, What is the description of the memory location $0320-0321 in the Commodore 64 Kernal?[/INST]ICKOUT    address $0320-0321   is: Vector: Indirect entry to Kernal CHKOUT Routine ($F250)."
"[INST]In the context of the C64, What is the function of the memory address $00D1-00D2 ?[/INST]PNT       address $00D1-00D2   is: Pointer: Current Screen Line Address."
"[INST]In the context of the C64, What is the description of the BITNUM variable located at address $0298?[/INST]BITNUM    address $0298        is: RS232 Number of Bits left to send."
"[INST]In the context of the C64, What is the purpose of the memory location $029F-02A0?[/INST]IRQTMP    address $029F-02A0   is: Temporary store for IRQ Vector during Tape  operations."
"[INST]In the context of the C64, What is the purpose of the memory location $00FF-010A ?[/INST]ASCWRK    address $00FF-010A   is: Assembly Area for Floating point to ASCII     conversion."
"[INST]In the context of the C64, What is the description of memory address $3283?[/INST]address $3283		is:			Background Color 2"
"[INST]In the context of the C64, What is the description of memory address $4274 ?[/INST]address $4274		is:			Voice 1: Pulse Waveform	Width - Low-Byte"
"[INST]In the context of the C64, What is the description of the flag located at address $D019 Bit 2?[/INST]address $D019 Bit 2	is: Sprite to Sprite Collision IRQ Flag"
"[INST]In the context of the C64, What does the address $DC00 bits 7-6 represent ?[/INST]address $DC00 bits 7-6	is: Read Paddles on Port A / B (01 = Port A, 10 = Port B)"
"[INST]In the context of the C64, What is the description of memory location $DC05?[/INST]address $DC05	is: Timer A: High-Byte"
"[INST]In the context of the C64, What is the function of the bit 0 in the $DC0D address?[/INST]address $DC0D bit 0 is	Timer A Interrupt"
"[INST]In the context of the C64, What is the description of the memory address $DD0C in a Commodore 64 computer?[/INST]address $DD0C is:	Synchronous Serial I/O Data Buffer"
"[INST]In the context of the C64, What is the function of the bit 3 of the I/O address $DD01 in a Commodore 64?[/INST]address $DD01 bit 3 is	User / RS-232 Ring Indicator"
"[INST]In the context of the C64, What is stored at memory address $DD0A?[/INST]address $DD0A is:	Time-of-Day Clock: Minutes"
"[INST]In the context of the C64, What is at address $DD01 bit 5?[/INST]address $DD01 bit 5 is	User"
"[INST]In the context of the C64, What is the function of bit 3 at address $DD0E ?[/INST]address $DD0E bit 3 is:	Timer A Run Mode: 1 = One-Shot, s"
"[INST]In the context of the C64, What is the description of the memory location $DC07 ?[/INST]address $DC07	is: Timer B: High-Byte"
"[INST]In the context of the C64, What is the description of the address $4278 ?[/INST]address $4278      bits        7-4  is:   Select Sustain Cycle Duration: 0-15"
"[INST]In the context of the C64, What does bit 7 of address $DC0E represent?[/INST]address $DC0E bit 7	is: Time-of-Day Clock Frequency: 1 = 50 Hz, 0 = 60 Hz"
"[INST]In the context of the C64, What is the description of memory address $3285 in the Commodore 64?[/INST]address $3285			is:		Sprite Multi-Color Register 0"
"[INST]In the context of the C64, What is the description of memory address $4276 ?[/INST]address $4276		is: 	Voice 1: Control Register"
"[INST]In the context of the C64, What is the description of the address $DC0F bits 4-0?[/INST]address $DC0F bits 4-0	is: Same as CIA Control Reg. A - for Timer B"
"[INST]In the context of the C64, What is the function of the register located at address $029B?[/INST]RIDBE     address $029B        is: RS232 Index to End of Input Buffer."
"[INST]In the context of the C64, What is the meaning and possible values of the Flag at memory address $00CF?[/INST]BLNON     address $00CF        is: Flag: Cursor Status; $00 = Off, $01 = On."
"[INST]In the context of the C64, What is the purpose of the memory space located at addresses $00FB-00FE?[/INST]FREKZP    address $00FB-00FE   is: Free Zero Page space for User Programs."
"[INST]In the context of the C64, What is the function of the address $02A2 ?[/INST]TODSNS    address $02A2        is: TOD sense during Tape I/O."
"[INST]In the context of the C64, What is the function of the component located at address $00C0?[/INST]CAS1      address $00C0        is: Tape Motor Switch."
"[INST]In the context of the C64, What is the function of the memory location at address $00BF?[/INST]MYCH      address $00BF        is: Serial Word Buffer."
"[INST]In the context of the C64, What is the function of the register located at address $00F9-00FA?[/INST]ROBUF     address $00F9-00FA   is: RS232 Output Buffer Pointer."
"[INST]In the context of the C64, What is the function of the ENABL command at address $02A1?[/INST]ENABL     address $02A1        is: RS232 Enables."
"[INST]In the context of the C64, What is the description of the memory location $0299-029A?[/INST]BAUDOF    address $0299-029A   is: RS232 Baud Rate; Full Bit time microseconds."
"[INST]In the context of the C64, What does the GDBLN at address $00CE represent ?[/INST]GDBLN     address $00CE        is: Character under Cursor while Cursor Inverted."
"[INST]In the context of the C64, What does bit 7 of address $4276 control ?[/INST]address $4276	bit 7 is 	Select Random Noise Waveform, 1 = On"
"[INST]In the context of the C64, What is the function of memory addresses $DD00-DDFF in a Commodore 64 computer?[/INST]addresses $DD00-DDFF	are:		MOS 6526 Complex Interface Adapter (CIA) #2"
"[INST]In the context of the C64, What is the description of memory address $3286 in the Commodore 64?[/INST]address $3286		is:			Sprite Multi-Color Register 1"
"[INST]In the context of the C64, What is the function of memory address $4278 ?[/INST]address $4278			Envelope Generator 1: Sustain / Release Cycle Control"
"[INST]In the context of the C64, What is the description of the memory location $DC0E in the Commodore 64?[/INST]address $DC0E	is	CIA Control Register A"
"[INST]In the context of the C64, What is the description of memory location $DC06 ?[/INST]address $DC06	is: Timer B: Low-Byte"
"[INST]In the context of the C64, What is the function of bit 4 of the $DD0E address ?[/INST]address $DD0E bit 4 is:	Force Load Timer A: 1 = Yes"
"[INST]In the context of the C64, What is the function of the bit 6 of the I/O port $DD01 in a Commodore 64?[/INST]address $DD01 bit 6 is	User / RS-232 Clear to Send"
"[INST]In the context of the C64, What is stored at memory address $DD09 in the Commodore 64?[/INST]address $DD09 is:	Time-of-Day Clock: Seconds"
"[INST]In the context of the C64, What is the purpose of the address range $DF00-DFFF ?[/INST]address $DF00-DFFF are	Reserved for Future I/O Expansion"
"[INST]In the context of the C64, What is the description of memory address $DD05 in the Commodore 64?[/INST]address $DD05 is:	Timer A: High-Byte"
"[INST]In the context of the C64, What is the function of the bit 2 of the I/O address $DD01 in a Commodore 64?[/INST]address $DD01 bit 2 is	User / RS-232 Data Terminal Ready"
"[INST]In the context of the C64, What is the description of the address $4283 ?[/INST]address $4283	bits5 is:	Select Sawtooth Waveform, 1 = On"
"[INST]In the context of the C64, What is the description of the address $DC0A?[/INST]address $DC0A	is: Time-of-Day Clock: Minutes"
"[INST]In the context of the C64, What is the function of the bit 3 in the $DC0D address?[/INST]address $DC0D bit 3 is	Serial Port Interrupt"
"[INST]In the context of the C64, What is the description of memory address $3290 in the context of a Commodore 64?[/INST]address $3290		is:			Sprite 3 Color"
"[INST]In the context of the C64, What is the function of the bit 7 of the I/O port address $DD01 in a Commodore 64 computer?[/INST]address $DD01 bit 7 is	User / RS-232 Data Set Ready"
"[INST]In the context of the C64, What is the description of memory address $4273 ?[/INST]address $4273		is:			Voice 1: Frequency Control - High-Byte"
"[INST]In the context of the C64, What is the memory location that stores the horizontal position of the first sprite in Commodore 64 graphics?[/INST]address $D000 is Sprite 0 X Pos"
"[INST]In the context of the C64, What is the function and possible values of the BLNSW address $00CC?[/INST]BLNSW     address $00CC        is: Flag: Cursor blink; $00 = Enabled, $01 =  Disabled."
"[INST]In the context of the C64, What does the PNTR at address $00D3 represent ?[/INST]PNTR      address $00D3        is: Cursor Column on current Line, including Wrap-round Line, if any."
"[INST]In the context of the C64, What is the description of the M51CDR register at address $0294?[/INST]M51CDR    address $0294        is: RS232 Pseudo 6551 command Register Image."
"[INST]In the context of the C64, What is the description of the memory location at address $02A5?[/INST]TLNIDX    address $02A5        is: Temporary for Line Index."
"[INST]In the context of the C64, What is the purpose and contents of the memory location $00D9-00F2?[/INST]LDTB1     address $00D9-00F2   is: Screen Line link Table/Editor temporaries.  High Byte of Line Screen Memory Location."
"[INST]In the context of the C64, What does the TVSFLG flag at address $02A6 ?[/INST]TVSFLG    address $02A6        is: Flag: TV Standard: $00 = NTSC, $01 = PAL."
"[INST]In the context of the C64, What is the function of the memory location addressed by $00F3-00F4 ?[/INST]USER      address $00F3-00F4   is: Pointer: Current Colour RAM Location."
"[INST]In the context of the C64, What is the meaning and usage of the address $00D4?[/INST]QTSW      address $00D4        is: Flag: Editor in Quote Mode; $00 = Not."
"[INST]In the context of the C64, What is the description of the address $0295-0296?[/INST]M51AJB    address $0295-0296   is: RS232 Non-standard Bits/Second."
"[INST]In the context of the C64, What is the purpose of the memory location at address $00CD in the system?[/INST]BLNCT     address $00CD        is: Timer: Count down for Cursor blink toggle."
"[INST]In the context of the C64, What information is stored in bits 6-7 of address $0001?[/INST]address $0001 bit 6-7 is:	Undefined"
"[INST]In the context of the C64, What is the description of memory address $4272?[/INST]address $4272		is:			Voice 1: Frequency Control - Low-Byte"
"[INST]In the context of the C64, What is the description of memory address $3289 in the context of a Commodore 64?[/INST]address $3289		is:			Sprite 2 Color"
"[INST]In the context of the C64, What is the function of the address $DD01 in the Commodore 64?[/INST]address $DD01 is:		Data Port B (User Port, RS-232)"
"[INST]In the context of the C64, What is the function of the bit 2 in the $DC0D address?[/INST]address $DC0D bit 2 is	Time-of-Day Clock Alarm Interrupt"
"[INST]In the context of the C64, What is the description of the address $4283 ?[/INST]address $4283	bits4 is:	Select Triangle Waveform, 1 = On"
"[INST]In the context of the C64, What is the description of the address $DC0B ?[/INST]address $DC0B	is: Time-of-Day Clock: Hours + AM/PM Flag (Bit 7)"
"[INST]In the context of the C64, What is the function of the bit 1 of the I/O port address $DD01 in a Commodore 64?[/INST]address $DD01 bit 1 is	User / RS-232 Request to Send"
"[INST]In the context of the C64, What is the description of memory address $DD06?[/INST]address $DD06 is:	Timer B: Low-Byte"
"[INST]In the context of the C64, What is the description of the register located at address $0000?[/INST]D6510  address  $0000       is:   6510 On-chip Data Direction Register."
"[INST]In the context of the C64, What is the function of memory address $DD02 ?[/INST]address $DD02 is:	Data Direction Register - Port A"
"[INST]In the context of the C64, What is stored at memory address $DD08 in the Commodore 64?[/INST]address $DD08 is:	Time-of-Day Clock: 1/10 Seconds"
"[INST]In the context of the C64, What is the description of the address $DC03 ?[/INST]address $DC03	is: Data Direction Register - Port B (56321)"
"[INST]In the context of the C64, What is the function of bit 4 of the $DC0D address in a Commodore 64 computer?[/INST]address $DC0D bit 4 is	FLAG1 IRQ (Cassette Read / Serial Bus SRQInput)"
"[INST]In the context of the C64, What is the description of the address $DC09?[/INST]address $DC09	is: Time-of-Day Clock: Seconds"
"[INST]In the context of the C64, What is the description of memory address $3293?[/INST]address $3293		is:			Sprite 6 Color"
"[INST]In the context of the C64, What is the description of memory address $3287 in the Commodore 64 memory map?[/INST]address $3287		is:			Sprite 0 Color"
"[INST]In the context of the C64, What is the description of memory address $3281?[/INST]address $3281		is:			Background Color 0"
"[INST]In the context of the C64, What is the purpose of the memory location at address $030F in a Commodore 64 computer?[/INST]SPREG     address $030F        is: Storage for 6510 Status Register during SYS."
"[INST]In the context of the C64, What is the function of the RIBUF address $00F7-00F8 ?[/INST]RIBUF     address $00F7-00F8   is: RS232 Input Buffer Pointer."
"[INST]In the context of the C64, What is the function of the TD1IRQ at address $02A4?[/INST]TD1IRQ    address $02A4        is: Temporary D1IRQ Indicator during Tape READ."
"[INST]In the context of the C64, What is the description of the M51CTR at address $0293?[/INST]M51CTR    address $0293        is: RS232 Pseudo 6551 control Register Image."
"[INST]In the context of the C64, What is stored at memory address $00D6 ?[/INST]TBLX      address $00D6        is: Current Screen Line number of Cursor."
"[INST]In the context of the C64, What is the purpose of the KEYLOG routine located at address $028F-0290?[/INST]KEYLOG    address $028F-0290   is: Vector: Routine to determine Keyboard table to use based on Shift Key Pattern ($EB48)."
"[INST]In the context of the C64, What is the function and configuration of the mode at address $0291?[/INST]MODE      address $0291        is: Flag: Upper/Lower Case change: $00 = Disabled, $80 = Enabled ($00)."
"[INST]In the context of the C64, What is the configuration setting for the AUTODN address $0292?[/INST]AUTODN    address $0292        is: Flag: Auto scroll down: $00 = Disabled ($00)."
"[INST]In the context of the C64, What is the description of the LNMX address $00D5?[/INST]LNMX      address $00D5        is: Current logical Line length: 39 or 79."
"[INST]In the context of the C64, What is the function and location of the KEYTAB command ?[/INST]KEYTAB    address $00F5-00F6   is: Vector: Current Keyboard decoding Table. ($EB81)"
"[INST]In the context of the C64, What is the purpose of the TRDTMP address $02A3 ?[/INST]TRDTMP    address $02A3        is: Temporary storage during Tape READ."
"[INST]In the context of the C64, What is the purpose of the memory location at address $030E in a Commodore 64 computer?[/INST]SYREG     address $030E        is: Storage for 6510 Y-Register during SYS."
"[INST]In the context of the C64, What is the description of the address located at $3282?[/INST]address $3282		is:			Background Color 1"
"[INST]In the context of the C64, What is the description of the memory address $3288 in the Commodore 64?[/INST]address $3288		is:			Sprite 1 Color"
"[INST]In the context of the C64, What is the description of memory address $3294?[/INST]address $3294		is:			Sprite 7 Color"
"[INST]In the context of the C64, What is the description of the address $DC08?[/INST]address $DC08	is: Time-of-Day Clock: 1/10 Seconds"
"[INST]In the context of the C64, What is the function of bit 7 in the $DC0D address?[/INST]address $DC0D bit 7 is	IRQ Flag (1 = IRQ Occurred) / Set-Clear Flag"
"[INST]In the context of the C64, What is the description of the address $DC02 ?[/INST]address $DC02	is: Data Direction Register - Port A (56320)"
"[INST]In the context of the C64, What is the description of memory address $DD07 in the Commodore 64?[/INST]address $DD07 is:	Timer B: High-Byte"
"[INST]In the context of the C64, What is the function of the bit 0 of the I/O address $DD01 in a Commodore 64?[/INST]address $DD01 bit 0 is	User / RS-232 Received Data"
"[INST]In the context of the C64, What is the meaning of error code 21: READ ERROR (drive not ready) on a disk controller?[/INST]1581 disk: Controller commands error code  21: READ ERROR (drive not ready)
    The  disk  controller  is unable to detect a sync mark on the
    desired track.  Caused by misalignment, or a diskette that is
    absent,  unformatted or improperly seated.  Can also indicate
    hardware  failure.  Unless  caused by one of the above simple
    causes, this error is usually unrecoverable."
"[INST]In the context of the C64, What is the function of the TREAD_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: TREAD_DV
      $AA     Reads  logical address without transferring
                      to the job queue buffer."
"[INST]In the context of the C64, What error message is generated when the data to be written exceeds the record size?[/INST]1581 disk: Controller commands error code 51: OVERFLOW IN RECORD
    The  data  to  be  written  in the current record exceeds the
    record size. The excess has been truncated (cut off). Be sure
    to include all special characters  (such as carriage returns)
    in calculating record sizes."
"[INST]In the context of the C64, What is the list of Kernal ROM subroutines for disk-related operations in a computer, along with an example program that reads a sequential file into memory from disk?[/INST]1581 disk:  MACHINE LANGUAGE PROGRAMS


  Here  is  a  list  of  host  computer  disk-related  Kernal ROM
subroutines  and  a  practical  example of their use in a program
that reads a sequential file into memory from disk.  Most require
advance  setup  of  one  or  more  processor  registers or memory
locations  and  all  are  called  with  the assembly language JSR
command.
  For a more  complete  description  as to what each routine does
and how parameters are set for each routine, see the Programmer's
Reference Guide for your specific computer.


                 DISK-RELATED KERNAL SUBROUTINES

Label        Address                    Functions
-----------------------------------------------------------------
SETLFS  =    $FFBA     ; SET LOGICAL, FIRST & SECOND ADDRESSES
SETNAM  =    $FFBD     ; SET LENGTH & ADDRESS OF FILENAME
OPEN    =    $FFC0     ; OPEN LOGICAL FILE
CLOSE   =    $FFC3     ; CLOSE LOGICAL FILE
CHKIN   =    $FFC6     ; SELECT CHANNEL FOR INPUT
CHKOUT  =    $FFC9     ; SELECT CHANNEL FOR OUTPUT
CLRCHN  =    $FFCC     ; CLEAR ALL CHANNELS & RESTORE DEFAULT I/O
CHRIN   =    $FFCF     ; GET BYTE FROM CURRENT INPUT DEVICE
CHROUT  =    $FFD2     ; OUTPUT BYTE TO CURRENT OUTPUT DEVICE
        ;
START   LDA  #4        ; SET LENGTH & ADDRESS
        LDX  #<FNADR   ; OF FILE NAME, LOW
        LDY  #>FNADR   ; & HIGH BYTES
        JSR  SETNAM    ; FOR NAME SETTER
        LDA  #3        ; SET FILE NUMBER
        LDX  #8        ; DISK DEVICE NUMBER
        LDY  #0        ; AND SECONDARY ADDRESS
        JSR  SETLFS    ; AND SET THEM
        JSR  OPEN      ; OPEN 3,8,0,'TEST'
        LDX  #3
        JSR  CHKIN     ; SELECT FILE 3 FOR INPUT
NEXT    JSR  CHRIN     ; GET NEXT BYTE FROM FILE
        BEQ  END       ; UNTIL FINISH OR FAIL
        JSR  CHROUT    ; OUTPUT BYTE TO SCREEN
        JMP  NEXT      ; AND LOOP BACK FOR MORE
        ;
END     LDA  #3        ; WHEN DONE
        JSR  CLOSE     ; CLOSE FILE
        JSR  CLRCHN    ; RESTORE DEFAULT I/O
        RTS            ; BACK TO BASIC
        ;
FNADR   .BYT 'TEST'    ; STORE FILE NAME HERE"
"[INST]In the context of the C64, What is the purpose of the BLOCK-ALLOCATE command in direct access commands, and how is it used to mark a sector as 'already used' on a diskette?[/INST]1581 disk:  ALLOCATING BLOCKS

  Once  you  have  written  something in a particular sector on a
diskette  with  the  help of direct access commands, you may wish
to mark that sector as  'already used',  to keep other files from
being written there. Blocks thus allocated will be safe until the
diskette is validated.

FORMAT FOR BLOCK-ALLOCATE COMMAND:

  PRINT#15,'BLOCK-ALLOCATE';drive#;track#;sector#

usually abbreviated as: PRINT#15,'B-A';drive#;track#;sector#

where  'drive#' is the drive number,  and  'track#' and 'sector#'
are  the track and sector containing the block of data to be read
into the file buffer.

ALTERNATE FORMAT:

  PRINT#15,'B-A:';drive#;track#;sector#

EXAMPLE:

  If  you  try  to allocate a block that isn't available, the DOS
will set the error message to number  65,  NO BLOCK,  and set the
track  and  sector  numbers  in  the  error  message  to the next
available track and sector number.  Therefore, before selecting a
block to write,  try  to allocate that block.  If the block isn't
available,  read  the next available block from the error channel
and allocate it instead.  However, do not allocate data blocks in
the  directory  track.  If  the  track  number returned is 0, the
diskette is full.
  Here is a program  that allocates a place to store a message on
a diskette.

  100 OPEN 15,8,15             Open command channel.
  110 OPEN 5,8,5,'#'           Open direct access channel.
  120 PRINT#5,'I THINK
      THEREFORE I AM'          Write a message to buffer.
  130 T=1: S=1                 Start at first track & sector.
  140 PRINT#15,'B-A';0;T;S     Try allocating it.
  150 INPUT#15,EN,EM$,ET,ES    See if it worked.
  160 IF EN=0 THEN 210         If so, we're almost done.
  170 IF EN<>65 THEN PRINT     'NO BLOCK'
      EN,EM$,ET,ES: STOP       means already allocated.
  180 IF ET=0 THEN PRINT       If next track is 0,
      'DISK FULL': STOP        we're out of room.
  190 IF ET=40 THEN ET=41:ES=0 Don't allocate the directory.
  200 T=ET: S=ES: GOTO 140     Try suggested track & sector next.
  210 PRINT#15,'U2';5;0;T;S    Write buffer to allocated
                               sector.
  220 PRINT 'STORED AT:';T,S   Say where message went
  220 CLOSE 5: CLOSE 15        and tidy up.
  230 END"
"[INST]In the context of the C64, What is the special character used by DOS to fill relative records as they are created, and how is it used when writing the last record in a relative file?[/INST]1581 disk:COMPLETING RELATIVE FILE CREATION

  Now that you have learned how to use both the  OPEN and RECORD#
commands,  you  are  almost  ready  to properly create a relative
file. The only additional fact you need to know is that CHR$(255)
is  a  special character in a relative file.  It is the character
used  by  the  DOS  to fill relative records as they are created,
before a program fills them with other information.  Thus, if you
want  to  write the last record,  you expect to need in your file
with  dummy  data  that  will not interfere with your later work,
CHR$(255)  is  the  obvious  choice."
"[INST]In the context of the C64, What does the DOS MISMATCH"" error code 3 on a Commodore 1581 disk indicate?""[/INST]1581 disk: Controller commands error code 3: DOS MISMATCH (COPYRIGHT CBM DOS V10 1581)
    If  the  disk-error status is checked when the drive is first
    turned  on,  before  a  directory  or  other command has been
    given,  this message will appear.  In that use,  it is not an
    error,  but rather an easy way to see which version of DOS is
    in use. If the message appears at other times, an attempt has
    been made to write to a diskette with an incompatible format."
"[INST]In the context of the C64, What are splat files"" and how should they be handled on a diskette?""[/INST]SPLAT FILES

  One  indicator you may occasionally notice on a directory line,
after  you  begin  saving  programs  and  files,  is  an asterisk
appearing  just  before  the file type of a file that is 0 blocks
long.  This  indicates  the file was not properly closed after it
was created, and that it should not be relied upon. These 'splat'
files normally need to be erased from the diskette and rewritten.
However,  do not use the SCRATCH command to get rid of them. They
can  only  be  safely erased by the VALIDATE or COLLECT commands.
One  of  these  should  normally be used whenever a splat file is
noticed on a diskette. All of these commands are described in the
following chapters.
  There  are  two  exceptions  to the above warning:  one is that
VALIDATE  and  COLLECT  cannot  be  used  on  some diskettes that
include direct access  (random) files  (Chapter 6).  The other is
that  if  the information in the splat file was crucial and can't
be  replaced,  there is a way to rescue whatever part of the file
was  properly  written.  This  option  is  described  in the next
chapter."
"[INST]In the context of the C64, What is the syntax and usage of the INPUT# statement in BASIC, and how can it be used to read data from a file?[/INST]1581 disk with basic 7,0: FORMAT FOR THE INPUT# STATEMENT:

  INPUT#file#,variable list

where 'file#' is the same file number given in the desired file's
current OPEN statement,  and 'variable list' is one or more valid
BASIC  variable  names.  If  more  than one data element is to be
input  by a particular INPUT# statement,  each variable name must
be separated from others by a comma.

EXAMPLES:

To read back in the grades written with the PRINT# example, use:

  300 FOR CLASS = 1 TO COURSES
  310 INPUT#1,GRADE$(CLASS)
  320 GOSUB 59990: REM CHECK FOR DISK ERRORS
  330 NEXT CLASS

assuming your program includes an error check subroutine like the
one in the last chapter.
  To  read  back  in  the  address data written by another PRINT#
example, it is safest to use:

  800 INPUT#5,NAME$
  810 GOSUB 59990: REM CHECK FOR DISK ERRORS
  820 INPUT#5,STREET$
  830 GOSUB 59990: REM CHECK FOR DISK ERRORS
  840 INPUT#5,CITY$
  850 GOSUB 59990: REM CHECK FOR DISK ERRORS

but many programs cheat on safety a bit and use

  800 INPUT#5,NAME$,STREET$,CITY$
  810 GOSUB 59990: REM CHECK FOR DISK ERRORS

This  is  done  primarily  when  top  speed  in  the  program  is
essential, and there is little risk of reading improper data from
the file."
"[INST]In the context of the C64, How do you erase a locked file on a diskette that cannot be deleted with the SCRATCH command?[/INST]1581 disk with basic 7,0:  Locked Files

  Occasionally,  a diskette will contain a locked file; one which
cannot  be  erased  with  the  SCRATCH command. Such files may be
recognized  by  the  '<'  character which immediately follows the
file type in their directory entry. If you wish to erase a locked
file,  you  will have to use a disk monitor to clear bit 6 of the
file-type   byte   in   the  directory  entry  on  the  diskette.
Conversely, to lock a file, you would set bit 6 of the same byte."
"[INST]In the context of the C64, What is the syntax and functionality of the RENAME command in a disk with BASIC 7.0?[/INST]1581 disk with basic 7,0: RENAME

  The RENAME command allows you to alter the name of a program or
other file in the diskette directory. Since only the directory is
affected, RENAME works very quickly.  If you try to RENAME a file
by using a file name already in the directory,  the computer will
respond  with  a  'FILE EXISTS'  error.  A file  must be properly
closed before it can be renamed.

FORMAT FOR RENAME COMMAND:

  RENAME [Ddrive#,] 'old name' TO [Ddrive#,] 'new name'
         [,Udevice#]

where both drive#s, if included, would be 0."
"[INST]In the context of the C64, What is the purpose of the error checking program in Basic 2.0 and how can it be used to diagnose and clear disk errors?[/INST]1581 disk: ERROR CHECKING

  In Basic 2.0,  when the red drive light flashes, you must write
a small program to find out what the error is. This causes you to
lose  any  program variables already in memory.  The following is
the error check program:

  10 OPEN 15,8,15
  20 INPUT#15,EN,EM$,ET,ES
  30 PRINT EN,EM$,ET,ES
  40 CLOSE 15

  This  little  program  reads  the error channel into four BASIC
variables  (described  below),  and  prints  the  results  on the
screen.  A message is displayed whether there is an error or not,
but if there was an error, the program clears it from disk memory
and stops the error light from blinking.
  Once  the  message  is  on  the  screen,  you can look it up in
Appendix B to see what it means, and what to do about it.
  For those of you who are writing programs,  the  following is a
small error-checking subroutine you can include in your programs:

  59980 REM READ ERROR CHANNEL
  59990 INPUT#15,EN,EM$,ET,ES
  60000 IF EN>1 THEN PRINT EN,EM$,ET,ES: STOP
  60010 RETURN

  This  assumes  file  15  was opened earlier in the program, and
that it will be closed at the end of the program.
  The  subroutine  reads  the  error channel and puts the results
into  the  named  variables  --  EN  (Error  Number),  EM$ (Error
Message),  ET (Error Track),  and ES (Error Sector). Of the four,
only  EM$  has  to  be a string.  You could choose other variable
names, although these have become traditional for this use.
  Two error numbers are harmless -- 0 means everything is OK, and
1  tells  how  many  files  were  erased  by  a  SCRATCH  command
(described  later  in  this  chapter).  If  the  error  status is
anything else,  line 60000 prints the error message and halts the
program.
  Because  this  is  a  subroutine,  you access it with the BASIC
GOSUB  command,  either  in immediate mode or from a program. The
RETURN  statement  in line 60010 will jump back to immediate mode
or the next statement in your program, whichever is appropriate."
"[INST]In the context of the C64, What are two common BASIC error messages that may occur when working with data files, and how do they relate to INPUT# and PRINT# statements?[/INST]1581 disk with basic 7,0:  MORE ABOUT INPUT#

  After you begin using data files regularly,  you  may encounter
two BASIC error messages.  They are  'STRING TOO LONG ERROR'  and
'FILE DATA ERROR'.  Both  are  likely  to halt your program at an
INPUT#  statement,  but  may also have been caused by errors in a
PRINT# statement when the file was written."
"[INST]In the context of the C64, What error message is displayed when trying to access a blank diskette in a 1581 disk controller without formatting it first?[/INST]1581 disk: Controller commands error code 74: DRIVE NOT READY
    An  attempt  has  been  made  to  access the 1581 single disk
    without a formatted diskette in place. Blank diskettes cannot
    be used until they have been formatted."
"[INST]In the context of the C64, What happens when you try to write to a non-existent record in a relative file in DOS?[/INST]1581 disk: EXPANDING A RELATIVE FILE

  If  you  underestimate your needs and want to expand a relative
file later, simply request the record number you need, even if it
doesn't  currently exist in the file.  If there is no such record
yet,  DOS  will create it as soon as you try to write information
in  it,  and  also automatically create any other missing records
below it in number.  When the first record beyond the current end
record  is  written,  the  DOS  returns  '50, RECORD NOT PRESENT'
error. This is expected and correct."
"[INST]In the context of the C64, What is the purpose of the buffer pointer in disk memory and how is it used to access and edit individual bytes within a block?[/INST]1581 disk:  THE BUFFER POINTER

  The buffer pointer points to where the next  READ or WRITE will
begin within a disk memory buffer.  By moving the buffer pointer,
you can access individual bytes within a block in any order. This
allows  you to edit any portion of a sector,  or organize it into
fields, like a relative record.

FORMAT FOR THE BUFFER-POINTER COMMAND:

  PRINT#15,'BUFFER-POINTER';channel#;byte

usually abbreviated as: PRINT#15,'B-P';channel#;byte

where  'channel#'  is  the channel number specified when the file
reserving the buffer was opened,  and  'byte'  is  the  character
number within the buffer at which to point (from 0 through 255).

ALTERNATE FORMATS:

  PRINT#15,'B-P:'channel#;byte
  PRINT#15,'B-P:channel#,byte'

EXAMPLE:

  Here  is  a  program  that locks the first program or file on a
diskette.  It works by reading the start of the directory  (Track
40, Sector 3) into disk memory, setting the buffer pointer to the
first  file  type  byte  (see Appendix C for details of directory
organization), locking it by setting bit 6 and rewriting it.

  110 OPEN 15,8,15                 Open command channel.
  120 OPEN 5,8,5,'#'               Open direct access channel.
  130 PRINT#15,'U1';5;0;40;3       Read Track 40, Sector 3.
  140 PRINT#15,'B-P';5;2           Point to Byte 2 of the buffer.
  150 GET#5,A$: IF A$=''
      THEN A$=CHR$(0)              Read it into memory.
  160 A=ASC(A$) OR 64              Turn on bit 6 to lock.
  170 PRINT#15,'B-P';5;2           Point to Byte 2 again.
  180 PRINT#5,CHR$(A);             Overwrite it in buffer.
  190 PRINT#15,'U2';5;0;40;3       Rewrite buffer to diskette.
  200 CLOSE 5                      Tidy up after.
  210 CLOSE 15
  220 END

After the above program is run,  the  first file on that diskette
can  no  longer be erased.  If you later need to erase that file,
rerun the same program, but substitute the revised line 160 below
to unlock the file again:

  160 A=ASC(A$) AND 191            Turn off bit 6 to unlock."
"[INST]In the context of the C64, What is the meaning of error code 50 RECORD NOT PRESENT"" in a disk controller command?""[/INST]1581 disk: Controller commands error code 50: RECORD NOT PRESENT
    The requested record number has not been created yet. This is
    not  an  error  in  a  new relative file or one that is being
    intentionally expanded. It results from reading past the last
    existing  record,  or  positioning  to  a non-existent record
    number with the RECORD# command."
"[INST]In the context of the C64, What is the purpose and behavior of the 'COPYRIGHT CBM 86' file on a 1581 disk?[/INST]1581 disk:  AUTO BOOT LOADER

  During some operations  (power-up reset,  burst INQUIRE,  burst
QUERY,  an  initialize command)  the 1581 will automatically look
for  a  file or the disk named  'COPYRIGHT CBM 86'  that is a USR
type-file.  The format of the file is the same  as that described
previously for the utility loader.  If it is present, the file is
automatically loaded and executed.

  The  automatic  loading  of this file can be disabled by either
renaming it, setting the appropriate flag in the RAM sectors (see
Appendix C),  or  by  setting  a  flag variable in RAM to disable
further autoboots (see JDEJAVU jump table vector in Chapter 10).

  At  the  end of the autobooted program it should return control
to the 1581 via the JCBMBOOTRTN jump table vector."
"[INST]In the context of the C64, What is the function of the PSEEK_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: PSEEK_DV
      $A8     Seeks to the specified physical track."
"[INST]In the context of the C64, What is the error message and explanation for a disk controller's inability to locate the header of a requested data block?[/INST]1581 disk: Controller commands error code READ ERROR (block header not found)
    The  disk  controller  is  unable to locate the header of the
    requested data block.  Caused by an illegal block or a header
    that has been destroyed. Usually unrecoverable."
"[INST]In the context of the C64, What is the function of the TWRT_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: TWRT_DV
       $AC     Writes    a    logical    address   without
                      transferring from the job queue buffer."
"[INST]In the context of the C64, What is the meaning of error code 22 in a disk controller command?[/INST]1581 disk: Controller commands error code 22: READ ERROR (data block not found)
    The  disk  controller  has been requested to read or verify a
    data   block  that  was  not  properly  written.   Occurs  in
    conjunction  with  BLOCK  commands  and  indicates an illegal
    track and/or sector request."
"[INST]In the context of the C64, What is the purpose of the BLOCK-WRITE command in DOS?[/INST]1581 disk:  BLOCK-WRITE

The  purpose  of  a BLOCK-WRITE is to save the contents of a file
buffer  into  a  specified sector.  It is thus the reverse of the
BLOCK-READ  command.  Although  the  BLOCK-WRITE command (B-W) is
still  part of the DOS command set,  it is nearly always replaced
by the U2 command.

FORMAT FOR THE BLOCK-WRITE COMMAND:

  PRINT#15,'U2';channel#;drive#;track#;sector#

where  'channel#'  is the channel number specified  when the file
into  which  the  block will be read was opened;  'drive#' is the
drive number;  and  'track#'  and  'sector#' are respectively the
track  and  sector  numbers that should receive the block of data
being saved from the file buffer.

ALTERNATE FORMATS:

  PRINT#15,'U2:'channel#;drive#;track#;sector#
  PRINT#15,'UB:'channel#;drive#;track#;sector#
  PRINT#15,'U2:channel#,drive#,track#,sector#'

EXAMPLES:

  To restore  Track 40,  Sector 3  of the directory from the disk
buffer filled by a BLOCK-READ, use:

  PRINT#15,'U2';5;0;40;3

You'll return to this example on the next page,  after  you learn
to alter the directory in a useful way.
  You  can  also  use  a  BLOCK-WRITE to write a name in Track 1,
Sector 1,  a  rarely-used  sector.  This  can be used as a way of
marking a diskette  as belonging to you.  Here is a program to do
it, using the alternate form of the BLOCK-WRITE command:

  110 INPUT'YOUR NAME';NA$            Enter a name.
  120 OPEN 15,8,15                    Open command channel.
  130 OPEN 4,8,4,'#'                  Open direct access channel.
  140 PRINT#4,NA$                     Write name to buffer.
  150 PRINT#15,'U2';4;0;1;1           Write buffer to Track1,
  160 CLOSE 4                         Sector 1 of diskette.
  170 CLOSE 15                        Tidy up after.
  180 END

As with the  BLOCK-READ command,  there is a  BLOCK-WRITE command
identical in function to  'U2'  that does not check the track and
sector parameters for valid bounds before attempting to write the
sector. Its format is:

  PRINT#15,'B-o';channel#;drive#;track#;sector#
  (The character after the B- is a shifted W.)

                       or

  PRINT#15,'B-';CHR$(215);channel#;drive#;track#;sector#"
"[INST]In the context of the C64, What are the USER commands available on the 1581 disk and what are their functions?[/INST]1581 disk:  USER COMMANDS

  Most  USER commands are intended to be used as machine language
JMP  or  BASIC  SYS  commands  to  machine language programs that
reside inside the disk memory.  However,  some of them have other
uses  as  well.  The USER1 and USER2 commands are used to replace
the  BLOCK-READ  and BLOCK- WRITE commands, UI re-starts the 1581
without  changing many variables,  UJ cold-starts the 1581 almost
as if it had been turned off and on again.

USER Command                       Function
-----------------------------------------------------------------
U0                     restores default user jump table
U0 + (CMD)             burst utility command
                       (see Chapter 9 Burst Commands)
U1 or UA               block read replacement
U2 or UB               block write replacement
U3 or UC               jump to $0500
U4 or UD               jump to $0503
U5 or UE               jump to $0506
U6 or UF               jump to $0509
U7 or UG               jump to $050C
U8 or UH               jump to $050F
U9 or UI               jump to ($FFFA) reset tables
U: or UJ               power up vector
-----------------------------------------------------------------

  By loading these memory locations with another machine language
JMP  command,  such as JMP $0520,  you can create longer routines
that  operate in the disk's memory along with an easy-to-use jump
table.

FORMAT FOR USER COMMANDS:

  PRINT#15,'Ucharacter';

where  'character' defines one of the preset user commands listed
above.

EXAMPLES:

  PRINT#15,'U:';             Form of DOS RESET command
  PRINT#15,'U3';             Execute program at start of buffer 2"
"[INST]In the context of the C64, What error message is displayed when a diskette or its directory is full and what actions can be taken to resolve the issue?[/INST]1581 disk: Controller commands error code 72: DISK FULL
    Either  the  diskette or its directory is full.  DISK FULL is
    sent  when  two  blocks  are  still  available,  allowing the
    current  file  to be closed.  If you get this message and the
    directory  shows any blocks left,  you have too many separate
    files  in  your  directory,  and  will  need to combine some,
    delete any that are no longer needed, or copy some to another
    diskette.

7"
"[INST]In the context of the C64, What is the purpose of the COLLECT command in BASIC 7.0?[/INST]1581 disk with basic 7,0: COLLECT

  The  COLLECT  command  recalculates  the Block Availability Map
(BAM)  of  the  current  diskette,  allocating only those sectors
still  being  used by valid,  properly closed files and programs.
All other sectors  (blocks) are left unallocated and free for re-
use, and all improperly closed files are automatically scratched.
However,  this  brief  description  of  COLLECT  doesn't indicate
either  the  power or the danger of the command.  Its power is in
restoring  to  good  health  many  diskettes whose directories or
Block Availability Maps have become muddled.  Any time the blocks
used  by  the  files  on a diskette plus the blocks shown as free
don't  add  up to the 3160 available on a fresh diskette, COLLECT
is  needed  (with  one  exception below).  Similarly,  any time a
diskette   contains  an  improperly  closed  file  (splat  file),
indicated  by  an  asterisk  (*)  next  to  its  file type in the
directory, that diskette needs to be collected.  In fact, but for
the one exception below,  it  is a good idea to COLLECT diskettes
whenever  you are concerned about their integrity.  Just note the
number  of  blocks  free  in  the diskette's directory before and
after  using  COLLECT.  If the totals differ,  there was indeed a
problem,  and the diskette should probably be copied onto a fresh
diskette  file-by-file,  using  a  copy  program described in the
previous section, rather than using backup program.
  The  exception  is diskettes containing direct access files, as
described in Chapter 6.  Most direct access (random) files do not
allocate  their  sectors  in a way COLLECT command can recognize.
Thus,  collecting  such a diskette may result in unallocating all
direct access files,  with  loss of all their contents when other
files are added.  Unless specifically instructed otherwise, never
COLLECT  a  diskette containing direct access files. (Note: these
are  not  the  same as the relative files described in Chapter 5.
COLLECT may be used on relative files without difficulty.)

FORMAT FOR THE COLLECT COMMAND:

  COLLECT [,Ddrive#][,Udevice#]"
"[INST]In the context of the C64, What is the cause and solution of the FILE DATA ERROR"" in BASIC programming?""[/INST]1581 disk with basic 7,0: 'FILE DATA' ERROR

  The  other  error  message   'FILE DATA ERROR'   is  caused  by
attempting  to  read  a  non-numeric  character  into  a  numeric
variable.  To a computer, a number is the characters 0 through 9,
the  '+'  and  '-'  signs,  the  decimal  point  (.),  the  SPACE
character, and the letter 'E' used in scientific notation. If any
other character appears in an INPUT# to a numeric variable, 'FILE
DATA ERROR'  will  be  displayed  and the program will halt.  The
usual  causes  of  this error are a mismatch between the order in
which variables are written to  and  read from a file,  a missing
carriage return within a  PRINT#  statement that writes more than
one data item,  or a data item  that includes either a comma or a
colon without a preceding quotation mark.  Once a file data error
has occurred, you should correct it by reading the data item into
a  string  variable,  and converting it back to a number with the
BASIC VAL() statement  after removing non-numeric characters with
the string functions described in your computer user's manual."
"[INST]In the context of the C64, What are the special pattern-matching characters used to load a program from a partial name or to provide selective directories, and how do they work?[/INST]1581 disk: PATTERN MATCHING

  You  can  use  special  pattern-matching  characters  to load a
program   from  a  partial  name  or  to  provide  the  selective
directories described earlier.
  The  two  characters  used in pattern matching are the asterisk
(*)  and  the question mark  (?).  They act something like a wild
card in a game of cards.  The difference between the two  is that
the  asterisk  makes  all  characters in  and beyond its position
wild,  while  the question mark makes only its own position wild.
Here are some examples and their results:

  LOAD'A*',8  loads the first file on disk that begins with an A,
  regardless of what follows

  DLOAD'SM?TH'  loads  the  first  file that starts with SM, ends
  with TH, and one other character between

  DIRECTORY'Q*'  loads  a  directory  of  files whose names begin
  with Q

  LOAD'*',8  is a special case. When an asterisk is used alone as
  a name,  it matches the last file used  (on the C64 and C128 in
  C64 mode).

  LOAD '0:*',8 loads the first file on the diskette (C64 and C128
  in C64 mode).

  DLOAD'*'  loads the first file on the diskette (Plus/4 and C128
  in C128 mode)."
"[INST]In the context of the C64, What is the reason behind the 'STRING TOO LONG' error in Commodore's BASIC 7.0 when reading data from a disk file?[/INST]1581 disk with basic 7,0: 'STRING TOO LONG' ERROR

  A BASIC string may be up to 255 characters long,  although  the
longest string you can enter via a single INPUT statement is just
under two lines of text. This lower limitation is due to the size
of the input buffer in Commodore's serial bus computers. The same
limit  applies  to  INPUT#  statements.  If a single data element
(string  or  number)  being  read from a disk file into an INPUT#
statement  contains  more  than  88  (BASIC 2)  and 160 (BASIC 7)
characters, BASIC will halt with a 'STRING TOO LONG ERROR'."
"[INST]In the context of the C64, What are the steps to print a directory in Commodore 64 BASIC?[/INST]1581 disk: PRINTING A DIRECTORY

  To printout a directory, use the following:

  LOAD'$',8
  OPEN 4,4:CMD 4:LIST
  PRINT#4:CLOSE 4"
"[INST]In the context of the C64, How do you handle renaming and deleting files with troublesome filenames, such as those containing commas, shifted spaces, or non-printing characters, in BASIC 7.0?[/INST]1581 disk with basic 7,0: RENAMING AND SCRATCHING TROUBLESOME FILES

  Eventually,  you  may  run  across  a  file  which  has a crazy
filename,  such as a comma by itself (',') or one that includes a
Shifted  Space.  Or  perhaps you will find one that includes non-
printing  characters.  Any  of  these  can be troublesome.  Comma
files,  for  instance,  are  an exception to the rule that no two
files can have the same name.  Since  it shouldn't be possible to
make  a  file whose name is only a comma,  the disk never expects
you to do it again.
  Files  with  a   Shifted  Space  in  their  name  can  also  be
troublesome,  because  the  disk  interprets the Shifted Space as
signaling  the end of the file name,  and prints whatever follows
after  the  quotation  mark  that  marks the end of a name in the
directory.  This  technique can be useful by allowing you to have
a long file name,  and  making the disk recognize a small part of
it  as  being  the same as the whole thing without using pattern-
matching characters.
  In any case,  if  you have a troublesome filename,  you can use
the  CHR$()  function  to  specify troublesome characters without
typing  them  directly.  This  may allow you to build them into a
RENAME  command.  If  this  fails,  you may also use the pattern-
matching characters  discussed for a SCRATCH command.  This gives
you  a  way  to  specify  the  name without using the troublesome
characters at all, but also means loss of your file.
  For  example,  if  you  have  managed  to  create  a file named
''MOVIES',  with an extra quotation mark at the front of the file
name,  you can rename it to  'MOVIES' using the CHR$() equivalent
of a quotation mark in the RENAME command:

  RENAME (CHR$(34)+'MOVIES') TO 'MOVIES'

The  CHR$(34)  forces  a  quotation  mark into the command string
without  upsetting  BASIC.  The  procedure  for  a file name that
includes a Shifted Space is similar, but uses CHR$(160).
  In cases  where even this doesn't work,  for  example,  if your
diskette contains a comma file,  (one named ',')  you can get rid
of it this way:

  SCRATCH '?'

  This example deletes all files with one-character names.

  Depending  on  the  exact  problem,  you  may  have  to be very
creative in choosing pattern-matching characters that will affect
only  the desired file,  and may have to rename other files first
to keep them from being scratched.
  In  some  cases,  it  may  be easier to copy desired files to a
different diskette and leave the troublesome files behind."
"[INST]In the context of the C64, What error message is displayed when the Block Availability Map (BAM) on a diskette does not match the copy in disk memory?[/INST]1581 disk: Controller commands error code 71: DIRECTORY ERROR
    The  BAM  (Block  Availability  Map) on the diskette does not
    match  the  copy in disk memory.  To correct,  Initialize the
    diskette."
"[INST]In the context of the C64, What is the format and requirements for using the UTILITY LOADER command to load a user-type file into drive RAM?[/INST]1581 disk:  UTILITY LOADER

  This command loads a user-type  (USR)  file into the drive RAM.
The  first  two  bytes  of the file must contain the low and high
addresses   respectively.   The  third  byte  is  the  amount  of
characters to follow.  In the addition,  a trailing checksum byte
must be included. The load address is the starting address.

FORMAT FOR THE UTILITY LOADER COMMAND:

  PRINT#15,'&0:filename'

  To return from this routine,  the  program  should  end with an
RTS."
"[INST]In the context of the C64, What are the original block-read and block-write commands, their formats, and how do they differ from the U1 and U2 commands?[/INST]1581 disk:  THE ORIGINAL BLOCK-READ AND BLOCK-WRITE COMMANDS

  Although  the  BLOCK-READ  and  BLOCK-WRITE commands are nearly
always  replaced  by  the  U1  and  U2 commands respectively, the
original  commands  can  still  be  used,  as  long  as you fully
understand their effects. Unlike U1 and U2, B-R and B-W allow you
to read or write less than a full sector. In the case of B-R, the
first  byte  of  the  selected  sector  is used to set the buffer
pointer (see next section), and determines how many bytes of that
sector are read into a disk memory buffer. A program may check to
be sure it  doesn't attempt to read past the end of data actually
loaded  into  the  buffer,  by watching for the value of the file
status  variable  ST  to change from 0 to 64.  When the buffer is
written  back  to diskette by B-W,  the first byte written is the
current  value  of  the buffer pointer.  Only that many bytes are
written into the specified sector. B-R and B-W may thus be useful
in working with custom-designed file structures.

FORMAT FOR THE ORIGINAL BLOCK-READ AND BLOCK-WRITE COMMANDS:

  PRINT#15,'BLOCK-READ';channel#;drive#;track#;sector#

abbreviated as: PRINT#15,'B-R';channel#;drive#;track#;sector#

and

  PRINT#15,'BLOCK-WRITE';channel#;drive#;track#;sector#

abbreviated as: PRINT#15,'B-W';channel#;drive#;track#;sector#

where  'channel#'  is  the channel number specified when the file
into  which  the  block will be read was opened,  'drive#' is the
drive number, and 'track#' and 'sector#' are the track and sector
numbers containing the desired block of data to be partially read
into or written from the file buffer.


|   In a true BLOCK-READ, the first byte of the selected sector |
| is  used  to  determine how many bytes of that sector to read |
| into the disk  memory buffer.  It thus cannot be used to read |
| an entire sector  into the buffer,  as the first data byte is |
| always  interpreted  as  being  number of characters to read, |
| rather than part of the data.                                 |
|   Similarly,  in  a  true  BLOCK-WRITE,  when  the  buffer is |
| written  back  to  diskette,  the  first  byte written is the |
| current value of the  buffer  pointer.  Only  that many bytes |
| are written into the specified  sector.  It cannot be used to |
| rewrite an entire sector onto diskette unchanged, because the |
| first data byte is overwritten by the buffer pointer.         |"
"[INST]In the context of the C64, What is the error message indicating a CRC error in a data block on a disk?[/INST]1581 disk: Controller commands error code 23: READ ERROR (CRC error in data block)
    There is an error in the data.  The sector has been read into
    disk memory, but its CRC is wrong."
"[INST]In the context of the C64, What is the function of the TPREAD_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: TPREAD_DV
     $B2     Reads    a    physical    address   without
                      transferring to the job queue buffer."
"[INST]In the context of the C64, What are the rules and procedures for creating and managing partitions and sub-directories on a 1581 disk?[/INST]1581 disk:  PARTITIONS AND SUB-DIRECTORIES

  The 1581 allows the user to create partition areas on the disk.
Partitions were originally implemented to provide a mechanism for
easily  protecting  a  particular  section  of  the disk. That is
useful  for  permanently  allocating  part of the disk for things
such as BOOT sectors, CP/M work area, or reserving space for user
defined random files.
  Normally,  sectors on the disk can be marked as used by setting
the appropriate bit in the RAM  (most easily done with the BLOCK-
ALLOCATE  command).  That prevents them from being overwritten. A
VALIDATE command, however, will de-allocate this area. To protect
these  special  blocks from being de-allocated during a VALIDATE,
place them in a user defined partition area. The VALIDATE command
in  the  1581  automatically  skips  over  file  entries that are
partition files (file type = CBM),  which guarantees the intended
area is, and remains, allocated.
  Partition areas are given names by the user when first created.
They appear in the main directory as file type CBM.
  A partition area is created by the following command:

  PRINT#15,'/0:partition name,'+CHR$(starting track)+CHR$
  (starting sector)+CHR$(<# of sectors)+CHR$(># of sectors)+',C'

  Large  enough  partitions  can also be used as sub-directories.
There are, however, certain limitations if a partition area is to
be used as a sub-directory area.

  1) The partition are must be at least 120 sectors in size.
  2) The starting sector must be 0.
  3) The ending sector must be a multiple of 40.
  4) The area to be allocated cannot contain track 40 (the
     original system track).

  Partitions  can  also  be  created with a partition. This means
that  sub-sub-directories can be created if their partitions meet
the above rules. 

  Partition  areas  which meet the qualifications of being a sub-
directory can then be selected by the following command:

  PRINT#15,'/0:partition name'

  Once  selected,  the  partition  are  cannot  be used as a sub-
directory until it is formatted.  The  HEADER or NEW commands are
used  to  format  this  sub-disk  area.  Make  sure that you have
successfully  selected  this partition area before formatting. If
not, the wrong directory area will be reformatted.  You can check
if  the  area  was  successfully  selected  by checking the error
channel. If everything went OK, the error channel would read:

  02, SELECTED PARTITION,first track#,last track#

  If   the   area  you  attempt  to  select  does  not  meet  the
qualifications of a sub-directory,  then  the error channel would
return:

  77, SELECTED PARTITION ILLEGAL,00,00

  Only  one  level of sub-directory can be selected at a time. To
get from the ROOT to PART21 you would have to execute the command
twice.

  PRINT#15,'/0:PART2'
  PRINT#15,'/0:PART21'

  Directories  can only be traversed in the forward direction. To
get  to  sub-directory  which  is  on  a node above the presently
selected node of the tree, you must select the ROOT directory and
work your way down the tree, selecting a branch at a time. To get
to the ROOT directory directly from any node type:

  PRINT#15,'/'

  When the user selects a particular sub-directory area,  it then
becomes  the  default  working  area.  Accesses  to  the disk for
directories, loading files, saving files, etc.,  will all be done
within  this  area.  Files  outside  of  the  selected  area  are
effectively invisible.
  File  and  local BAM information for sub-directories are stored
within  the  sub-directory  areas themselves.  The information is
stored  on  the  first allocated track of the partition area, and
has the same format as track 40.  When  creating  partitions  and
sub-directories  within  sub-directories it is the responsibility
of  the  user  to  make  sure  that  he  doesn't  overwrite  this
information!  The  DOS  only  checks  to make sure that you don't
attempt  to  overwrite  this  information  for the ROOT directory
(track 40).  It  is  up  to  the  user  to  make  sure  that this
information isn't corrupted in the sub-directories.
  Partitioned  areas  can  be freed up  simply by  SCRATCHING the
partition  file  entry  in  the  appropriate  directory.  If  the
partition was being used as a sub-directory,  all of the files in
that sub-directory will be lost."
"[INST]In the context of the C64, What is the purpose and syntax of the MEMORY-WRITE command in the context of the 1581 disk drive?[/INST]1581 disk:  MEMORY-WRITE

  The  MEMORY-WRITE  command is the equivalent of the  BASIC POKE
command,  but has its effect in disk memory instead of within the
computer.  M-W  allows you to write up to 35 bytes at a time into
disk  memory.  The  MEMORY-EXECUTE  and some USER commands can be
used to run any programs written this way:

FORMAT FOR THE MEMORY-WRITE COMMAND:

  PRINT#15,'M-W'CHR$(<address)CHR$(>address)CHR$(# of bytes)
           CHR$(data byte(s))

where  '<address'  is the low order part,  and  '>address' is the
high order part of the address  in disk memory  to begin writing,
'# of bytes'  is  the  number  of  memory  locations that will be
written (from 1-35),  and 'data byte' is 1 or more byte values to
be written into disk memory, each as a CHR$() value.

EXAMPLES:

We  can  use  this line to turn off the 'bumps' when loading DOS-
protected  programs  (i.e.,  programs  that  have  been protected
against  being  copied by creating and checking for specific disk
errors).

  PRINT#15,'M-W'CHR$(48)CHR$(0)CHR$(1)CHR$(133)

  The following line can be used to recover bad sectors,  such as
when  an  important  file  has  been  damaged  and cannot be read
normally:

  PRINT#15,'M-W'CHR$(48)CHR$(0)CHR$(1)CHR$(31)

  These two examples may be very useful under some circumstances.
They   are   the   equivalent   of   POKE 48,133  and  POKE 48,31
respectively,  but  in  disk memory,  not inside the computer. As
mentioned in the previous section's first example, location 48 in
the  1581  disk  drive  signifies  two separate activities to the
drive,  all related to error recovery.  Bit 7  (the high bit), if
set means no  'bumps'  (don't move the read head to track 1). The
bottom six bits are the count of how many times the disk will try
to  read  each  sector  before  and  after trying seeks and bumps
before  giving  up.  Since  31  is the largest number that can be
expressed  in  six  bits,  that  is  the  maximum number of tries
allowed.
  From this example,  you  can see the value of knowing something
about  PEEKS,  POKES,  and  machine-language before using direct-
access disk commands, as well as their potential power."
"[INST]In the context of the C64, What are the return codes and their descriptions for a disk controller job?[/INST]1581 disk:  Controller JOB Return Codes

Name            Code  Description
OK_DV            $0x  No error.
MISHD_DV_ER      $02  Can't find header block.
NOADAM_DV_ER     $03  No address mark detected.
MISDBLK_DV_ER    $04  Data block not present.
CRCDBLK_DV_ER    $05  CRC error encountered in data block.
FMT_DV_ER        $06  Format error.
VERERR_DV_ER     $07  Verify error.
WRTPR_DV_ER      $08  Attempt to write to a write protected disk.
CRCHD_DV_ER      $09  CRC error encountered in header block.
                 $0A  Reserved.
DSKCHG_DV_W      $0B  Disk was changed/disk ID mismatch.
DSKNTLOG_DV_ER   $0C  Disk format not logical.
CONTROLLER_DV_ER $0D  Floppy disk controller IC error.
SYNTAX_DV_ER     $0E  Syntax error. Invalid job number.
NODSKPRS_DV_ER   $0F  No disk is present in the drive."
"[INST]In the context of the C64, What is the meaning of the PARTITION SELECTED"" error code returned by a disk controller command?""[/INST]1581 disk: Controller commands error code PARTITION SELECTED (not an error)
    The disk partition requested has been selected."
"[INST]In the context of the C64, What is a sequential data file and how does it work on a diskette?[/INST]1581 disk with basic 7,0: SEQUENTIAL DATA FILES


  A file on a diskette is just like a file cabinet in your office
-- an organized place to put things. Nearly everything you put on
a diskette goes in one kind of file or another. So far all you've
used are program files,  but there are others.  In  this  chapter
you'll learn about sequential data files.
  The primary purpose of a data file  is to store the contents of
program variables, so they won't be lost when the program ends. A
sequential  data  file  is  one  in  which  the  contents  of the
variables are stored 'in sequence',  one right after another. You
may  already  be  familiar  with  sequential  files  from using a
DATASSETTE,  because  sequential  files on diskette are just like
the  data  files  used  on  cassettes.  Whether  on  cassette  or
diskette, sequential files must be read from beginning to end.
  When  sequential  files  are  created,  information  (data)  is
transferred  byte-by-byte,  through  a buffer,  onto the magnetic
media.  Once  in  the disk drive, program files,  sequential data
files,  and user files all work sequentially.  Even the directory
acts like a sequential file.
  To use sequential files properly, we will learn some more BASIC
words  in  the next few pages.  Then we'll put them together in a
simple but useful program.


|   Besides  sequential  data  files,  two other file types are |
| recorded sequentially on a diskette.  They are program files, |
| and user files.  When you save a program on a diskette, it is |
| saved  in  order  from  beginning  to  end,   just  like  the |
| information in a sequential data file. The main difference is |
| in the commands you use to access it.  User files can be even |
| more similar to sequential data files.  User files are almost |
| never used,  but like program files, they could be treated as |
| though  they  were  sequential  data  files  and  some can be |
| accessed with the same commands.                              |
|   For the advanced user,  the similarity  of the various file |
| types  offers  the possibility of reading a program file into |
| the computer a byte (character) at a time and rewriting it to |
| the diskette in a modified form.                              |"
"[INST]In the context of the C64, What are the key features and capabilities of the Commodore 1581 disk drive?[/INST]The  Commodore 1581  is a versatile 3.5' disk drive that can be
used with a variety of computers,  including  the  COMMODORE 128,
the COMMODORE 64, the Plus 4, COMMODORE 16, and VIC 20.
  Also,  in  addition to the convenience of 3.5' disks,  the 1581
offers the following features:

  o Standard  and  fast  serial data transfer rates  --  The 1581
    automatically selects the proper data transfer rate  (fast or
    slow) to match the operating modes available on the Commodore
    128 computer.

  o Double-sided, double-density MFM data recording  --  Provides
    more than 800K formatted storage capacity per disk (400K+ per
    side).

  o Special high-speed burst commands -- These commands, used for
    machine language programs, transfer data several times faster
    than the standard or fast serial rates."
"[INST]In the context of the C64, What is the syntax and usage of the CLOSE statement in BASIC 2.0 and BASIC 7.0, and how can you close all open files at once?[/INST]1581 disk with basic 7,0: FORMAT FOR THE CLOSE STATEMENT:

  BASIC 7.0:  DCLOSE#file#[,Udevice#]
  BASIC 2.0:  CLOSE file#

where 'file#' is the same file number given in the desired file's
current OPEN statement.

EXAMPLES:

  To  close  the  data file #5 used as an example on the previous
page, use:

  BASIC 7.0:  DCLOSE#5
  BASIC 2.0:  CLOSE 5

  In BASIC 7.0,  when the DCLOSE statement is used alone (no # or
file# parameters),  it closes all disk files at once.  With a bit
of planning, the same can be done via a program loop. Since there
is no harm in closing a file  that wasn't open,  close every file
you  even  think  might  be  open before ending a program. If you
always gave your files numbers  between 1 and 5,  you could close
them all with

  9950 FOR I=1 TO 5
  9960 CLOSE I
  9970 GOSUB 59990: REM CHECK FOR DISK ERRORS
  9980 NEXT I

assuming your program includes an error check subroutine like the
one in the last chapter."
"[INST]In the context of the C64, What is the error message displayed when a disk controller encounters a format error?[/INST]1581 disk: Controller commands error code 75: FORMAT ERROR"
"[INST]In the context of the C64, What error message would indicate a problem with the floppy disk controller IC (WD177x)?[/INST]1581 disk: Controller commands error code 76: CONTROLLER ERROR
    The  floppy  disk controller  IC (WD177x)  is not functioning
    properly."
"[INST]In the context of the C64, What is the command to format a new diskette on a Commodore computer?[/INST]HOW TO PREPARE A NEW DISKETTE

  A diskette needs a pattern of circular magnetic tracks in order
for  the  drive's  read/write  head  to  find  things on it. This
pattern is not on your diskettes  when you buy them,  but you can
use  the  HEADER  command  or  the  NEW  command  to  add it to a
diskette.  That  is  known  as  formatting the disk.  This is the
command to use with the C128 in C128 mode or Plus/4:

  HEADER 'diskette name',Iid,Ddrive#[,Udevice#]

where 'diskette name' is any desired name for the diskette, up to
16  characters  long  (including spaces).  'id'  can  be  any two
characters as long as they don't form a BASIC keyword (such as IF
or  ON)  either  on  their own or with the capital I before them.
'drive#' is 0.  'device#' is 8, unless you have changed it as per
instructions in Appendix A  (the 1581 assumes 8 even if you don't
type it in).

  The command for the C64, VIC 20, or C128 in C64 mode is this:

  OPEN 15,device#,15,'NEWdrive#:diskette name,id'
  CLOSE 15

  The  device#,  drive#,  diskette  name,  and id are the same as
described above."
"[INST]In the context of the C64, How does the INPUT# statement in BASIC differ from the INPUT statement, and what are some limitations of using INPUT# to read data from a file?[/INST]1581 disk with basic 7,0: READING FILE DATA: USING INPUT#

  Once  information has been written properly to a diskette file,
it  may  be read back into the computer with an INPUT# statement.
Just  as  the  PRINT# statement is much like the PRINT statement,
INPUT#  is  nearly  identical to  INPUT,  except that the list of
items  following  the  command  word comes from a particular file
instead of the keyboard.  Both statements are subject to the same
limitations-halting  input after a comma or colon,  not accepting
data  items  too  large  to  fit in BASIC's input buffer, and not
accepting non-numeric data into a numeric variable."
"[INST]In the context of the C64, What is the purpose of the OPEN statement in Commodore BASIC and how does it interact with various devices in a Commodore computer system?[/INST]1581 disk with basic 7,0:  OPENING A FILE

  One  of  the most powerful tools in Commodore BASIC is the OPEN
statement.  With it, you may send data almost anywhere, much like
a telephone switchboard.  As you might expect, a command that can
do  this  much  is  fairly  complex.  You  have already used OPEN
statements regularly in some of your diskette commands.
  Before you study the format of the OPEN statement, let's review
some of the possible devices in a Commodore computer system.

Device#:  Name:   Used for:
-----------------------------------------------------------------
0     Keyboard    Receiving input from the computer operator
1     DATASSETTE  Sending and receiving information from cassette
2     RS232       Sending and receiving information from a modem
3     Screen      Sending output to a video display
4,5   Printer     Sending output to a hard copy printer
8-11  Disk Drive  Sending and receiving information from diskette
-----------------------------------------------------------------

  Because of the flexibility of the OPEN statement it is possible
for  a  single  program  statement  to  contact  any one of these
devices,  or  even  others,  depending  on  the value of a single
character in the command. If the character is kept in a variable,
the  device can even change each time that part of the program is
used,  sending  data alternately and with equal ease to diskette,
cassette, printer and screen.


|   In  the  last  chapter  you  learned  how to check for disk |
| errors  after  disk  commands  in  a  program.  It is equally |
| important  to check for disk errors after using file-handling |
| statements.  Failure  to  detect  a  disk  error before using |
| another file-handling statement could cause loss of data, and |
| failure of the BASIC program.                                 |
|   The  easiest  way  to check the disk is to follow all file- |
| handling statements with a GOSUB statement  to an error check |
| subroutine.                                                   |
|                                                               |
| EXAMPLE:                                                      |
|                                                               |
|   BASIC 7.0:  840 DOPEN#4,'DEGREE DAY DATA',D0,U8,W           |
|               850 GOSUB 59990: REM CHECK FOR DISK ERRORS      |
|                                                               |
|   BASIC 2.0:  840 OPEN 4,8,4,'0:DEGREE DAY DATA,S,W'          |
|               850 GOSUB 59990: REM CHECK FOR DISK ERRORS      |
|                                                               |
+---------------------------------------------------------------+"
"[INST]In the context of the C64, What message appears when the error channel is checked after using the SCRATCH command?[/INST]1581 disk: Controller commands error code FILES SCRATCHED

    This  is  the  message that appears when the error channel is
    checked  after  using  the SCRATCH command.  The track number
    tells how many files were erased."
"[INST]In the context of the C64, What is the function of the FORMATDK_DV command in a disk controller job?[/INST]1581 disk Controller Job commands: FORMATDK_DV
   $F0     Formats  the disk with the default physical
                      format."
"[INST]In the context of the C64, What is the format of the MEMORY-READ command in Commodore disk commands?[/INST]1581 disk: FORMAT FOR THE MEMORY-READ COMMAND:

  PRINT#15,'M-R'CHR$(<address)CHR$(>address)CHR$(# of bytes)

where  '<address'  is the low order part,  and  '>address' is the
high order part of the address in disk memory to be read.  If the
optional  '# of bytes'  is specified,  it selects how many memory
locations will be read in,  from 1-256  (# of bytes = 0 for 256).
Otherwise, 1 character will be read.

  The next byte read using the GET# statement through channel #15
(the  error  channel),  will  be  from  that  address in the disk
controller's memory, and successive bytes will be from successive
memory locations.
  Any  INPUT#  from  the error channel will give peculiar results
when you're using this command. This can be cleared up by sending
any other command to the disk, except another memory command.

EXAMPLES:

  To  see  how many tries the disk will make to read a particular
sector,  and  whether  'bumps'  to  track  one  and  back will be
attempted before declaring the sector unreadable, you can use the
following  lines.  They  will read a special variable in the zero
page  of  disk  memory,  called  REVCNT.  It  is  located  at $30
hexadecimal.

110 OPEN 15,8,15                            Open command channel.
120 PRINT#15,'M-R'CHR$(48)CHR$(0)           Same as G=PEEK(48).
130 GET#15,G$: IF G$='' THEN G$=CHR$(0)
140 G=ASC(G$)
150 B=G AND 128:B$='ON':IF B THEN B$='OFF'  Check bit 7.
160 T=G AND 31: PRINT'# OF TRIES IS';T      Check bits 0-5
170 PRINT 'BUMPS ARE';B$                    and give results.
180 CLOSE 15                                Tidy up after.
190 END

Here's  a  more  general  purpose  program that reads one or more
locations anywhere in disk memory:

110 OPEN 15,8,15                            Open command channel.
120 INPUT '# OF BYTES TO READ (0=END)';NL   Enter number of bytes
                                            wanted
130 IF NL<1 THEN CLOSE 15: END              unless done.
140 IF NL>255 THEN 120                      or way out of line.
150 INPUT 'STARTING AT ADDRESS';AD          Enter starting
                                            address.
160 AH=INT(AD/256): AL=AD-AH*256            Convert it into disk
                                            form.
170 PRINT#15,'M-R'CHR$(AL)CHR$(AH)CHR$(NL)  Actual Memory-Read.
180 FOR I=1 TO NL                           Loop until have all
                                            the data,
190 GET#15,A$: IF A$='' THEN A$=CHR$(0)
200 PRINT ASC(A$);                          printing it as we go,
210 NEXT I
220 PRINT
230 GOTO 120                                forever."
"[INST]In the context of the C64, What is the command to free a block of data on a disk in DOS, and what is its format?[/INST]1581 disk:  FREEING BLOCKS

  The  BLOCK-FREE  command is the opposite of  BLOCK-ALLOCATE. It
frees  a  block  that you don't need any more,  for re-use by the
DOS.  BLOCK-FREE  updates  the BAM to show a particular sector is
not in use, rather than actually erasing any data.

FORMAT FOR BLOCK-FREE COMMAND:

  PRINT#15,'BLOCK-FREE';drive#;track#;sector#

abbreviated as: PRINT#15,'B-F';drive#;track#;sector#

where  'drive#' is the drive number,  and  'track#' and 'sector#'
are  respectively  the  track  and  sector numbers containing the
desired block of data to be read into the file buffer.

ALTERNATE FORMAT:

  PRINT#15,'B-F:';drive#;track#;sector#

EXAMPLE:

  To  free  the  sector  in which we wrote our name in the BLOCK-
WRITE example, and allocated in the first BLOCK-ALLOCATE example,
we could use the following command:

  PRINT#15,'B-F';0;1;1"
"[INST]In the context of the C64, What is the command and format to execute a machine language program or subroutine stored in disk memory on a 1581 disk?[/INST]1581 disk:  MEMORY-EXECUTE

  Any routine in disk memory,  either  in  RAM  or  ROM,  can  be
executed with the MEMORY-EXECUTE command. It is the equivalent of
the  BASIC  SYS call to a machine language program or subroutine,
but works in disk memory instead of within the computer.

FORMAT FOR THE MEMORY-EXECUTE COMMAND:

  PRINT#15,'M-E'CHR$(<address)CHR$(>address)

where  '<address'  is the low order part,  and  '>address' is the
high order part of the address in disk memory  at which execution
is to begin.

  Most  uses  require intimate knowledge of the inner workings of
the  DOS,  and  preliminary  setup  with other commands,  such as
MEMORY-WRITE.

  The  routine  should  end  with an RTS to return control to the
1581."
"[INST]In the context of the C64, What does error code 67 on a disk controller indicate?[/INST]1581 disk: Controller commands error code 67: ILLEGAL SYSTEM T OR S
    This special error message indicates an illegal system  track
    or sector."
"[INST]In the context of the C64, How does a file-handling program using random files keep track of which blocks on the disk have been used?[/INST]1581 disk:  USING RANDOM FILES

  By combining the commands in this chapter,  it  is  possible to
develop a file-handling program that uses random files.  What you
need to know now is how to keep track of which blocks on the disk
such a file has used. (Even though you know a sector has not been
allocated by your random file,  you  must  also be sure it wasn't
allocated by another unrelated file on the diskette.)
  The  most  common way of recording which sectors have been used
by  a  random  file is in a sequential file.  The sequential file
stores a list of record numbers, with the track, sector, and byte
location of each record.  This means three channels are needed by
a random file:  one  for the command channel,  one for the random
data, and the last for the sequential data."
"[INST]In the context of the C64, What is the format for temporarily changing the disk device number in Commodore computers?[/INST]1581 disk: FORMAT FOR TEMPORARILY CHANGING THE DISK DEVICE NUMBER:

  PRINT#15,'U0>'+CHR$(n)

  Where n = 8 to 30

EXAMPLE:

  Here is a program that sets any device number:

   5 INPUT 'OLD DEVICE NUMBER';ODV
  10 INPUT 'NEW DEVICE NUMBER';DV
  20 IF DV<8 OR DV>30 THEN 10
  30 OPEN 15,ODV,15,'U0>'+CHR$(DV): CLOSE 15

+---------------------------- NOTE -----------------------------+
|   If  you  will  be  using  two  disk  drives,  and  want  to |
| temporarily change the device number of one, you will need to |
| run the above program with the disk drive whose device number |
| not to be changed turned off. After the program has been run, |
| you may turn that drive back on.  If you need to connect more |
| than  two  drives at once,  you will need to use the hardware |
| method of changing device numbers.                            |
+---------------------------------------------------------------+"
"[INST]In the context of the C64, What is the function of the TPWRT_DV command in a disk controller job?[/INST]1581 disk Controller Job commands: TPWRT_DV
      $B4     Writes    a    physical   address   without
                      transferring from the job queue buffer."
"[INST]In the context of the C64, What is the importance of closing a file after using it ?[/INST]1581 disk with basic 7,0: CLOSING A FILE

  After you finish using a data file,  it  is extremely important
that you CLOSE it.  During the process of writing a file, data is
accumulated  in  a  memory  buffer,  and  only written out to the
diskette when the buffer fills.
  Working this way, there is almost always a small amount of data
in  the  buffer  that  has  not been written to diskette yet, and
which would simply be lost if the computer system were tuned off.
Similarly,  there  are  diskette  housekeeping  matters,  such as
updating the BAM  (Block Availability Map) of sectors used by the
current file,  which are not performed during the ordinary course
of  writing  a  file.  This  is  the  reason  for  having a CLOSE
statement.  When  you  are done with a file,  the CLOSE statement
will  write  the  rest of the data buffer out to diskette, update
the  BAM,  and complete the file's entry in the directory. Always
close  a  data file when you are done using it.  Failure to do so
may cause loss of the entire file.
  However,  do not close the disk command channel until all other
files  have been closed.  The command channel should be the first
file opened, and the last file closed in any program."
"[INST]In the context of the C64, How can you create a sub-directory that lists a single selected type of file using the LOAD or DIRECTORY command?[/INST]1581 disk: SELECTIVE DIRECTORIES

  By altering the directory  LOAD command,  you can create a sub-
directory that lists a single selected type of file. For example,
you  could  request  a list of all sequential data files (Chapter
4), or one of all the relative data files (Chapter 5). The format
for this command is:

  LOAD'$0:pattern=filetype',8    (for the C64)

where pattern specifies a particular group of files, and filetype
is  the  one-letter  abbreviation  for  the types of files listed
below:

  P = Program
  S = Sequential
  R = Relative
  U = User

The command for the C128 and Plus/4 is this:

  DIRECTORY'pattern=filetype'

Some examples:

  LOAD'$0:*=R',8  and  DIRECTORY'*=R' display all relative files.

  LOAD'$0:Z*=R',8  and  DIRECTORY'Z*=R'  display  a sub-directory
  consisting of all relative files  that start with the letter Z.
  (the asterisk (*) is explained in the Section 1.10.)"
"[INST]In the context of the C64, What is the syntax and usage of the DCLEAR command in a CP/M system?[/INST]1581 disk with basic 7,0:FORMAT FOR THE DCLEAR COMMAND:

  DCLEAR [Ddrive#]"
"[INST]In the context of the C64, What is the purpose of the BLOCK-READ command in DOS?[/INST]1581 disk:  BLOCK-READ

  The  purpose  of  a  BLOCK-READ  is  to  load the contents of a
specified  sector  into  a  file buffer.  Although the BLOCK-READ
command (B-R) is still part of the DOS command set,  it is nearly
always replaced the U1 command (See Chapter 6).

FORMAT FOR THE BLOCK-READ COMMAND:

  PRINT#15,'U1';channel#;drive#;track#;sector#

where  'channel#'  is  the channel number specified when the file
into  which  the  block will be read was opened,  'drive#' is the
drive number,  and  'track#'  and  'sector#' are respectively the
track  and sector numbers containing the desired block of data to
be read into the file buffer.

ALTERNATE FORMATS:

  PRINT#15,'U1:'channel#;drive#;track#;sector#
  PRINT#15,'UA:'channel#;drive#;track#;sector#
  PRINT#15,'U1:channel#,drive#,track#,sector#'

EXAMPLE:

  Here  is  a  complete program to read a sector into disk memory
using  U1,  and  from  there into computer memory via GET#. (If a
carriage  return will appear at least once in every 88 characters
of data, INPUT# may be used in place of GET#).

  110 MB=7936: REM $1F00            Define a memory buffer.
  120 INPUT'TRACK TO READ';T        Select a track
  130 INPUT'SECTOR TO READ';S       and sector.
  140 OPEN 15,8,15                  Open command channel.
  150 OPEN 5,8,5,'#'                Open direct access channel.
  160 PRINT#15,'U1';5;0;T;S         Read sector into disk buffer.
  170 FOR I=MB TO MB+255            Use a loop to
  180 GET#5,A$: IF A$=''            copy disk buffer
      THEN A$=CHR$(0)               into computer memory.
  190 POKE I,ASC(A$)
  200 NEXT
  210 CLOSE 5:CLOSE 15              Tidy up after.
  220 END

  As the loop progresses, the contents of the specified track and
sector are copied into computer memory,  beginning at the address
set by variable MB in line 160,  and  may be examined and altered
there.

  The  DOS  always checks that the track and sector parameters of
the  BLOCK-READ  command are within the proper range.  If they're
not,  a '66, ILLEGAL TRACK AND SECTOR'  error occurs.  In certain
instances it might be necessary to access a track and sector that
are not within what the DOS considers the proper bounds.  This is
a  special  case  and,  unless  absolutely  necessary,  should be
avoided. Nonetheless, there is a command identical in function to
'U1' that doesn't check to see if the track and sector parameters
are within bounds before attempting to read it. Its format is:

  PRINT#15,'B-_';channel#;drive#;track#;sector#
  (The character following the B- is a shifted R.)

                        or

  PRINT#15,'B-';CHR$(210);channel#;drive#;track#;sector#"
"[INST]In the context of the C64, What error message is displayed when trying to select a partition that does not meet the criteria of a directory partition?[/INST]1581 disk: Controller commands error code 77: SELECTED PARTITION ILLEGAL
    An attempt has been made to select a partition  that does not
    meet the criteria of a directory partition."
"[INST]In the context of the C64, What is the format for opening a direct access file on a 1581 disk, and how do you specify the memory buffer to use?[/INST]1581 disk:  OPENING A DATA CHANNEL FOR DIRECT ACCESS

  When  working  with  direct access data,  you need two channels
open to the disk:  the  command channel we've used throughout the
book,  and  another for data.  The command channel is opened with
the  usual  OPEN 15,8,15  or  equivalent.  A  direct  access data
channel  is  opened  much like other files,  except that the hash
sign (#),  optionally followed by a memory buffer number, is used
as a file name.

FORMAT FOR DIRECT ACCESS FILE OPEN STATEMENTS:

  OPEN file#,device#,channel#,'#buffer#'

where 'file#' is the file number,  'device#' is the disk's device
number,  normally  8;  'channel#' is the channel number, a number
between  2 and 14  not used by other files open at the same time;
and  'buffer#',  if present,  is a 0,  1,  2,  3,  4,  5,  or  6,
specifying  the  memory  buffer  within  the 1581 to use for this
file's data.

EXAMPLES:

To specify which disk buffer to use:

  OPEN 4,8,4,'#2'

If  you  don't  specify  which to use  (OPEN 5,8,5,'#'), the 1581
selects one."
"[INST]In the context of the C64, What is the purpose of the DCLEAR command on a Commodore 1581 disk drive?[/INST]1581 disk with basic 7,0: DCLEAR

  One command that should not often be needed on the 1581, but is
still of occasional value is DCLEAR.  On the 1581, and nearly all
other Commodore drives, this function is performed automatically,
whenever a new diskette is inserted.
  The result of an DCLEAR,  whether forced by a command,  or done
automatically  by  the  disk,  is  a  re-reading  of  the current
diskette's BAM  into a disk buffer.  This information must always
be  correct  in  order  for the disk to store new files properly.
However,  since the chore is handled automatically, the only time
you'd  need  to  use the command is if something happened to make
the information in the drive buffers unreliable."
"[INST]In the context of the C64, What is the syntax and usage of the PRINT# command in BASIC, and how is it used to write data to a sequential disk file?[/INST]1581 disk with basic 7,0:FORMAT FOR THE PRINT# COMMAND:

  PRINT#file#,data list

where 'file#' is the same file number given in the desired file's
current  OPEN statement.  During any given access of a particular
file, the file number must remain constant because it serves as a
shorthand  way  of relating all other file-handling commands back
to the correct OPEN statement.  Given a file number, the computer
can look up everything else about a file that matters.
  The 'data list' is the same as for a PRINT statement  -- a list
of  constants,  variables and/or expressions,  including numbers,
strings or both. However, it's better if each PRINT# statement to
disk  include  only  one  data item.  If you wish to include more
items,  they  should be separated by a carriage return character,
not  a comma.  Semicolons are permitted,  but not recorded in the
file, and do not result in any added spaces in the file. Use them
to  separate  items in the list that might otherwise be confused,
such  as  a  string  variable  immediately  following  a  numeric
variable.

|   Do  not  leave  a  space between PRINT  and  #,  and do not |
| abbreviate  the  command as ?#.  The correct abbreviation for |
| PRINT# is pR.                                                 |

EXAMPLES:

  To record a few grades for John Paul Jones,  using a sequential
disk file #1 previously opened for writing, use:

  200 FOR CLASS=1 TO COURSES
  210 PRINT#1,GRADE$(CLASS)
  220 GOSUB 59990: REM CHECK FOR DISK ERRORS
  230 NEXT CLASS

assuming your program includes an error check subroutine like the
one in the last chapter.
  In  using  PRINT#,  there is an exception to the requirement to
check  for  disk errors after every file-handling statement. When
using PRINT#, a single check after an entire set of data has been
written  will  still  detect  the error,  so long as the check is
made before any other file-handling statement  or disk command is
used.  You may be familiar with PRINT statements in which several
items follow each other:

  400 PRINT NAME$,STREET$,CITY$

To  get  those  same variables onto sequential disk file number 5
instead  of  the screen,  the best approach would be to use three
separate PRINT# statements, as follows:

  400 PRINT#5,NAME$
  410 PRINT#5,STREET$
  420 PRINT#5,CITY$

If you need to combine them, here is a safe way to do it:

  400 PRINT#5,NAME$;CHR$(13);STREET$;CHR$(13);CITY$

CHR$(13)  is  the  carriage  return  character,  and has the same
effect  as  putting  the print items in separate lines. If you do
this  often,  some  space  and  time  may  be saved by previously
defining a variable as equal to CHR$(13):

   10 CR$=CHR$(13)
  400 PRINT#5,NAME$;CR$;STREET$;CR$;CITY$

  The  basic idea is that a proper sequential disk-file write, if
redirected  to  the  screen,  will display only one data item per
line, with each succeeding item on the next line."
"[INST]In the context of the C64, What is a diskette directory and how is it viewed on a Commodore computer?[/INST]DISKETTE DIRECTORY

  A directory is a list of the files on a diskette.  To  view the
directory on the  C128 or Plus/4,  type the word  DIRECTORY  on a
blank line and press the  [RETURN]  key or simply press the  [F3]
key  on  the C128.  That doesn't erase anything in memory, so you
can  call up a directory anytime  --  even from within a program.
The C64 directory command, LOAD'$',8 (press [RETURN]) LIST (press
[RETURN]), does erase what's in memory.
  If a directory doesn't all fit on the screen, it will scroll up
until  it  reaches the last line.  If you want to pause, stop, or
slow  down  the  scrolling,  refer  to your particular computer's
user's manual for instructions as to which keys to use.
  To  get  an  idea  of  what  a  directory  looks like, load the
directory from the Test/Demo diskette.
  The 0 on the left-hand side of the top line is the drive number
of the 1581.  The diskette name is next, followed by the diskette
id  --  both  of  which  are  determined  when  the  diskette  is
formatted.
  The  3D  at the end of the top line means the 1581 uses version
3D of Commodore's disk operating system (DOS).
  Each   of   the   remaining  lines  provides  three  pieces  of
information  about the files on the diskette.  At the left end of
each  line  is  the size of the file in blocks of 254 characters.
Four  blocks  are  equivalent  to  almost 1K of memory inside the
computer.  The  middle  of the line contains the name of the file
enclosed in quotation marks.  All characters within the quotation
marks  are  part  of  the  filename.  The right side of each line
contains a three-letter abbreviation of the file type.  The types
of files are described in later chapters.
  The  bottom  line  of  a  directory  shows  how many blocks are
available  for  use.  This  number  ranges  from  3160 on a newly
formatted diskette to 0 on one that is completely full."
"[INST]In the context of the C64, What does the DETWP_DV disk controller job command $B6 do?[/INST]1581 disk Controller Job commands: DETWP_DV
      $B6     Checks   if  the  disk  inserted  is  write
                      protected.  Returns  $00  if  disk  is  not
                      protected, else $08."
"[INST]In the context of the C64, What is the meaning of the Controller commands error code 00"" message on a disk?""[/INST]1581 disk: Controller commands error code 00 
	OK (not an error)
    This  is  the  message  that  usually  appears when the error
    channel is checked. It means there is no current error in the
    disk unit."
"[INST]In the context of the C64, What is the error message and explanation for error code 70: NO CHANNEL?[/INST]1581 disk: Controller commands error code 70: NO CHANNEL (available)
    The requested channel is not available or all channels are in
    use. A maximum of three sequential files or one relative file
    plus one sequential file may be opened at one time,  plus the
    command channel. Do not omit the drive number in a sequential
    OPEN command, or only two sequential files can be used. Close
    all files as soon as you no longer need them."
"[INST]In the context of the C64, What are the internal disk commands that expert programmers can use to directly alter the workings of the 1581 disk drive?[/INST]1581 disk:  INTERNAL DISK COMMANDS


  Expert  programmers  can  give commands that directly alter the
workings of the  1581,  much as skilled programmers can alter the
workings of BASIC inside the computer with PEEKs,  POKEs  and SYS
calls.  It  is  also  possible to write machine language programs
that  load  and  run entirely within the 1581,  either by writing
them into disk memory from  the  computer,  or  by  loading  them
directly  from diskette into the desired disk memory buffer. This
is  similar  to  loading and running machine language programs in
your computer.
  As when learning to use PEEK,  POKE  and  SYS in your computer,
extreme caution is advised in using the commands in this chapter.
They are essentially machine language commands,  and  lack all of
BASIC's safeguards.  If anything goes wrong, you may have to turn
the disk drive off and on again  (after removing the diskette) to
regain  control.  Do not practice these commands on any important
diskette.  Rather,  make a spare copy and work with that. Knowing
how  to program a 6502 in machine language will help greatly, and
you  will  also need a good memory map of the 1581.  A brief 1581
map appears below."
"[INST]In the context of the C64, What is the command and its format to load a machine language routine from a diskette into a memory buffer and execute it?[/INST]1581 disk:  BLOCK-EXECUTE

  This  rarely-used  command  will  load  a  sector  containing a
machine  language routine into a memory buffer from diskette, and
execute  it  from  the first location within the buffer,  until a
ReTurn from Subroutine (RTS) instruction ends the command.

FORMAT FOR THE BLOCK-EXECUTE COMMAND:

  PRINT#15,'B-E:';channel#;drive#;track#;sector#

where  'channel#'  is  the channel number specified when the file
into which the block will be loaded was opened,  'drive#'  is the
drive number,  and  'track#'  and  'sector#' are respectively the
track  and sector numbers containing the desired block of data to
be loaded into the file buffer and executed there.

ALTERNATE FORMATS:

  PRINT#15,'B-E:';channel#;drive#;track#;sector#
  PRINT#15,'B-E:channel#,drive#,track#,sector#'

EXAMPLES:

  Assuming  you've  written a machine language program onto Track
1,  Sector 8  of  a diskette,  and would like to run it in buffer
number 1  in  disk  memory  (starting  at $0400 hexadecimal), you
could do so as follows:

110 OPEN 15,8,15               Open command channel.
120 OPEN 2,8,2,'#1'            Open direct access channel to
                               buffer 1.
130 PRINT#15,'B-E:';2;0;1;8    Load Track1, Sector 8 in it
                               & execute.
140 CLOSE 2                    Tidy up after.
150 CLOSE 15
160 END"
"[INST]In the context of the C64, What is the purpose and functionality of the BUFMOVE_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: BUFMOVE_DV
    $9E     Moves data between the job queue buffer and
                      the track cache buffer. The track parameter
                      in  the  job  queue denotes the position in
                      the track cache buffer to transfer to/from.
                      The sector parameter denotes the following:
                        Bit 7 :  Direction  (1 = to  track  cache
                                 buffer)
                        Bit 6 :  Mark Flag  (set/clear the 'track
                                 cache modified' flag)
                        Bit 5 :  Transfer (1 = do the transfer)
                        Bits 4-0:# of 256 byte blocks to transfer
                      With bit 7 set,  the corresponding physical
                      track  position  in  the  job queue (HDRS2)
                      must  be updated for the purpose of telling
                      the  controller  what  physical  track  the
                      track cache buffer belongs to.  In addition
                      the side var (SIDS) must also be updated."
"[INST]In the context of the C64, What is the function of the EXBUF_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: EXBUF_DV
      $E0     Executes  the code in the corresponding job
                      queue buffer after the motor is up to speed
                      and the head is on track."
"[INST]In the context of the C64, What is the syntax and usage of the SCRATCH command in a disk with basic 7,0?[/INST]1581 disk with basic 7,0: FORMAT FOR THE SCRATCH COMMAND:

  SCRATCH 'pattern'[,Ddrive#][,Udevice#]

where  'pattern'  is  any  valid  file  name  or pattern-matching
character.

  You will be asked as a precaution:

  ARE YOU SURE?_

If you ARE sure, simply press Y and RETURN.  If not, press RETURN
alone or type any other answer, and the command will be canceled.
  The  number  of files that were scratched will be automatically
displayed.  For example,  if your diskette contains program files
named 'TEST',  'TRAIN',  'TRUCK', and 'TAIL', you may SCRATCH all
four,  along  with any other files beginning with the letter 'T',
by using the command:

  SCRATCH 'T*'

and  if  the  four listed were the only files beginning with 'T',
you will see:

  01, FILES SCRATCHED,04,00
  READY
  _

The '04' tells you 4 files were scratched.

  You can perform a  SCRATCH within a program,  but there will be
no prompt message displayed."
"[INST]In the context of the C64, What is the command to re-read the directory of a diskette into a disk buffer when the information becomes unreliable?[/INST]1581 disk: INITIALIZE

  When  a  diskette is inserted into the drive,  its directory is
automatically  re-read  into  a  disk  buffer.  You would use the
command only if that information became unreliable.

FORMAT FOR THE INITIALIZE COMMAND:

  PRINT#15,'INITIALIZEdrive#'

or it may be abbreviated to

  PRINT#15,'Idrive#'

EXAMPLE:

  PRINT#15,'I0'

  PRINT#15,'INITIALIZE0'

where the command channel is assumed to be opened by file 15, and
'drive#' is 0."
"[INST]In the context of the C64, What is the format for the validate command in a disk system, and how can it be abbreviated?[/INST]1581 disk: FORMAT FOR THE VALIDATE COMMAND:

  PRINT#15,'VALIDATE0'

or abbreviated as:

  PRINT#15,'V0'

where  '0'  is the drive number.  As usual, it is assumed file 15
has  been  opened to the command channel and will be closed after
the command has been executed."
"[INST]In the context of the C64, What is the purpose of the SCRATCH command in a disk with basic 7,0?[/INST]1581 disk with basic 7,0: SCRATCH

  The  SCRATCH  command allows you to erase unwanted programs and
files  from  your diskettes,  and free up the space they occupied
for  use  by  other  files and programs.  It can be used to erase
either  a  single  file,  or  several  files at once via pattern-
matching."
"[INST]In the context of the C64, What is the purpose of the RESET_DV command in a disk controller job?[/INST]1581 disk Controller Job commands: RESET_DV
      $82     Resets  the  disk controller and associated
                      variables."
"[INST]In the context of the C64, What is the function of the TRKWRT_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: TRKWRT_DV     $A2
     Dumps  the  track  cache buffer to the disk
                      (only  if  the track cache modified flag is
                      set)."
"[INST]In the context of the C64, What is the function of the JUMPC_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: JUMPC_DV
      $D0     Executes  the code in the corresponding job
                      queue buffer."
"[INST]In the context of the C64, What is the purpose of the $9C command in the disk controller job commands?[/INST]1581 disk Controller Job commands: SIDE_DV
       $9C     Sets  up the side select electronics to the
                      value specified (in SIDS)."
"[INST]In the context of the C64, What is the protocol and code for burst read and write operations in a 1581 disk system?[/INST]1581 disk: BURST TRANSFER PROTOCOL

  Before  using  the following burst transfer routines,  you must
determine  whether  or  not the peripheral is a fast device.  The
Fast   Serial  (byte  mode)  protocol  makes  that  determination
internally  when  you  include a query routine (send-cmd-string).
This  routine  addresses the peripheral as a listener and thereby
determines its speed.


BURST READ

send-cmd-string;                      (*determine speed*)
if device-fast then
    serial-in;                        (*serial port input*)
    repeat                            (*repeat for all sectors*)
        read-error;                   (*retrieve error byte*)
    toggle-clock;                     (*wait for status*)
    wait-byte;                        (*wait for byte*)
    if status = ok then
        toggle-clock;                 (*start double buffer*)
        repeat                        (*repeat for sector-size*)
            wait-byte;                (*get data*)
            toggle-clock;             (*start next*)
            store-byte;               (*save data*)
        until last-byte;              (*last byte ?*)
    until last-sector;                (*until last sector*)
    set-clock-high;                   (*restore clock*)
else
    read-1581;                        (*send unit read*)


BURST WRITE

send-cmd-string;                      (*determine speed*)
if device-fast then
    repeat                            (*repeat for all sectors*)
        serial-out;                   (*serial port out*)
            repeat                    (*repeat for sector-size*)
                send-byte;            (*send byte*)
            until last-byte;          (*last byte ?*)
        serial-in;                    (*serial port in*)
        set-clock-low;                (*ready for status*)
        read-err;                     (*controller error ?*)
        set-clock-high;               (*restore clock*)
    until last-sector;                (*until last sector*)
else
    write-1581;                       (*send unit write*)"
"[INST]In the context of the C64, What is the syntax and usage of the COPY command on a Commodore 1581 disk drive?[/INST]1581 disk:  COPY

  The COPY command allows you to make a spare copy of any program
or file on a diskette.  On a single drive like the 1581, the copy
must  be  on  the  same diskette,  which means it must be given a
different name from the file copied. It's also used to combine up
to  four sequential data file  (linking the files one to another,
end  to end in a chain).  Files are linked in the order and other
files  on  the  diskette  are  not changed.  Files must be closed
before they are copied or linked.

FORMAT FOR THE COPY COMMAND:

  PRINT#15,'COPYdrive#:new file=old file'

EXAMPLES:

  PRINT#15,'COPY0:BACKUP=ORIGINAL'

or abbreviated as:

  PRINT#15,'Cdrive#:new file=old file'

  PRINT#15,'C0:BACKUP=ORIGINAL'

where  'drive#'  is the drive number  'new file'  is the copy and
'old file' is the original.

FORMAT FOR THE COMBINE OPTION:

  PRINT#15,'Cdrive#:new file=file 1,file 2,file 3,file 4'

where 'drive#' is always 0,

| The  length  of  a  command string (command and filenames) is |
| limited to 41 characters.                                     |"
"[INST]In the context of the C64, What is the purpose of the CONCAT command in a CP/M system?[/INST]1581 disk with basic 7,0: CONCAT

  The  CONCAT  command  allows  you  to concatenate (combine) two
sequential files."
"[INST]In the context of the C64, What is the syntax and functionality of the CONCAT command in CP/M?[/INST]1581 disk with basic 7,0:FORMAT FOR THE CONCAT COMMAND:

  CONCAT [Ddrive#,]'add file' TO [Ddrive#,] 'master file'
         [,Udevice#]

where  the  optional  'drive#'  would be 0 in both cases. The old
'master file'  is  deleted and replaced with a new  'master file'
which  is  the concatenation of the old  'master file'  and  'add
file'.

| The  length  of  a  command string (command and filenames) is |
| limited to 41 characters.                                     |"
"[INST]In the context of the C64, What is the purpose and precautions of using the VALIDATE command on a diskette?[/INST]1581 disk:  VALIDATE

  The VALIDATE command recalculates the  Block  Availability  Map
(BAM)  of  the  current  diskette,  allocating only those sectors
still  being  used by valid,  properly-closed files and programs.
All other sectors  (blocks) are left unallocated and free for re-
use, and all improperly closed files are automatically scratched.
This  brief  description  of its workings doesn't indicate either
the power or the danger of the VALIDATE command.  Its power is in
restoring  to  good  health  many  diskettes whose directories or
block availability maps have become muddled.  Any time the blocks
used  by  the  files  on a diskette plus the blocks shown as free
don't add up to the 3160 available on a fresh diskette,  VALIDATE
is  needed,  with  one  exception  below.  Similarly,  any time a
diskette   contains   an  improperly-closed  file  (splat  file),
indicated  by  an  asterisk  (*)  next  to  its  file type in the
directory,  that diskette needs to be validated. In fact, but for
the  one  exception,  it  is  a  good  idea to VALIDATE diskettes
whenever you are the least bit concerned about their integrity.
  The  exception  is diskettes containing direct access files, as
described in Chapter 6.  Most direct access (random) files do not
allocate  their  sectors  in  a  way  the  VALIDATE  command  can
recognize.  Thus, using VALIDATE on such a diskette may result in
unallocating  all  direct  access  files,  with loss of all their
contents   when  other  files  are  added.   Unless  specifically
instructed otherwise, never use VALIDATE on a diskette containing
direct access files."
"[INST]In the context of the C64, What is the breakdown of the status byte in a 1581 disk assembly, including the meaning of each bit and the possible values for mode, drive number, sector size, and controller status?[/INST]1581 disk in assembly: STATUS BYTE BREAKDOWN

 BIT 7    6       5       4       3       2       1       0
-----------------------------------------------------------------
 MODE     DN     SECTOR SIZE         [ CONTROLLER STATUS]
-----------------------------------------------------------------
*MODE -- 1 = Alien Disk Format  (non-default physical format,  or
         default  physical  format  without   Directory  and  BAM
         information)
         0 = Resident Disk Format  (default  physical format with
         Directory and BAM information)
 DN  --  drive number

*Resident Disk Format is based on whether required information is
 present in BAM/DIRECTORY track.

SECTOR SIZE
             00 ........ 128 BYTE SECTORS (NOT SUPPORTED)
             01 ........ 256 BYTE SECTORS
             10 ........ 512 BYTE SECTORS (DEFAULT)
             11 ........ 1024 BYTE SECTORS

CONTROLLER STATUS
             000X ...... OK
             0010 ...... CAN'T FIND HEADER BLOCK
             0011 ...... NO ADDRESS MARK
             0100 ...... DATA BLOCK NOT PRESENT
             0101 ...... DATA CRC ERROR
             0110 ...... FORMAT ERROR
             0111 ...... VERIFY ERROR
             1000 ...... WRITE PROTECT ERROR
             1001 ...... HEADER BLOCK CRC ERROR
             1010 ...... WRITE PROTECTED
             1011 ...... DISK CHANGE
             1100 ...... DISK FORMAT NOT LOGICAL
             1101 ...... RESERVED
             1110 ...... SYNTAX ERROR
             1111 ...... NO DRIVE PRESENT"
"[INST]In the context of the C64, What is the purpose of the $9A command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: ERRLEDOFF_DV  
$9A     Disables error LED blinking."
"[INST]In the context of the C64, What is the purpose of the RESTORE_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: RESTORE_DV    $C0
     Restores  the  read/write  head  to track 0
                      ('bump')."
"[INST]In the context of the C64, What is the function of the SEEKHD_DV disk controller job command in a 1581 disk controller?[/INST]1581 disk Controller Job commands: SEEKHD_DV
     $B0     Logs  in a disk by reading information from
                      the  first  header  encountered on the disk
                      into RAM so that it can be used by the DOS.
                      The track cache buffer is not updated."
"[INST]In the context of the C64, What is the function of the $84 command in the MOTON_DV disk controller job commands?[/INST]1581 disk Controller Job commands: MOTON_DV
      $84     Turns on the spindle motor  (overlays a $01
                      in the Job Queue after the spin-up sequence
                      is complete)."
"[INST]In the context of the C64, What is the purpose of the DISKIN_DV command in a disk controller job?[/INST]1581 disk Controller Job commands: DISKIN_DV
     $92     Determines  if  there is a disk inserted in
                      the drive."
"[INST]In the context of the C64, What is the purpose of the SAVE command ?[/INST]1581 disk with basic 7,0: SAVE

  This  command  will save a program or file so you can reuse it.
The  diskette  must  be  formatted before you can save it to that
diskette."
"[INST]In the context of the C64, What is the purpose of the VERIFY command in Commodore computers?[/INST]1581 disk with basic 7,0: VERIFY

  This  command  makes  a  byte-by-byte comparison of the program
currently   in   memory  against  a  program  on  diskette.  This
comparison includes the BASIC line links,  which may be different
for different types of memory configurations.  What this means is
that  a  program  saved to disk on a C64 and reloaded into a C128
wouldn't   verify  properly  because  the  line  links  point  to
different  memory  locations.  If  the  disk  copy of the program
differs at all from the copy in memory,  a 'VERIFY ERROR' will be
displayed. This doesn't mean either copy is bad, but if they were
supposed to be identical, there is a problem."
"[INST]In the context of the C64, How do you handle renaming and deleting files with troublesome characters in their names, such as commas, Shifted Spaces, or non-printing characters, in a disk file system?[/INST]1581 disk: RENAMING AND SCRATCHING TROUBLESOME FILES

  Eventually,  you  may  run  across  a  file  which  has  an odd
filename,  such as a comma by itself (',') or one that includes a
Shifted Space (a Shifted Space looks same as a regular space, but
if  a  file  with a space in its name won't load properly and all
else is correct,  it's probably a Shifted Space).  Or perhaps you
will find one that includes non-printing characters. Any of these
can be troublesome.  Comma files,  for instance, are an exception
to  the  rule  that no two files can have the same name. Since it
shouldn't  be possible to make a file whose name is only a comma,
the disk never expects you to do it again.
  Files  with  a   Shifted  Space  in  their  name  can  also  be
troublesome,  because  the  disk  interprets the Shifted Space as
signaling  the end of the file name,  and prints whatever follows
after  the  quotation  mark  that  marks the end of a name in the
directory.  This  technique can be useful by allowing you to have
a  long file name,  and making the disk recognize a small part of
it  as  being  the same as the whole thing without using pattern-
matching characters.
  In any case,  if  you have a troublesome filename,  you can use
the  CHR$()  function  to  specify troublesome characters without
typing  them  directly.  This  may allow you to build them into a
RENAME  command.  If  this  fails,  you may also use the pattern-
matching characters in a SCRATCH command. This gives you a way to
specify the name without using the troublesome characters at all,
but also means loss of your file.
  For  example,  if  you  have  managed  to  create  a file named
''MOVIES',  with an extra quotation mark at the front of the file
name,  you can rename it to  'MOVIES' using the CHR$() equivalent
of a quotation mark in the RENAME command:

  PRINT#15,'R0:MOVIES='+CHR$(34)+'MOVIES'

The  CHR$(34)  forces  a  quotation  mark into the command string
without  upsetting  BASIC.  The  procedure  for  a file name that
includes a Shifted Space is similar, but uses CHR$(160).
  In cases  where even this doesn't work,  for  example,  if your
diskette contains a comma file,  (one named ',')  you can get rid
of it this way:

  PRINT#15,'S0:?'

  This example deletes all files with one-character names.

  Depending  on  the  exact  problem,  you  may  have  to be very
creative in choosing pattern-matching characters that will affect
only  the desired file,  and may have to rename other files first
to keep them from being scratched.
  In  some  cases,  it  may  be easier to copy desired files to a
different diskette and leave the troublesome files behind."
"[INST]In the context of the C64, What is the syntax and usage of the RENAME command in a diskette directory?[/INST]1581 disk:  RENAME

  The RENAME command allows you to alter the name of a program or
other file in the diskette directory. Since only the directory is
affected, RENAME works very quickly.

FORMAT FOR RENAME COMMAND:

  PRINT#15,'RENAME0:new name=old name'

or it may be abbreviated as:

  PRINT#15,'R0:new name=old name'

where  'new name' is the name you want the file to have, and 'old
name'  is  the name it has now.  'new name' may be any valid file
name,  up  to  16  characters  in length.  It is assumed you have
already opened file 15 to the command channel.
  One  caution  --  be  sure  the  file you are renaming has been
properly closed before you rename it.

EXAMPLES:

Just before saving a new copy of a 'calendar' program,  you might
type:

  PRINT#15,'R0:CALENDAR/BACKUP=CALENDAR'

Or to move a program called  'BOOT',  currently the first program
on a diskette to someplace else in the directory, you might type:

  PRINT#15,'R0:TEMP=BOOT'

followed by a COPY command (described later),  which turns 'TEMP'
into a new copy of  'BOOT',  and finishing with a SCRATCH command
to get rid of the original copy of 'BOOT'."
"[INST]In the context of the C64, What is the procedure for saving a new version of a file using the DSAVE command in BASIC 7.0?[/INST]1581 disk with basic 7,0:FORMAT FOR SAVE WITH REPLACE:

  DSAVE '@file name'[,Ddrive#][,Udevice#]

  The  actual  procedure  is  this  --  the  new version is saved
completely,  then  the old version is scratched and its directory
entry altered to point to the new version.  Because it works this
way,  there  is little danger a disaster such as having the power
going  off  midway through the process would destroy both the old
and new copies of the file. Nothing happens to the old copy until
after the new copy is saved properly."
"[INST]In the context of the C64, What is the purpose of the PRINT DS$ command and how can it be used in a program to handle disk errors?[/INST]1581 disk with basic 7,0: ERROR CHECKING

  When  the  drive  light  (red light) flashes,  you must use the
following command to find out what the error is:

  PRINT DS$

  A  message  is  displayed  whether there is an error or not. If
there  was an error,  this command clears it from disk memory and
turns off the error light on the disk drive.
  Once  the  message  is  on  the  screen,  you can look it up in
Appendix B to see what it means, and what to do about it.
  For those of you who are writing programs,  the  following is a
small error-checking subroutine you can include in your programs:

  59990 REM READ ERROR CHANNEL
  60000 IF DS>1 THEN PRINT DS$: STOP
  60010 RETURN

  The  subroutine  reads  the  error channel and puts the results
into  the  reserved  variables  DS  and  DS$.  They  are  updated
automatically by BASIC.
  Two error numbers are harmless -- 0 means everything is OK, and
1  tells  how  many  files  were  erased  by  a  SCRATCH  command
(described  later  in  this  chapter).  If  the  error  status is
anything else,  line 60000 prints the error message and halts the
program.
  Because  this  is  a  subroutine,  you access it with the BASIC
GOSUB  command,  either  in immediate mode or from a program. The
RETURN  statement  in line 60010 will jump back to immediate mode
or the next statement in your program, whichever is appropriate."
"[INST]In the context of the C64, What is the disk controller job command to turn on the activity LED?[/INST]1581 disk Controller Job commands: LEDACTON_DV   $94
     Turns on the activity LED."
"[INST]In the context of the C64, What is the function of the MOTOFF_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: MOTOFF_DV
     $86     Turns the spindle motor off after the spin-
                      down sequence is complete."
"[INST]In the context of the C64, What is the function of the SEEKPHD_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: SEEKPHD_DV
    $B8     Seeks   to   a  particular  logical  track,
                      sector. The track cache is not updated."
"[INST]In the context of the C64, What is the purpose of the $98 command in the 1581 disk controller job commands?[/INST]1581 disk Controller Job commands: ERRLEDON_DV
   $98     Enables error LED blinking."
"[INST]In the context of the C64, What is the function of the MOTOFFI_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: MOTOFFI_DV
    $8A     Turns the spindle motor off immediately."
"[INST]In the context of the C64, What is the syntax and usage of the DVERIFY command in BASIC 7.0?[/INST]1581 disk with basic 7,0:FORMAT FOR THE DVERIFY COMMAND:

  DVERIFY 'file name'[,Ddrive#][,Udevice#]

  The  following  version of the command verifies a file that was
just saved:

  DVERIFY'*'

  This  command  won't  work  properly  after  SAVE-WITH-REPLACE,
because  the  last  file used was the one deleted,  and the drive
will try to compare the deleted file to the program in memory. No
harm will result, but 'VERIFY ERROR' will always be announced. To
use  DVERIFY after @SAVE,  include at least part of the file name
that is to be verified in the pattern."
"[INST]In the context of the C64, What is the syntax and usage of the DSAVE command in BASIC 7.0?[/INST]1581 disk with basic 7,0:FORMAT FOR THE SAVE COMMAND:

  DSAVE 'file name'[,Ddrive#][,Udevice#]

  This  command  will  not  work in copying programs that are not
written  in  BASIC.  To copy these machine-language programs, you
can use the BSAVE command or the built-in Monitor S command."
"[INST]In the context of the C64, What is the syntax and usage of the BSAVE command in Commodore 128?[/INST]1581 disk with basic 7,0:FORMAT FOR THE BSAVE COMMAND:

  BSAVE 'file name'[,Ddrive#][,Udevice#][,Bbank#]
                   [,Pstarting address][TO Pending address+1]

where  the  usual options are the same and bank# is one of the 16
banks of the C128.  The address to be saved are given in decimal.
Note  that  the ending address must be 1 location beyond the last
location to be saved.
  To access a built-in monitor, type MONITOR.  To exit a monitor,
type X alone on a line."
"[INST]In the context of the C64, What is the syntax and usage of the COPY command on a Commodore 1581 disk with Basic 7.0?[/INST]1581 disk with basic 7,0: COPY

  The COPY command allows you to make a spare copy of any program
or file on a diskette. However, on a single derive like the 1581,
the  copy  must  be on the same diskette,  which means it must be
given a different name from the file copied.  The source file and
other files on the diskette are not changed. Files must be closed
before they can be copied or concatenated.

FORMAT FOR THE COPY COMMAND:

  COPY [Ddrive#,]'old file name' TO [Ddrive#,]'new file name'
       [,Udevice#]

where both drive#s would be 0 if included."
"[INST]In the context of the C64, What is the function of the $88 command in the MOTONI_DV disk controller job?[/INST]1581 disk Controller Job commands: MOTONI_DV
     $88     Turns the spindle motor on immediately."
"[INST]In the context of the C64, What is the purpose of the $96 command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: LEDACTOFF_DV
  $96     Turns off the activity LED."
"[INST]In the context of the C64, What is the purpose of the WRTVER_DV disk controller job command $A0?[/INST]1581 disk Controller Job commands: WRTVER_DV
     $A0     Verifies  the  track  cache  buffer's  data
                      against the specified logical track's data."
"[INST]In the context of the C64, What is the format and protocol of the QUERY DISK FORMAT command in a disk assembly?[/INST]1581 disk in assembly: QUERY DISK FORMAT

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       F      X      T      S      1      0      1      N
-----------------------------------------------------------------
  03               OFFSET      (OPTIONAL, F-BIT SET)
-----------------------------------------------------------------

SWITCHES: F -- force flag  (F = 1 steps the head  with the offset
          specified in byte 03)
          T -- sector table (T = 1, send sector table)
          N -- drive number
          X -- don't care
          S -- side select

PROTOCOL: Burst handshake.

CONVENTIONS: Determines  the  diskette  format  on any particular
             track.   Also   logs  non-standard  diskettes  (i.e.
             minimum sector addresses other than one).

OUTPUT:  * burst status byte (no bytes will follow if there is an
           error)
        ** burst status byte  (no bytes will follow  if there was
           an error in compiling MFM format information)
           number of sectors (on a particular track)
           logical track (track number found in the disk header)
           minimum sector (sector with the lowest value address)
           maximum sector (sector with the highest value address)
           interleave (always returns 1)
           sector table (with T bit set, sector table is sent)
 * status from track offset zero
** if F bit is set, status is from offset track"
"[INST]In the context of the C64, What precautions should be taken when using the SCRATCH command to delete files, and how to recover from accidentally deleting a file or a splat"" file?""[/INST]1581 disk: Scratch in-depth

  SCRATCH  is  a powerful command and should be used with caution
to be sure you delete only the files you really want erased. When
using  it  with  a  pattern,  we  suggest  you first use the same
pattern in a  DIRECTORY  command,  to be sure exactly which files
will  be  deleted.  That  way you'll have no unpleasant surprises
when you use the same pattern in the SCRATCH command.
  If you accidentally SCRATCH a file you shouldn't have, there is
still  a  chance of saving it by using the 'UNSCRATCH' program on
your Test/Demo diskette.

More about Splats

  Never SCRATCH a splat file.  These are files  that show up in a
directory listing with an asterisk (*)  just before the file type
for  an entry.  The asterisk (or splat) means that file was never
properly  closed,  and  thus  there  is  no valid chain of sector
links for the SCRATCH command to follow in erasing the file.
  If you  SCRATCH such a file,  odds are you will improperly free
up  sectors  that are still needed by other programs or files and
cause  permanent damage to those later when you add more files to
the  diskette.  If you find a splat file,  or if you discover too
late  that  you have scratched such a file,  immediately validate
the diskette using the  VALIDATE  command described later in this
chapter.  If  you  have  added  any  files  to the diskette since
scratching  the  splat  file,  it is best to immediately copy the
entire  diskette onto another fresh diskette,  but do this with a
copy  program  rather than with a backup program.  Otherwise, the
same problem will be recreated on the new diskette.  When the new
copy is done,  compare the number of blocks free in its directory
to  the  number  free  on  the original diskette.  If the numbers
match, no damage has been done.  If not, very likely at least one
file  on  the  diskette  has  been  corrupted,  and all should be
checked immediately."
"[INST]In the context of the C64, How do you erase a locked file on a diskette that cannot be deleted with the SCRATCH command?[/INST]1581 disk: Locked Files

  Occasionally,  a diskette will contain a locked file; one which
cannot  be  erased with the  SCRATCH  command.  Such files may be
recognized  by  the  '<'  character which immediately follows the
file type in their directory entry. If you wish to erase a locked
file, you will have to use a sector editor program to clear bit 6
of  the  file-type  byte  in the directory entry on the diskette.
Conversely, to lock a file, you would set bit 6 of the same byte."
"[INST]In the context of the C64, What is the format of the 1581 disk in assembly, including the byte layout and switches?[/INST]1581 disk in assembly:  FORMAT

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       M      X      X      X      0      1      1      N
-----------------------------------------------------------------
  03   SECTOR SIZE           *(OPTIONAL, DEF-02,512 BYTE SECTORS)
-----------------------------------------------------------------
  04   LAST TRACK NUMBER      (OPTIONAL, DEF-79)
-----------------------------------------------------------------
  05   NUMBER OF SECTORS    **(OPTIONAL, DEF DEPENDS ON BYTE 03)
-----------------------------------------------------------------
  06   STARTING TRACK         (OPTIONAL, DEF-0)
-----------------------------------------------------------------
  07   FILL BYTE              (OPTIONAL, DEF-$E5)
-----------------------------------------------------------------
  08   STARTING SECTOR        (OPTIONAL, DEF-1)
-----------------------------------------------------------------

SWITCHES: M -- mode (1 = will accept BYTES 03-08,0 = will format,
          create directory and BAM)
          N -- drive number

PROTOCOL: Conventional.

CONVENTIONS: CMD 4 must be followed with CMD 3  or  CMD 6 once to
             log the disk in.

OUTPUT: None. Status will be updated within the drive."
"[INST]In the context of the C64, What is the function of the WRTSD_DV command in a disk controller job?[/INST]1581 disk Controller Job commands: WRTSD_DV
      $90     Writes  the  job  queue's  buffer data to a
                      particular  logical track,  sector.  If the
                      same  track  is already in the track cache,
                      then  this  involves  only transferring the
                      job  queue  buffer  data to the track cache
                      buffer.  If  a different track's data is in
                      the  disk  (only  if  it was modified), the
                      desired  track  read  into  the track cache
                      buffer,  and finally the job queue buffer's
                      data transferred to the track cache."
"[INST]In the context of the C64, What is the format and protocol for the CMD 2 -- WRITE command in a disk assembly?[/INST]1581 disk in assembly : CMD 2 -- WRITE

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       L      E      X      S      0      0      1      N
-----------------------------------------------------------------
  03                       DESTINATION TRACK
-----------------------------------------------------------------
  04                       DESTINATION SECTOR
-----------------------------------------------------------------
  05                       NUMBER OF SECTORS
-----------------------------------------------------------------
  06                      NEXT TRACK (OPTIONAL)
-----------------------------------------------------------------

RANGE: All  values  are  determined by the particular disk format
       and format of translation table.

SWITCHES: L -- logical flag(1=do logical to physical translation)
          E -- ignore error (1 = ignore)
          S -- side select
          N -- drive number

PROTOCOL: Burst  data  to  the drive,  then host must perform the
          following:  fast  serial input,  pull the clock low and
          wait  for  the  burst status byte,  pull clock high, go
          output for multi-sector transfers and continue.

CONVENTIONS: Before you can READ or WRITE to a diskette,  it must
             be logged-in using either the  INQUIRE DISK or QUERY
             DISK FORMAT command (both are described later). This
             must be done once each time you change diskettes.

INPUT: Host must transfer burst data.

OUTPUT: One burst status byte following each WRITE operation."
"[INST]In the context of the C64, What is the primary interface between the host computer and the 1581 system, responsible for managing file creation, modification, and deletion, and keeping track of file names and free space on the disk?[/INST]1581 disk:  CONTROLLER JOB QUEUE

  The  software  in  the  1581's  ROM can be broken down into two
major  components  --  the DOS and the Controller.  The DOS (Disk
Operating  System)  is  the  software  interface between the host
computer  and  the  1581 system.  The DOS keeps track of the file
management details necessary to create,  modify and delete files.
It  monitors  the  amount of free space left on a disk, and keeps
track of the file names in the directory. It remembers where each
file starts, and ensures that none of them overlap. When the host
sends commands,  the DOS checks make sure that the syntax and the
parameters  are  valid.  The  DOS  is very complex,  and its code
occupies the majority of the ROM.

  The  Controller,  on  the  other hand,  knows nothing about the
concept of files. The Controller deals only in the physical world
of  the  disk  itself.  It is responsible for reading and writing
each of the individual sectors on the disk.

  The  DOS  and  Controller  communicate  to each other primarily
through  a  'mailbox',  known  as the Job Queue.  Because the DOS
deals more in the abstract, or logical, world, it does not access
the physical disk itself. If the DOS requires access to the disk,
it must ask the controller to do it.  The DOS places a Controller
Command  Code into the Job Queue and then waits for the requested
operation  to  be  completed.  The Controller polls the Job Queue
every 10 milliseconds  (the polling rate is determined by timer B
of  8520)  looking for something to do.  If there is a job in the
queue,  the Controller executes the job and returns a status byte
to the DOS.  To speed things up, the polling of the job queue can
be  bypassed  by  a  direct  jump  to JSTROBE_CONTROLLER at $FF54
(refer to the section describing the Vectored Jump Table). A call
to JSTROBE_CONTROLLER requires the command in the accumulator and
the job queue offset in the x register.

  Most  of  the tasks that the Controller can be asked to perform
require parameters. The parameters are also placed in a 'mailbox'
location  for  the  Controller  to  access  (prior to placing the
command byte into the queue, of course).  These parameters can be
either the physical or the logical parameters,  depending on what
the command expects to see. Logical parameters are placed in HDRS
as  two consecutive bytes of track,  sector.  Physical parameters
are  also  placed  in  HDRS,  but  in  addition  the side must be
specified  (in  SIDS).  Commands  that require logical parameters
must  translate  them  into  physical parameters at some point in
their  execution.  The  logical  parameters  are  translated into
physical parameters by a vectored routine called TRANSTS, and are
written into  HDRS2  and  SIDS.  The DOS will always pass logical
parameters, and uses only the Controller commands that allowed to
put  jobs  in  its  own  queue,  so  it  needs  to  pass physical
parameters as well as logical.

               Mailbox Locations of the Controller
-----------------------------------------------------------------
Name     Address  Purpose
-----------------------------------------------------------------
JOBS      $0002   JOB queue for Controller commands (JOBS 0-8).
            .     Each JOB uses 1 byte. The last 2 locations
            .     ($09,$0A) are reserved for BAM jobs only!
          $000A
HDRS      $000B   Logical or physical track, sector for each of
            .     the jobs in the JOB queue (2 bytes per job).
            .
          $001C
HDRS2     $01BC   Translated (physical) track, sector for each
            .     of the jobs in the JOB queue (2 bytes per job).
            .
          $01CD
SIDS      $01CE   Physical side for each of the jobs
            .     in the job queue (1 byte per job).
            .
          $01D6
CACHE     $008B   Pointer to BUFFCACHE below.
CACHEOFF  $009F   Offset into the track cache buffer.
            .     (1 byte per job).
            .
          $00A7
BUFFCACHE $0C00   20 pages for track cache.
            .
            .
          $1FFF

  Associated with each of the nine  Job Queue  locations  (Jobs 0
through 8) are nine 256 byte buffers (buffers 0-8),  beginning at
location  $0300.  Data passed from/to a particular Job during its
execution  is  located  in  the  buffer  which corresponds to the
position  of  the  Controller  Job  Code  in  the  Job Queue. For
example,  if the  Controller  Code  in  Job Queue  position 2 (at
location  $0004)  requests that a logical sector of data be read,
the data is put into Buffer 2 (at location $0500).

  Table 1 is a list of Controller Job Codes  that can be put into
the  Job Queue.  Table 2 is a list of the codes that are returned
by the Controller once the job has been executed. The return code
is  placed  into  the  Job Queue in the same memory location that
contained the Controller Job Code. Consequently, the procedure to
use the Controller is the following:

  1) Write  any  parameters  needed by the Job into the parameter
     variables (HDRS, HDRS2, SIDS).
  2) Write the Controller Code into the Job Queue (JOBS).
  3) Wait  for  the  job  to  be  completed by simply polling the
     location in JOBS where the Job code was put, and waiting for
     it to change (bit 7 will be reset to 0)."
"[INST]In the context of the C64, What is the function of the SEEK_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: SEEK_DV
       $8C     Seeks  to  a  particular   physical   track
                      (cylinder).   The  current  physical  track
                      position   should   be  put  in  the  track
                      parameter of HDRS."
"[INST]In the context of the C64, What is the purpose of the SAVE WITH REPLACE command in a disk drive?[/INST]1581 disk with basic 7,0: SAVE WITH REPLACE

  If a file already exists, it can't be saved again with the same
name  because  the  disk  drive allows only one copy of any given
file name per diskette. It is possible to get around this problem
using the  RENAME  and  SCRATCH  commands described later in this
chapter.  If all you wish to do is replace a program or data file
with a revised version, another command is more convenient. Known
as SAVE-WITH-REPLACE, or @SAVE.  This option tells the disk drive
to  replace  any file it finds in the diskette directory with the
same name, substituting the new file for the old version."
"[INST]In the context of the C64, What is the command and its format to erase unwanted files and free up disk space in a C64 system?[/INST]1581 disk:  SCRATCH

  The SCRATCH command allows you to erase unwanted files and free
the space they occupied for use by other files. It can be used to
erase either a single file  or several files at once via pattern-
matching.

FORMAT FOR THE SCRATCH COMMAND:

  PRINT#15,'SCRATCH0:pattern'

or abbreviate it as:

  PRINT#15,'S0:pattern'

'pattern'  can  be any file name or combination of characters and
wildcard characters.  As usual, it is assumed the command channel
has  already  been  opened  as  file 15.  Although not absolutely
necessary,  it  is  best  to  include the drive number in SCRATCH
commands.
  If  you  check  the  error channel after a SCRATCH command, the
value  for  ET  (error  track)  will tell you how many files were
scratched.  For example,  if your diskette contains program files
named  'TEST',  'TRAIN',  'TRUCK' and 'TAIL', you may SCRATCH all
four,  along  with any other files beginning with the letter 'T',
by using the command:

  PRINT#15,'S0:T*'

Then, to prove they are gone, you can type:

  GOSUB 59990

to  call  the  error  checking  subroutine  given earlier in this
chapter.  If  the  four listed were the only files beginning with
'T', you will see:

  01, FILES SCRATCHED,04,00
  READY.

The '04' tells you 4 files were scratched."
"[INST]In the context of the C64, What is the purpose and syntax of the VERIFY command ?[/INST]1581 disk:  VERIFY

  The  VERIFY  command can be used to make certain that a program
file  was  properly  saved  to disk.  It works much like the LOAD
command,  except  that  it  only  compares  each character in the
program  against  the  equivalent  character  in  the  computer's
memory, instead of actually being copied into memory.
  If  the  disk  copy of the program differs even a tiny bit from
the copy in memory, 'VERIFY ERROR' will be displayed, to tell you
that the copies differ. This doesn't mean either copy is bad, but
if they were supposed to be identical, there is a problem.
  Naturally,  there's no point in trying to VERIFY a disk copy of
a program after the original is no longer in memory. With nothing
to compare to,  an apparent error will always be announced,  even
though  the  disk copy is automatically verified as it is written
to the diskette."
"[INST]In the context of the C64, What is the format for using the SAVE command on a Commodore 1581 disk with BASIC 7.0?[/INST]1581 disk with basic 7,0:FORMAT FOR A MONITOR SAVE:

  S 'drive#:file name',device#,starting address,ending address+1

where 'drive#:' is the drive number,  0 on the 1581;  'file name'
is any valid file name up to 14 characters long  (16 if you leave
out the drive# and the colon that follows it); 'device#' is a two
digit device number,  normally  08 on the 1581  (the leading 0 is
required); and the addresses to be saved are given in Hexadecimal
(base 16), but without a leading dollar sign (for the Plus/4). On
the C128, the addresses need not be in Hexadecimal. Note that the
ending address listed must be 1 location beyond the last location
to be saved."
"[INST]In the context of the C64, What is the description of the FORMAT_DV command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: FORMAT_DV
     $8E     Formats  one  physical track (one half of a
                      cylinder).   The   head   must   be  placed
                      physically  over  the  proper cylinder, and
                      the  head  electronics must be selected for
                      the side desired."
"[INST]In the context of the C64, What happens when the READ_DV command is executed on a disk controller job?[/INST]1581 disk Controller Job commands: READ_DV
       $80     Reads  a particular logical sector into the
                      job queue buffer  (only if the disk has not
                      been  changed).  If  the  desired sector is
                      already in the track cache buffer,  then no
                      disk  activity  is  required  (the  data is
                      merely  transferred  from  the  track cache
                      memory to the job queue buffer memory).  If
                      the  desired  sector  is  not  in the track
                      cache,  then  the  current  track  cache is
                      dumped  to  disk   (only  if  it  has  been
                      modified),  the  desired track is read into
                      the track cache, and finally the particular
                      sector's data is transferred from the track
                      cache memory to the job queue buffer."
"[INST]In the context of the C64, What is the format of the output of the INQUIRE DISK command in a 1581 disk assembly?[/INST]1581 disk in assembly : INQUIRE DISK

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       X      X      X      S      0      1      0      N
-----------------------------------------------------------------

SWITCHES: N -- drive number

PROTOCOL: Burst handshake.

OUTPUT: One   burst   status  byte  following  each  INQUIRE DISK
        operation."
"[INST]In the context of the C64, What is the function of the SP_WRITE command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: SP_WRITE
      $A6     Writes  to  the  specified  physical sector
                      directly.  It does not use the track cache.
                      Data  to  be  written  starts  at buffer #0
                      ($0300)."
"[INST]In the context of the C64, What is the output of the DUMP TRACK CACHE BUFFER command in a CMD 8 disk assembly?[/INST]1581 disk in assembly:CMD 8 -- DUMP TRACK CACHE BUFFER

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       F      S      X      1      1      1      0      1
-----------------------------------------------------------------
  03                         PHYSICAL TRACK
-----------------------------------------------------------------

SWITCHES: X -- don't care
          S -- side select
          F -- (1 = write even if not 'dirty')"
"[INST]In the context of the C64, What is described in the chapter about the internal operations of the 1581 disk?[/INST]1581 disk:  1581 INTERNAL OPERATION


This  chapter  describes  some  of the internal operations of the
1581  --  how things work on the 'other side of the fence' of the
host computer.  Experienced programmers may find this information
useful.  The information learned in previous chapters (especially
Chapter 7)  combined with that presented in this chapter provides
a  wide  realm  of  possibilities for the creative and persistent
programmer. Please be reminded, however, of the NOTE presented at
the beginning of Chapter 7 regarding future compatibility."
"[INST]In the context of the C64, What is the meaning of the Error 73"" message that appears when reading the disk error channel?""[/INST]1581 disk:  One  disk  error  message  is  not  always an error. Error 73,
'COPYRIGHT CBM DOS V10 1581'  will  appear  if  you read the disk
error  channel  before sending any disk commands when you turn on
your computer.  This is a handy way to check which version of DOS
you  are  using.  However,  if  this message appears later, after
other disk commands, it means there is a mismatch between the DOS
used  to  format  your diskette and the DOS in your drive. DOS is
Disk Operating System."
"[INST]In the context of the C64, What precautions should be taken when using the SCRATCH command, and what can be done if a file is accidentally deleted?[/INST]1581 disk with basic 7,0: in depth scratch:

  SCRATCH  is  a powerful command and should be used with caution
to be sure you delete only the files you really want erased. When
using  it  with  a  pattern,  we  suggest  you first use the same
pattern in a  DIRECTORY  command,  to be sure exactly which files
will  be  deleted.  That  way you'll have no unpleasant surprises
when you use the same pattern in the SCRATCH command.
  If you accidentally SCRATCH a file you shouldn't have, there is
still  a  chance of saving it by using the 'UNSCRATCH' program on
your Test/Demo diskette."
"[INST]In the context of the C64, What should you never do to a 'splat file' on a disk, and how can you recover from accidentally doing so?[/INST]1581 disk with basic 7,0: More about Splats

  Never SCRATCH a splat file.  These are files  that show up in a
directory listing with an asterisk (*)  just before the file type
for  an entry.  The asterisk (or splat) means that file was never
properly  closed,  and  thus  there  is  no valid chain of sector
links for the  SCRATCH  command to follow in erasing the file. If
you  SCRATCH  such  a file,  odds are you will improperly free up
sectors  that  are  still  needed  by other programs or files and
cause  permanent damage to those later when you add more files to
the diskette.
  If you find a splat file,  or if you discover too late that you
have  scratched  such  a  file, immediately validate the diskette
using the COLLECT command described later in this chapter. If you
have  added  any files to the diskette since scratching the splat
file,  it  is  best  to immediately copy the entire diskette onto
another  fresh  diskette,  but do this with a copy program rather
than with a backup program.  Otherwise,  the same problem will be
recreated on the new diskette. When the new copy is done, compare
the  number of blocks free in its directory to the number free on
the  original diskette.  If the numbers match, no damage has been
done.  If not,  very likely at least one file on the diskette has
been corrupted, and all should be checked immediately."
"[INST]In the context of the C64, What is the syntax and limitations of the SAVE command in Commodore computers?[/INST]1581 disk:  To reset drive, type: OPEN 15,8,15,'UJ':CLOSE 15.


1581 disk:  SAVE

  The  SAVE  command  preserves  a program or file on a formatted
diskette for latter use.

FORMAT FOR THE SAVE COMMAND:

  SAVE 'drive#:file name',device#

where   'file  name'  is  any  string  expression  of  up  to  16
characters,  preceded  by  the  drive  number  and  a  colon, and
followed by the device number of the disk, normally 8.
  However,  the  SAVE  command  will not work in copying programs
that  are  not in the BASIC text area,  such as 'DOS 5.1' for the
C64.  To copy it and similar machine-language programs,  you will
need a machine-language monitor program, such as the one resident
in the C128."
"[INST]In the context of the C64, What are the procedures and commands used to interact with the 1581 disk drive?[/INST]1581 disk: EXPLANATION OF PROCEDURES

send-cmd-string   sends  one  byte  of  the  command to determine
                  whether the drive is fast or slow.

toggle-clock      changes the state of the clock line.

set-clock-high    changes the state of the clock to logic 1.

set-clock-low     changes the state of the clock to logic 0.

wait-byte         polls the 8520 for a byte ready.

read-error        calls toggle-clock and wait-byte,  then returns
                  to the main if there are no errors.

store-data        stores data in a particular memory location.

last-byte         depending  on  sector size,  will increment and
                  compare value to sector size.

serial-in         sets the 8520 serial port and driver circuit to
                  input mode.

read-err          calls wait-byte and evaluates the status of the
                  previous controller job.

serial-out        sets the 8520 serial port and driver circuit to
                  output mode.

send-byte         sends a byte of data to the 1581.

read-1581         sends a typical unit read to a 1581.

write-1581        sends a typical unit write to a 1581."
"[INST]In the context of the C64, What is the format and protocol of the INQUIRE STATUS command in a disk assembly?[/INST]1581 disk in assembly: INQUIRE STATUS

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       W      C      M      0      1      1      0      N
-----------------------------------------------------------------
  03                  NEW STATUS (W-BIT CLEAR)
-----------------------------------------------------------------
  04                  NEW ORA MASK (M-BIT SET)
-----------------------------------------------------------------
  05                  NEW AND MASK (M-BIT SET)
-----------------------------------------------------------------

SWITCHES: W -- write switch (0 = write)
          M -- write AND/OR mask (04 new OR mask (M-bit set),  05
          new AND mask (M-bit set))
          C -- change (C=1 and W=0 -- log in disk, C=1 and W=1 --
          return  whether  disk was logged,  i.e. $B error or old
          status)
          N -- drive number
          X -- don't care

PROTOCOL: Burst handshake (W=1), conventional (W=0).

CONVENTIONS: This  is  a  method  of  reading  or writing current
             status, and changing the status mask value.

OUTPUT: None (W=0), Burst status byte (W=1)."
"[INST]In the context of the C64, What is the function of the SP_READ command in a 1581 disk controller job?[/INST]1581 disk Controller Job commands: SP_READ
       $A4     Reads   the   specified   physical   sector
                      directly  into  RAM starting at #0 ($0300).
                      It does not use the track cache buffer. The
                      sector   is   always  read  from  the  disk
                      regardless  of  the current contents of the
                      track cache."
"[INST]In the context of the C64, What is the difference between the logical and physical disk format of the Commodore 1581 disk drive?[/INST]1581 disk:  LOGICAL VERSUS PHYSICAL FORMAT

  All  DOS  operations  of  the 1581 are done in 256 byte blocks.
These blocks appear as individually numbered sectors on the disk.
By  going  through the DOS interface via the commands outlined in
this manual, the logical disk format is as follows:

  single sided
  80 tracks (track 1 through track 80)
  40 x 256 byte sectors per track (sector 0 through sector 39)

  Internally,  however,  the 1581 has a different view of things.
The disk is actually formatted as follows:

  double sided (side 0 and side 1)
  80 tracks per side (track 0 through track 79)
  10 x 512 byte sectors per track (sector 1 through sector 10)

  That  is  the  physical  disk  format created whenever a HEADER
(NEW)  command  is  sent  to the 1581 from the host computer. The
physical  format  is different from the logical so that more data
can be squeezed onto each disk.

  All commands sent from the host computer are parsed through the
DOS  (except the BURST commands) and refer to the logical format.
Software  inside the 1581 automatically takes care of the logical
to  physical translations necessary to retrieve the data properly
from the disk."
"[INST]In the context of the C64, What is the format and functionality of the CHGUTL UTILITY commands and parameters?[/INST]1581 disk in assembly: CHGUTL UTILITY

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       X      X      X      1      1      1      1      0
-----------------------------------------------------------------
  03     UTILITY COMMANDS: 'B','S','R','T','V',#DEV,'MR','MW'
-----------------------------------------------------------------
  04     COMMAND PARAMETER
-----------------------------------------------------------------

SWITCHES: X -- don't care

UTILITY COMMANDS; 'B' -- serial bus mode
                  'S' -- DOS sector interleave
                  'R' -- DOS retries
                  'T' -- ROM signature analysis
                  'V' -- verify select
                  #DEV -- device#

Note: Byte 02 is equivalent to '>'.

EXAMPLES: 'U0>B1' = Fast Serial, 'U0>B0' = Slow Serial
          'U0>S' + CHR$(SECTOR INTERLEAVE)
          'U0>R' + CHR$(RETRIES)
          'U0>T' (If the ROM signature failed, the activity LED
                 blinks 4 times)
          'U0>V0' = Disk Verify ON, 'U0>V1' = Disk Verify OFF
          'U0>' + CHR$(#DEV), where #DEV = 4 - 30
          'U0>MR' + CHR$(>memory address) + (# of pages)*
          'U0>MW' + CHR$(>memory address) + (# of pages)*

 * Burst memory read and memory write use standard burst protocol
   (without status byte)."
"[INST]In the context of the C64, What is the purpose and syntax of the SAVE WITH REPLACE command in disk operations?[/INST]1581 disk:  SAVE WITH REPLACE

  If a file already exists, it can't be saved again with the same
name  because  the  disk  drive only allows one copy of any given
file name per diskette. It is possible to get around this problem
using the  RENAME and  SCRATCH commands described later. However,
if  all  you  wish to do is replace a program or data file with a
revised  version,  another  command  is more convenient. Known as
SAVE-WITH-REPLACE, or @SAVE.  This option tells the disk drive to
replace any file it finds in the diskette directory with the same
name, substituting the new file for the old version.

FORMAT FOR SAVE WITH REPLACE:

  SAVE '@drive#:file name',device#

where all the parameters are as usual except for adding a leading
'at' sign (@). The 'drive#:' is required here.

EXAMPLE:

  SAVE'@0:REVISED PROGRAM',8

  The  actual  procedure   is  that  the  new  version  is  saved
completely, then the old version is erased. Because it works this
way,  there  is  little  danger  a  disaster such as losing power
midway  through  the  process  would destroy both the old and new
copies  of the file.  Nothing happens to the old copy until after
the new copy is saved properly."
"[INST]In the context of the C64, What is the format for a monitor save command on a 1581 disk?[/INST]1581 disk: FORMAT FOR A MONITOR SAVE:

  S 'drive#:file name',device#,starting address,ending address+1

where 'drive#:' is the drive number,  0 on the 1581;  'file name'
is any valid file name up to 14 characters long  (leaving two for
the  drive  number  and  colon);  'device#' is a two digit device
number,  normally 08 (the leading 0 is required); and the address
to be saved are given in Hexadecimal but without a leading dollar
sign  ($).  Note  the  ending address listed must be one location
beyond the last location to be saved.

EXAMPLE:

  Here is the required syntax to SAVE a copy of 'DOS 5.1':

  S '0:DOS 5.1',08,CC00,D000"
"[INST]In the context of the C64, What is the format and protocol of the FASTLOAD UTILITY disk in assembly?[/INST]1581 disk in assembly: FASTLOAD UTILITY

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       P      X      X      1      1      1      1      1
-----------------------------------------------------------------
  03                          FILE NAME
-----------------------------------------------------------------

SWITCHES: P -- sequential file bit (P = 1,  does not have to be a
          program file)
          X -- don't care

PROTOCOL: Burst handshake.

OUTPUT: Burst status byte preceding each sector transferred.

STATUS IS AS FOLLOWS:   0000000X -- OK
                      * 00000010 -- file not found
                     ** 00011111 -- EOI

*  Values between 3 and 15 should be considered a file read error
** The  byte  following the EOI status byte is the number of data
   bytes to follow."
"[INST]In the context of the C64, What is the purpose and functionality of the Track Cache Buffer in the 1581 disk drive?[/INST]1581 disk:  TRACK CACHE BUFFER

  One  of  the  improvements  in  the  1581  design over previous
Commodore  disk  drives  which makes the device more efficient is
the Track Cache buffer. This buffer is located from $0C00 through
$1FFF.  All  disk  accesses involve an entire physical track at a
time.  If  a single sector is needed from a particular track, the
entire  track is read into RAM.  Consequently,  any more requests
for sectors from the same track require only a RAM data transfer,
rather  than  a  search  of  the  track on the disk again. Sector
writes  are also speeded up considerably,  since each consecutive
write  to  sectors  on  the same track requires only a RAM to RAM
data transfer. After data is written into the Track Cache Buffer,
it  is not written to the disk until one of the following occurs:
1) a request is made for access of a sector on a different track,
2) a  'dump  track  buffer'  command is issued,  or  3) after 250
milliseconds of no serial bus activity."
"[INST]In the context of the C64, What error message is displayed when trying to create a new file with a duplicate name on a diskette?[/INST]1581 disk: Controller commands error code 63: FILE EXISTS
    A  file  with  the  same name as has been requested for a new
    file already exists on the diskette. Duplicate file names are
    not allowed. Select another name."
"[INST]In the context of the C64, What is the error code 26 on a disk controller, and what is its typical cause?[/INST]1581 disk: Controller commands error code 26: WRITE PROTECT ON
    The controller has been requested to write a data block while
    the  write-protect  sensor  is  uncovered.  Usually caused by
    writing  to  a  diskette  whose write protect notch is pushed
    back  to  expose  the hole to prevent changing the diskette's
    contents."
"[INST]In the context of the C64, What are the jump table vectors and their corresponding descriptions for the 1581 disk controller?[/INST]1581 disk:  Indirect Vector Jump Table
Name             Location  Description
-----------------------------------------------------------------
JIDLE              $FF00   Main  idle  loop.  When  a  Controller
                           command is completed  the IDLE routine
                           is executed. It first checks to see if
                           there are any more jobs pending in the
                           Job Queue. If so, it executes them. If
                           not,  it sits in the idle loop waiting
                           for  something  to  happen,   such  as
                           another  job being put into the queue,
                           ATN  line going low,  disk inserted or
                           removed, etc.
JIRQ               $FF03   Interrupt routine. Interrupts normally
                           occur  from  the following sources  --
                           ATN  line going low,  Fast Serial Byte
                           is   shifted   in,   timer  time  out,
                           execution of a BRK instruction.
JNMI               $FF06   Does  a  'soft'  reset  (UI  command).
                           Default   vectors  and  variables  are
                           restored.  Searches for 'COPYRIGHT CBM
                           86'  USR  type  file  to  boot. No RAM
                           check or ROM checksum is done. Device#
                           switches are read.
JVERDIR            $FF09   VALIDATE command (collect).
JINTDRV            $FF0C   INITIALIZE command.
JPART              $FF0F   Routine to create or switch partitions
JMEM               $FF12   Memory  Read/Memory  Write  (M-R, M-W)
                           commands.
JBLOCK             $FF15   Performs all  BLOCK commands,  such as
                           ALLOCATE,  FREE, READ, WRITE, EXECUTE,
                           POINTER.
JUSER              $FF18   USER command.
JRECORD            $FF1B   RECORD   command   for  relative  file
                           positioning.
JUTLODR            $FF1E   Utility loader command (&).
JDSKCPY            $FF21   COPY command.
JRENAME            $FF24   RENAME command.
JSCRTCH            $FF27   SCRATCH command.
JNEW               $FF2A   NEW/Format command.
ERROR              $FF2D   Controller error handler routine.
JATNSRV            $FF30   Serial Bus attention (ATN) server.
JTALK              $FF33   Serial Bus talk routine.
JLISTEN            $FF36   Serial Bus listen routine.
JLCC               $FF39   Controller routine.
JTRANS_TS          $FF3C   Logical to physical sector translation
                           routine.
CMDERR             $FF3F   DOS error handler routine.

JSTROBE_CONTROLLER $FF54   Direct Controller call.
JCBMBOOT           $FF57   CBM autoloader routine.
JCBMBOOTRTN        $FF5A   Return   from   CBM   autoloader  with
                           autoloader disabled.
JSIGNATURE         $FF5D   Signature analysis routine.
JDEJAVU            $FF60   Switch    for   autoloader   boot   on
                           INITIALIZE   or   BURST INQUIRE/QUERY.
                           Enter   with   carry   set  to  enable
                           autoloader, carry clear to disable it.
JSPINOUT           $FF63   SPIN,  SPOUT.   Sets  up  fast  serial
                           direction  as  input or output.  Carry
                           set to do SPOUT, cleared to do SPIN.
JALLOCBUFF         $FF66   Allocates   RAM  buffers.   Call  with
                           buffer#  in  reg A  (1 = buffer 0, 2 =
                           buffer 1...)."
"[INST]In the context of the C64, What are the different ways to open a sequential file in BASIC 7.0 and BASIC 2.0, and how can you read and write to these files?[/INST]1581 disk with basic 7,0:EXAMPLES OF OPENING SEQUENTIAL FILES:

  To create a sequential file of phone numbers, you could use:

  BASIC 7.0:  DOPEN#2,'PHONES',D0,U8,W
  BASIC 2.0:  OPEN 2,8,2,'0:PHONES,SEQUENTIAL,WRITE'
              or
              OPEN 2,8,2,'0:PHONES,S,W'

  On  the  chance  you've  already  got  a  'PHONES'  file on our
diskette, you can avoid a 'FILE EXISTS' error message by doing an
@OPEN:

  BASIC 7.0:  DOPEN#2,'@PHONES',D0,U8,W
  BASIC 2.0:  OPEN 2,8,2,'@0:PHONES,S,W'

This  erases  all  your old phone numbers,  so make sure that any
information  that  may  be  deleted  is  of  no importance. After
writing  our  phone  file,  remove  the diskette and turn off the
system.  To recall the data in the file, reopen it with something
like:

  BASIC 7.0:  DOPEN#8,'PHONES',D0,U8
  BASIC 2.0:  OPEN 8,8,8,'0:PHONES,S,R'

It doesn't matter  whether the file and channel numbers match the
ones we used before,  but the file name does have to match.  It's
possible  to  use an abbreviation form of the file name, if there
are no other files that would have the same abbreviation:

  BASIC 7.0:  DOPEN#10,'PH*',D0,U8
  BASIC 2.0:  OPEN 10,8,6,'0:PH*,S,R'

  If you have too many phone numbers,  they  might not fit in one
file.  In  that  case,  use  several similar file names and let a
program choose the correct file.

  BASIC 7.0:  100 INPUT'WHICH PHONE NUMBERS FILE (1-3)';PH
              110 IF PH<>1 AND PH<>2 AND PH<>3 THEN 100
              120 DOPEN#4,'PHONE'+STR$(PH),D0,U8

  BASIC 2.0:  100 INPUT'WHICH PHONE NUMBERS FILE (1-3)';PH
              110 IF PH<>1 AND PH<>2 AND PH<>3 THEN 100
              120 OPEN 4,8,2,'PHONE'+STR$(PH)+',S,R'

You can omit the drive number on an OPEN command  to read a file.
Doing  so  allows those with dual drives to search both diskettes
for the file."
"[INST]In the context of the C64, What is the BASIC code to read a relative record from a disk file in both variable and fixed length fields formats?[/INST]1581 disk:  READING A RELATIVE RECORD

  Once  a  relative record has been written properly to diskette,
reading it back  into computer memory  is fairly simple,  but the
procedure  again  varies,  depending  on whether it uses fixed or
variable  length  fields.  Here  are  the program lines needed to
read  back  the  variable fields created above from record number
RE in file and channel 3:

BASIC 7.0:

start tok64 /128 readv128.prg
   10 :
   20 dopen#3,'myrelfile',l88
   30 input'enter record number';re
   40 :
   50 :
   60 record#3,(re),1
   70 gosub 1000
   80 input#3,na$,sa$,cs$,zp$
   90 gosub 1000
  100 record#3,(re),1
  110 gosub 1000
  120 print na$:print sa$
  130 print cs$:print zp$
  140 dclose#3:end
 1000 if ds<20 then return
 1002 :
 1010 print'error:';ds$:dclose#3:end

BASIC 2.0:

start tok64 readv64.prg
   10 open 15,8,15
   20 open 3,8,3,'myrelfile,l,'+chr$(88)
   30 input'enter record number';re
   40 rh=int(re/256)
   50 rl=re-256*rh
   60 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
   70 gosub 1000
   80 input#3,na$,sa$,cs$,zp$
   90 gosub 1000
  100 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  110 gosub 1000
  120 print na$:print sa$
  130 print cs$:print zp$
  140 close 3:close 15:end
 1000 input#15,en,em$,et,es
 1002 if en<20 then return
 1010 print'error:';em$:close 3:close 15:end


  Here are the lines  needed to read back  the version with fixed
length fields:

BASIC 7.0:

start tok64 /128 readf128.prg
   10 :
   20 dopen#3,'myrelfile',l88
   30 input'enter record number';re
   40 :
   50 :
   60 record#3,(re),1
   70 gosub 1000
   80 input#3,da$
   90 gosub 1000
  100 record#3,(re),1
  110 gosub 1000
  112 na$=left$(da$,27)
  114 sa$=mid$(da$,28,27)
  116 cs$=mid$(da$,55,23)
  118 zp$=right$(da$,10)
  120 print na$:print sa$
  130 print cs$:print zp$
  140 dclose#3:end
 1000 if ds<20 then return
 1002 :
 1010 print'error:';ds$:dclose#3:end


BASIC 2.0:

start tok64 readf64.prg
   10 open 15,8,15
   20 open 3,8,3,'myrelfile,l,'+chr$(88)
   30 input'enter record number';re
   40 rh=int(re/256)
   50 rl=re-256*rh
   60 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
   70 gosub 1000
   80 input#3,da$
   90 gosub 1000
  100 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  110 gosub 1000
  112 na$=left$(da$,27)
  114 sa$=mid$(da$,28,27)
  116 cs$=mid$(da$,55,23)
  118 zp$=right$(da$,10)
  120 print na$:print sa$
  130 print cs$:print zp$
  140 close 3:close 15:end
 1000 input#15,en,em$,et,es
 1002 if en<20 then return
 1010 print'error:';em$:close 3:close 15:end"
"[INST]In the context of the C64, What is an example of a BASIC 7.0 program that demonstrates the use of sequential files?[/INST]1581 disk with basic 7,0: DEMONSTRATION OF SEQUENTIAL FILES (BASIC 7.0)

  Use  the  following  program  for  your  first experiments with
sequential  files.  Comments  have  been added to help you better
understand it.

 150 cr$=chr$(13)                 Make a carriage return variable
 170 print chr$(147):rem clear
     screen
 190 print'** write a file **'
 210 print
 220 dopen#2,'@seq file',w        Open demo file with replace
 230 gosub 500                    Check for disk errors
 240 print'enter a word,
     then a number'
 250 print'or 'end,0' to stop'
 260 print
 270 input a$,b                   Accept a string & number
                                  from keyboard
 280 print#2,a$;cr$;b             Write them to the disk file
 290 gosub 500
 300 if a$<>'end' then 270
 310 print
 320 dclose#2                     Tidy up
 340 print'** read same file
     back **'
 360 print
 370 dopen#2,'seq file'           Reopen same file for reading
 380 gosub 500
 390 input#2,a$,b                 Read next string & number
                                  from file
 400 rs=st
 410 gosub 500
 420 print a$,b                   Display file contents
 430 if rs=0 then 390             until done,
 440 if rs<>64 then
     print'status=';rs            unless there's an error
 450 dclose#2                     Then quit
 460 end
 480 rem ** error check s/r **
 500 if ds>0 then print ds$:stop
 510 return"
"[INST]In the context of the C64, What is the purpose and syntax of the GET# statement in BASIC, and how is it used to retrieve data from a disk drive?[/INST]1581 disk with basic 7,0: READING FILE DATA: USING GET#

  The  GET#  statement  retrieves  data  from the disk drive, one
character  at a time.  Like the similar keyboard GET statement in
BASIC,  it  only  accepts  a  single  character  into a specified
variable. However, unlike the GET statement, it doesn't just fall
through  to  the next statement if there is no data to be gotten.
The  primary  use  of  GET# is to retrieve from diskette any data
that  cannot be read into an INPUT# statement,  either because it
is  too  long  to  fit in the input buffer or because it includes
troublesome characters.

FORMAT FOR THE GET# STATEMENT:

  GET#file#,variable list

where 'file#' is the same file number given in the desired file's
current OPEN statement,  and 'variable list' is one or more valid
BASIC  variable  names.  If  more  than one data element is to be
input by a particular GET# statement,  each variable name must be
separated from others by a comma.
  In practice,  you will almost never see a GET or GET# statement
containing  more  than  one  variable  name.  If  more  than  one
character  is  needed,  a  loop  is  used  rather than additional
variables.  Also  as in the INPUT# statement,  it is safer to use
string  variables  when  the file to be read might contain a non-
numeric character.
  Data in a GET# statement comes in byte-by-byte,  including such
normally  invisible  characters  as  the Carriage Return, and the
various cursor controls.  All but one will be read properly.  The
exception is CHR$(0),  the ASCII Null character.  It is different
from an empty string  (one of the form A$=''),  even though empty
strings are often referred to as null strings.  Unfortunately, in
a GET# statement,  CHR$(0) is converted into an empty string. The
cure is to test for an empty string after a GET#, and replace any
that  are  found  with  CHR$(0) instead.  The first example below
illustrates the method.

EXAMPLES:

  To  read  a file that may contain a CHR$(0),  such as a machine
language program file, you could correct any CHR$(0) bytes with

  1100 GET#3,G$:IF G$='' THEN G$=CHR$(0)

  If an overlong string has managed to be recorded in a file,  it
may be read back safely into the computer with GET#, using a loop
such as this

  3300 B$=''
  3310 GET#1,A$
  3320 IF A$<>CHR$(13) THEN B$=B$+A$: GOTO 3310

The limit for such a technique is 255 characters.  It will ignore
CHR$(0),  but that may be an advantage in building a text string.
If CHR$(0) is required in the file, then add the following line:

  3315 IF A$='' THEN A$=CHR$(0)

  GET# may be useful in recovering damaged files,  or files  with
unknown contents. The BASIC reserved variable ST (the file STatus
variable)  can  be used to indicate when all of a properly closed
file has been read.

  500 GET#2,S$
  510 SU=ST: REM REMEMBER FILE STATUS
  520 PRINT S$;
  530 IF SU=0 THEN 500: REM IF THERE'S MORE TO BE READ
  540 IF SU<>64 THEN PRINT'STATUS ERROR: ST =';SU

Copying  ST into  SU is often an unnecessary precaution, but must
be done  if any other file-handling statement appears between the
one which read from the file  and the one that loops back to read
again.  For example, it would be required if line 520 was changed
to

  520 PRINT#1,S$;

Otherwise,  the  file status checked in line 530 would be that of
the write file, not the read file.

  The  following  table applies to single errors or a combination
of two or more errors.

|       POSSIBLE VALUES OF THE FILE STATUS VARIABLE 'ST',       |
|                       AND THEIR MEANINGS                      |
|                                                               |
| IF ST=                        THEN                            |
|    0     All is OK                                            |
|    1     Receiving device was not available                   |
|          (time out on talker)                                 |
|    2     Transmitting device was not available                |
|          (time out on listener)                               |
|    4     Cassette data file block was too short               |
|    8     Cassette data file block was too long                |
|   16     Unrecoverable read error from cassette, verify error |
|   32     Cassette checksum error -- one or more faulty        |
|          characters were read                                 |
|   64     End of file reached (EOI detected)                   |
|  128     Device not present, or end of tape mark found        |
|          on cassette                                          |"
"[INST]In the context of the C64, What is the BASIC 2.0 code to write a record to a file?[/INST]BASIC 2.0:

start tok64 writef64.prg
  100 input'enter record number';re
  110 open 15,8,15
  120 open 3,8,3,'myrelfile,l,'+chr$(88)
  130 bl$='{160*27}'
  140 input'name';na$
  145 ln=len(na$)
  150 if ln>27 then 140
  155 na$=na$+left$(bl$,27-ln)
  160 input'street';sa$
  165 ln=len(sa$)
  170 if ln>27 then 160
  175 sa$=sa$+left$(bl$,27-ln)
  180 input'city & state';cs$
  185 ln=len(cs$)
  190 if ln>23 then 180
  195 cs$=cs$+left$(bl$,23-ln)
  200 input'zip code';zp$
  205 ln=len(zp$)
  210 if ln>10 then 200
  215 zp$=zp$+left$(bl$,10-ln)
  220 da$=na$+sa$+cs$+zp$
  260 rh=int(re/256)
  270 rl=re-256*rh
  280 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  290 gosub 1000:if en=50 then print#3,chr$(255):gosub 1000:\
      goto 280
  300 gosub 1000
  310 print#3,da$
  320 gosub 1000
  330 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  340 gosub 1000
  350 close 3:close 15:end
 1000 input#15,en,em$,et,es
 1002 if en<20 then return
 1010 print'error:';em$:close 3:close 15:end"
"[INST]In the context of the C64, What is the syntax for opening a sequential file in BASIC 7.0 and BASIC 2.0?[/INST]1581 disk with basic 7,0: FORMAT FOR THE DISK OPEN STATEMENT FOR SEQUENTIAL FILES:

  BASIC 7.0: DOPEN#file#,'file name'[,Ddrive#][,Udevice#][,W]
  BASIC 2.0: OPEN file#,device#,channel#,'drive#:file name,
                                          file type,direction'"
"[INST]In the context of the C64, How do you change the device number of a 1581 disk drive?[/INST]1581 disk: CHANGING THE DEVICE NUMBER

  Two  switches  on the back of the 1581 enable you to change the
device#  of  the drive.  You can use a screwdriver,  pen,  or any
other  small tool to set the switches.  The following table shows
the settings required for each device number:

            +------------+------------+-------------+
            |    Left    |    Right   |   Device#   |
            +------------+------------+-------------+
            |     UP     |     UP     |      8      |
            |    DOWN    |     UP     |      9      |
            |     UP     |    DOWN    |      10     |
            |    DOWN    |    DOWN    |      11     |
            +------------+------------+-------------+

  Another  way  to temporarily change the device number of a disk
drive is via a program.  When power is first turned on, the drive
reads  an  I/O  location  whose  value  is  controlled by the two
switches  on  its circuit board,  and writes the device number it
reads  there  into  memory  locations  119  and  120.   Any  time
thereafter, you may write over that device number with a new one,
which will be effective until it is changed again, or the 1581 is
reset."
"[INST]In the context of the C64, What is the error message and explanation for a CRC error in the header of a requested data block on a disk controller?[/INST]1581 disk: Controller commands error code 27: READ ERROR (CRC error in header)
    The  controller  detected an error in the header bytes of the
    requested  data  block.  The  block  was  not  read into disk
    memory."
"[INST]In the context of the C64, What error message is displayed when trying to access a file with a mismatched type?[/INST]1581 disk: Controller commands error code 64: FILE TYPE MISMATCH
    The  requested file access is not possible using files of the
    type named. Reread the chapter covering that file type."
"[INST]In the context of the C64, What error message is displayed when a user enters an invalid command in DOS?[/INST]1581 disk: Controller commands error code 31: SYNTAX ERROR (invalid command)
    The  DOS  does not recognize the command.  It must begin with
    the first character sent. Check your typing and try again."
"[INST]In the context of the C64, What is the disk command that allows you to read bytes from disk memory into the computer, similar to the BASIC PEEK() function?[/INST]1581 disk:  MEMORY-READ

  The 6502 has an address  space  from  $0000-$FFFF.  You can get
direct  access  to  any  location  within  this  by  using memory
commands. MEMORY-READ allows you to select which byte or bytes to
read from disk memory into the computer.  The MEMORY-READ command
is  the  equivalent  of the BASIC PEEK() function,  but reads the
disk's memory instead of the computer's memory.


|   Unlike other disk commands, those in this chapter cannot be |
| spelled out in full. Thus, M-R is correct, but MEMORY-READ is |
| not a permitted alternate wording.                            |"
"[INST]In the context of the C64, What is the error message and explanation for a DOS error code 66?[/INST]1581 disk: Controller commands error code 66: ILLEGAL TRACK AND SECTOR
    The  DOS has attempted to access a track or sector which does
    not  exist.  May  indicate  a faulty link pointer in the data
    block."
"[INST]In the context of the C64, What are the advantages and types of random access files on Commodore disk drives?[/INST]1581 disk with basic 7,0: RELATIVE DATA FILES


  Sequential files are very useful  when you're just working with
a continuous stream of data --  i.e. information that can be read
or written all at once.  However, sequential files are not useful
in some situations.  For  example,  after writing a large list of
mail labels,  you wouldn't want to have to reread the entire list
each time you need a person's record. Instead, you need some kind
of random access, a way to get to a particular label in your file
without having to read through all those preceding it.
  As  an  example,  compare  a  record  turntable with a cassette
recorder. You have to listen to a cassette from beginning to end,
but  a  turntable  needle  can  be  picked  up  at  any time, and
instantly moved to any spot on the record.  Your disk drive works
like a turntable in that respect.  In this chapter you will learn
about a type of file that reflects this flexibility.
  Actually,  two  different  types  of random access files may be
used on Commodore disk drives:  relative files  and random files.
Relative  files  are  much more convenient for most data handling
operations,  but  true  random  access  file  commands  are  also
available  to  advanced users,  and will be discussed in the next
chapter."
"[INST]In the context of the C64, What is the purpose of using index files in conjunction with sequential and relative files?[/INST]1581 disk:  THE VALUE OF INDEX FILES

  In the last two chapters you have learned how to use sequential
and relative files separately.  But they are often used together,
with the sequential file used to keep brief records of which name
in  the  relative  file is stored in each record number. That way
the  contents  of  the  sequential file can be read into a string
array and sorted alphabetically. After sorting, a technique known
as a binary search can be used to quickly find an entered name in
the  array,  and  read  in  or write the associated record in the
relative  file.  Advanced  programs can maintain two or more such
index files, sorted in differing ways simultaneously."
"[INST]In the context of the C64, What are direct access commands used for on a diskette?[/INST]1581 disk:  DIRECT ACCESS COMMANDS


  Direct  access  commands  specify  individual  sectors  on  the
diskette,  reading  and  writing  information entirely under your
direction.  This  gives them almost complete flexibility in data-
handling programs, but imposes tremendous responsibilities on the
programmer.  As a result,  they are normally used only in complex
commercial  programs  able to properly organize data without help
from the disk drive itself.
  A far more common use of direct access commands is  in  utility
programs  used  to  view and alter parts of the diskette that are
not normally seen directly.  For  instance,  such commands can be
used to change the name of a diskette  without erasing all of its
programs,  to lock a program so it can't be erased,  or hide your
name in a location where it won't be expected."
"[INST]In the context of the C64, What is the concept of organizing data in a relative file, and how does it differ from sequential files in terms of structure and access speed?[/INST]1581 disk with basic 7,0: FILES, RECORDS, AND FIELDS

  When learning about sequential files,  you  did not worry about
the organization of data within a file,  so long as the variables
used to write the file  matched up properly with those which read
it  back  into the computer.  But in order for relative access to
work,  you need a more structured and predictable environment for
our data.
  The  structure  you  will  use  is  similar to that used in the
traditional filing cabinet. In a traditional office, all customer
records might be kept in a single file cabinet. Within this file,
each  customer  has a personal record in a file folder with their
name on it,  that contains everything the office knows about that
person.  Likewise,  within  each  file folder,  there may be many
small  slips  of  paper,  each  containing one bit of information
about  that customer,  such as a home phone number or the date of
the most recent purchase.
  In  a  computerized office,  the file cabinet is gone,  but the
concept of a file containing all the information about a group or
topic  remains.  The file folders are gone too, but the notion of
subdividing the file into individual records remains. The slip of
paper  within  the  personal  records  are gone too,  replaced by
subdivisions  within  the records,  called fields.  Each field is
large enough to hold one piece of information about one record in
the  file.  Thus,  within  each  file there are many records, and
within each record there are typically many fields.
  A  relative  file takes care of organizing the records for you,
numbering them from 1 to the highest record number,  by ones, but
the fields are up to you to organize.  Each record will be of the
same size, but the 1581 won't insist that they all be divided the
same way. On the other hand, they normally will be subdivided the
same  way,  and  if it can be known in advance exactly where each
field  starts  within  each  record,  there are even fast ways to
access  a  desired  field within a record without reading through
the  other  fields.  As  all  of this implies,  access speed is a
primary reason for putting information into a relative disk file.
Some  well-written  relative  file  programs are able to find and
read  the record of one desired person out of a thousand in under
15 seconds, a feat no sequential file program could match."
"[INST]In the context of the C64, What is the memory map and functionality of the Commodore 1581 disk drive?[/INST]1581 disk:  1581 MEMORY MAP

Location                        Purpose
-----------------------------------------------------------------
0000-00FF       Zero page work area, job queue, variables
0100-01FF       Stack, variables, vectors
0200-02FF       Command buffer, tables, variables
0300-09FF       Data buffers (0-6)
0A00-0AFF       BAM for tracks 0-39
0B00-0BFF       BAM for tracks 40-79
0C00-1FFF       Track cache buffer
4000-5FFF       8520A CIA
6000-7FFF       WD177X FDC
8000-FEFF       32K byte ROM, DOS and controller routines
FF00-FFFF       Jump table, vectors
-----------------------------------------------------------------
|   The  1581,  as  well  as  other  Commodore  peripherals, is |
| designed   to   support   interfacing  via  software  command |
| structures.  The software commands provided in the 1581 allow |
| for   a   smooth   and  controllable  interface  between  the |
| peripheral  and  CPU.  Although  Commodore  has  provided the |
| mechanism  enabling  users  to  load  and  execute  their own |
| machine language programs within the 1581 system, please keep |
| in mind that Commodore reserves the right to change ROM, RAM, |
| I/O and hardware structure at any time.  Consequently, if the |
| defined software interface is bypassed,  future compatibility |
| of  the  user's machine language software within the 1581 may |
| be in question. The 1581 was not designed primarily as a user |
| programmable  device,  but Commodore recognizes that  certain |
| operations   (such  as  copy  protection)  cannot  be  easily |
| achieved without this ability.                                |


  If  you  find  it  necessary to use machine language within the
1581,  use  the jump table listed in this chapter and Chapter 10.
That  will  lessen the possibility of incompatibility if a future
version of the 1581 changes internally.  Also, let the controller
work for you on the physical level by requesting its help via the
JOB QUEUE.  That  too  will  greatly  increase  the likelihood of
future compatibility."
"[INST]In the context of the C64, What is the error code 65 on a disk controller and how should you respond to it?[/INST]1581 disk: Controller commands error code 65: NO BLOCK
    Occurs  in  conjunction  with  B-A.  The  sector you tried to
    allocate  is already allocated.  The track and sector numbers
    returned  are  the next higher track and sector available. If
    the  track  number  returned is 0,  all remaining sectors are
    full. If the diskette is not full yet,  try a lower track and
    sector."
"[INST]In the context of the C64, What is the error message and explanation for a DOS error code 30?[/INST]1581 disk: Controller commands error code 30: SYNTAX ERROR (general syntax)
    The  DOS  cannot  interpret  the  command sent to the command
    channel.  Typically,  this  is caused by an illegal number of
    file  names or an illegal pattern.  Check your typing and try
    again."
"[INST]In the context of the C64, What are the key features and considerations of the Burst Command Instruction Set (BCIS) for the 1581 disk?[/INST]1581 disk:  BURST COMMANDS


  The  Burst  Command  Instruction  Set  (BCIS)  is  a  series of
powerful,  versatile,  and complex commands that enables the user
to format,  read,  and write in numerous formats.  Burst commands
are sent via kernal calls, but the handshaking of data is done by
the user for maximum performance. There is no parameter checking,
so exercise care  when using the BCIS.  For instance,  if a burst
read  with an illegal track address is sent to a 1581,  the drive
will keep trying to find the invalid track.  Reading  and writing
in other formats is automatic if the commands are given in proper
sequence. Please become thoroughly familiar with all the commands
and follow the examples given in this chapter.  It's important to
follow the handshake conventions exactly for maximum performance.
  With the exception of  READ  and  WRITE,  burst commands do not
translate  from  logical to physical track and sector.  All track
and  sector  parameters  refer to physical locations (see Chapter
10).  Burst  sector  READ  and  WRITE  commands provide a flag to
enable logical to physical translation.  If the flag is set,  the
drive  does  the  translation  and  the default logical number of
bytes  per  sector  (256)  is transferred instead of the physical
number of bytes per sector (512)."
"[INST]In the context of the C64, What is the error message and explanation for a DOS error code 34?[/INST]1581 disk: Controller commands error code 34: SYNTAX ERROR (no file given)
    The  file  name was left out of a command or the DOS does not
    recognize  it  as  such.  Typically,  a  colon (:)  has  been
    omitted. Try again."
"[INST]In the context of the C64, What is the error code 61 in DOS and what does it indicate?[/INST]1581 disk: Controller commands error code 61: FILE NOT OPEN
    A file is being accessed that has not been opened by the DOS.
    In some such cases no error message is generated.  Rather the
    request is simply ignored."
"[INST]In the context of the C64, What is the format for the RECORD# command in BASIC 7.0 and BASIC 2.0, and how does it work?[/INST]FORMAT FOR THE RECORD# COMMAND:

  BASIC 7.0: RECORD#file#,record number[,offset]
  BASIC 2.0: PRINT#15,'P'+CHR$(channel#+96)+CHR$(<record#)+
             CHR$(>record#)+CHR$(offset)

where  'file#'  is  the  file#  specified  in  the  current DOPEN
statement for the specified file,  'record number' is the desired
record number,  'channel#' is the channel number specified in the
current OPEN statement for the specified file,  '<record#' is the
low  byte  of the desired record number,  expressed as a two-byte
integer,  '>record#'  is  the  high  byte  of  the desired record
number,  and an optional 'offset' value,  if present, is the byte
within  the  record  at  which  a  following Read or Write should
begin.
  To fully understand this command,  you must understand how most
integers  are  stored  in computers based on the 6502 and related
microprocessors.   In   the   binary   arithmetic   used  by  the
microprocessor,  it  is  possible to express any unsigned integer
from  0-255  in  a single byte.  It is also possible to store any
unsigned integer from 0-65535 in two bytes, with one byte holding
the  part  of the number that is evenly divisible by 256, and any
remainder  in the other byte.  In machine language,  such numbers
are  written backwards,  with the low-order byte  (the remainder)
first,  followed  by  the  high-order byte.  In assembly language
programs written with the Commodore Assembler,  the low part of a
two-byte  number  is  indicated  by  preceding its label with the
less-than character (<).  Similarly,  the high part of the number
is indicated by greater-than (>).

|   To avoid the remote possibility of corrupting relative file |
| data, it is necessary to give RECORD# command once before the |
| Read or Write access and once after the access.               |
|   Although  this  is  not  necessary  for  the  1581,   other |
| Commodore drives require it. To make your programs compatible |
| with those other drives, it's a good idea to use it.          |

EXAMPLES:

  In  BASIC  7.0,  to  position the record pointer for file #2 to
record number 3, type:

  RECORD#2,3

  In BASIC 2.0,  to position the record pointer for channel #2 to
record number 3, type:

  PRINT#15,'P'+CHR$(98)+CHR$(3)+CHR$(0)

The  CHR$(98)  comes from adding the constant (96) to the desired
channel  number  (2).  (96+2=98)  Although the command appears to
work  even  when  96  is  not  added  to  the channel number, the
constant is normally added to maintain compatibility with the way
RECORD# works in BASIC 7.0.
  Since  3  is  less  than  256,  the  high  byte  of  its binary
representation is 0, and the entire value fits into the low byte.
Since you want to read or write from the beginning of the record,
no offset value is needed.
  Since these calculations quickly become tedious,  most programs
are  written to do them for you.  Here is an example of a program
which  inputs  a  record number and converts it into the required
low-byte/high-byte form:

  450 INPUT'RECORD NUMBER DESIRED';RE
  460 IF RE<1 OR RE>65535 THEN 450
  470 RH=INT(RE/256)
  480 RL=RE-256*RH
  490 PRINT#15,'P'+CHR$(98)+CHR$(RL)+CHR$(RH)

Assuming  RH  and  RL  are calculated as in the previous example,
programs  may  also  use  variables  for  the channel, record and
offset required:

  570 INPUT'CHANNEL, RECORD, OFFSET DESIRED';CH,RE,OF
  630 PRINT#15,'P'+CHR$(CH+96)+CHR$(RL)+CHR$(RH)+CHR$(OF)"
"[INST]In the context of the C64, What is the BASIC 7.0 code to create a program that accepts user input for a record number, name, street, city and state, and zip code, and then writes this data to a file with fixed-length fields?[/INST]To  use  the  above  program  lines  for the version with fixed
length fields, we would alter a few lines as follows:

BASIC 7.0:

start tok64 /128 writf128.prg
  100 input'enter record number';re
  110 :
  120 dopen#3,'myrelfile',l88
  130 bl$='{160*27}'
  140 input'name';na$
  145 ln=len(na$)
  150 if ln>27 then 140
  155 na$=na$+left$(bl$,27-ln)
  160 input'street';sa$
  165 ln=len(sa$)
  170 if ln>27 then 160
  175 sa$=sa$+left$(bl$,27-ln)
  180 input'city & state';cs$
  185 ln=len(cs$)
  190 if ln>23 then 180
  195 cs$=cs$+left$(bl$,23-ln)
  200 input'zip code';zp$
  205 ln=len(zp$)
  210 if ln>10 then 200
  215 zp$=zp$+left$(bl$,10-ln)
  220 da$=na$+sa$+cs$+zp$
  260 :
  270 :
  280 record#3,(re),1
  290 if ds=50 then print#3,chr$(255):gosub 1000:goto 280
  300 gosub 1000
  310 print#3,da$
  320 gosub 1000
  330 record#3,(re),1
  340 gosub 1000
  350 dclose#3:end
 1000 if ds<20 then return
 1002 :
 1010 print'error:';ds$:dclose#3:end"
"[INST]In the context of the C64, What command should you type to properly close all open disk files in BASIC when it halts with an error?[/INST]1581 disk:  If  BASIC  halts with an error when you have files open, BASIC
aborts  them  without closing them properly on the disk. To close
them properly on the disk, you must type:

  CLOSE 15: OPEN 15,8,15,'I': CLOSE 15

This  opens  the command channel and immediately closes it, along
with all other disk files.  Failure to close a disk file properly
both  in  BASIC  and  on the disk may result in losing the entire
file."
"[INST]In the context of the C64, what is the format for the VERIFY command?[/INST]FORMAT FOR THE VERIFY COMMAND:

  VERIFY 'drive#:pattern',device#,relocate flag

where  'drive#:'  is  an optional drive number,  'pattern' is any
string expression that evaluates to a file name,  with or without
pattern-matching  characters,  and  'device#'  is the disk device
number, normally 8. If the relocate flag is present and equals 1,
the  file  will  be verified where originally saved,  rather than
relocated into the BASIC text area.

A useful alternate form of the command is:

  VERIFY '*',device#

It  verifies  the last files used without having to type its name
or drive number. However, it won't work properly after SAVE-WITH-
REPLACE,  because the last file used was the one deleted, and the
drive  will  try  to  compare  the deleted file to the program in
memory.  No  harm will result,  but 'VERIFY ERROR' will always be
announced.  To  use VERIFY after @SAVE,  include at least part of
the file name that is to be verified in the pattern.

  One  other  note  about  VERIFY  -- when you VERIFY a relocated
BASIC  file,  an  error  will  nearly always be announced, due to
changes  in  the  link  pointers  of  BASIC  programs made during
relocation.  It  is best to VERIFY files saved from the same type
of  machine,  and  identical  memory  size.  For example, a BASIC
program  saved from a Plus/4 can't be verified easily with a C64,
even  when  the  program  would  work fine on both machines. This
shouldn't  matter,  as the only time you'll be verifying files on
machines  other  than  the  one  which wrote them is when you are
comparing  two  disk  files  to see if they are the same. This is
done by loading one and verifying against the other, and can only
be  done  on the same machine and memory size as the one on which
the files were first created."
"[INST]In the context of the C64, What is an example of a BASIC program to write a record to a relative file in Commodore 64?[/INST]1581 disk: WRITING THE RECORD

  Here  is  an  example of program lines to enter variable length
fields for the above file design,  build them into a string,  and
send them to record number RE  in file number 3  (assumed to be a
relative file that uses channel number 3).

BASIC 7.0:

start tok64 /128 writv128.prg
  100 input'enter record number';re
  110 :
  120 dopen#3,'myrelfile',l88
  130 cr$=chr$(13)
  140 input'name';na$
  150 if len(na$)>30 then 140
  160 input'street';sa$
  170 if len(sa$)>30 then 160
  180 input'city & state';cs$
  190 if len(cs$)>25 then 180
  200 input'zip code';zp$
  210 if len(zp$)>10 then 200
  220 da$=na$+cr$+sa$+cr$+cs$+cr$+zp$
  230 if len(da$)<88 then 260
  240 print'record too long'
  250 goto 140
  260 :
  270 :
  280 record#3,(re),1
  290 if ds=50 then print#3,chr$(255):gosub 1000:goto 280
  300 gosub 1000
  310 print#3,da$
  320 gosub 1000
  330 record#3,(re),1
  340 gosub 1000
  350 dclose#3:end
 1000 if ds<20 then return
 1002 :
 1010 print'error:';ds$:dclose#3:end


BASIC 2.0:

start tok64 writev64.prg
  100 input'enter record number';re
  110 open 15,8,15
  120 open 3,8,3,'myrelfile,l,'+chr$(88)
  130 cr$=chr$(13)
  140 input'name';na$
  150 if len(na$)>30 then 140
  160 input'street';sa$
  170 if len(sa$)>30 then 160
  180 input'city & state';cs$
  190 if len(cs$)>25 then 180
  200 input'zip code';zp$
  210 if len(zp$)>10 then 200
  220 da$=na$+cr$+sa$+cr$+cs$+cr$+zp$
  230 if len(da$)<88 then 260
  240 print'record too long'
  250 goto 140
  260 rh=int(re/256)
  270 rl=re-256*rh
  280 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  290 gosub 1000:if en=50 then print#3,chr$(255):gosub 1000:\
      goto 280
  300 gosub 1000
  310 print#3,da$
  320 gosub 1000
  330 print#15,'p'+chr$(96+3)+chr$(rl)+chr$(rh)+chr$(1)
  340 gosub 1000
  350 close 3:close 15:end
 1000 input#15,en,em$,et,es
 1002 if en<20 then return
 1010 print'error:';em$:close 3:close 15:end"
"[INST]In the context of the C64, What is the recommended approach when opening a relative file for the first time to ensure reliable usage and avoid potential issues?[/INST]USING RELATIVE FILES: RECORD# COMMAND

  When  a  relative file is opened for the first time,  it is not
quite ready for use. Both to save time when using the file later,
and to assure  that the file will work reliably,  it is necessary
to  create  several records before closing the file for the first
time.  At  a  minimum,  enough records to fill more than two disk
sectors (512 bytes) should be written. In practice, most programs
go ahead  and create as many records as the program is eventually
expected  to  use.  That  approach  has the additional benefit of
avoiding  such  problems  as  running out of room on the diskette
before the entire file is completed.
  If  you  simply  begin  writing  data to a just-opened relative
file,  it will act much like a sequential file,  putting the data
elements  written  by  the  first  PRINT# statement in record #1,
those  written by the second PRINT# statement in record #2 and so
on.  This  means  each  record must be written by a single PRINT#
statement,  using  embedded  carriage  returns within the data to
separate  fields  that  will  be  read  in via one or more INPUT#
statements later. However, it is far better to explicitly specify
which record number is desired via a RECORD# command to the disk.
This  allows  you to access records in any desired order, hopping
anywhere in a file with equal ease."
"[INST]In the context of the C64, What is the error message displayed when a file is not found on the specified drive?[/INST]1581 disk: Controller commands error code 62: FILE NOT FOUND
    The  requested  file  does  not exist on the indicated drive.
    Check your spelling and try again."
"[INST]In the context of the C64, What is the format and protocol of the READ command in a disk assembly, including the byte structure, switches, and conventions?[/INST]1581 disk in assembly :  CMD 1 -- READ

 BYTE    BIT 7    6      5      4      3      2      1      0
-----------------------------------------------------------------
  00       0      1      0      1      0      1      0      1
-----------------------------------------------------------------
  01       0      0      1      1      0      0      0      0
-----------------------------------------------------------------
  02       L      E      X      S      0      0      0      N
-----------------------------------------------------------------
  03                       DESTINATION TRACK
-----------------------------------------------------------------
  04                       DESTINATION SECTOR
-----------------------------------------------------------------
  05                       NUMBER OF SECTORS
-----------------------------------------------------------------
  06                      NEXT TRACK (OPTIONAL)
-----------------------------------------------------------------

RANGE: All  values  are  determined by the particular disk format
       and format of translation table.

SWITCHES: L -- logical flag(1=do logical to physical translation)
          E -- ignore error (1 = ignore)
          S -- side select
          N -- drive number

PROTOCOL: Burst handshake.

CONVENTIONS: Before you can READ or WRITE to a diskette,  it must
             be logged-in using either the  INQUIRE DISK or QUERY
             DISK FORMAT command (both are described later). This
             must be done once each time you change diskettes.

OUTPUT: One burst status byte,  followed  by burst data,  is sent
        for each sector transferred.  An error prevents data from
        being sent unless the E bit is set."
"[INST]In the context of the C64, What is the error message displayed when a syntax error occurs in a controller command?[/INST]1581 disk: Controller commands error code 39: SYNTAX ERROR (invalid command)
    The  DOS  does  not  recognize  a command sent to the command
    channel  (secondary  address  15).  Check your typing and try
    again."
"[INST]In the context of the C64, What is the error code 25 on a disk controller and what does it indicate?[/INST]1581 disk: Controller commands error code 25: WRITE ERROR (write-verify error)
    The  controller  has  detected  a  mismatch  between the data
    written  to  diskette  and  the same data in disk memory. May
    mean  the diskette is faulty.  If so,  try another.  Use only
    high-quality diskettes from reputable makers."
"[INST]In the context of the C64, What error message is displayed when a write file that has not been closed is reopened for reading?[/INST]1581 disk: Controller commands error code 60: WRITE FILE OPEN
    A  write  file that has not been closed is being reopened for
    reading.  This file must be immediately rescued, as described
    in  BASIC  Hint #2  in  Chapter 2,  or it will become a splat
    (improperly closed) file and probably be lost."
"[INST]In the context of the C64, What error message is displayed when using pattern matching characters in a file name while trying to save or open a file for writing?[/INST]1581 disk: Controller commands error code 33: SYNTAX ERROR (invalid file name)
    Pattern  matching  characters  cannot  be  used  in  the SAVE
    command  or when Opening files for the purpose of Writing new
    data. Spell out the file name."
"[INST]In the context of the C64, What are the commands used to read and write relative file data, and how do they differ from sequential file programming?[/INST]1581 disk: WRITING RELATIVE FILE DATA

  The commands used  to read and write relative file data are the
same  PRINT#,  INPUT#,  and  GET# commands  used in the preceding
chapter  on  sequential files.  Each command is used as described
there.  However,  some  aspects of relative file access do differ
from  sequential  file  programming,  and  we  will  cover  those
differences here."
"[INST]In the context of the C64, What are the limitations and benefits of using relative files in DOS?[/INST]FILE LIMITS

  With  relative  files,  you  don't  have to worry about exactly
where  on  the  diskette's surface a given record will be stored,
or  whether  it will fit properly within the current disk sector,
or need to be extended onto the next available sector.  DOS takes
care of all that for you.  All you need to do is specify how long
each  record  is,  in bytes,  and how many records you will need.
DOS  will do the rest,  and organize things in such a way that it
can  quickly find any record in the file,  as soon as it is given
the record number (ordinal position within the file).
  The  only  limit that will concern you is that each record must
be  the  same  size,  and  the  record  length you choose must be
between 2 and 254 characters.  Naturally the entire file also has
to fit on your diskette, along with any other existing file(s)."
"[INST]In the context of the C64, How can commas and colons be safely included within a data element when using INPUT or INPUT# statements in BASIC?[/INST]1581 disk with basic 7,0: COMMAS (,) AND COLONS (:)

  commas  and colons can cause trouble in a
file,  because they delimit  (end) the data element in which they
appear  and cause any remaining characters in the data element to
be read into the next INPUT# variable.  They have the same effect
in an INPUT statement,  causing the common  'EXTRA IGNORED' error
message.  However,  sometimes  you  really  need a comma or colon
within a data element,  such as a name written as  'Last, First'.
The cure  is to precede such data elements with a quotation mark.
After a quotation mark,  in either an  INPUT or INPUT# statement,
all   other  characters  except  a  carriage  return  or  another
quotation mark are accepted as part of the current data element.

EXAMPLES:

  To force a quotation mark into a data element  going to a file,
append a CHR$(34) to the start of the data element. For example:

  PRINT#2,CHR$(34)+'DOE,JOHN'

or

  PRINT#2,CHR$(34);'DOE,JOHN'

If  you  do  this  often,  some  space  and time may be saved by
previously  defining  a  variable as equal to CHR$(34) as we did
earlier with CHR$(13):

   20 QT$=CHR$(34)
  ...
  400 PRINT#5,QT$+NAME$

  In  each  case,  the added quotation mark will be stripped from
the data  by the  INPUT  or  INPUT#  statement,  but the comma or
colon will remain part of the data."
"[INST]In the context of the C64, How does the storage of numeric data on diskettes in BASIC 7.0 differ from its storage in computer memory, and what are some strategies for optimizing disk space when writing numeric data to files?[/INST]1581 disk with basic 7,0: NUMERIC DATA STORAGE ON DISKETTE


  Inside the computer,  the space  occupied by a numeric variable
depends  only  on  its  type.  Simple numeric variables use seven
bytes  (character locations) of memory.  Real array variables use
five bytes per array element,  and integer array elements use two
bytes each.  In contrast,  when a numeric variable or any type is
written to a file,  the space it occupies depends entirely on its
length, not its type.  This is because numeric data is written to
a  file  in  the form of a string,  as if the STR$() function had
been  performed on it.  The first character will be a blank space
if the number is positive,  and a minus sign (-) if the number is
negative.   Then  comes  the  number,  digit-by-digit.  The  last
character is a cursor right character.
  This  format allows the disk data to be read back into a string
or  numeric  variable  later.  It is,  however,  wasteful of disk
space,  and  it can be difficult to anticipate the space required
by  numbers  of  unknown  length.  For this reason, some programs
convert all numeric variables into strings before writing them to
diskette,  and  use  string  functions  to  remove  any  unneeded
characters in advance.  Doing so still allows those data elements
to be read back into a numeric variable by INPUT# later, although
file  data  errors  may  be  avoided  by  reading  all data in as
strings, and converting to numbers using the VAL() function after
the information is inside the computer.
  For example, 'N$=RIGHT$(STR$(N),LEN(STR$(N))-1)' will convert a
positive  number  N  into a string  N$  without the usual leading
space for its numeric sign.  Then instead of  writing  PRINT#5,N,
you would use PRINT#5,N$."
"[INST]In the context of the C64, What is the format of the OPEN statement to create or reopen a relative file in BASIC 7.0 and BASIC 2.0?[/INST]CREATING A RELATIVE FILE

  When a relative file is to be used for the first time, its OPEN
statement will create the file; after that, the OPEN statement is
used to reopen the file for both reading and writing.

FORMAT STATEMENT TO OPEN A RELATIVE FILE:

  BASIC 7.0: DOPEN#file#,'file name',Lrecord length
             [,Ddrive#][,Udevice#]
  BASIC 2.0: OPENfile#,device#,channel#,'drive#:file name,L,'+
             CHR$(record length)

where  'file#' is the file number,  normally an integer between 1
and 127; 'device#' is the device number to be used, normally 8 on
the  1581;  'channel#'  selects  a particular channel along which
communications  for this file can take place,  normally between 2
and 14;  'drive#' is the drive number,  always 0 on the 1581; and
'file name' is the name of the file,  with a maximum length of 16
characters.  Pattern  matching characters are allowed in the name
when accessing an existing file, but not when creating a new one.
The  record  length is the size of each record within the file in
bytes used, including carriage returns, quotation marks and other
special characters.


|  o Do not precede the file name  (in BASIC 7.0)  or the drive |
| number  (in BASIC 2.0)  with  the 'at' sign (@);  there is no |
| reason to replace a relative file.                            |
|  o L record length (in BASIC 7.0) or ,L,'+CHR$(record length) |
| (in BASIC 2.0) is only required when a relative file is first |
| created,  though it may be used later,  so long as the record |
| length is the same as when the file was first created.  Since |
| relative files may be read from or written to alternately and |
| with  equal  case,  there is no need to specify Read or Write |
| mode when opening a relative file.                            |
|  o 'file#',  'device#'  and  'channel#' must be valid numeric |
| constants, variables or expressions.  The rest of the command |
| must be a valid string literal,  variable  or  expression. In |
| BASIC 7.0 DOPEN, whenever a variable or expression is used as |
| a file name it must be surrounded by parentheses.             |

EXAMPLES:

  To create or reopen a relative file named  'GRADES',  of record
length 100 use:

  BASIC 7.0: DOPEN#2,'GRADES',L100,D0,U8
  BASIC 2.0: OPEN 2,8,2,'GRADES,L,'+CHR$(100)

  To  reopen  an  unknown relative file of the user's choice that
has already been created, use:

  BASIC 7.0:  200 INPUT'WHICH FILE';FI$
              210 DOPEN#5,(FI$),D0,U8
  BASIC 2.0:  200 INPUT'WHICH FILE';FI$
              210 OPEN 5,8,5,FI$"
"[INST]In the context of the C64, What are the two popular ways to organize individual fields of information within a fixed-length relative record, and what are the advantages and disadvantages of each approach?[/INST]1581 disk: DESIGNING A RELATIVE RECORD

  As  stated earlier in this chapter,  each relative record has a
fixed length, including all special characters. Within that fixed
length, there are two popular ways to organize various individual
fields of information. One is free-format, with individual fields
varying in length from record to record, and each field separated
from the next by a carriage return character  (each of which does
take  up  one character space in the record).  The other approach
is to use fixed-length fields,  that may  or may not be separated
by carriage returns. If fixed length fields are not all separated
by  carriage returns,  you will either need to be sure a carriage
return is included within each 88-character portion of the record
(88 is for BASIC 2, 160 is for BASIC 7). If this is not done, you
will  have  to  use  the  GET#  command  to read the record, at a
significant cost in speed.
  Since  each  relative record is most easily written by a single
PRINT# statement,  the recommended approach is to build a copy of
the current record in memory before writing it to disk. It can be
collected into a single string variable  with the help of BASIC's
many string-handling functions,  and then all written out at once
from that variable.
  Here  is  an  example.  If  we are writing a 4-line mail label,
consisting of 4 fields named  'NAME',  'STREET',  'CITY & STATE',
and 'ZIP CODE', and have a total record size of 87 characters, we
can organize it in either of two ways:

  WITH FIXED LENGTH  FIELDS         WITH VARIABLE LENGTH FIELDS

Field Name     Length             Field Name        Length

NAME           27 characters      NAME              31 characters
STREET         27 characters      STREET            31 characters
CITY & STATE   23 characters      CITY & STATE      26 characters
ZIP CODE       10 characters      ZIP CODE          11 characters
----------------------------      -------------------------------
Total length   87 characters      Potential length  99 characters
                                  Edited length     87 characters

  With fixed length records,  the field lengths add up to exactly
the  record  length.  Since  the  total length is just within the
input  buffer size limitation,  no carriage return characters are
needed.  With variable length records,  you can take advantage of
the  variability  of  actual  address  lengths.  While  one  name
contains  27  letters,  another  may  have only 15,  and the same
variability exists in street and city lengths.  Although variable
length records lose one character per field for carriage returns,
they  can  take advantage of the difference between maximum field
length  and  average  field length.  A program that uses variable
record  lengths must calculate the total length of each record as
it is entered,  to be sure the total of all fields doesn't exceed
the space available."
"[INST]In the context of the C64, What error message is displayed when a disk controller command exceeds 58 characters?[/INST]1581 disk: Controller commands error code 32: SYNTAX ERROR (long line)
    The   command   sent  is  longer  than  58  characters.   Use
    abbreviated disk commands."
"[INST]In the context of the C64, What error message and solution are provided when a file is too large to be created on a diskette?[/INST]1581 disk: Controller commands error code 52: FILE TOO LARGE
    There isn't room left on the diskette to create the requested
    relative record.  To avoid this error, create the last record
    number  that  will be needed as you first create the file. If
    the file is too large for the diskette,  either split it into
    two files on two diskettes,  or use abbreviations in the data
    to allow shorter records."
"[INST]In the context of the C64, What is the error message displayed when a disk controller encounters an invalid bit pattern in a data byte during a read operation?[/INST]1581 disk: Controller commands error code2 4: READ ERROR (byte sector header)
    The  data  or  header  has  been read into disk memory, but a
    hardware  error has been created by an invalid bit pattern in
    the data byte."
"[INST]In the context of the C64, What are the different addressing modes supported by instructions in a 6510 processor?[/INST]Addressing Modes
Each instruction supports one or more addressing
modes. Common instructions like LDA (load accumulator) support more addressing modes than less
common ones (BIT).
• The immediate addressing mode is indicated with
a # sign: LDA #$17 loads the immediate value of
$17 into the accumulator.
• Absolute addressing specifies a 16 bit address as an
operand: LDA $0314 loads from the memory address $0314.
• Zero page addressing is an optimized version of
absolute addressing: LDA $02 will read from address $0002 in memory, but the instruction can be
encoded more tightly, and execution is faster.
• Absolute-X-indexed addressing reads from a specified address, to which the contents of the X register
is added. LDA $0200,X reads from the address
$020A, in case X is $0A. This allows reading from
tables.
• Absolute-Y-indexed is the same thing, but with the
Y register.
• Zero-Page-X-indexed is an optimized version of
Absolute-X-indexed. LDA $F0,X reads from the
Xth location in a table stored starting at $00F0 in
memory. Note that zero page addresses will wrap
around, so $F0 + $10 = $00.
• Zero-Page-Y-indexed is the same thing, but with
the Y register.
• Zero-Page-X-indexed-indirect adds X to a specified
zero page address, reads a 16 bit pointer from the
resulting address and finally accesses memory at
that address. So LDA ($80,X) will read from an
address specified by the array of pointers at $0080
and the index X into the array. This addressing
mode is rarely used.
• Zero-Page-indirect-Y-indexed treats two consecutive bytes in zero page as an address and adds Y to
the address. LDA ($14),Y will read from $E020, if
the address stored at $14/$15 is $E000 and Y is
$20. This addressing mode is the most convenient
way to work with pointers, as no register can hold
16 bits."
"[INST]In the context of the C64, What are the instructions and characteristics of the 6502/6510 processor related to register transfer and stack operations?[/INST]Register Transfer and Stack
There are several 1 byte instructions without operands that move data between registers. TAX, TXA,
TAY and TYA move between A, X and Y. TSX and
TXS copies between X and the stack pointer.
The stack pointer always points to the next address
that is written to. This means that an empty stack has
a stack pointer of $FF, and pushing a value first
writes the value and then decrements the stack
pointer. The 6502 can move the accumulator from
and to the stack (PHA/PLA), as well as the processor
status P (PHP/PLP)."
"[INST]In the context of the C64, What are the different types of instructions that make up the instruction set of the 6510 processor?[/INST]Instruction Set
The instruction set is very streamlined, and avoid
redundancies. There are load instructions (LDA/
LDX/LDY to load A, X and Y respecively), store instructions (STA/STX/STY), read-modify-write instructions (logic: ASL/LSR/ROL/ROR, count: INC/
DEC), arithmetic (ADC/SBC; note that these always
include the carry: CLC/ADC is a regular addition, and
SEC/SBC is a regular subtraction, because of the
one's complement logic), compare (CMP/CPX/CPY;
these are subtractions without storing the result),
logic (AND/ORA/EOR, and BIT, which is AND without storing the result), as well as branch instructions,
flag manipulation, register transfer and stack manipulation."
"[INST]In the context of the C64, What are the key features and characteristics of the 6502 CPU, including its architecture, registers, and instruction set?[/INST]6502 CPU
The CPU inside the C64 is a 0.985 MHz (on PAL)
MOS 6510, which is a close derivative of the wellknown 8 bit little-endian MOS 6502. The 6502 was
introduced in 1975 by MOS Technology, a company
formed earlier the same year by former Motorola engineers, headed by Chuck Peddle. The philosophy of
the 6502 was to have a reduced instruction set and a
small register file, making it simpler and faster than
CPUs like the Z80 at the same clock speed, as well as
cheaper to manufacture.
Unlike other CPUs, the 6502 does not have a set of
general purpose registers. Instead, it has a single accumulator A (for arithmetic and logic), two index registers X and Y (for incrementing, decrementing and
indexing memory) and a stack pointer. All these registers are 8 bits. The processor status, consisting of
the negative (N), overflow (V), break (B), decimal (D),
interrupt (I), zero (Z) and carry (C) flags is exposed as
register P. The program counter (PC) is 16 bits wide.
The fact that the stack pointer is 8 bit means that the
stack is confined to the area between $0100 and
$01FF in the address space, i.e. the upper half of the
effective stack pointer is hard-coded to $01. There is
another special area in the address space: The first
256 bytes, at $0000 to $00FF are referred to as the
zero page (ZP). Many instructions support special
encodings for zero page addresses, which saves one
byte in the instruction encoding as well as at least one
cycle of execution time. This can be seen as an extension of the register file to another 256 (though external) registers.
All opcodes are one byte, and have 0, 1 or 2 byte operands. The 8x8 opcode matrix is somewhat logical
(e.g. branch instructions are encoded as $10, $30,
$50, ...), but there is no easy rule to construct the opcode table. Nevertheless, the opcode table is a minimal encoding for optimal decoding in the 6502's internal PLA ROM."
"[INST]In the context of the C64, What is the history of the Commodore 64, including its development, features, and impact on the computer market?[/INST]History of the C64
Commodore Business Machines was founded in 1962
by Jack Tramiel. The company specialized on electronic calculators, and in 1976, Commodore bought the chip manufacturer MOS Technology and decided to have Chuck Peddle from MOS evolve their KIM-1 computer kit (a design that demos their new MOS 6502 8 bit CPU) into the Commodore PET series: computers with built-in monitors for the home, school and small business market that ended up competing with devices from Atari and Apple. In 1981, Commodore introduced the VIC-20, a 5 KB stripped down monitorless computer-in-thekeyboard design based on the PET for the home computer market. This was followed by the (incompatible) higher-end Commodore 64 in 1982 that included more PET features, came with 64 KB of RAM (an immense amount compared to the rest of the market) and was very aggressively priced at US$595 beating the competition by a factor of two. This was made possible by designing and building most of the system in-house. Although some features of the C64 were taken from the PET models of the time, it had to be connected to a TV set, which only made 40 columns of text possible (as opposed to 80 columns on the PET). Also, the BASIC 4.0 codebase was stripped down to the old 2.0 feature set to make it fit into 8 KB.
In the beginning, the C64 did well in the competition. The superior but compatible C128 from 1985 did well, too, but was never more popular than the C64, which continued to be sold. The direct successor to the lowend VIC-20, the 1984 Plus/4 and its siblings, the C16 and the C116, failed, mostly because they were incompatible with the C64, which at that time already had a remarkable software library. A few years after the introduction, the C64 was still offered as a low-end alternative to the Commodore Amiga, and while it became less popular in the USA,
it gained more and more popularity in Europe. In the early 90s, when manufacturing costs of a C64 were as low as $25, it gained a second life in Eastern Europe.
Production did not end until the liquidation of Commodore in 1994. According to the 1993 Annual Report, 17 million C64 had been produced in by then, as
well as 4.5 million C128."
"[INST]In the context of the C64, What are the key features, capabilities, and technical specifications of the Commodore 64 (C64) computer?[/INST]Look and Feel
A C64 only needs to be connected to power and a TV set (or monitor) to be fully functional. When turned on, it shows a blue-on-blue theme with a startup message and drops into a BASIC interpreter derived from
Microsoft BASIC. In order to load and save BASIC programs or use third party software, the C64 requires mass storage - either a “datasette” cassette tape drive or a disk drive like the 5.25' Commodore 1541.
Unless the user really wanted to interact with the BASIC interpreter, he would typically only use the BASIC instructions LOAD, LIST and RUN in order to access mass storage. LOAD'$',8 followed by LIST shows the directory of the disk in the drive, and
LOAD'filename',8 followed by RUN would load and start a program. If a tape drive is connected, LOAD and RUN will launch the first program on tape - pressing SHIFT and the RUN/STOP key has the same effect.

By default, typing characters without SHIFT will result in upper case characters being shown on the screen. This can be changed by pressing the Commodore key and SHIFT at the same time, which switches to the upper/lower character set. This behavior is due to the fact that the first PET only had uppercase characters, and that BASIC required keywords unshifted - but all tutorials taught them as uppercase. This is also the reason why in Commodore's version of ASCII, called PETSCII, the codes for uppercase and lowercase characters are reversed.
The text based user interface is not a line editor, but a screen editor, i.e. the cursor can be moved freely on the screen, and pressing RETURN on a line with existing text will present the text to the application as if it were just typed in.
While a physical screen line is only 40 characters, the screen editor logic can extend it to a logical 80 characters - whenever a character is entered on the 40th column, the rest of the screen is moved down by one line, ”opening” a line that extends the previous line to 80 characters.
The C64 screen editor supports selecting one out of 16 color for the foreground text by pressing the key combinations Ctrl+1 to Ctrl+8 and Commodore+1 to Commodore+8. Reverse text mode can be turned on and off with Ctrl+9 and Ctrl+0.


Ports and Connections
The C64 has a whole range of connection possibilities.
On the side, it has two 9 pin Atari-style joystick connectors that can also be used for a mouse, light pens or paddles. On the back, there is the expansion port, which exports the complete processor bus, allowing not only game cartridges but also cartridges with I/O chips that map themselves into the CPU's address space - or even cartridges that completely replace the CPU. For a conventional TV connection, there is an RCA connector that outputs an RF signal. For monitors, there is an extra DIN connector that carries separate chroma, luma and audio signals (S-Video).
For connecting Commodore compatible printers and disk drives, there is a DIN connector for the IEC bus.
There is also a dedicated connector for datasette drives. The ”User Port” consists of several GPIO pins that can be used for custom hardware projects, or as a RS-232 port (with TTL levels), for which support exists in the ROM."
"[INST]In the context of the C64, What is the memory mapping of the Commodore 64's 6510 CPU, including the address ranges for RAM, ROM, I/O devices, and other components?[/INST]Address Space
The 8 bit C64 design has a 16 bit address bus, allowing the CPU to address 64 KB of memory. Since the
C64 has 64 KB of RAM, filling the complete address
space, ROM and I/O chips are mapped into regions of
the address space that are shared with RAM: The
CPU can switch these regions between RAM and a
second or third mapping. These regions are as follows:
• $0000-$9FFF: RAM
• $A000-$BFFF: RAM or BASIC ROM
• $C000-$CFFF: RAM
• $D000-$DFFF: RAM or memory mapped I/O
chips or character ROM
• $E000-$FFFF: RAM or KERNAL ROM
In contrast to CPUs like the Z80 and the 8086, and
like most modern CPUs, I/O devices are memory
mapped on the C64's 6510 CPU. The mapping is as
follows:
• $D000-$D3FF: VIC video controller
• $D400-$D7FF: SID sound controller
• $D800-$DBFF: Color RAM
• $DC00-$DCFF: CIA 1 I/O controller
• $DD00-$DDFF: CIA 2 I/O controller
• $DE00-$DFFF: for extensions on the expansion
port"
"[INST]In the context of the C64, What are the components that make up the Commodore 64 motherboard?[/INST]Board
On the C64 motherboard, there is a dedicated IC each for the main tasks. There is the MOS 6510 CPU, eight 64 KBit RAM chips (later consolidated into 2), three ROM chips with KERNAL (I/O library), BASIC and the character set (KERNAL and BASIC were later consolidated), two 6526 CIA I/O controllers (one for keyboard and joystick, one for the IEC bus and the user port), the 6581 SID sound chip, and the 6567/6569 VIC video chip, as well as the RAM chip that holds the 512 bytes of Color RAM.
All non-RAM chips are custom chips designed manufactured by MOS, Commodore's inhouse chip company."
"[INST]In the context of the C64, What are the memory layout and addressing capabilities of the VIC chip in a Commodore 64 computer?[/INST]Memory Layout
The VIC can address 16 KB at a time. All VIC data
structures can be stored anywhere in these 16 KB, but
they have to be aligned to their size.
• The screen RAM is $0400 bytes in size and can be
at $0000, $0400, ...
• The character set is $0800 bytes, and can be at
$0000, $0800, ...
• The bitmap is $2000 bytes and can be at $0000 or
$2000.
• Sprites are $40 bytes, and can be at $0000,
$0040, ...
Two GPIO pins of the second 6526 CIA are connected
to bits 6 and 7 of RAM when the VIC accesses it. By
changing the lower 2 bits of $DD02, the VIC can be
switched between banks $0000-$3FFF (11), $4000-
$7FFF (10), $8000-$BFFF (01) and $C000-$FFFF
(00).
If the VIC is set to banks $0000 or $8000, then the
two built-in character sets shadow RAM in the area of
$1000-$1FFF. This means that the built-in character
set can be used on those banks without occupying
RAM, but it also means that the area from $1000-
$1FFF cannot be used for bitmap, screen RAM or
sprite data either.
For timing reasons, color information is not taken
from main RAM, but from a dedicated Color RAM.
These $0400 half-bytes are accessible to the C64 at
$D800-$DBFF and can not be bank switched."
"[INST]In the context of the C64, What are the characteristics and capabilities of the VIC's hardware sprites (MOBs) on the Commodore 64?[/INST]Sprites
The VIC has eight hardware sprites (also called
MOBs, movable objects). Each sprite is 24x21 pixels,
which is encoded in 63 bytes. Set bits will be drawn in
the sprite's individual foreground color, and cleared
bits will be transparent. The index to the sprite's bitmap data in memory is an 8 bit value that is read
from the last 8 bytes of screen RAM - since the screen
is only 1000 characters, the last 24 characters of the
$0400=1024 bytes area would otherwise be unused.
There is also a multicolor mode for sprites, which
makes pixels twice as wide and decreases the horizontal resolution to 12 pixels. In this mode, 00 is still
transparent, and 10 encodes the sprite's individual
color. The codes 01 and 11 take the color out of the
sprite multicolor registers ($D025 and $D026),
which are shared among all sprites.
Sprites can be positioned at arbitrary pixel positions
on the screen, and overlap. In this case, sprites with
lower numbers have priority over sprites with higher
numbers. Each sprite can either be shown in front or
behind background pixels. Sprites can be X- and Yexpanded by a factor of two, and collision of two
sprites or of a sprite and background pixels is detected by hardware: Whenever two non-transparent
sprite pixels are drawn at the same position on the
screen, they have collided. Whenever a nonbackground pixel is drawn by the character generator
at the same position where a non-background pixel of
a sprite is draw, the sprite has collided with the background. An exception from this rule is the 01 code in
the character data, which also counts as background.
This way, a background picture can be constructed
that does not cause collisions in certain areas. In
practice, most newer games do not use the hardware
functionality, but instead test for overlapping sprite
bounding boxes in software."
"[INST]In the context of the C64, How does the VIC chip handle graphics modes, including hi-res and multi-color bitmap modes, in terms of resolution, pixel encoding, and color management?[/INST]Bitmap Mode
In hi-res graphics mode, the VIC supports a resolution of 320x200, which uses the same pixel frequency
as 40x25 character mode (40*8=320, 25*8=200).
The bitmap can reside at $0000 or $2000, and the
VIC reads one byte for 8 pixels. But hi-res mode does
not only support monochrome graphics: The foreground and background colors of each 8x8 tile are
taken from the high and low nibble of screen RAM,
which would otherwise be unused. Color RAM is not
used in this mode.
The encoding of the bitmap is identical to the encoding of a character set, making it a non-linear framebuffer: The first eight bytes of the bitmap represent
the pixels in the tile at character position (0,0), the
second eight bytes represent the tile at character position (1,0), which is pixel position (8,0), and so on.
This layout makes pixel addressing in software
slower.
In Multi-Color Bitmap Mode, the horizontal resolution is halved to 160x200, and pixels are twice the
width. Every set of two bits in the encodes one of four
colors per tile: 00 takes it from the global background
register ($D021), 01 and 10 take it from the upper
and lower nibble of screen RAM, respectively, and 11
takes it from Color RAM."
"[INST]In the context of the C64, How does the VIC support scrolling and what are the implications for screen mode and border size?[/INST]Scrolling
The VIC supports hardware X and Y scrolling by 0 to
7 pixels. Since the 40th column is half visible and another column left of the first column is half-visible
when the horizontal shift register is set to e.g. 4, a
41th column would be needed. Instead, it is possible
to switch the screen to 38 column mode, i.e. the
whole screen is a little narrower, and more border is
shown on the left and on the right. The screen can
also be switched from 25 to 24 lines the same way."
"[INST]In the context of the C64, What is the memory configuration of a Commodore 64 system, including how the ROMs and I/O area can be altered, and how programs typically utilize the available memory?[/INST]Memory Configuration
In a running system with BASIC and KERNAL, the
BASIC and KERNAL ROMs are turned on and visible
at $A000-$BFFF and $E000-$FFFF respectively,
and at $D000-$DFFF, the I/O area is visible. Using
the 3 lowest bits in the processor port at address 1,
this configuration can be altered. The ROMs can be
turned off, revealing RAM instead, and the I/O area
can be configured to show either RAM or the character set ROM. Note that writing to ROM will always
direct the data to the underlying RAM.
In practice, many programs run in the default configuration and use both KERNAL library routines, as
well as functions in BASIC, to keep their own code as
small as possible. More recent programs and almost
all games turn off all of ROM, to get direct control of
the interrupt vector without having to go though the
KERNAL handler first. The I/O area is typically configured to show the I/O registers and Color RAM, and
only rarely switched to a different configuration to
temporarily access the RAM underneath. A few applications read the character ROM at program start and
modify the copy.
The C64 supports another ROM bank at $8000-
$9FFF, which can only be serviced by an external cartridge connected to the expansion port. If KERNAL
detects the magic string ”CBM80” at $8004 on
startup, it will jump to the code of the cartridge right
away."
"[INST]In the context of the C64, What are the characteristics and modes of the Commodore 64's character display system?[/INST]Character Mode
The C64 has two built-in character sets that the VIC
can access. They can be shown on the screen by writing the numbers 0 to 255 into screen RAM (at $0400
by default). The default font has uppercase characters
and lots of line-drawing symbols in the lower 128
characters, and the second half consists of the same
characters, but inverse. The alternative font has upper- and lowercase characters and omits some of the
symbols.
The foreground color of the characters can be
changed by writing the color numbers into the Color
RAM, which is located at $D800-$DBFF. There is
one byte per character, but only the lower 4 bits are
actually preserved by Color RAM.
Each character is 8x8 pixels, and stored as eight bytes
in the character ROM, one line being one byte. A 1-bit
will take the color from the Color RAM ($D800-
$DBFF), and a 0 bit will take it from the global background color register ($D021). The pixel matrix is
determined by looking up the character index in the
screen RAM (at $0400-$07FF by default) and consequently looking up the pattern the current character
set (the VIC sees the default font at $1000, although
for the 6502 it is invisible there).
In Extended Color Mode (ECM), it is possible to
chose between one of four background colors (registers $D021 to $D024) with the upper two bits of the
character index, but then only 6 bits will be used to
look up the character pattern, decreasing the number
of possible characters to 64. The built-in (uppercase)
character set is well-suited for this: While it is similar
to the ASCII encoding, it has the uppercase characters
mapped to codes $01 to $1A, so the most important
characters are within the first $40.
Multi-Color Character Mode allows up to four colors
per character and is intended for tile-based games,
like platformers. If bit 3 of the value in Color RAM is
0, then the character gets displayed just like in nonmulticolor mode, but colors are restricted to the first
eight. If bit 3 is 1, then pairs of horizontally adjacent
bits are combined in their meaning: 00 represents the
screen background ($D021), 01 is the second background register ($D022), 10 is the third background
register ($D023), and 11 is the color specified in bits
0-2 of the Color RAM. Pixels in these characters are
twice as wide, so the resolution of a character is 4x8."
"[INST]In the context of the C64, What are the features and capabilities of the MOS 6567/6569 VIC-II video chip in the Commodore 64?[/INST]6567/6569 VIC
The video chip inside the C64 is called the MOS
6567/6569 VIC-II (Video Interface Controller) - the
video chip in the VIC-20 had been the original VIC,
and was the reason for the marketing name of the
VIC-20.
The VIC supports a 40x25 text mode, a 320x200 bitmap mode, 16 colors and 8 sprites - all of these features have lots of sub-modes and options. The
amount of memory the VIC can address is 16 KB, and
while by default, it accesses the first 16 KB of the C64
RAM, it can be configured to use any of the four
banks.
The 16 colors of the VIC are divided into two sets of
eight. The first eight are the more important colors,
as some modes only support the first eight. The colors
are, in the original order: black, white, red, cyan, purple, green, blue, yellow, orange, brown, pink, dark
gray, gray, light green, light blue and light gray."
"[INST]In the context of the C64, What are the key aspects of the VIC's timing that are essential to understand for advanced programming and achieving cycle-exact timing in assembly code?[/INST]Timing
For advanced VIC programming, it is necessary to not
just set up a certain mode and have the VIC display it,
but to reprogram the VIC while it is drawing the picture. For this, it is necessary, to understand its timing.
While the pixels within the screen area are 320 by
200, the VIC actively draws pixels in the border color
outside of this area, which (on PAL) is 403x284 pixels. Analog TV standards specify an H blank area at
the end of every line, and V blank area at the end of
every screen. So counting this timing as pixels, this
gives an absolute resolution of 504x312 pixels. The
interesting and very useful connection about the pixel
clock and the system clocks is that an 8 pixel character is drawn every system clock cycle, i.e. about 1 million times a second. The 504 horizontal pixels therefore mean that a line is drawn on the screen every 63
cycles. With this information, it is possible to do
cycle-exact timing of assembly code to switch a VIC
register at an 8 pixel granularity.
Further timing details (badlines, sprite timing), as
well as the application of this information to do tricks
like FLD, FLI and AGSP would go beyond the scope
of this article."
"[INST]In the context of the C64, What are the components and connections of the tape interface?[/INST]Tape Interface
The tape interface consists of a single line each for
data input and output, motor control and key sense.
The raw data is read from and written to the data
lines, and all encoding and decoding of the data
stream is done in software. 3 of the required lines are
connected to the processor port at zero page location
1, and one (data input) is connected to CIA 2."
"[INST]In the context of the C64, What is the IEC bus and how does it work on Commodore computers?[/INST]IEC Bus
The IEC bus is a serial version of the IEEE-488 bus
used on the PET. Devices on the IEC bus are daisychained, and are all connected to the same three
lines: ATN (attention), clock and data. IEC has a single bus master, which is the computer. It is the only
device to ever raise ATN, while every device can output to clock and data, depending on the state of the
bus.
If the computer raises ATN, every device on the bus
listens for the 4 bit device number and compares it
with its own. The protocol on who sends and who receives is determined by the computer sending TALK/
UNTALK and LISTEN/UNLISTEN requests, quick is an ATN sequence, followed by one of the four commands.
While KERNAL exports the interface at this level, it
also allows high-level open, close, read and write operations on the IEC bus, as well as load and save operations. The BASIC LOAD and SAVE commands are
directly hooked up to this interface.
The IEC bus was designed for the serial shift register
in the VIA (Versatile Interface Adapter) of the VIC-20
and its disk drive, but it turned out that the VIA had a
bug that made the shift register unusable, so the IEC
protocol had to be implemented in software. While
the C64 has CIAs, in which the bug has been fixed,
the 1541 still used VIAs. It wasn't until the C128 (in its
native mode only) that the computer could talk to the
floppy drive (Commodore 1570/1571/1581) in its intended speed."
"[INST]In the context of the C64, What was the graphical user interface-based operating system released by Berkeley Softworks in 1986 for the Commodore 64?[/INST]GEOS
While KERNAL is a minimal character-based operating system in ROM, there is also a disk-based operating system with a graphical user interface for the C64.
GEOS was released by Berkeley Softworks in 1986
and Commodore bundled it with the C64 for some
time. The GUI, which can be controlled by a joystick
or a mouse, runs in 320x200 graphics mode and resembles early versions of MacOS. GEOS is a 16 KB
library that includes an optimized disk interface
(faster, support for timstamps, icons and multi-fork
”VLIR” files), library code for drawing to the screen,
high level UI primitives for menus, buttons and dialog boxes (with callbacks) and a simple memory
swapping facility. Furthermore GEOS allows input
and printer driver plugins, as well as proportional
fonts in different sizes. Internally, GEOS has a jump
table to its library routines that consists of about 150
entries.
GEOS came with applications like GeoPaint and GeoWrite; Berkeley Softworks themselves offered solutions like GeoPublish and GeoCalc, and more software was available from third parties.
GEOS' only requirement is a 1541 disk drive, but a
3.5' 1581 drive, a RAM extension or one of the later
hard drives helped speed it up a lot."
"[INST]In the context of the C64, What are the features and uses of the 6526 CIA (Complex Interface Adapter) in the Commodore 64 computer?[/INST]6526 CIA
The C64 has two identical 6526 CIAs (Complex Interface Adapter) that are mostly used for I/O. One CIA
features 16 general purpose I/O pins (8 bit port A and
8 bit port B) that can be used either as an input or an
output, two programmable timers and a real-timeclock.
The timers have 16 bit counters and count down by
one either on each clock cycle, or on an external
event, or on a timer A underflow (in the case of timer
B). This allows concatenating the timers to one 32 bit
timer. On an underflow, the CIA can be programmed
to cause an IRQ or to send data through a serial shift
register. The CIA also supports receiving data
through a shift register.
The real-time-clock has a resolution of 1/10 of seconds and supports generating interrupts at a certain
time.
CIA 1 is hooked up to the keyboard and the joystick
ports. Since the keyboard consists of 64 keys (plus
SHIFT LOCK, which is parallel to the left SHIFT key,
and RESTORE, which is directly connected to the
CPU's NMI line), these can be laid out in a 8x8 matrix
of lines, key presses connecting the intersections. One
side of the matrix is connected to port A (output), and
the perpendicular side is connected to port B (input).
The keyboard driver can now write the values of $01,
$02, $04 etc. in port A and test the input of port B to
see which keys are pressed. The two joysticks are
connected in parallel to port A and port B, so they can
cause spurious keyboard events.
CIA 2 is hooked up to the IEC bus, and I/O lines control the VIC bank. The rest is exposed on the user
port, and can be used for RS-232.
KERNAL uses CIA 1 for the 50 Hz system timer, but,
apart from the ports, doesn't use any of the extra features of either CIA."
"[INST]In the context of the C64, What are the various peripherals and accessories that were developed for the Commodore 64 (C64) computer?[/INST]Other Peripherals
The 1541 is the necessary companion to a C64. It can
be replaced by a 1570 (1541 with fast bus routines for
the C128) or a 1571 (double-sided 1570), since they
include a 1541 compatibility mode. The 3.5' Commodore 1581, which supports 880 KB per disk, can
hardly be a replacement for a 1541, because most applications contain their own floppy speeders that
make lots of assumptions on the exact on-disk format. For GEOS, it can be very useful though.
Creative Micro Devices sold and continues to sell a
line of hard drives that have an IEC connection but
contain a 3.5' SCSI drive inside. Although they have a
6502 CPU built in and allow code execution on their
CPU, they are not compatible enough to replace a
1541 either.
Several memory extension cartridges exist for the
expansion port of the C64: The Commodore REU
(contains a DMA chip that transfers data between
itself and main RAM), as well as the third party
GeoRAM (maps a block to the $DE00-$DFFF area)
and RAMLink (battery backed, designed as RAM
disk).
Freezer cartridges like the Action Replay and the Final Cartridge were not only popular because they
could dump all of memory to disk and thus copy certain copy-protected games, but also because they featured floppy speeders that disabled the original routines directly at startup time, without any effort from
the user.
In the mid 90s, CPU speeders for the expansion port
became popular. The 8 MHz Flash 8 is rare today, but
many enthusiasts have a SuperCPU, which replaces
the onboard CPU with a 20 MHz 65C816, which has a
native 16 bit mode that can address up to 16 MB or
RAM. There are a few applications and games that
require a SuperCPU. The speedup of GEOS with a
SuperCPU is significant.
In the 2000s, the enthusiast scene created all kinds of
peripherals, like ethernet interfaces, IDE interfaces
and SD card readers.
And there are not only peripherals: In 2004, the
Commodore 64 DTV, a reimplemented C64 appeared
in the form of a Joystick. The device is fairly compatible and can be extended to connect to a keyboard and
a 1541."
"[INST]In the context of the C64, What is the role and functionality of the KERNAL I/O library in Commodore 8-bit systems, particularly in the Commodore 64?[/INST]KERNAL
The C64 has an 8 KB I/O library at $E000-$FFFF
which is utilized by BASIC, but is intended to be used
by other applications as well. All Commodore 8 bit
systems have a standardized library call interface in
the form of jump tables at the very top of memory
that call into machine-specific functions for I/O.
KERNAL is started form the RESET vector, initializes
the machine, sets up an interrupt service routine that
handles the keyboard, animates the cursor and does
the real time clock. The C64 has a hardware clock in
each of the CIA chips, but KERNAL has not been updated to use this feature since the VIC-20.
KERNAL provides an abstract character I/O interface
to a number of devices. All devices support open,
read, write and close. The open call takes three parameters: The logical file number (there is a maximum of 16 channels), the device number and the secondary address. There are 16 device numbers statically assigned to the devices. The 8 bit secondary address can signal something to the device, like speed or
an operation mode. Some devices (tape and IEC)
support an optional filename.
Device 0 is the keyboard. While KERNAL exports raw
key presses, the keyboard can also be accessed
through character I/O, which will go through the
screen editor and replay all characters on the screen
that are in the line of the cursor, regardless of
whether the user typed them or they had been there
before.
Device 1 is the tape drive. KERNAL reads and writes
blocks of data at a time and buffers them for character I/O.
Device 2 is RS-232. KERNAL contains a very sophisticated (but rarely used) software RS-232 implementation that supports up to 2400 baud.
Device 3 is the screen. KERNAL interprets special
codes, manages the cursor position and handles
scrolling.
Devices 4 to 15 will be directed to the IEC bus. By
convention, devices 4 to 7 are printers and plotters,
and devices 8 to 15 are floppy or hard disks.
KERNAL allows interacting with the IEC bus manually by sending TALK and LISTEN requests to the
bus."
"[INST]In the context of the C64, What is the history and features of Microsoft BASIC and its variations, including Commodore BASIC, on early home computers?[/INST]BASIC
Microsoft had a strong position in the market for
(mostly ROM) BASIC interpreters in 8080-based
home computers when the MOS 6502 was released in
1975, so they rewrote their interpreter in 6502 assembly. Microsoft BASIC was pure 6502 code with a
minimal character I/O interface to the machine's
”monitor”, i.e. I/O library.
Commodore decided to license the interpreter for the
1977 PET and extended it slightly to interface with
their disk and tape libraries. Commodore BASIC was
very buggy, so they went back to Microsoft for an update, which, with the Commodore changes re-applied,
shipped in newer PETs as BASIC V2. For version 4,
Commodore added several extensions, both language
constructs as well as support for graphics and sound.
Being a low-end machine, Commodore took the bugfixed BASIC V4 codebase and removed all features
after V2, making it independent of the machine's
graphics and sound features again, and fitting it back
into 8 KB, and shipped this version on the VIC-20.
The Commodore 64 got the exact same version, except that it runs at a different memory address
($A000-$BFFF).
Microsoft BASIC is a line-based editor, that is, lines
can be shown with the LIST command, and they can
be modified by re-typing them. This integrates nicely
with the KERNAL screen editor: The cursor can be
moved up to LISTed lines, the lines can be modified,
and when RETURN is pressed, the whole line is fed
into BASIC again.
4
A nice feature of this and later versions of Commodore BASIC is the fact that all important parts, like
the tokenizer, the detokenizer and the interpreter
loop jump over a jump table in RAM before they do
their work, allowing the user to extend BASIC arbitrarily. The most well-known BASIC extension is Simons' BASIC, a cartridge that maps 8 KB of extra
ROM at $8000-$9FFF."
"[INST]In the context of the C64, What are the technical specifications and features of the Commodore 1541 Disk Drive used with the Commodore 64?[/INST]1541 Disk Drive
The Commodore 1541 Disk Drive is the most common
disk drive used with the C64. It uses 5.25' SS/DD
(single side, double density) disks, but disks can be
flipped, and the other side can be used as well, if the
disks are double sided. The 1541 does not use the index hole, and uses software markers (SYNC) instead
to be able to tell the start of a sector. Due to reliability
problems of early drives, the 1541 only uses 35 out of
the 40 possible tracks on a 5.25' disk. The tracks have
a variable number of 256 byte sectors, ranging from
21 on the outside to 17 on the inside. The data is written in 4 different speeds. This makes an overall 683
sectors, or 174,848 bytes.
The file system is stored on track 18. Track 18, sector
0 contains the disk name and the BAM (block availability map), which stores one bit per sector (1 = free).
Track 18, sector 1 is the first sector containing directory entries: There are eight 32 byte entries per sector, with a maximum filename length of 16 characters. The first two bytes of a directory sector point to
the next directory entry sector.
The files on disk are also stored as a linked list. The
first two bytes of every sector are either the track and
sector number of the next block, or the first byte is 0
and the second byte is the number of valid bytes in
this sector.
The 1541 is a stripped down version of the PET drive
series, which had a parallel connection, and contained two 6502 CPUs: One for doing the filesystem
and communicating with the computer, and one for
reading data from disk and writing data to it, as well
as encoding and decoding the data. The 1541 only has
a single 6502 CPU running at 1 MHz, which (using
timer IRQs) regularly switches itself between the two
modes. The two virtual CPUs still communicate with
each other using a messaging interface in the zero
page. The 1541 has 2 KB of RAM at $0000-$07FF.
The 1541 has two VIA I/O controllers at $1800 (for
the IEC bus) and at $1C00 (for the drive). The firmware is located at $C000-$FFFF.
Since loading an application or a game takes minutes
on an unmodified C64, several ”floppy speeders” appeared (either as software on disk or built into applications, as ROM extension cartridges, or as internal
replacement ROMs), that consisted of implementations of more optimized protocols for the IEC bus for
both the C64 and the 1541. The 1541 code was uploaded using the old bus protocol. Such a new protocol would for example not do a handshake on every
bit using the clock line, but shift a complete byte
through in 4 steps, two bits at a time, using the clock
and data line at the same time. This would of course
only work if both CPUs were not interrupted. VIC
timing on the C64 side could already affect this, so
many floppy speeders turned off the screen while
loading."
"[INST]In the context of the C64, How many cycles do different types of instructions take on a 6502 processor?[/INST]Cycle Counting
It is quite straightforward to find out how many cycles an instruction takes. As a rule of thumb, an instruction takes as many cycles as the number of
memory fetches it has to perform, but at least two.
Therefore, single-byte opcodes (one byte fetches;
NOP/TAX/INX etc.) as well as instructions with immediate operands take two cycles. Zero page instructions take three memory accesses (opcode, address,
data), so they are three cycles. Absolute instructions
take four accesses (opcode, address low, address high,
data), so they are four cycles.
Read-modify-write instructions (INC/DEC/shift/
rotate) are an exception: They require 4 memory accesses for the zero page case and 5 otherwise, but they
take 5 and 6 cycles, respectively.
Branches take 3 cycles if they are taken and two if
they are not taken. And extra cycle has to be added if
the branch crosses a page boundary. JMP is 3, push is
3, pull is 4, JSR and RTS are 6 each.
All other timings can be looked up in the 6502's reference, but they are very easy to memorize."
"[INST]In the context of the C64, What are some common tricks and optimizations used when programming the 6502 microprocessor?[/INST]Common Tricks
• The BIT instruction exists in a two-byte (immediate operand) and three-byte (absolute operand)
variant. Since BIT only changes the flags, it effectively skips one or two bytes in the instruction
stream. This can be used to replace a two-byte
branch or a three-byte JMP with a one-byte BIT if
only one or two bytes have to be skipped.
• The architecture allows safe self-modifying code so a common optimization for copy loops is to use
LDA $nn00,X and STA $mm00,X, looping X from
$00 to $FF and then incrementing the bytes that
encode nn and mm for the next page. Compared toa LDA (zp1),Y: STA (zp2),Y sequence, this gets the
inner loop down from 16 cycles (5 LDA, 6 STA, 2
INY, 3 BNE) to 14 (4 LDA, 5 STA, 2 INY, 3 BNE).
• A PHA/PLA combination is 7 cycles, while an STA/
LDA combination in the zero page is 6 cycles, so
unless there is no free zero page space, PHA/PLA
should be avoided to quickly store a value. Using
an absolute store to write the value into the operand of a future immediate load (i.e. self modification) is the same speed at the zero page solution,
but does not waste zero page space.
• An elegant way to store a flag is to have it in bit #7
of a zero page address. While a load/store combination has to be used to set the flag, it can be
cleared with a simple LSR (5 cycles) and tested
with BIT (3 cycles), without affecting register contents.
• Since the 6502 is so register starved, only 3 bytes
can be passed to a subroutine in registers. Also, the
stack is small, and accessing it is slow, so stack
frames as seen on modern architectures are very
uncommon. Many applications and libraries (e.g.
GEOS) use a dedicated area in the zero page as virtual registers.
• The 6502 has no instructions for multiplication,
division or floating point arithmetic. Most 6502-
based computers have a BASIC interpreter in ROM
though, and they typically include a math and
floating point library."
"[INST]In the context of the C64, What are the key differences between the MOS 6510 used in the Commodore 64 and the generic MOS 6502, and how does it interact with other components on the C64?[/INST]The MOS 6510
Except for the pin layout, the MOS 6510 that is used
in the C64 differs from the generic MOS 6502 in two
ways: It can make the bus tri-state when not used, so
the VIC can use it, and it has a 6 bit I/O port built in,
which can be controlled using zero page locations 0
and 1. In register 0, each bit from 0-5 set it to output
if 1, and to input if 0. Bits 0-5 in register 1 are the actual I/O pins. On the C64, bits 0-2 are outputs and
control bank switching, they turn the ROMs and the
I/O area on and off. Bits 3-5 go to the tape connector
and control the motor and the data sent to the head,
and detect whether a key on the tape deck is pressed."
"[INST]In the context of the C64, What are some of the bugs and quirks of the original 6502 microprocessor implementation?[/INST]Bugs and Quirks
The original 6502 implementation has a series of
bugs and other anomalies that have never been fixed
in MOS chips (not counting the 65CE02, which was
only used in Amiga peripherals).
• The indirect version of JMP loads the program
counter from the wrong address, if the vector's address lies on a page boundary: JMP ($23FF) will
read the address from $23FF and $2300 instead of
$23FF and $2400.
• When in decimal mode, the negative flag reflects
the original binary result, not the effective decimal
result.
• If a software interrupt (BRK) and a hardware interrupt occur at the same time, the BRK is dropped.
• Read instructions (LDA/AND etc.) with the
absolute-indexed addressing mode first read from
the absolute address without the index register
added, and then read again from the correct address. LDX #$07 LDA $D019,X will first read from
$D019, discard the result, and then read from
$D020. On the C64, this read form $D019 would
ACK all pending VIC interrupts, while it is only
supposed to read the border color ($D020).
• Read-modify-write instructions with absolute addresses first read the value, but one cycle before
they store the result, they store the original value
again. On a C64, this can be seen when incrementing the screen border color at a defined area of the
screen, as every write to the register will cause a
tiny gray dot on the screen. When this is used with
certain I/O ports, this can have other side effects.
The latter two quirks have been used heavily for
obfuscating copy protection software.
• Instruction decoding in the 6502 is done by a PLA
that compares the current cycle number within the
instruction and the current opcode against a ROM
of 130 mask lines, of which any number can fire
independently. The outputs of these lines are then
fed into components like the ALU, bus control, register control and program counter logic. The instruction set only consists of 151 defined opcodes,
and since handling the remaining 105 opcodes as
NOPs or traps would have required extra lines in
the PLA, they will match against some lines that
were meant for instructions with similar opcodes.
Some of these ”illegal opcodes” lead to useful results and are used in some software (SAX = store A
& X), but most of the instructions make little sense
(SHX = store X & the upper 8 bits of the program
counter), and some even lock up the CPU, disabling IRQs and NMIs (CRA/KIL)."
"[INST]In the context of the C64, What are the effects of flags and branches on 8-bit load and logic instructions, and how do conditional branches and decimal mode work in a 6502/6510 processor architecture?[/INST]Flags and Branches
All load and logic instructions set N and Z accordingly, shift instructions also modify C, and arithmetic
instructions touch N V, Z and C. The D (decimal), I
(interrupt disable) and C flags can be set and cleared
programmatically (CLD/SED, CLI/SEI, CLC/SEC),
while the V flag can only be cleared (CLV). Conditional branches are possible based on the value of the
negative (BPL/BMI), overflow (BVC/BVS), zero
(BNE/BEQ) and carry (BCC/BCS) flags. Branches
encode an 8 bit relative offset and can therefore reach
code in the area of +127 and -128. Since a compare is
the same as a subtraction, BCC is a branch on (unsigned) below, and BCS is a branch on above-orequal.
NOP
NOP (no operation) does nothing. Its encoding is
$EA.
Decimal Mode
If the D flag is set, all ADC and SBC operations will be
BCD-adjusted afterwards, i.e. $09+$02 won't be $0B,
but $11, since 9+2=11. The BCD correction circuit has
been patented in US patent 3,991,307."
"[INST]In the context of the C64, What are the different types of control transfer instructions and interrupts available on C64, and how do they function?[/INST]Control Transfer
Next to the absolute JMP instruction, there is an indirect version that jumps over a vector (e.g. JMP
($FFFC)). JSR (jump to subroutine) only has an absolute version, and stores the address of the next instruction minus one on the stack. RTS (return from
subroutine) takes the address from the stack, adds
one, and moves it into the program counter. The ”minus one” logic was chosen because it could save one
cycle in the implementation of JSR.
A hardware interrupt, unless disabled by a set interrupt (I) flag, pushes the address of the next instruction minus one (just like JSR), pushes the processor
status afterwards, disables interrupts, and jumps over
the vector at $FFFE/$FFFF. RTI return from interrupt) is the same as the combination of PLP and RTS.
BRK causes a software interrupt and behaves the
same as a hardware interrupt, except that it sets the B
flag on the stack to 1 (a hardware interrupt sets it to 0)
NMIs behave the same as IRQs, but they cannot be
masked, and they use the $FFFA/$FFFB vector. The
reset vector is at $FFFC/$FFFD."
"[INST]In the context of the C64, What is the function that returns the natural logarithm of a number X?[/INST]basic: LOG(X)  (logarithm)

  Will  return  the natural log of X.  The natural log to the base e (see
EXP(X)). To convert to log base 10, simply divide by LOG(10)."
"[INST]In the context of the C64, What is the purpose and syntax of the PRINT# statement in BASIC programming?[/INST]basic: PRINT#

  There are a few differences between this statement and PRINT. PRINT# is
followed by a number,  which refers to the device or data file previously
OPENed.  This number is followed by a comma and a list to be printed. The
comma and semicolon have the same effect as they do in PRINT. Please note
that some devices may not work with TAB and SPC.

  100 PRINT#1, 'DATA VALUES'; A%, B1, C$"
"[INST]In the context of the C64, What is the format and syntax of the DATA statement in a programming language?[/INST]basic: DATA

  This  statement  is  followed  by  a  list  of items to be used by READ
statements.  Items  may  be numeric values or text strings, and items are
separated  by commas.  String items need not be inside quote marks unless
they contain space,  colon, or comma.  If two commas have nothing between
them, the value will be READ as a zero for a number, or an empty string.

  DATA 12, 14.5, 'HELLO, MOM', 3.14, PART1"
"[INST]In the context of the C64, What should you do if you purchased peripheral equipment, such as a VIC 1541 disk drive or a VIC 1525E printer?[/INST]Audio System
  If you purchased peripheral equipment, such as a VIC 1541 disk drive or
a VIC 1525E printer,  you may wish to connect it at this time.  Refer  to
the  user's  manuals  supplied  with  any  additional  equipment  for the
procedure for connecting it to the computer."
"[INST]In the context of the C64, What are the registers and procedures involved in creating and moving sprites in a graphics program?[/INST]basic: Sprites

 you need to know what
picture making locations control the functions you need. These locations,
called registers, could be illustrated in this manner:

  Register(s)   Description

   0            X coordinate of sprite 0
   1            Y coordinate of sprite 0
   2 - 15       Paired like 0 and 1 for sprites 1-7
  16            Most Significant Bit -- X coordinate
  21            Sprite appear: 1 = appear, 0 = disappear
  29            Expand sprite in 'X' Direction
  23            Expand sprite in 'Y' Direction
  39-46         Sprite 0-7 color

  In  addition  to  this  information you need to know from which 64 byte
section sprites will get their data (1 byte is used).
  This data is handled by 8 locations directly after screen memory:

        | 2040 | 2041 | 2042 | 2043 | 2044 | 2045 | 2046 | 2047 |
     SPRITE 0      1      2      3      4      5      6      7

  Now let's outline the exact procedure to get things moving  and finally
write a program.
  There  are  only a few things necessary to actually create  and move an
object.

  1. Make the proper sprite(s) appear on the screen by POKEing into
     location 21 a 1 for the bit which turns on the sprite.
  2. Set sprite pointer (locations 2040-2047) to where sprite data should
     be read from.
  3. POKE actual data into memory.
  4. Through a loop, update X and Y coordinates to move sprite around.
  5. You can, optionally, expand the object, change colors,  or perform a
     variety  of  special  functions.  Using  location  29 to expand your
     sprite in the 'X' direction and location 23 in the 'Y' direction."
"[INST]In the context of the C64, What are the steps to start programming in BASIC on a Commodore 64?[/INST]basic: how to start ?

Clear the screen by holding down the <SHIFT> key, and then depressing the
<CLR/HOME> key.
Type NEW and press <RETURN>. (This just clears out any numbers that might
have been left in the computer from your experimenting.)
Now type the following exactly as shown  (remember to hit <RETURN>  after
each line)

  10 ? 'COMMODORE 64'
  20 GOTO 10

  Now, type RUN and hit <RETURN> -- watch what happens.  Your screen will
come alive with COMMODORE 64. After you've finished watching the display,
hit <RUN/STOP> to stop the program."
"[INST]In the context of the C64, What are the editing options and techniques available to correct mistakes in a line of text?[/INST]basic:  Editing Tips

  If you make a mistake on a line, you have a number of editing options.

1. You can retype a line anytime,  and the  computer  will  automatically
   substitute the new line for the old one.
2. An unwanted line can be erased by simply typing the  line  number  and
   <RETURN>.
3. You can also easily edit an existing line,  using the cursor keys  and
   editing keys.

   Suppose you made a typing mistake in a line of the example. To correct
it without retyping the entire line, try this:
  Type LIST, then using the <SHIFT> and <CRSR UP/DOWN> keys together move
the  cursor  up  until  it  is  positioned  on  the line that needs to be
changed.
  Now,  use  the  cursor-right  key  to  move the cursor to the character
you  want  to  change,  typing the change over the old character. Now hit
<RETURN> and the corrected line will replace the old one.
  If you need more space on the line, position the cursor where the space
is needed and hit  <SHIFT>  and  <INST/DEL>  at the same time and a space
will  open  up.  Now  just  type  in  the  additional information and hit
<RETURN>.  Likewise,  you  can  delete unwanted characters by placing the
cursor to the right of the unwanted character and hitting the  <INST/DEL>
key."
"[INST]In the context of the C64, What are the steps to set up and troubleshoot a Commodore 64 computer?[/INST]USING THE COMMODORE 64

1. Turn  on  the computer using the rocker switch on the right-side panel
   when you're looking at the computer from the front.
2. After a few moments the following will be displayed on the TV screen:

      **** COMMODORE 64 BASIC V2 ****
   64K RAM SYSTEM  38911 BASIC BYTES FREE

   READY.
   _  

Cursor signals Commodore 64 is waiting for your input

3. If your TV has a manual fine tuning knob,  adjust the TV until you get
   a clear picture.
4. You  may also want to adjust the color and tint controls on the TV for
   the best display. You can use the color adjustment procedure described
   later to get everything setup properly.  When you first get a picture,
   the  screen  should appear mostly dark blue,  with a light blue border
   and letters.

TROUBLESHOOTING CHART

| Symptom               Cause                 Remedy                    |
| Indicator Light      Computer not 'On'     Make sure power switch     |
| not 'On'                                   is in 'On' position        |
|                                                                       |
|                      Power cable not       Check power socket for     |
|                      not plugged in        loose or disconnected      |
|                                            power cable                |
|                                                                       |
|                      Power supply not      Check connection with      |
|                      plugged in            wall outlet                |
|                                                                       |
|                      Bad fuse in           Take system to authorized  |
|                      computer              dealer for replacement of  |
|                                            fuse                       |
|                                                                       |
|                      TV on wrong           Check other channel        |
|                      channel               for picture (3 or 4)       |
|                                                                       |
|                      Incorrect             Computer hooks up to       |
|                      hookup                VHF antenna terminals      |
|                                                                       |
|                      Video cable not       Check TV output cable      |
|                      plugged in            connection                 |
|                                                                       |
|                      Computer set for      Set computer for same      |
|                      wrong channel         channel as TV (3 or 4)     |
|                                                                       |
| Random patterns on   Cartridge not         Reinsert cartridge after   |
| TV with cartridge    properly inserted     turning off power          |
| in place                                                              |
|                                                                       |
| Picture without      Poorly tuned TV       Retune TV                  |
| color                                                                 |
|                                                                       |
| Picture with         Bad color             Adjust color/hue/          |
| poor color           adjustment on TV      brightness controls on TV  |
|                                                                       |
| Sound with excess    TV volume up high     Adjust volume of TV        |
| background noise                                                      |
|                                                                       |
| Picture OK,          TV volume too low     Adjust volume of TV        |
| but no sound                                                          |
|                                                                       |
|                      Aux. output not       Connect sound jack to      |
|                      properly connected    aux. input on amplifier    |
|                                            and select aux. input      |"
"[INST]In the context of the C64, What are the types of variables used in Commodore 64 BASIC and how are they specified?[/INST]basic: VARIABLES

  The Commodore 64 uses three types of variables in BASIC. These are real
numeric, integer numeric, and string (alphanumeric) variables.
  Variable  names  may consist of a single letter, a letter followed by a
number, or two letters.
  An  integer  variable  is specified by using the percent (%) sign after
the  variable name.  String variable have the dollar sign ($) after their
name.

Examples

  Real Variable Names: A, A5, BZ
  Integer Variable Names: A%, A5%, BZ%
  String Variable Names: A$, A5$, BZ$"
"[INST]In the context of the C64, What is the purpose and syntax of the DEF FN command in a programming language?[/INST]basic: DEF FN

  This  command  allows you to define a complex calculation as a function
with a short name.  In the case of a long formula that is used many times
within the program, this can save time and space.
  This  function  name  will  be  FN and any legal variable name  (1 or 2
characters long).  First you must define the function using the statement
DEF  followed  by  the  function  name.  Following  the  name is a set of
parentheses enclosing a numeric variable. Then follows the actual formula
that  you want to define,  with the variable in the proper spot.  You can
then 'call' the formula, substituting any number for the variable.

  10 DEF FN A(X) = 12 * ( 34.75 - X / .3 )
  20 PRINT FN A(7)"
"[INST]In the context of the C64, What are the basic syntax and usage of the POKE and PRINT statements in a programming language?[/INST]basic: POKE

  POKE is always followed by two numbers, or formulas. The first location
is a memory location; the second number is a decimal value from 0 to 255,
which  will  be  placed in the memory location,  replacing any previously
stored value.

  10 POKE 53281,0
  20 S = 4096 * 13
  30 POKE S + 29, 8

PRINT

  The  PRINT  statement  is  the  first one most people learn to use, but
there  are  a  number of variations to be aware of. PRINT can be followed
by:

  Text String with quotes
  Variable names
  Functions
  Punctuation marks

  Punctuation  marks  are used to help format the data on the screen. The
comma   divides  the  screen  into  four  columns,  while  the  semicolon
suppresses  all  spacing.  Either mark can be last symbol on a line. This
results  in the next thing PRINTed acting as if it were a continuation of
the same PRINT statement.

  10 PRINT 'HELLO'
  20 PRINT 'HELLO', A$
  30 PRINT A + B
  40 PRINT J;
  50 PRINT A, B, C, D

  Also see: POS, SPC and TAB functions."
"[INST]In the context of the C64, What is the function of the basic function INT(X) in a programming language?[/INST]basic: INT(X)

  Returns the truncated value of X, that is,  with all the decimal places
to the right of the decimal point removed. The result will always be less
than, or equal to, X. Thus, any negative numbers with decimal places will
become the integer less than their current value."
"[INST]In the context of the C64, What is the purpose of the ON command in BASIC programming?[/INST]basic: ON

  This command turns the GOTO and GOSUB commands into special versions of
the IF statement. ON is followed by a formula, which is evaluated. If the
result of the calculation is one, the first line on the list is executed;
if the result is 2, the second line is executed, and so on. If the result
is 0,  negative,  or  larger  than  the  list  of numbers,  the next line
executed will be the statement following the ON statement.

  10 INPUT X
  20 ON X GOTO 10,20,30,40,50"
"[INST]In the context of the C64, What is the mathematical function that returns the value of e (approximately 2.718) raised to the power of a given number?[/INST]basic: EXP(X)

  Returns the value of the mathematical constant e (2.71827183) raised to
the power of X."
"[INST]In the context of the C64, What are the rules for assigning a name to a variable in BASIC?[/INST]basic: variable names: 

  In  assigning  a  name  to a variable there are a few things to keep in
mind.  First,  a  variable name can have one or two characters. The first
character  must  be  an  alphabetic  character  from  A to Z;  the second
character  can  be either alphabetic or numeric (in the range 0 to 9).  A
third character can be included to indicate the type of variable (integer
or text string), '%' or '$'.
  You can use variable names  having more than two alphabetic characters,
but  only the first two are recognized by the computer.  So PA and PARTNO
are the same and would refer to the same variable box.
  The  last  rule  for  variable names is simple:  they can't contain any
BASIC keywords  (reserved  words)  such as GOTO, RUN, etc.  Refer back to
Appendix D for a complete list of BASIC reserved words."
"[INST]In the context of the C64, What are the different types of operators in programming, including their symbols and uses, and how do they interact with each other in an expression?[/INST]basic: OPERATORS

  The arithmetic operators include the following signs:

  +  Addition
  -  Subtraction
  *  Multiplication
  /  Division
  ^  Raising to a power (exponentiation)

  On a line  containing  more than one operator,  there is a set order in
which operations always occur. If several operations are used together on
the  same  line,  the  computer  assigns  priorities  as follows:  First,
exponentiation. Next, multiplication and division, and last, addition and
subtraction.
  You can change the order of operations  by enclosing within parentheses
the calculation to be performed first. Operations enclosed in parentheses
will take place before other operations.
  There are also operations for equalities and inequalities:

  =  Equal To
  <  Less Than
  >  Greater Than
  <= Less Than or Equal To
  >= Greater Than or Equal To
  <> Not Equal To

  Finally, there are three logical operators:

  AND
  OR
  NOT

  These are used most  often  to  join  multiple  formulas  in  IF...THEN
statements. For example:

  IF A=B AND C=D THEN 100  (Requires both parts to be true)
  IF A=B OR  C=D THEN 100  (Allows either part to be true)"
"[INST]In the context of the C64, What are the optional connections available on the Commodore 64 and how can they be utilized?[/INST]c64 Optional Connections

  Since the Commodore 64 furnishes a channel of high fidelity sound,  you
may wish to play it through a quality amplifier to realize the best sound
possible.   In addition,  the  Commodore  64  also  provides  a  standard
'composite' video signal, which can be fed into a television monitor.
  These  options  are made possible by the audio/video output jack on the
rear panel  of the Commodore 64.  The easiest way to gain access to these
signals is by using a standard 5-Pin DIN audio cable (not supplied). This
cable connects directly to the audio/video connector on the computer. Two
of  the  four pins on the opposite end of the cable contain the audio and
video signals.  Optionally,  you can construct your own cable,  using the
pinouts shown in Appendix I as a guide.
  Normally,  the  BLACK  connector  of  the  DIN cable supplies the AUDIO
signal.  This  plug  may  be  connected  to  the  AUXILIARY  input  of an
amplifier,  or the AUDIO IN connector of a monitor or other video system,
such as a video cassette recorder (VCR).
  The  WHITE  or  RED connector usually supplies the direct VIDEO signal.
This  plug is connected to the VIDEO IN connector of the monitor or video
input section of some other video system, such as a VCR.
  Depending  on  the manufacturer of your DIN cable,  the color coding of
the plugs may be different.  Use the pinouts shown in Appendix I to match
up the proper plugs  if you don't get an audio or video signal  using the
suggested connections."
"[INST]In the context of the C64, What is the concept in programming that allows for the creation of lists of variables with the same name, using extra numbers to specify the element of the list, and how are they defined and used in Commodore 64 BASIC?[/INST]basic: Arrays are lists of variables with the same name,  using extra  numbers
to specify the element of the array.  Arrays are defined  using  the  DIM
statement, and may contain floating point, integer,  or string variables.
The array variable name is followed by a set of parentheses ( ) enclosing
the number of variables in the list.

  A(7), BZ%(11), A$(50), PT(20,20)

  NOTE:  There are three variable names which are reserved for use by the
Commodore 64, and may not be defined by you.  These variables are: ST, TI
and  TI$.   ST  is  a  status  variable  which  relates  to  input/output
operations.  The value of ST will change  if there is a problem loading a
program from disk or tape.
  TI and TI$ are variables which relate to the real-time clock built into
the Commodore 64. The variable TI is updated every 1/60th of a second. It
starts at 0 when the computer is turned on, and is reset only by changing
the value of TI$.
  TI$  is a string which is constantly updated by the system.  The  first
two characters contain the number of hours , the  3rd and 4th  characters
the number of minutes,  and  the 5th and 6th characters are the number of
seconds.  This  variable  can  be  given  any numeric value,  and will be
updated from that point.

  TI$ = '101530' sets the clock to 10:15 and 30 seconds AM.

  This clock is erased when the computer is turned  off,  and  starts  at
zero when the system is turned back on."
"[INST]In the context of the C64, How does the antenna switchbox facilitate the connection between the Commodore 64 and a TV?[/INST]No additional connections are required to use the c64 with your TV. The antenna switchbox will
connect the computer to the TV when the slide switch is in the 'computer'
position.  When  the switch is in the 'TV' position your set will operate
normally."
"[INST]In the context of the C64, What is the concept in programming languages that allows you to store and label a value, such as a number or string of text characters, in a computer's memory?[/INST]basic:  Variables

  Variables  are  some  of  the  most  used  features  of any programming
language,  because  variables  can represent much more information in the
computer.  Understanding how variables operate will make computing easier
and allow us to accomplish feats that would not be possible otherwise.
  Imagine a number of boxes within the computer that can hold a number or
a string of text characters.  Each of these boxes is to be labeled with a
name  that  we choose.  That name is called a variable and represents the
information in the respective box.
  For example, if we say:

  10 X% = 15
  20 X = 23.5
  30 X$ = 'THE SUM OF X% + X ='

  The computer might represent the variables like this:

  X%  15

  X   23.5

  X$  THE SUM OF X% + X =

  A  variable  name  represents  the  box,  or memory location, where the
current  value  of  the variable is stored. As you can see, we can assign
either  an  integer  number, floating point number, or a text string to a
variable.
  The '%' symbol  following  a  variable name indicates the variable will
represent  an  integer  number.  The following are valid integer variable
names:

  A%
  X%
  A1%
  NM%

  The  '$'  following  the  variable  name  indicates  the  variable will
represent a text string. The following are examples of string variables:

  A$
  X$
  MI$

  Floating  point  variables  follow  the  same  format,  with  the  type
indicator:

  A1
  X
  Y
  MI"
"[INST]In the context of the C64, What is the purpose of the basic function FN xx(X) in a programming language?[/INST]basic: FN xx(X)

  Returns  the  value  of  the  user-defined function xx created in a DEF
FN xx(X) statement."
"[INST]In the context of the C64, What is the purpose and syntax of the OPEN statement in Commodore 64 BASIC programming?[/INST]basic: OPEN

  Then  OPEN  statement allows the Commodore 64 to access devices such as
the cassette recorder and disk for data,  a printer,  or even the screen.
OPEN  is followed by a number (0-255),  to which all following statements
will  refer.  There is usually a second number after the first,  which is
the device number.
  The device numbers are:

  0   Screen
  1   Cassette
  4   Printer
  8   Disk

  Following the device number may be a third number, separated again by a
third number, separated again by a comma, which is the secondary address.
In the case of the cassette,  this is 0 for read,  1 for write, and 2 for
write with end-of-tape marker.
  In the case of the disk,  the number refers to the buffer,  or channel,
number.  In  the  printer,  the  secondary address controls features like
expanded printing. See the Commodore 64 Programmer's Reference Manual for
more details.

  10 OPEN 1,0           OPENs the SCREEN as a device
  20 OPEN 2,1,0,'D'     OPENs the cassette for reading,
                        file to be searched for is D
  30 OPEN 3,4           OPENs the printer
  40 OPEN 4,8,15        OPENs the data channel on the disk

  Also see: CLOSE, CMD, GET#, INPUT#, and PRINT#, system variable ST, and
Appendix B."
"[INST]In the context of the C64, What is the purpose and characteristics of the REM statement in a program?[/INST]basic: REM  (Remark)

  REMark  is a note to whomever is reading a LIST of the program.  It may
explain  a section of the program,  or give additional instructions.  REM
statements  in no way affect the operation of the program,  except to add
to its length. REM may be followed by any text."
"[INST]In the context of the C64, What is the function that returns the absolute value of a number, without its sign, and always returns a positive answer?[/INST]basic: ABS(X)  (absolute value)

  ABS  returns  the absolute value of the number,  without its sign (+ or
-). The answer is always positive."
"[INST]In the context of the C64, What is the formula to generate a random number within a specific range in BASIC programming?[/INST]basic:  Random Numbers and Other Functions

The RND instruction is generating random numbers

  PRINT INT(6*RND(1))+1,

The general formula for generating a set of random numbers in a certain
range is:

  NUMBER=INT(LOWER+(UPPER-LOWER+1)*RND(1))"
"[INST]In the context of the C64, What items should you find in the Commodore 64 container besides the manual?[/INST]Before  attaching  anything to the computer,  check the contents of the
Commodore  64  container.  Besides  a  manual,  you  should  find  the
following items:

  1. Commodore 64
  2. Power supply (black box with an AC plug and supply cord)
  3. Video cable
  4. TV Switchbox (small silver box with short antenna leads).

  If any items are missing  check back with your dealer immediately for a
replacement."
"[INST]In the context of the C64, What is the memory map structure used to store character and color information on the Commodore 64's screen?[/INST]COLOR MEMORY MAP

For every spot on the Commodore 64's
screen  there are two memory locations,  one for the character code,  and
the  other  for  the color code.  The color memory map begins at location
55296 (top left-hand  corner),  and continues on for 1000 locations.  The
same color codes, from 0-15, that we used to change border and background
colors can be used here to directly change character colors."
"[INST]In the context of the C64, What are the components and their functions located on the side panel of a Commodore 64 computer?[/INST]SIDE PANEL CONNECTIONS

  1. POWER SOCKET.  The  free  end  of the cable from the power supply is
     attached here to supply power to the Commodore 64.
  2. POWER SWITCH. Turns on power to the Commodore 64.
  3. GAME PORTS.  Each  game  connector  can  accept  a  joystick or game
     controller  paddle,  while the lightpen can only be plugged into the
     game port closest to the front of your computer."
"[INST]In the context of the C64, How do sprites work on the Commodore 64 and how are they controlled?[/INST]basic:  Sprite Creation

  Sprites are controlled by a separate picture-maker in the Commodore 64.
This  picture maker handles the video display.  It does all the hard work
of  creating  and  keeping  track  of  characters and graphics,  creating
colors, and moving around.
  This display circuit has 46 different 'ON/OFF' locations which act like
internal  memory  locations.  Each  of these locations breaks down into a
series of 8 blocks. And each block can either be 'ON' or 'OFF'. We'll get
into  more  detail  about this later.  By POKEing the appropriate decimal
value  in  the  proper  memory location you can control the formation and
movement of your sprite creations.
  In  addition  to accessing many of the picture making locations we will
also be using some of the Commodore 64's main memory to store information
(data) that defines the sprites. Finally, eight memory locations directly
after  the  screen memory will be used to tell the computer exactly which
memory area each sprite will get its data from."
"[INST]In the context of the C64, What is the process to change text colors and create a rainbow effect in a basic printing system?[/INST]basic: PRINTing Colors

you  can  change  text colors by simply holding the <CTRL> key and one of
the color keys.  

You have a full range of 16 text colors to work with.  Using <CTRL> key
and a number key, the following colors are available:

     1        2        3        4        5       6        7        8
   Black    White     Red     Cyan    Purple   Green    Blue    Yellow

  If  you  hold  down the <C=> key along with the appropriate number key,
these additional eight colors can be used:

     1        2        3        4        5       6        7        8
   Orange   Brown   Lt.Red    Gray 1  Gray 2  Lt.Green  Lt.Blue  Gray 3

Type NEW,  and experiment with the following.  Hold down the <CTRL> key
and  at  the  same  time hit the <1> key.  Next,  hit the <R> key without
holding down the <CTRL> key.  Now,  while again depressing the <CTRL> key
at the same time hit the <2> key.  Release the <CTRL> key and hit the <A>
key. Move through the numbers, alternating with the letters, and type out
the word RAINBOW as follows:"
"[INST]In the context of the C64, What is the purpose and syntax of the WAIT command in a programming language?[/INST]basic: WAIT

  WAIT  is  used  to  halt  the  program  until  the contents of a memory
location changes in a specific way. WAIT is followed by a memory location
(X) and up to two variables. The format is:

  WAIT X,Y,Z

  The  contents  of the memory location are first exclusive-ORed with the
third  number,  if  present,  and  then  logically  ANDed with the second
number.  If  the  result  is  zero,  the program goes back to that memory
location  and  checks  again.  When  the  result  is nonzero, the program
continues with the next statement."
"[INST]In the context of the C64, What is the purpose of the READ statement in programming?[/INST]basic: READ

  READ  is  used to assign information from DATA statements to variables,
so the information may be put to use. Care must be taken to avoid READing
strings where READ is expecting a number, which will give a TYPE MISMATCH
ERROR."
"[INST]In the context of the C64, What is the mathematical function that returns the angle, measured in radians, whose tangent is X?[/INST]basic: ATN(X)  (arctangent)

  Returns the angle, measured in radians, whose tangent is X."
"[INST]In the context of the C64, What is the purpose of the RESTORE statement in a program?[/INST]basic: RESTORE

  When  executed  in  a  program,  the pointer to which an item in a DATA
statement will be READ next is reset to the first item in the list.  This
gives you ability to re-READ the information. RESTORE stands by itself on
a line."
"[INST]In the context of the C64, What is the formula to calculate the memory location on the Commodore 64 screen, and how would you use it to determine the memory location of a ball bouncing on the screen at column 20, row 12?[/INST]basic:   Screen  memory  in  the Commodore 64 normally begins at memory location
1024,  and ends at location 2023.  Location 1024 is the upper left corner
of the screen. Location 1025 is the position of the next character to the
right  of that,  and so on down the row.  Location 1063 is the right-most
position of the first row. The next location following the last character
on a row is the first character on the next row down.

  Now,  let's  say that you're controlling a ball bouncing on the screen.
The ball is in the middle of the screen,  column 20, row 12.  The formula
for calculation of the memory location on the screen is:

  POINT = 1024 + X + 40 * Y

where X is the column and Y is the row.
  Therefore, the memory location of the ball is:
  POKE 1524, 81
  POKE 55796, 1"
"[INST]In the context of the C64, What are the steps to connect a Commodore 64 computer to a TV?[/INST]CONNECTIONS TO TV:
Connect the computer to your TV as shown below.
1. Attach one end of the TV cable to the phono type TV signal jack at the
   rear of the Commodore 64. Just push it in. Either end of the cable can
   be used.
2. Connect the other end of the cable to the antenna switchbox. Just push
   it in.
3. If you have a VHF antenna, disconnect it from your TV set.
4. Connect your VHF antenna cable to the screw terminals labeled 'antenna
   input'  on  the  switchbox.  If your antenna cable is the round 75-ohm
   coax  type,  use  a 75-ohm to 300-ohm adapter (not supplied) to attach
   your antenna cable to the switchbox.
5. Connect the twin lead output cable of the antenna switchbox to the VHF
   antenna  terminals  of  your  TV set.  If your set is one of the newer
   types  with  a round 75-ohm VHF connector,  you will need a 300-ohm to
   75-ohm converter (not supplied) to connect the switchbox to the 75-ohm
   VHF antenna input on the set.
6. Set  the  TV's  VHF  tuner  to  the  channel  number  indicated on the
   computer's  channel selector switch (channel 3  move the switch to the
   left,  channel 4  move the switch to the right).  If a strong local TV
   signal  is present on one of these channels,  select the other channel
   to avoid possible interference.
7. Plug  the  power supply cable into the power socket on the side of the
   Commodore 64.  Just  push  it in.  It is 'keyed' to allow insertion in
   only one direction, so you can't connect the power cord the wrong way.
   The power supply converts household current into the form the computer
   uses."
"[INST]In the context of the C64, What is the purpose and functionality of the GET command in BASIC programming?[/INST]basic:  GET

  GET  allows  you  to  input  one  character at a time from the keyboard
without  hitting  <RETURN>.  This  really  speeds  entering  data in many
applications.  Whatever  key  is hit is assigned variable to the variable
you specify with GET.
  The following routine illustrates how GET works:

  NEW

   1 PRINT '{CLR/HOME}'
  10 GET A$: IF A$ = '' THEN 10
  20 PRINT A$;        
  30 GOTO 10          

If you RUN the program,  the screen will clear  and each time you hit a
key, will  print  it  on  the  display,  and  then GET another
character. It is important to note that the character entered will not be
displayed  unless you specifically PRINT it to the screen,  as we've done
here."
"[INST]In the context of the C64, What is the purpose and syntax of the NEXT statement in a FOR loop?[/INST]basic: NEXT

  NEXT  is  always  used in conjunction with the FOR statement.  When the
program  reaches a NEXT statement,  it checks the FOR statement to see if
the limit of the loop has been reached.  If the loop is not finished, the
loop  variable  is increased by the specified STEP value.  If the loop is
finished,  execution  proceeds  with  the  statement following NEXT.
  NEXT  may  be  followed by a variable name,  or list of variable names,
separated by commas.  If there are no names listed, the last loop started
is the one being completed. If variables are given, they are completed in
order from left to right.

  10 FOR X = 1 TO 100: NEXT"
"[INST]In the context of the C64, What are the explanations and examples of the INPUT# and LET statements in BASIC programming?[/INST]basic: INPUT#

  INPUT#  is  similar  to INPUT,  but takes data from a previously OPENed
file or device.

  10 INPUT#1, A

LET

  LET  is  hardly  ever  used  in programs, since it is optional, but the
statement is the heart of all BASIC programs.  The variable name which is
to  be  assigned  the  result of a calculation is on the left side of the
equal sign, and the formula in the right.

  10 LET A = 5
  20 LET D$ = 'HELLO'"
"[INST]In the context of the C64, What happens when you run a BASIC program that uses the INPUT statement to prompt the user for input, and how can you exit the program?[/INST]basic: INPUT


To get an idea of how INPUT works,  type  NEW  <RETURN>  and enter this
short program:

  10 INPUT A$
  20 PRINT 'YOU TYPED: ';A$
  30 PRINT
  40 GOTO 10
  RUN
  ? COMMODORE 64 
  YOU TYPED: COMMODORE 64 

  What  happens  when  you  run this simple program. A question mark will
appear,  indicating  that  the  computer  is  waiting  for  you  to  type
something. Enter any character, or group of characters, from the keyboard
and  hit  <RETURN>.  The  computer  will  then  respond with 'YOU TYPED:'
followed by the information you entered.
You  can  INPUT  either numeric or string variables,  and even have the
INPUT statement prompt the user with a message. The format of INPUT is:

  INPUT 'PROMPT MESSAGE';VARIABLE


Or, just:

  INPUT VARIABLE

NOTE:  To  get out of this program hold down the <RUN/STOP> and <RESTORE>
keys."
"[INST]In the context of the C64, How does the Commodore 64's screen memory map work and how can characters be displayed on the screen?[/INST]basic: SCREEN MEMORY MAP

  Since  the  computer's screen is capable of holding 1000 characters (40
columns by 25 lines)  there are 1000 memory locations set aside to handle
what  is placed on the screen.  The layout of the screen could be thought
of as a grid, with each square representing a memory location.
  And  since  each location in memory can contain a number from 0 to 255,
there  are  256  possible  values for each memory location.  These values
represent  the  different  characters  the  Commodore 64 can display (see
Appendix E).  By  POKEing  the  value  for a character in the appropriate
screen  memory  location,  that character will be displayed in the proper
position."
"[INST]In the context of the C64, What are the different connections and interfaces available on the rear of a Commodore 64 computer?[/INST]REAR CONNECTIONS

  4. CARTRIDGE SLOT.  The rectangular slot to the left accepts program or
     game cartridges.
  5. CHANNEL SELECTOR.  Use  this  switch  to select which TV channel the
     computer's picture will be displayed on.
  6. TV CONNECTOR.  This connector supplies both the picture and sound to
     your television set.
  7. AUDIO & VIDEO OUTPUT.  This  connector supplies direct audio,  which
     can  be connected to a high quality sound system,  and a 'composite'
     video signal, which can be fed into a television 'monitor'.
  8. SERIAL PORT.  You can attach a printer or single disk drive directly
     to the Commodore 64 through this connector.
  9. CASSETTE INTERFACE.  A  DATASSETTE  recorder  can be attached to the
     computer  so  you  can  save  information entered for use at a later
     time.
 10. USER PORT.  Various interface cartridges can be attached to the user
     port, such as the VICMODEM, or RS 232 communication cartridge."
"[INST]In the context of the C64, What happens when a program encounters a RETURN statement, and what error occurs if no GOSUB was previously issued?[/INST]basic: RETURN

  This  statement  is  always  used  in conjunction with GOSUB.  When the
program  encounters  a  RETURN,  it  will go to the statement immediately
following the GOSUB command.  If no GOSUB was previously issued, a RETURN
WITHOUT GOSUB ERROR will occur."
"[INST]In the context of the C64, What is the function that returns the value of the cosine of an angle measured in radians?[/INST]basic: COS(X)  (cosine)

  Returns  the  value of the cosine of X, where X is an angle measured in
radians."
"[INST]In the context of the C64, What is the operator used for division in BASIC, and how would you divide 144 by 12?[/INST]basic: DIVISION

  Division uses the familiar '/'. For example, to divide 144 by 12, type:

  PRINT 144 / 12           <----- Hit <RETURN>
  12"
"[INST]In the context of the C64, What are the steps to reset the Commodore 64 screen and text color to their default settings after running a color test?[/INST]C64 Rinitialize

<SHIFT> and <CLR/HOME>.  The screen should clear and the cursor
will  be  positioned  in  the  'home' spot (upper left-hand corner of the
screen).
  Now, simultaneously hold <C=> and the <7> key. This sets the text color
back to light blue.  There is one more step needed to get everything back
to normal. Hold <CTRL> and <0> (Zero not Oh!). This sets the display mode
back  to  normal.  If  you  remember,  we turned REVERSE type on with the
<CTRL><9> to create the color bars (the color bars were actually reversed
spaces).  If  we were in the normal text mode during the color test,  the
cursor would have moved, but just left blank spaces."
"[INST]In the context of the C64, What is the function of the Commodore key (<C=>) on a Commodore computer?[/INST]<C=> COMMODORE KEY key

  The Commodore key <C=> performs a number of functions. First, it allows
you to move between the text and graphic display modes.
  When  the computer is first turned on,  it is in the upper case/graphic
mode,  that  is,  everything  you  type is in upper case letters.  As was
mentioned, using the <SHIFT> key in this mode will display the graphic on
the right side of the keys.
  If you hold down the <C=> key and <SHIFT> key,  the display will change
to upper and lower case. Now, if you hold down the <C=> key and any other
key with a graphic symbol,  the graphic shown on the left side of the key
will be displayed.
  To get back into the upper case/graphic mode hold down the <C=> key and
<SHIFT> key again.
  The second function of the <C=> key is to  allow you access to a second
set  of  eight  text colors.  By holding down the <C=> key and any of the
number keys,  any text now typed will be in the alternate color available
from  the  key  you depressed.  Chapter 5 lists the text colors available
from each key.

`"
"[INST]In the context of the C64, What is the syntax to multiply two numbers in a programming language?[/INST]basic: MULTIPLICATION

  If  you  wanted  to  multiply  12  times  12,  use  the asterisk (*) to
represent multiplication. You would type:

  PRINT 12 * 12            <----- Hit <RETURN>
  144"
"[INST]In the context of the C64, What is the function of the BASIC command STR$(X)""?""[/INST]basic: STR$(X)

  This will return a string  which is identical to the PRINTed version of
X."
"[INST]In the context of the C64, What is the purpose and function of the key that stands for ConTRoL?[/INST]<CTRL> key

  The  <CTRL>  key,  which  stands for ConTRoL, allows you to set colors,
and  perform  other  specialized  functions. You hold the <CTRL> key down
while  depressing  another  designated key to get a control function. You
had an opportunity to try the <CTRL> key  when you changed text colors to
create different color bars during the setup procedure."
"[INST]In the context of the C64, What is the purpose of the plus sign (+) in arithmetic operations?[/INST]basic: ADDITION

  The plus sign (+) signals addition: we instructed the computer to print
the result of 12 added to 12.  Other arithmetic operations take a similar
form to addition.  Remember to always hit <RETURN> after typing PRINT and
the calculation."
"[INST]In the context of the C64, What is the syntax to subtract 9 from 12 in a programming language?[/INST]basic: SUBTRACTION

  To subtract, use the conventional minus (-) sign. Type:

  PRINT 12 - 9             
  3"
"[INST]In the context of the C64, What is the function of the <RUN/STOP> key in a BASIC program, and how can it be used in shifted mode?[/INST]<RUN/STOP> key

  Normally,  depressing the <RUN/STOP>  key  will stop the execution of a
BASIC program. It signals the computer to STOP doing something. Using the
<RUN/STOP> key in the shifted mode will allow you to automatically load a
program from tape."
"[INST]In the context of the C64, What is the function of the RIGHT$ command in BASIC?[/INST]basic: RIGHT$(X$,X)

  Returns the rightmost X characters in X$."
"[INST]In the context of the C64, What is one of the most important features of the Commodore 64?[/INST]Loading and Saving Programs

  One  of  the most important features of the Commodore 64 is the ability
to save and load programs to and from cassette tape or disk.
  This  capability allows you to save the programs you write for use at a
later time, or purchase prewritten programs to use with the Commodore 64.
  Make  sure  that  either  the  disk  drive or cassette unit is attached
properly."
"[INST]In the context of the C64, What is the procedure to save a program on tape in a computer?[/INST]SAVING PROGRAMS ON TAPE

  After entering a program, if you wish to save it on tape, type:

  SAVE 'PROGRAM NAME'

  'PROGRAM NAME' can be up to 16 characters long.  After you hit <RETURN>
the computer will respond with:

  PRESS PLAY AND RECORD ON TAPE

  Press both the record and play keys on the datassette.  The screen will
blank, turning the color of the border.
  After  the  program  is  saved on tape, the READY prompt will reappear,
indicating  that  you can start working on another program,  or just turn
off the computer for a while."
"[INST]In the context of the C64, What is the purpose of the four function keys on the right side of the keyboard?[/INST]FUNCTION KEYS key

  The  four  function  keys  on  the  right  side  of the keyboard can be
'programmed'  to  handle  a variety of functions.  They can be defined in
many ways to handle repetitive tasks."
"[INST]In the context of the C64, What does the <RESTORE> command do in a computer?[/INST]<RESTORE>  key

  <RESTORE>  operates as the name implies.  It stores the computer to the
normal  state  it was in before you changed things with a program or some
command. A lot more will be said on this in later chapters."
"[INST]In the context of the C64, What is the process and syntax for loading a program from a disk on a computer?[/INST]LOADING PROGRAMS FROM DISK

  Loading a program from disk follows the same format. Type:

  LOAD 'PROGRAM NAME',8

  The  8  is  the  code for the disk, so you're just letting the computer
know that you want the program loaded from the disk.
  After  you  hit  <RETURN>  the disk will start whirring and the display
shows:

  SEARCHING FOR PROGRAM NAME
  LOADING
  READY.
  _

NOTE:
  When   you   load  a  new  program  into  the  computer's  memory,  any
instructions  that  were  in the computer previously will be erased. Make
sure  you  save  a  program  you're  working on before loading a new one.
Once a program has been loaded, you can RUN it, LIST, or make changes and
re-save the new version."
"[INST]In the context of the C64, What are the steps to reset a Commodore 64 computer to its normal display, and how can you completely reset the machine as if it were turned off and on again?[/INST]C64 Reset
There is a simple way to
reset the machine  to the normal display.  First press the <RUN/STOP> key
and then press the <RESTORE> key.  <RUN/STOP> must always be held down in
order to use the <RESTORE> key function.
  This will clear the screen and return everything to normal. If there is
a  program  in  the computer,  it will be left untouched.  This is a good
sequence to remember, especially if you do a lot of programming.
  If  you  wish  to  reset  the machine as if it were turned off and then
switched on again, type,  SYS 64759  and press <RETURN>. Be careful using
this  command!  It  will  wipe  out  any  program  or information that is
currently in the computer."
"[INST]In the context of the C64, What is the command to save a program to disk, and what does the number 8 represent in the command?[/INST]SAVING PROGRAMS ON DISK

  Saving a program on disk is even simpler. Type:

  SAVE 'PROGRAM NAME',8

  The  8  is  the code for the disk,  so you're just letting the computer
know you want the program saved to disk.
  After you press  <RETURN>  the disk will start to turn and the computer
will respond with:

  SAVING PROGRAM NAME
  OK
  READY.
  _"
"[INST]In the context of the C64, What are the steps to load a game cartridge on a Commodore 64 computer?[/INST]CARTRIDGES: The Commodore 64 computer has a line of programs and games
on cartridge.  The programs offer a wide variety of business and personal
applications  and  the  games  are  just  like real arcade games  --  not
imitations. To load these games, first turn on your TV set. Next turn OFF
your  Commodore 64.  YOU MUST TURN OFF YOUR COMMODORE 64 BEFORE INSERTING
OR  REMOVING  CARTRIDGES  OR  YOU  MAY  DAMAGE  THE CARTRIDGE AND/OR YOUR
COMMODORE 64! Third insert the cartridge.  Now turn your Commodore 64 on.
Finally  type  the  appropriate START key as is listed on the instruction
sheet that comes with each game."
"[INST]In the context of the C64, What are the steps to load a program from a cassette tape into a computer?[/INST]CASSETTES:  Use  your  DATASSETTE  recorder  and  the  ordinary  audio
cassettes  that  came as part of your prepackaged program.  Make sure the
tape is completely rewound to the beginning of the first side.  Then just
type  LOAD.  The  computer  will  answer with PRESS PLAY ON TAPE,  so you
respond  by  pressing play on your datassette machine.  At this point the
computer  screen  will go blank until the program is found.  The computer
will say  FOUND (PROGRAM NAME)  on the screen.  Now you press down on the
<C=> key.  This will actually load the program into the computer.  If you
want to stop the loading simply press <RUN/STOP> key."
"[INST]In the context of the C64, What is the purpose of the PRINT command in BASIC programming, and how can it be used for calculations and displaying results?[/INST]PRINT and Calculations

  Now  that  you've  gotten  through  a  couple  of  the  more  difficult
operations  you need  in order to keep the programs you like,  lets start
making some programs for you to save.
  Try typing the following exactly as shown:

  PRINT 'COMMODORE 64'     <----- Type this line and hit <RETURN>
  COMMODORE 64            <------ Computer typed

  READY.
  _

  If  you  make  a  typing  mistake,  use the <INST/DEL> key to erase the
character  immediately  to the left of the cursor. You can delete as many
characters as necessary.
  Let's  see  what  went on in the example above.  First,  you instructed
(commanded) the computer to PRINT whatever was inside the quote marks. By
hitting  <RETURN>  you  told  the computer to do  what you instructed and
COMMODORE 64 was printed on the screen.
  When you use the PRINT statement in this form,  whatever is enclosed in
quotes is printed exactly as you typed it.
  If the computer responded with:

  ?SYNTAX ERROR

ask yourself if you made a mistake in typing,  or forgot the quote marks.
The  computer  is  precise  and  expects  instructions  to  be given in a
specific form.
  But don't get worried; just remember to enter things as we present them
in the examples and you'll get along great with the Commodore 64.
  Remember, you can't hurt the computer by typing on it, and the best way
to learn BASIC is to try different things and see what happens.
  PRINT  is  one  of  the  most useful and powerful commands in the BASIC
language.  With  it,  you  can  display  just  about  anything  you wish,
including graphics and results of computations.
  For example,  try the following.  Clear the screen  by holding down the
<SHIFT> key  and  <CLR/HOME> key and type (be sure to use the '1' key for
one, not a letter 'I'):

  PRINT 12 + 12            
  24                      

  READY.
  _

  What you've discovered is  that the Commodore 64 is a calculator in its
basic form.  The result of '24' was calculated and printed automatically.
In  fact,  you can also perform  subtraction,  multiplication,  division,
exponentiation, and  advanced  math  functions such as calculating square
roots, etc. And you're not limited to a single calculation on a line, but
more on that later.
  Note  that in the above form,  PRINT behaved differently from the first
example.  In  this  case,  a value or result of a calculation is printed,
rather  than  the  exact message you entered because the quote marks were
omitted."
"[INST]In the context of the C64, What does the BASIC function ASC(X$) return?[/INST]basic: ASC(X$)

  This function will return the ASCII code of the first character of X$."
"[INST]In the context of the C64, What is the function of the <INST/DEL> key in a text editor?[/INST]<INST/DEL> key

  If  you  hit  the  <INST/DEL>  key,  the cursor will move back a space,
erasing  (DELeting)  the  previous  character you typed. If you're in the
middle of a line, the character to the left is deleted and the characters
to the right automatically move together to close up the space.
  A <SHIFT>ed <INST/DEL> allows you to INSerT information on a line.  For
example,  if you noticed a typing mistake  in the beginning of a line  --
perhaps you left out part of the name  -- you could use the <CRSR> key to
move back to the error  and then hit <INST/DEL>  to insert a space.  Then
just type in the missing later."
"[INST]In the context of the C64, What is the function of the CLR/HOME key on a computer keyboard?[/INST]<CLR/HOME> key

  <CLR/HOME>  positions  the cursor at the 'HOME' position of the screen,
which is the upper left-hand corner.  A shifted <CLR/HOME> will clear the
screen and place the cursor in the home position."
"[INST]In the context of the C64, What is the purpose and functionality of the BASIC function USR(X)?[/INST]basic: USR(X)

  When  this  function  is used,  the program jumps to a machine language
program  whose  starting  point  is  contained  in memory locations.  The
parameter X is passed to the machine language program,  which will return
another  value  back  to  the  BASIC  program.  Refer to the Commodore 64
Programmer's Reference Manual  for  more  details  on  this  function and
machine language programming."
"[INST]In the context of the C64, What is the purpose of the SGN(X) function in basic programming?[/INST]basic: SGN(X)  (sign)

  This function returns the sign (positive, negative, or zero) of X.  The
result will be +1 if positive, 0 if zero, and -1 if negative."
"[INST]In the context of the C64, What is the function of TAB(X) in a print statement in BASIC program?[/INST]basic: TAB(X)

  TAB is used in a PRINT statement; the next item to be PRINTed will
be in column X."
"[INST]In the context of the C64, What are the steps to load a program from tape on a Commodore computer?[/INST]LOADING PROGRAMS FROM TAPE

  Loading  a program back from tape or disk is just as simple.  For tape,
rewind the tape back to the beginning and type:

  LOAD 'PROGRAM NAME'

  If  you  don't remember the program name,  just type LOAD and the first
program on the tape will be loaded into memory.
  After you press <RETURN> the computer will respond with:

  PRESS PLAY ON TAPE

  After  you  depress  the  play  key, the screen will blank, turning the
border color of the screen as the computer searches for the program.
  When the program is found, the screen will display:

  FOUND PROGRAM NAME

To  actually  load  the  program,  depress the <C=> key. To abandon the
loading  procedure,  hit  <RUN/STOP>.  If  you hit the Commodore key, the
screen  will  again  turn  the  border color while the program is loaded.
After  the  loading procedure is completed, the screen will return to the
normal state and the READY prompt will reappear."
"[INST]In the context of the C64, What is the function of the <CRSR> key on a keyboard?[/INST]<CRSR> key

  There are two keys marked <CRSR> (CuRSoR), one with up and down arrows,
the other with left and right arrows.  You can use these keys to move the
cursor up and down or left and right.  In the unshifted mode,  the <CRSR>
keys  will  let  you  move  the  cursor down and to the right.  Using the
<SHIFT> key and <CRSR> keys allows the cursor to be moved either up or to
the  left.  The  cursor keys have a special repeat feature that keeps the
cursor moving until you release the key."
"[INST]In the context of the C64, What features does the Commodore 64 offer to help with correcting typing mistakes and moving information on the screen?[/INST]EDITING key

  No  one  is  perfect,  and  the Commodore 64 takes that into account. A
number  of  editing  keys  let  you  correct  typing  mistakes  and  move
information around on the screen."
"[INST]In the context of the C64, What are the steps to load a preprogrammed disk and run a software program?[/INST]DISK:  Using your disk drive,  carefully insert the preprogrammed disk
so  that  the label on the disk is facing up and is closest to you.  Look
for  a  little notch on the disk (it might be covered with a little piece
of tape). If  you're inserting the disk properly the notch will be on the
left side.  Once the disk is inside  close the protective gate by pushing
down on the lever.  Now type  LOAD 'PROGRAM NAME',8  and hit the <RETURN>
key. The disk will make noise and your screen will say:

  SEARCHING FOR PROGRAM NAME
  LOADING
  READY.
  _

  When  the  READY  comes  on  and  the  _ is on, just type RUN, and your
prepackaged software is ready to use."
"[INST]In the context of the C64, What are the abbreviations and corresponding keyboard shortcuts for various BASIC commands?[/INST]ABS     A <SHIFT+B>                
 NOT     N <SHIFT+O>
 AND     A <SHIFT+N>                
 ASC     A <SHIFT+S>                
 OPEN    O <SHIFT+P>
 ATN     A <SHIFT+T>                
 CHR$    C <SHIFT+H>                
 PEEK    P <SHIFT+E>
 CLOSE   CL <SHIFT+O>               
 POKE    P <SHIFT+O>
 CLR     C <SHIFT+L>                
 CMD     C <SHIFT+M>                
 PRINT   ? 
 CONT    C <SHIFT+O>                
 PRINT#  P <SHIFT+R>
 READ    R <SHIFT+E>
 DATA    D <SHIFT+A>                
 DEF     D <SHIFT+E>                
 RESTORE RE <SHIFT+S>
 DIM     D <SHIFT+I>                
 RETURN  RE <SHIFT+T>
 END     E <SHIFT+N>                
 RIGHT$  R <SHIFT+I>
 EXP     E <SHIFT+X>                
 RND     R <SHIFT+N>
 RUN     R <SHIFT+U>
 FOR     F <SHIFT+O>                
 SAVE    S <SHIFT+A>
 FRE     F <SHIFT+R>                
 SGN     S <SHIFT+G>
 GET     G <SHIFT+E>                
 SIN     S <SHIFT+I>
 SPC     S <SHIFT+P>
 GOSUB   GO <SHIFT+S>               
 SQR     S <SHIFT+Q>
 GOTO    G <SHIFT+O>                
 STEP    ST <SHIFT+E>
 STOP    S <SHIFT+T>
 INPUT#  I <SHIFT+N>                
 STR$    ST <SHIFT+R>
 SYS     S <SHIFT+Y>
 LEFT$   LE <SHIFT+F>               
 TAB(    T <SHIFT+A>
 LET     L <SHIFT+E>                
 THEN    T <SHIFT+H>
 LIST    L <SHIFT+I>  
 LOAD    L <SHIFT+O>                
 TIME$   TI$
 USR     U <SHIFT+S>
 MID$    M <SHIFT+I>                
 VAL     V <SHIFT+A>
 VERIFY  V <SHIFT+E>
 NEXT    N <SHIFT+E>                
 WAIT    W <SHIFT+A>"
"[INST]In the context of the C64, What are the definitions and behaviors of the SIN(X), SQR(X), and TAN(X) functions?[/INST]basic: SIN(X)  (sine)

  SIN(X) is the trigonometric sine function.  The result will be the sine
of X, where X is an angle in radians.

SQR(X)  (square root)

  This  function will return the square root of X,  where X is a positive
number or 0. If X is negative, an ILLEGAL QUANTITY ERROR results.

TAN(X)  (tangent)

  The result will be the tangent of X, where X is an angle in radians."
"[INST]In the context of the C64, What is the function of the LEFT$ command in BASIC?[/INST]basic: LEFT$(X$,X)

  Returns a string containing the leftmost X characters of X$."
"[INST]In the context of the C64, What does the FRE(X) function return in terms of memory availability?[/INST]basic: FRE(X)

  This  function  returns the number of unused bytes available in memory,
regardless  of the value of X.  Note that FRE(X) will read out n negative
numbers if the number of unused bytes is over 32K."
"[INST]In the context of the C64, What is the procedure to adjust the color settings on a Commodore 64 computer using the keyboard controls?[/INST]C64 Color Adjustment

  There  is  a simple way to get a pattern of colors on the TV so you can
easily  adjust  the  set.  Even  though  you may not be familiar with the
operation  of the computer right now,  just follow along,  and you'll see
how easy it is to use the Commodore 64.
  First,  look on the left side of the keyboard and locate the key marked
<CTRL>.  This  stands for ConTRoL and is used,  in conjunction with other
keys, to instruct the computer to do a specific task.

  To  use  a  control  function,  you  hold  down  the  <CTRL>  key while
depressing a second key.
  Try this:  hold the <CTRL> key  while also depressing the <9> key. Then
release both keys. Nothing obvious should have happened, but if you touch
any  key  now,  the  screen  will show the character displayed in reverse
type, rather than normal type -- like the opening message or anything you
typed earlier.
  Hold down the <SPACE BAR>. What happens? If you did the above procedure
correctly,  you  should  see  a light blue bar move across the screen and
then move down to the next line as long as the <SPACE BAR> is depressed.

     **** COMMODORE 64 BASIC V2 ****
  64K RAM SYSTEM  38911 BASIC BYTES FREE

  READY.

  Now,  hold <CTRL>  while depressing any of the other number keys.  Each
of  them  has a color  marked on the front.  Anything displayed from this
point will be in that color. For example, hold <CTRL> and the <8> key and
release both. Now hold the <SPACE BAR>.
  Watch the display.  The bar is now in yellow!  In a like manner you can
change  the  bar  to  any  of  the colors indicated on the number keys by
holding <CTRL> and the appropriate key.
  Change the bar to a few more different colors and then adjust the color
and  tint  controls  on  your  TV  so  the display matches the colors you
selected.
  The display should appear something like this:

     **** COMMODORE 64 BASIC V2 ****
  64K RAM SYSTEM  38911 BASIC BYTES FREE

  READY.
  _________________________     <------ <3> Red bar
  _______ ____________ ____     <------ <3>,<6>,<7> Red, Green, Blue bars
  __________ ______________     <------ <7>,<8> Blue, Yellow bars
  ____________                  <------ <8> Yellow bar

  At  this  point  everything is properly adjusted and working correctly.
The following chapters will introduce you to the BASIC language. However,
you can  immediately start using some of the many prewritten applications
and  games available for the Commodore 64  without knowing anything about
computer programming.
  Each  of  these packages contains detailed information about how to use
the  program.  It is suggested,  though,  that you read through the first
few  chapters  of  this  manual  to  become  more familiar with the basic
operation of your new system."
"[INST]In the context of the C64, What is the operation represented by the '^' symbol in programming, and how does it differ from multiplication?[/INST]basic: EXPONENTIATION

  In  a  like fashion,  you can easily raise a number to a power (this is
the same as multiplying a number by itself  a specified number of times).
The '^' (up arrow) signifies exponentiation.

  PRINT 12 ^ 5
  248832

  This is the same as typing:

  PRINT 12 * 12 * 12 * 12 * 12
  248832"
"[INST]In the context of the C64, What is a shortcut way to replace the BASIC command PRINT"" in a calculation?""[/INST]BASIC  has  number  of  shortcut ways of doing things.  One such way is
abbreviating BASIC commands (or keywords).  A '?' can be used in place of
PRINT,  for example.  As we go on you'll be presented with many commands;
Appendix D shows the abbreviations for each and what will be displayed on
the screen when you type the abbreviated form.

many calculations
may be performed on the same line, and they can be of mixed types.
  You could calculate this problem:

  ? 3 + 5 - 7 + 2          (The '?' replaces the word PRINT)
  3"
"[INST]In the context of the C64, What is the first thing you should do after setting up your Commodore 64?[/INST]C64 Keyboard

  Now that you've got everything set up and adjusted,  please  take a few
moments  to  familiarize  yourself  with  the keyboard which is your most
important means of communication with the Commodore 64.
  You  will  find  the keyboard similar to a standard typewriter keyboard
found  in  most  areas.  There  are,  however, a number of new keys which
control specialized functions. What follows is a brief description of the
various  keys  and how they function.  The detailed operation of each key
will be covered in later sections."
"[INST]In the context of the C64, What is the purpose and behavior of the VAL function in Basic programming?[/INST]basic: VAL(X$)

  This function converts X$ into a number, and is essentially the inverse
operation  from STR$.  The string is examined from the leftmost character
to  the  right,  for  as  many  characters  as are in recognizable number
format.

  10 X = VAL('123.456')             X = 123.456
  10 X = VAL('12A13B')              X = 12
  10 X = VAL('RIU017')              X = 0
  10 X = VAL('-1.23.45.67')         X = -1.23"
"[INST]In the context of the C64, What is the function in Visual Basic that returns a string character whose ASCII code is a specified value?[/INST]basic: CHR$(X)

  This is the opposite of ASC, and returns a string character whose ASCII
code is X."
"[INST]In the context of the C64, What does the BASIC function POS(X) return?[/INST]basic: POS(X)

  This function returns the number of the column (0-39) at which the next
PRINT statement will begin on the screen. X may have any value and is not
used."
"[INST]In the context of the C64, What is the function in BASIC that returns the number of characters in a string, including spaces and symbols?[/INST]basic: LEN(X$)

  Returned will be the number of characters  (including  spaces and other
symbols) in the string X$."
"[INST]In the context of the C64, What is the function of the key on a keyboard that allows you to switch between uppercase and lowercase characters, as well as access graphic characters and special functions?[/INST]<SHIFT> key

  The <SHIFT> key works like that on a standard typewriter. Many keys are
capable of displaying two letters or symbols  and two graphic characters.
In  the  'upper/lower case' mode the <SHIFT> key gives you standard upper
case  characters.  In the 'upper case/graphic' mode  the <SHIFT> key will
display the graphic character on the right hand side of the front part of
the key.
  In the case of special YELLOW function keys,  the <SHIFT> key will give
you the function marked on the front of the key."
"[INST]In the context of the C64, What does the <RETURN> key do when you press it after typing information?[/INST]<RETURN> key

  The <RETURN> key signals the computer  to look at the information  that
you typed and enters that information into memory."
"[INST]In the context of the C64, What is the syntax and purpose of the MID$ function in BASIC programming?[/INST]basic: MID$(X$,S,X)

  This will return a string containing X characters starting from the Sth
character in X$."
"[INST]In the context of the C64, What is the function of the basic statement SPC(X)"" in a PRINT statement?""[/INST]basic: SPC(X)

  This is used in a PRINT statement to skip X spaces forward."
"[INST]In the context of the C64, What is the concept in Commodore 64 programming that allows you to directly manipulate specific memory locations to change various aspects of the computer's behavior, such as screen colors and object definitions?[/INST]basic:  PEEKs and POKEs

  Just  as  variables  could be thought of as a representation of 'boxes'
within the machine where you placed your information,  you can also think
of  some  specially  defined  'boxes'  within the computer that represent
specific memory locations.

  The  Commodore 64  looks  at  these  memory  locations  to see what the
screen's background and border color should be, what characters are to be
displayed on the screen -- and where -- and a host of other tasks.
  By  placing,  'POKEing',  a  different  value  into  the  proper memory
location,  we can change colors, define and move objects, and even create
music.

  Above  we  showed just four locations,  two of which control the screen
and background colors. Try typing this:

  POKE 53281,7 <RETURN>

  The  background  color  of  the screen will change to yellow because we
placed the value '7' --  for yellow --  in the location that controls the
background color of the screen."
"[INST]In the context of the C64, What are the differences and uses of the GOSUB and GOTO statements in programming?[/INST]basic: GOSUB

  This statement is similar to GOTO,  except the computer remembers which
program line it last executed before the GOSUB. When a line with a RETURN
statement  is  encountered,  the  program  jumps  back  to  the statement
immediately following the GOSUB.  This is useful if there is a routine in
your program that occurs in several parts of the program.
Instead of typing the routine over and over, execute GOSUBs each time the
routine is needed.

  20 GOSUB 800

GOTO or GO TO

  When a statement with the GOTO command is reached,  the next line to be
executed will be the one with the line number following the word GOTO."
"[INST]In the context of the C64, What is the function of the NEW command in BASIC programming?[/INST]basic: NEW

  This  command  erases  the  entire  program in memory,  and also clears
out  any  variables  that  may  have  been  used.  Unless the program was
SAVEd, it is lost. BE CAREFUL WHEN YOU USE THIS COMMAND.
  The NEW command can also be used as a BASIC program statement. When the
program reaches this line,  the program is erased.  This is useful if you
want to leave everything neat when the program is done."
"[INST]In the context of the C64, What is the purpose and syntax of the LOAD command in Commodore 64?[/INST]basic: LOAD

  This  command  is  used  to  transfer  a program from tape or disk into
memory  so  the  program  can  be  used.  If  you  just type LOAD and hit
RETURN,  the  first  program found on the cassette unit will be placed in
memory.  The  command  may  be followed by a program name enclosed within
quotes.  The  name  may  then  be  followed  by  a  comma and a number or
numeric  variable,  which  acts  as a device number to indicate where the
program is coming from.

  If  no  device  number  is  given,  the Commodore 64 assumes device #1,
which  is  the  cassette  unit.  The  other device commonly used with the
LOAD command is the disk device, which is device #8.

  LOAD              Reads in the next program on tape
  LOAD 'HELLO'      Searches tape for program called HELLO,
                    and loads program, if found
  LOAD A$           Looks for program whose name is in the variable A$
  LOAD 'HELLO',8    Looks for program called HELLO on the disk drive
  LOAD '*',8        Looks for first program on disk"
"[INST]In the context of the C64, What is the purpose of the GET# statement in BASIC programming?[/INST]basic: GET#

  The GET# statement is used with a previously OPENed device or file,  to
input one character at a time from that device or file.

  GET #1,A$

This would input one character from a data file."
"[INST]In the context of the C64, What are the keyboard shortcuts and corresponding colors for the display?[/INST]KEYBOARD    COLOR      DISPLAY         KEYBOARD    COLOR      DISPLAY
  ---------------------------------------------------------------------
  <CTRL><1>   BLACK                      <C=><1>     ORANGE
  <CTRL><2>   WHITE                      <C=><2>     BROWN
  <CTRL><3>   RED                        <C=><3>     LT. RED
  <CTRL><4>   CYAN                       <C=><4>     GRAY 1
  <CTRL><5>   PURPLE                     <C=><5>     GRAY 2
  <CTRL><6>   GREEN                      <C=><6>     LT. GREEN
  <CTRL><7>   BLUE                       <C=><7>     LT. BLUE
  <CTRL><8>   YELLOW                     <C=><8>     GRAY 3"
"[INST]In the context of the C64, What is the purpose of the SYS command in a programming language?[/INST]basic: SYS

  SYS  is  followed  by  a  decimal  number or numeric value in the range
0-65535.  The  program  will  then  begin  executing the machine language
program  starting  at  that  memory  location. This is similar to the USR
function, but does not allow parameter passing."
"[INST]In the context of the C64, What is the purpose of the RUN command in a programming language?[/INST]basic: RUN

  This  command  causes  execution  of  a  program,  once  the program is
loaded  into  memory.  If  there  is  no  line  number following RUN, the
computer  will  start  with  the  lowest line number. If a line number is
designated, the program will start executing from the specified line.

  RUN               Starts program at lowest line number
  RUN 100           Starts execution at line 100
  RUN X             UNDEFINED STATEMENT ERROR. You must always specify an
                    actual line number, not a variable representation"
"[INST]In the context of the C64, What is the purpose and syntax of the IF ... THEN statement in BASIC programming?[/INST]basic: IF ... THEN

  IF ... THEN lets the computer analyze a situation and take two possible
courses of action,  depending on the outcome.  If the expression is true,
the  statement  following  THEN  is  executed.  This  may  be  any  BASIC
statement.
  If the expression is false, the program goes directly to the next line.
  The expression being evaluated may be a variable or formula,  in  which
case it is considered true if nonzero,  and false if zero.  In most cases,
there  is an expression involving relational operators  (=, <, >, <=, >=,
<>, AND, OR, NOT).

  10 IF X > 10 THEN END"
"[INST]In the context of the C64, What is the purpose and syntax of the INPUT statement in a programming language?[/INST]basic: INPUT

  The  INPUT  statement  allows  the  program  to get data from the user,
assigning  that  data  to  a  variable.  The  program  will stop, print a
question  mark  (?)  on  the screen, and wait for the user to type in the
answer and hit RETURN.
  INPUT  is  followed  by  a  variable name, or a list of variable names,
separated by commas.  A message may be placed within quote marks,  before
the  list of variable names to be INPUT.  If more than one variable is to
be INPUT, they must be separated by commas when typed.

  10 INPUT 'PLEASE ENTER YOUR FIRST NAME';A$
  20 PRINT 'ENTER YOUR CODE NUMBER';: INPUT B"
"[INST]In the context of the C64, What is the purpose and syntax of the SAVE command in Commodore 64 BASIC?[/INST]basic: SAVE

  This  command  will  store  the program currently in memory on cassette
or  disk.  If  you  just  type SAVE and RETURN, the program will be SAVEd
on  cassette.  The  computer  has no way of knowing if there is a program
already  on  that  tape, so be careful with your tapes or you may erase a
valuable program.
  If you type SAVE followed by a name in quotes or a string variable, the
computer  will  give  the  program  that  name,  so it can be more easily
located  and retrieved in the future.  The name may also be followed by a
device number.
  After  the  device  number,  there  can be a comma and a second number,
either  0  or  1. If the second number is 1, the Commodore 64 will put an
END-OF-TAPE  marker  after  your  program.  This signals the computer not
to  look  any  further on the tape if you were to give an additional LOAD
command.  If  you  try  to  LOAD  a program and the computer finds one of
these markers, you will get a FILE NOT FOUND ERROR.

  SAVE              Stores program to tape without name
  SAVE 'HELLO'      Stores on tape with name HELLO
  SAVE A$           Stores on tape with name A$
  SAVE 'HELLO',8    Stores on disk with name HELLO
  SAVE 'HELLO',1,1  Stores on tape with name HELLO and follows
                    program with END-OF-TAPE marker"
"[INST]In the context of the C64, What is the purpose and behavior of the STOP statement in a program?[/INST]basic: STOP

  This statement will halt program execution.  The message,  BREAK IN xxx
will  be  displayed,  where  xxx is the line number containing STOP.  The
program may be restarted by using the CONT command. STOP is normally used
in debugging a program."
"[INST]In the context of the C64, What is the purpose of the BASIC command PEEK(X)?[/INST]basic: PEEK(X)

  Used  to  find  out  contents  of  memory  location  X,  in  the  range
0-65535,  giving  a  result from 0-255. PEEK is often used in conjunction
with the POKE statement."
"[INST]In the context of the C64, What is the purpose and usage of the CMD command in BASIC programming?[/INST]basic: CMD

  CMD sends the output which normally would go to the screen (i.e., PRINT
statements,  LISTs,  but  not  POKEs  onto the screen)  to another device
instead.  This could be a printer,  or a data file on tape or disk.  This
device or file must be OPENed first.  The CMD command must be followed by
a number or numeric variable referring to the file.

  OPEN 1,4          OPENs device #4, which is the printer
  CMD 1             All normal output now goes to printer
  LIST              The program listing now goes to
                    the printer, not the screen

  To send output back to the screen, CLOSE the file with CLOSE 1."
"[INST]In the context of the C64, What is the purpose and syntax of the GET statement in BASIC programming?[/INST]basic: GET

  The  GET  statement  allows  you  to  get  data from the keyboard,  one
character at a time. When GET is executed, the character that is typed is
assigned to the variable.  If no character is typed,  then a null (empty)
character is assigned.
  GET  is  followed by a variable name,  usually a string variable.  If a
numeric  variable  was  used and a nonnumeric key depressed,  the program
would halt with an error message.  The GET statement may be placed into a
loop,  checking for  any result.  This loop will continue  until a key is
hit.

  10 GET A$: IF  A$ = ''  THEN 10"
"[INST]In the context of the C64, What is the purpose of the flashing square under READY on the screen?[/INST]CURSOR

  The  flashing  square  under  READY  is called the cursor and indicates
where what you type on the keyboard  will be displayed on the screen.  As
you  type,  the cursor will move ahead one space,  as the original cursor
position  is  replaced  with  the character you typed.  Try typing on the
keyboard and watch as characters you type are displayed on the TV screen."
"[INST]In the context of the C64, What advice does Commodore offer to users who may encounter difficulties with their COMMODORE 64 computer?[/INST]TIP:  The  COMMODORE 64  was designed  to be used by everyone.  But we at
Commodore  recognize  that  computer  users may,  occasionally,  run into
difficulties.  To  help  answer  your  questions  and  give  you some fun
programming  ideas,  Commodore  has  created several publications to help
you.  You might also find that it's a good idea to join a Commodore Users
Club  to  help  you  meet some other COMMODORE 64 owners who can help you
gain knowledge and experience."
"[INST]In the context of the C64, What is the syntax and functionality of the FOR loop statement in a programming language?[/INST]basic: FOR ... TO ... STEP

  This statement works with the NEXT statement to repeat a section of the
program a set number of times. The format is:

  FOR (Var. Name)=(Start of Count) TO (End of Count) STEP (Count By)

  The  loop  variable  will  be  added  to  or subtracted from during the
program.  Without any STEP specified,  STEP is assumed to be 1. The start
count and end count are the limits to the value of the loop variable.

  10 FOR L = 1 to 10 STEP .1
  20 PRINT L
  30 NEXT L

  The end of the loop value may be followed by the word STEP  and another
number or variable.  In this case, the value following STEP is added each
time instead of 1. This allows you to count backwards, or by fractions."
"[INST]In the context of the C64, What is the effect of the CLR command in BASIC?[/INST]basic: CLR

  This command will erase any variables in memory, but leaves the program
itself intact.  This command is automatically executed when a RUN command
is given."
"[INST]In the context of the C64, What is the syntax and behavior of the RND function in a programming language, including how to generate a random number between a specific range and how to reseed the random number generator?[/INST]basic: RND(X)  (random number)

  RND(X)  returns  a  random  number  in  the range 0-1. The first random
number  should  be  generated by the formula RND(-TI) to start things off
differently  every  time.  After  this,  X  should be a 1 or any positive
number.  If  X  is zero, the result will be the same random number as the
last one.
  A  negative  value  for  X  will  reseed  the generator. The use of the
same  negative  number  for  X  will  result  in  the  same  sequence  of
'random' numbers.
  The formula for generating a number between X and Y is:

  N = RND(1) * (Y-X) + X

where,
  Y is the upper limit,
  X is the lower range of numbers desired."
"[INST]In the context of the C64, What is the purpose of the DIM statement in programming and how does it relate to arrays?[/INST]basic: DIM

  When you use more than 11 elements of an array,  you must execute a DIM
statement for the array.  Keep in mind that the whole array takes up room
in  memory,  so  don't  create  an  array  much  larger than you'll need.
To  figure  the number of variables created with DIM,  multiply the total
number of elements in each dimension of the array.

  10 DIM A$(40), B7(15), CC%(4,4,4)
             ^       ^         ^
             |       |         |
   41 elements  16 elements  125 elements

  You  can  dimension more than one array in a DIM statement. However, be
careful not to dimension an array more than once."
"[INST]In the context of the C64, What is the purpose and syntax of the VERIFY command in Commodore 64?[/INST]basic: VERIFY

  This  command  causes  the  computer  to  check  the program on disk or
tape  against  the  one  in  memory.  This  is  proof that the program is
actually SAVEd,  in case the tape or disk is bad, or something went wrong
during  the  SAVE.  VERIFY  without anything after the command causes the
Commodore  64  to  check  the  next  program on tape, regardless of name,
against the program in memory.
  VERIFY  followed by a program name,  or a string variable,  will search
for that program and then check. Device numbers can also be included with
the verify command.

  VERIFY            Checks the next program on tape
  VERIFY 'HELLO'    Searches for HELLO, checks against memory
  VERIFY 'HELLO',8  Searches for HELLO on disk, then checks"
"[INST]In the context of the C64, What is the purpose of the CONT command in a program?[/INST]basic: CONT (Continue)

  This command is used to restart the execution of a  program  which  has
been stopped by either using the <STOP> key, a STOP statement,  or an END
statement within the program. The program will restart at the exact place
from where it left off.
  CONT will not work if you have changed or added lines  to  the  program
(or even just moved the cursor),  or if the  program  halted  due  to  an
error, or if you caused an error before trying to restart the program. In
these cases you will get a CAN'T CONTINUE ERROR."
"[INST]In the context of the C64, What are the different ways to use the LIST command in BASIC programming?[/INST]basic: LIST

  The  LIST  command  allows  you  to look at lines of a BASIC program in
memory.  You  can  ask  for  the  entire program to be displayed, or only
certain line numbers.

  LIST              Shows entire program
  LIST 10-          Shows only from line 10 until end
  LIST 10           Shows only line 10
  LIST -10          Shows lines from beginning until 10
  LIST 10-20        Shows line from 10 to 20, inclusive"
"[INST]In the context of the C64, What is the purpose of the CLOSE command in a programming language?[/INST]basic: CLOSE

  This  command  completes  and closes any files used by OPEN statements.
The number following CLOSE is the file number to be closed.

  CLOSE 2           Only file #2 is closed"
"[INST]In the context of the C64, What happens when a program encounters an END statement?[/INST]basic: END

  When a program encounters an END statement, the program halts, as if it
ran out of lines. You may use CONT to restart the program."
"[INST]In the context of the C64, What is the purpose of the OPEN statement in BASIC?[/INST]OUTPUT TO OTHER DEVICES

    It is often necessary to send output to devices other than the screen,
  like a cassette deck, printer, disk drive, or modem. The OPEN statement
  in BASIC creates a 'channel' to talk to one of these devices. Once the
  channel is OPEN, the PRINT# statement will send characters to that
  device.

  EXAMPLE of OPEN and PRINT# Statements:

    100 OPEN 4,4: PRINT# 4, 'WRITING ON PRINTER'
    110 OPEN 3,8,3,'0:DISK-FILE,S,W':PRINT#3,'SEND TO DISK'
    120 OPEN 1,1,1,'TAPE-FILE': PRINT#1,'WRITE ON TAPE'
    130 OPEN 2,2,0,CHR$(10):PRINT#2,'SEND TO MODEM'
    The OPEN statement is somewhat different for each device. The pa-
  rameters in the OPEN statement are shown in the table below for each
  device."
"[INST]In the context of the C64, How can I output data to the RS-232 on the Commodore 64?[/INST]SENDING DATA TO AN RS-232 CHANNEL

    When sending data, the output buffer can hold 255 characters before a
  full buffer hold-off occurs. The system will wait in the CHROUT routine
  until transmission is allowed or the <RUN/STOP> and <RESTORE> keys are
  used to recover the system through a WARM START.


  BASIC SYNTAX:

    CMD lfn-acts same as in the BASIC specifications.
    PRINT#lfn,<variable list>


  KERNAL ENTRIES:

    CHKOUT ($FFC9)-See Memory Map for more information on entry and exit
  conditions.
    CHROUT ($FFD2)-See Memory Map for more information on entry conditions.
 
 
  | IMPORTANT NOTES: There is no carriage-return delay built into the     |
  | output channel. This means that a normal RS-232 printer cannot        |
  | correctly print, unless some form of hold-off (asking the Commodore 64|
  | to wait) or internal buffering is implemented by the printer. The     |
  | hold-off can easily be implemented in your program. If a CTS (x-line) |
  | handshake is implemented, the Commodore 64 buffer will fill, and then |
  | hold-off more output until transmission is allowed by the RS-232      |
  | device. X-line handshaking is a handshake routine that uses multi-    |
  | lines for receiving and transmitting data.                            |
  |   The routine CHKOUT handles the x-line handshake, which follows the  |
  | EIA standard (August 1979) for RS-232-C interfaces. The RTS, CTS, and |
  | DCD lines are implemented with the Commodore 64 defined as the Data   |
  | Terminal Device.                                                      |"
"[INST]In the context of the C64, What is the purpose of the RTS instruction in the 6502 assembly language?[/INST]RTS                    RTS Return from subroutine                     RTS
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   RTS                 |    60   |    1    |    6     |"
"[INST]In the context of the C64, What is the purpose of the JSR 6502 instruction ?[/INST]JSR          JSR Jump to new location saving return address           JSR


  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Absolute      |   JSR Oper            |    20   |    3    |    6     |"
"[INST]In the context of the C64, What is the primary function of the input/output port described in the given text?[/INST]THE INPUT/OUTPUT PORT

    This register appears at memory locations 0 (for the DATA DIRECTION
  REGISTER) and 1 (for the actual PORT). It is an 8-bit input/output port.
  On the Commodore 64 this register is used for memory management, to
  allow the chip to control more than 64K of RAM and ROM memory.
    The details of these registers are not given here. They are explained
  as the principles needed to explain them are explained."
"[INST]In the context of the C64, What types of filtering are available on the SID chip?[/INST]FILTERING

    The harmonic content of a waveform can be changed by using a filter.
  The SID chip is equipped with three types of filtering. They can be used
  separately or in combination with one another. Let's go back to the
  sample program you've been using to play with a simple example that uses
  a filter. There are several filter controls to set.
    You add line 15 in the program to set the cutoff frequency of the
  filter. The cutoff frequency is the reference point for the filter. You
  SET the high and low frequency cutoff points in registers 21 and 22. To
  turn ON the filter for voice 1, POKE register 23.
    Next change line 30 to show that a high-pass filter will be used (see
  the SID register map).


    The SID chip also has a low-pass filter. As its name implies, this
  filter will pass the frequencies below cutoff and attenuate those above.


    Finally, the chip is equipped with a bandpass filter, which passes a
  narrow band of frequencies around the cutoff, and attenuates all others.


    The high- and low-pass filters can be combined to form a notch reject
  filter which passes frequencies away from the cutoff while attenuating
  at the cutoff frequency.



    Register 24 determines which type filter you want to use. This is in
  addition to register 24's function as the overall volume control. Bit 6
  controls the high-pass filter (0 = off, 1 = on), bit 5 is the bandpass
  filter, and bit 4 is the low-pass filter. The low 3 bits of the cutoff
  frequency are determined by register 21 (Lcf) (Lcf = 0 through 7). While
  the 8 bits of the high cutoff frequency are determined by register 22
  (Hcf) (Hcf = 0 through 255).
    Through careful use of filtering, you can change the harmonic structure
  of any waveform to get just the sound you want. In addition, changing the
  filtering of a sound as it goes through the ADSR phases of its life can
  produce interesting effects."
"[INST]In the context of the C64, What is the purpose of the RAMTAS kernal function?[/INST]B.20. Function Name: RAMTAS

    Purpose: Perform RAM test
    Call address: $FF87 (hex) 65415 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: This routine is used to test RAM and set the top and
  bottom of memory pointers accordingly. It also clears locations $0000 to
  $0101 and $0200 to $03FF. It also allocates the cassette buffer, and sets
  the screen base to $0400. Normally, this routine is called as part of the
  initialization process of a Commodore 64 program cartridge.

  EXAMPLE:
    JSR RAMTAS"
"[INST]In the context of the C64, For sprites: What values can the X position take on, and how do you move beyond the range of 0 to 255?[/INST]X POSITION VALUES BEYOND 255:

    X positions run from 0 to 255... and then START OVER from 0 to 255. To
  put a sprite beyond X position 255 on the far right side of the screen,
  you must first POKE V+ 16 as shown, THEN POKE a new X valve from 0 to 63,
  which will place the sprite in one of the X positions at the right side
  of the screen. To get back to positions 0-255, POKE V+16,0 and POKE in an
  X value from 0 to 255.

  Y POSITION VALUES:

    Y positions run from 0 to 255, including 0 to 49 off the TOP of the
  viewing area, 50 to 229 IN the,viewing area, and 230 to 255 off the
  BOTTOM of the viewing area."
"[INST]In the context of the C64, What is the purpose of the CIOUT routine in a serial communication system?[/INST]B-6. Function Name: CIOUT

    Purpose: Transmit a byte over the serial bus
    Call address: $FFA8 (hex) 65448 (decimal)
    Communication registers: A
    Preparatory routines: LISTEN, [SECOND]
    Error returns: See READST
    Stack requirements: 5
    Registers affected: None

    Description: This routine is used to send information to devices on the
  serial bus. A call to this routine will put a data byte onto the serial
  bus using full serial handshaking. Before this routine is called, the
  LISTEN KERNAL routine must be used to command a device on the serial bus
  to get ready to receive data. (If a device needs a secondary address, it
  must also be sent by using the SECOND KERNAL routine.) The accumulator is
  loaded with a byte to handshake as data on the serial bus. A device must
  be listening or the status word will return a timeout. This routine
  always buffers one character. (The routine holds the previous character
  to be sent back.) So when a call to the KERNAL UNLSN routine is made to
  end the data transmission, the buffered character is sent with an End Or
  Identify (EOI) set. Then the UNLSN command is sent to the device.
  How to Use:

    0) Use the LISTEN KERNAL routine (and the SECOND routine if needed).
    1) Load the accumulator with a byte of data.
    2) Call this routine to send the data byte.

  EXAMPLE:


    LDA #'X       ;SEND AN X TO THE SERIAL BUS
    JSR CIOUT"
"[INST]In the context of the C64, What is the purpose of the BANK SELECT bits in the 6526 COMPLEX INTERFACE ADAPTER CHIP #2 (CIA #2) in the Commodore 64?[/INST]VIDEO BANK SELECTION
 OR VBLANK

    The VIC-II chip can access ('see') 16K of memory at a time. Since there
  is 64K of memory in the Commodore 64, you want to be able to have the
  VIC-II chip see all of it. There is a way. There are 4 possible BANKS
  (or sections) of 16K of memory. All that is needed is some means of
  controlling which 16K bank the VIC-II chip looks at. In that way, the
  chip can 'see' the entire 64K of memory. The BANK SELECT bits that allow
  you access to all the different sections of memory are located in the
  6526 COMPLEX INTERFACE ADAPTER CHIP #2 (CIA #2). The POKE and PEEK BASIC
  statements (or their machine language versions) are used to select a
  bank, by controlling bits 0 and 1 of PORT A of CIA#2 (location 56576 (or
  $DD00 HEX)). These 2 bits must be set to outputs by setting bits 0 and 1
  of location 56578 ($DD02,HEX) to change banks. The following example
  shows this:

    POKE 56578,PEEK(56578)OR 3: REM MAKE SURE BITS 0 AND 1 ARE OUTPUTS
    POKE 56576,(PEEK(56576)AND 252)OR A: REM CHANGE BANKS



  This 16K bank concept is part of everything that the VIC-II chip does.
  You should always be aware of which bank the VIC-II chip is pointing at,
  since this will affect where character data patterns come from, where the
  screen is, where sprites come from, etc. When you turn on the power of
  your Commodore 64, bits 0 and 1 of location 56576 are automatically set
  to BANK 0 ($0000-$3FFF) for all display information.

  
  NOTE: The Commodore 64 character set is not available to the VIC-II 
  chip in BANKS 1 and 3. (See character memory section.)"
"[INST]In the context of the C64, What is the purpose of the interrupt status register in the Commodore 64?[/INST]INTERRUPT STATUS REGISTER

    The interrupt status register shows the current status of any interrupt
  source. The current status of bit 2 of the interrupt register will be a 1
  when two sprites hit each other. The same is true, in a corresponding 1
  to 1 relationship, for bits 0-3 listed in the chart below. Bit 7 is also
  set with a 1, whenever an interrupt occurs.
    The interrupt status register is located at 53273 ($D019) and is as
  follows:

    LATCH  BIT#             DESCRIPTION

    IRST    0   Set when current raster count = stored raster count
    IMDC    1   Set by SPRITE-DATA collision (1st one only, until reset)
    IMMC    2   Set by SPRITE-SPRITE collision (1st one only, until reset)
     ILP    3   Set by negative transition of light pen (1 per frame)
     IRQ    7   Set by latch set and enabled
 
    Once an interrupt bit has been set, it's 'latched' in and must be
  cleared by writing a 1 to that bit in the interrupt register when you're
  ready to handle it. This allows selective interrupt handling, without
  having to store the other interrupt bits."
"[INST]In the context of the C64, What are the three registers used to move a sprite around the screen on a Commodore 64?[/INST]SPRITE POSITIONING

    Once you've made a sprite you want to be able to move it around the
  screen. To do this, your Commodore 64 uses three positioning registers:

    1) SPRITE X POSITION REGISTER
    2) SPRITE Y POSITION REGISTER
    3) MOST SIGNIFICANT BIT X POSITION REGISTER

    Each sprite has an X position register, a Y position register, and a
  bit in the X most significant bit register. This lets you position your
  sprites very accurately. You can place your sprite in 512 possible X
  positions and 256 possible Y positions.
    The X and Y position registers work together, in pairs, as a team. The
  locations of the X and Y registers appear in the memory map as follows:
  First is the X register for sprite 0, then the Y register for sprite 0.
  Next comes the X register for sprite 1, the Y register for sprite 1, and
  so on. After all 16 X and Y registers comes the most significant bit in
  the X position (X MSB) located in its own register."
"[INST]In the context of the C64, What is the correct POKE statement to move the screen to a new location?[/INST]The location of screen memory can be changed easily by a POKE to
  control register 53272 ($D018 HEX). However, this register is also used
  to control which character set is used, so be careful to avoid disturbing
  that part of the control register. The UPPER 4 bits control the location
  of screen memory. To move the screen, the following statement should be
  used:
  POKE53272,(PEEK(53272)AND15)OR A
  Where 'A' has one of the following values:
$0000
$0400
$0800
$0C00
$1000
$1400
$1800
$1C00
$2000
$2400
$2400
$2800 
$2800 
$2C00 
$2C00 
$3000 
$3000 
$3400 
$3400 
$3800 
$3800 
$3C00 
$3C00 

* Remember that the BANK ADDRESS of the VIC-II chip must be added in.
* Remember that the BANK ADDRESS of the VIC-II chip must be added in.
You must also tell the KERNAL'S screen editor where the screen is as
follows: POKE 648, page (where page = address/256, e.g., 1024/256= 4,
so POKE 648,4)."
"[INST]In the context of the C64, What is the purpose of the INTERRUPT ENABLE REGISTER in the VIC-II chip?[/INST]The INTERRUPT ENABLE REGISTER is located at 53274 ($D01A). It has the
  same format as the interrupt status register. Unless the corresponding
  bit in the interrupt enable register is set to a 1, no interrupt from
  that source will take place. The interrupt status register can still be
  polled for information, but no interrupts will be generated.
    To enable an interrupt request the corresponding interrupt enable bit
  (as shown in the chart above) must be set to a 1.
    This powerful interrupt structure lets you use split screen modes. For
  instance you can have half of the screen bit mapped, half text, more than
  8 sprites at a time, etc. The secret is to use interrupts properly. For
  example, if you want the top half of the screen to be bit mapped and the
  bottom to be text, just set the raster compare register (as explained
  previously) for halfway down the screen. When the interrupt occurs, tell
  the VIC-II chip to get characters from ROM, then set the raster compare
  register to interrupt at the top of the screen. When the interrupt occurs
  at the top of the screen, tell the VIC-II chip to get characters from RAM
  (bit map mode).
  You can also display more than 8 sprites in the same way. Unfortunately BASIC isn't fast enough to do this very well. So if you want to start using display interrupts, you should work in machine language."
"[INST]In the context of the C64, What is the purpose of the CINT routine in the Commodore 64 KERNAL?[/INST]B-7. Function Name: CINT

    Purpose: Initialize screen editor & 6567 video chip
    Call address: $FF81 (hex) 65409 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: None
    Stack requirements: 4
    Registers affected: A, X, Y


    Description: This routine sets up the 6567 video controller chip in the
  Commodore 64 for normal operation. The KERNAL screen editor is also
  initialized. This routine should be called by a Commodore 64 program
  cartridge.

  How to Use:

    1) Call this routine.

  EXAMPLE:

    JSR CINT
    JMP RUN       ;BEGIN EXECUTION"
"[INST]In the context of the C64, What is the purpose and description of the RDTIM function in  kernal?[/INST]B-21. Function Name: RDTIM

    Purpose: Read system clock
    Call address: $FFDE (hex) 65502 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: This routine is used to read the system clock. The clock's
  resolution is a 60th of a second. Three bytes are returned by the
  routine. The accumulator contains the most significant byte, the X index
  register contains the next most significant byte, and the Y index
  register contains the least significant byte.

  EXAMPLE:

    JSR RDTIM
    STY TIME
    STX TIME+1
    STA TIME+2
    ...
    TIME *=*+3"
"[INST]In the context of the C64, What is the recommended memory setting for each sprite in the computer's memory?[/INST]SPRITE COLORS:

    To make sprite 0 WHITE, type: POKE V+39,1 (use COLOR POKE SETTING shown
  in chart, and INDIVIDUAL COLOR CODES shown below):

    0-BLACK     4-PURPLE        8-ORANGE        12-MED. GREY
    1-WHITE     5-GREEN         9-BROWN         13-LT. GREEN
    2-RED       6-BLUE          10-LT. RED      14-LT. BLUE
    3-CYAN      7-YELLOW        11-DARK GREY    15-LT. GREY

  MEMORY LOCATION:

    You must 'reserve' a separate 64-BYTE BLOCK of numbers in the
  computer's memory for each sprite of which 63 BYTES will be used for
  sprite data. The memory settings shown below are recommended for the
  'sprite pointer' settings in the chart above. Each sprite will be unique
  and you'll have to define it as you wish. To make all sprites exactly the
  same, point the sprites you want to look the same to the same register
  for sprites."
"[INST]In the context of the C64, What is the purpose of the TYA instruction in the 6502 assembly language?[/INST]TYA                TYA Transfer index Y to accumulator                TYA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TYA                 |    98   |    1    |    2     |"
"[INST]In the context of the C64, What does the stack pointer register contain on C64?[/INST]THE STACK POINTER

    This register contains the location of the first empty place on the
  stack. The stack is used for temporary storage by machine language pro-
  grams, and by the computer."
"[INST]In the context of the C64, What are the details for the Jump 6502 instruction?[/INST]JMP                     JMP Jump to new location                      JMP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Absolute      |   JMP Oper            |    4C   |    3    |    3     |
  |  Indirect      |   JMP (Oper)          |    6C   |    3    |    5     |"
"[INST]In the context of the C64, What is the instruction that performs a return from interrupt in 6502?[/INST]RTI                    RTI Return from interrupt                      RTI

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   RTI                 |    4D   |    1    |    6     |"
"[INST]In the context of the C64, How can I get data from an RS-232 channel on a Commodore 64?[/INST]GETTING DATA FROM AN RS-232 CHANNEL

    When getting data from an RS-232 channel, the Commodore 64 receiver
  buffer will hold up to 255 characters before the buffer overflows. This
  is indicated in the RS-232 status word (ST in BASIC, or RSSTAT in machine
  language). If an overflow occurs, then all characters received during a
  full buffer condition, from that point on, are lost. Obviously, it pays
  to keep the buffer as clear as possible.
    If you wish to receive RS-232 data at high speeds (BASIC can only go so
  fast, especially considering garbage collects. This can cause the re-
  ceiver buffer to overflow), you will have to use machine language
  routines to handle this type of data burst.

  BASIC SYNTAX:

    Recommended: GET#lfn, <string variable>
    NOT Recommended: INPUT#lfn <variable list>

  KERNAL ENTRIES:

    CHKIN ($FFC6)-See Memory Map for more information on entry and exit
  conditions.
    GETIN ($FFE4)-See Memory Map for more information on entry and exit
  conditions.
    CHRIN ($FFCF)-See Memory Map for more information on entry and exit
  conditions.

  | NOTES:                                                                |
  |   If the word length is less than 8 bits, all unused bit(s) will be   |
  | assigned a value of zero.                                             |
  |   If a GET# does not find any data in the buffer, the character '' (a |
  | null) is returned.                                                    |
  |   If INPUT# is used, then the system will hang in a waiting condition |
  | until a non-null character and a following carriage return is         |
  | received. Therefore, if the Clear To Send (CTS) or Data Set Ready     |
  | (DSR) line(s) disappear during character INPUT#, the system will hang |
  | in a RESTORE-only state. This is why the INPUT# and CHRIN routines are|
  | NOT recommended.                                                      |
  |   The routine CHKIN handles the x-line handshake which follows the EIA|
  | standard (August 1979) for RS-232-C interfaces. (The Request To Send  |
  | (RTS), CTS, and Received line signal (DCD) lines are implemented with |
  | the Commodore 64 computer defined as the Data Terminal device.)       |"
"[INST]In the context of the C64, How does the print function works?[/INST]OUTPUT TO THE TV

    The simplest form of output in BASIC is the PRINT statement. PRINT uses
  the TV screen as the output device, and your eyes are the input device
  because they use the information on the screen.
    When PRINTing on the screen, your main objective is to format the
  information on the screen so it's easy to read. You should try to think
  like a graphic artist, using colors, placement of letters, capital and
  lower case letters, as well as graphics to best communicate the
  information. Remember, no matter how smart your program, you want to be
  able to understand what the results mean to you.
    The PRINT statement uses certain character codes as 'commands' to the
  cursor. The <CRSR> key doesn't actually display anything, it just makes
  the cursor change position. Other commands change colors, clear the
  screen, and insert or delete spaces. The <RETURN> key has a character
  code number (CHR$) of 13. A complete table of these codes is contained in
  Appendix C.
    There are two functions in the BASIC language that work with the PRINT
  statement. TAB positions the,cursor on the given position from the left
  edge of the screen, SPC moves the cursor right a given number of spaces
  from the current position.
    Punctuation marks in the PRINT statement serve to separate and format
  information. The semicolon (;) separates 2 items without any spaces in
  between. If it is the last thing on a line, the cursor remains after the
  last thing PRINTed instead of going down to the next line. It suppresses
  (replaces) the RETURN character that is normally PRINTed at the end of
  the line.
    The comma (,) separates items into columns. The Commodore 64 has 4
  columns of 10 characters each on the screen. When the computer PRINTs a
  comma, it moves the cursor right to the start of the next column. If it
  is past the last column of the line, it moves the cursor down to the next
  line. Like the semicolon, if it is the last item on a line the RETURN is
  suppressed.
    The quote marks ('') separate literal text from variables. The first
  quote mark on the line starts the literal area, and the next quote mark
  ends it. By the way, you don't have to have a final quote mark at the
  end of the line.
    The RETURN code (CHR$ code of 13) makes the cursor go to the next
  logical line on the screen. This is not always the very next line. When
  you type past the end of a line, that line is linked to the next line.
  The computer knows that both lines are really one long line. The links
  are held in the line link table (see the memory map for how this is set
  up).
    A logical line can be 1 or 2 screen lines long, depending on what was
  typed or PRINTed.  The logical line the cursor is on determines where the
  <RETURN> key sends it. The logical line at the top of the screen
  determines if the screen scrolls 1 or 2 lines at a time. There are other
  ways to use the TV as an output device. The chapter on graphics describes
  the commands to create objects that move across the screen. The VIC chip
  section tells how the screen and border colors and sizes are changed. And
  the sound chapter tells how the TV speaker creates music and special
  effects."
"[INST]In the context of the C64, What is the Commodore 64's built-in interface for connecting to devices?[/INST]RS-232 INTERFACE DESCRIPTION

  GENERAL OUTLINE

    The Commodore 64 has a built-in RS-232 interface for connection to any
  RS-232 modem, printer, or other device. To connect a device to the
  Commodore 64, all you need is a cable and a little bit of programming.
    RS-232 on the Commodore 64 is set-up in the standard RS-232 format, but
  the voltages are TTL levels (0 to 5V) rather than the normal RS-232 -12
  to 12 volt range. The cable between the Commodore 64 and the RS-232
  device should take care of the necessary voltage conversions. The
  Commodore RS-232 interface cartridge handles this properly.
    The RS-232 interface software can be accessed from BASIC or from the
  KERNAL for machine language programming.
    RS-232 on the BASIC level uses the normal BASIC commands: OPEN, CLOSE,
  CMD, INPUT#, GET#, PRINT#, and the reserved variable ST. INPUT# and GET#
  fetch data from the receiving buffer, while PRINT# and CMD place data
  into the transmitting buffer. The use of these commands (and examples)
  will be described in more detail later in this chapter.
    The RS-232 KERNAL byte and bit level handlers run under the control of
  the 6526 CIA #2 device timers and interrupts. The 6526 chip generates

  NMI (Non-Maskable Interrupt) requests for RS-232 processing. This allows
  background RS-232 processing to take place during BASIC and machine
  language programs. There are built-in hold-offs in the KERNAL, cassette,
  and serial bus routines to prevent the disruption of data storage or
  transmission by the NMIs that are generated by the RS-232 routines.
  During cassette or serial bus activities, data can NOT be received from
  RS-232 devices. But because these hold-offs are only local (assuming
  you're careful about your programming) no interference should result.
    There are two buffers in the Commodore 64 RS-232 interface to help
  prevent the loss of data when transmitting or receiving RS-232 informa-
  tion.
    The Commodore 64 RS-232 KERNAL buffers consist of two first-in/first-
  out (FIFO) buffers, each 256 bytes long, at the top of memory. The
  OPENing of an RS-232 channel automatically allocates 512 bytes of memory
  for these buffers. If there is not enough free space beyond the end of
  your BASIC program no error message will be printed, and the end of your
  program will be destroyed. SO BE CAREFUL!
    These buffers are automatically removed by using the CLOSE command."
"[INST]In the context of the C64, What is the purpose and functionality of the MACHINE LANGUAGE MONITOR (64MON) program?[/INST]MACHINE LANGUAGE MONITOR (64MON):

    This program allows you to enter a program in either HEX or SYMBOLIC
  codes, and save the portion of memory the program is in. Advantages of
  this method include easier entry of the machine language routines,
  debugging aids, and a much faster means of saving and loading. The
  drawback to this method is that it generally requires the BASIC program
  to load the machine language routine from tape or disk when it is
  started. (For more details on 64MON see the machine language section.)

  EXAMPLE:

    The following is an example of a BASIC program using a machine language
  routine prepared by 64MON. The routine is stored on tape:

    10 IF FLAG=L THEN 20
    15 FLAG=1:LOAD'MACHINE LANGUAGE ROUTINE NAME',1,1
    20
    .
    .
    REST OF BASIC PROGRAM"
"[INST]In the context of the C64, What is the purpose of the SETTMO kernal routine?[/INST]Function  Name: SETTMO

    Purpose: Set IEEE bus card timeout flag
    Call address: $FFA2 (hex) 65442 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: None

  NOTE: This routine is used ONLY with an IEEE add-on card!      
  
    Description: This routine sets the timeout flag for the IEEE bus. When
  the timeout flag is set, the Commodore 64 will wait for a device on the
  IEEE port for 64 milliseconds. If the device does not respond to the
  Commodore 64's Data Address Valid (DAV) signal within that time the
  Commodore 64 will recognize an error condition and leave the handshake
  sequence. When this routine is called when the accumulator contains a 0
  in bit 7, timeouts are enabled. A 1 in bit 7 will disable the timeouts.

NOTE: The Commodore 64 uses the timeout feature to communicate that a 
disk file is not found on an attempt to OPEN a file only with an IEEE card.                                                                 |
  
  How to Use:

  TO SET THE TIMEOUT FLAG
    1) Set bit 7 of the accumulator to 0.
    2) Call this routine.

  TO RESET THE TIMEOUT FLAG
    1) Set bit 7 of the accumulator to 1.
    2) Call this routine.

  EXAMPLE:

    ;DISABLE TIMEOUT
    LDA #0
    JSR SETTMO"
"[INST]In the context of the C64, What are the details of the 6502 LDA instruction?[/INST]LDA                  LDA Load accumulator with memory                 LDA


  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   LDA #Oper           |    A9   |    2    |    2     |
  |  Zero Page     |   LDA Oper            |    A5   |    2    |    3     |
  |  Zero Page,X   |   LDA Oper,X          |    B5   |    2    |    4     |
  |  Absolute      |   LDA Oper            |    AD   |    3    |    4     |
  |  Absolute,X    |   LDA Oper,X          |    BD   |    3    |    4*    |
  |  Absolute,Y    |   LDA Oper,Y          |    B9   |    3    |    4*    |
  |  (Indirect,X)  |   LDA (Oper,X)        |    A1   |    2    |    6     |
  |  (Indirect),Y  |   LDA (Oper),Y        |    B1   |    2    |    5*    |
  * Add 1 if page boundary is crossed."
"[INST]In the context of the C64, What is the purpose of the SBC instruction in 6502?[/INST]SBC          SBC Subtract memory from accumulator with borrow         SBC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   SBC #Oper           |    E9   |    2    |    2     |
  |  Zero Page     |   SBC Oper            |    E5   |    2    |    3     |
  |  Zero Page,X   |   SBC Oper,X          |    F5   |    2    |    4     |
  |  Absolute      |   SBC Oper            |    ED   |    3    |    4     |
  |  Absolute,X    |   SBC Oper,X          |    FD   |    3    |    4*    |
  |  Absolute,Y    |   SBC Oper,Y          |    F9   |    3    |    4*    |
  |  (Indirect,X)  |   SBC (Oper,X)        |    E1   |    2    |    6     |
  |  (Indirect),Y  |   SBC (Oper),Y        |    F1   |    2    |    5     |
  * Add 1 when page boundary is crossed."
"[INST]In the context of the C64, What is the harmonic structure of a triangular wave, and how does it relate to the fundamental frequency and the harmonic number?[/INST]UNDERSTANDING WAVEFORMS

    When a note is played, it consists of a sine wave oscillating at the
  fundamental frequency and the harmonics of that wave.
    The fundamental frequency defines the overall pitch of the note.
  Harmonics are sine waves having frequencies which are integer multiples
  of the fundamental frequency. A sound wave is the fundamental frequency
  and all of the harmonics it takes to make up that sound.

    In musical theory let's say that the fundamental frequency is harmonic
  number 1. The second harmonic has a frequency twice the fundamental
  frequency, the third harmonic is three times the fundamental frequency,
  and so on. The amounts of each harmonic present in a note give it its
  timbre.
    An acoustic instrument, like a guitar or a violin, has a very compli-
  cated harmonic structure. In fact, the harmonic structure may vary as a
   single note is played. You have already played with the waveforms
  available in your Commodore music synthesizer. Now let's talk about how
  the harmonics work with the triangular, sawtooth, and rectangular waves.
    A triangular wave contains only odd harmonics. The amount of each
  harmonic present is proportional to the reciprocal of the square of the
  harmonic number. In other words harmonic number 3 is 1/9 quieter than
  harmonic number 1, because the harmonic 3 squared is 9 (3 X 3) and the
  reciprocal of 9 is 1/9.
    As you can see, there is a similarity in shape of a triangular wave to
  a sine wave oscillating at the fundamental frequency.
    Sawtooth waves contain all the harmonics. The amount of each harmonic
  present is proportional to the reciprocal of the harmonic number. For
  example, harmonic number 2 is 1/2 as loud as harmonic number 1.
    The square wave contains odd harmonics in proportion to the reciprocal
  of the harmonic number. Other rectangular waves have varying harmonic
  content. By changing the pulse width, the timbre of the sound of a
  rectangular wave can be varied tremendously.

    By choosing carefully the waveform used, you can start with a harmonic
  structure that looks somewhat like the sound you want. To refine the
  sound, you can add another aspect of sound quality available on your
  Commodore 64 called filtering, which we'll discuss later in this section."
"[INST]In the context of the C64, What is the primary component of the CPU that consists of eight flags?[/INST]THE STATUS REGISTER

    This register consists of eight 'flags' (a flag = something that indi-
  cates whether something has, or has not occurred)."
"[INST]In the context of the C64, HWhat is the purpose of the CHROUT routine in the KERNAL?[/INST]B-5. Function Name: CHROUT

    Purpose: Output a character
    Call address: $FFD2 (hex) 65490 (decimal)
    Communication registers: A
    Preparatory routines: (CHKOUT,OPEN)
    Error returns: 0 (See READST)
    Stack requirements: 8+
    Registers affected: A

    Description: This routine outputs a character to an already opened
  channel. Use the KERNAL OPEN and CHKOUT routines to set up the output
  channel before calling this routine, If this call is omitted, data is
  sent to the default output device (number 3, the screen). The data byte
  to be output is loaded into the accumulator, and this routine is called.
  The data is then sent to the specified output device. The channel is left
  open after the call.

 
 NOTE: Care must be taken when using this routine to send data to a    
 specific serial device since data will be sent to all open output     
 channels on the bus. Unless this is desired, all open output channels 
 on the serial bus other than the intended destination channel must be 
 closed by a call to the KERNAL CLRCHN routine.                        

  How to Use:

    0) Use the CHKOUT KERNAL routine if needed, (see description above).
    1) Load the data to be output into the accumulator.
    2) Call this routine.

  EXAMPLE:

    ;DUPLICATE THE BASIC INSTRUCTION CMD 4,'A';
    LDX #4          ;LOGICAL FILE #4
    JSR CHKOUT      ;OPEN CHANNEL OUT
    LDA #'A
    JSR CHROUT      ;SEND CHARACTER"
"[INST]In the context of the C64, What is the purpose of the PLOT kernal function?[/INST]B-19. Function Name: PLOT

    Purpose: Set cursor location
    Call address: $FFF0 (hex) 65520 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: A call to this routine with the accumulator carry flag
  set loads the current position of the cursor on the screen (in X,Y
  coordinates) into the Y and X registers. Y is the column number of the
  cursor location (6-39), and X is the row number of the location of the
  cursor (0-24). A call with the carry bit clear moves the cursor to X,Y
  as determined by the Y and X registers.

  How to Use:


  READING CURSOR LOCATION

    1) Set the carry flag.
    2) Call this routine.
    3) Get the X and Y position from the Y and X registers, respectively.


  SETTING CURSOR LOCATION

    1) Clear carry flag.
    2) Set the Y and X registers to the desired cursor location.
    3) Call this routine.


  EXAMPLE:

    ;MOVE THE CURSOR TO ROW 10, COLUMN 5 (5,10)
    LDX #10
    LDY #5
    CLC
    JSR PLOT"
"[INST]In the context of the C64, explain the vertical positionning of sprites[/INST]VERTICAL POSITIONING

    Setting up positions in the horizontal direction is a little more
  difficult than vertical positioning, so we'll discuss vertical (Y)
  positioning first.
    There are 200 different dot positions that can be individually pro-
  grammed onto your TV screen in the Y direction. The sprite Y position
  registers can handle numbers up to 255. This means that you have more
  than enough register locations to handle moving a sprite up and down. You
  also want to be able to smoothly move a sprite on and off the screen.
  More than 200 values are needed for this.
    The first on-screen value from the top of the screen, and in the Y
  direction for an unexpanded sprite is 30. For a sprite expanded in the Y
  direction it would be 9. (Since each dot is twice as tall, this makes a
  certain amount of sense, as the initial position is STILL calculated from
  the top left corner of the sprite.)
    The first Y value in which a sprite (expanded or not) is fully on the
  screen (all 21 possible lines displayed) is 50.
    The last Y value in which an unexpanded sprite is fully on the screen
  is 229. The last Y value in which an expanded sprite is fully on the
  screen is 208.
    The first Y value in which a sprite is fully off the screen is 250."
"[INST]In the context of the C64, What is the starting location of the VIC-II chip in the Commodore 64's memory?[/INST]GRAPHICS LOCATIONS

    Some general information first. There are 1000 possible locations on
  the Commodore 64 screen. Normally, the screen starts at location 1024
  ($0400 in HEXadecimal notation) and goes to location 2023. Each of
  these locations is 8 bits wide. This means that it can hold any integer
  number from 0 to 255. Connected with screen memory is a group of 1000
  locations called COLOR MEMORY or COLOR RAM. These start at location 55296
  ($D800 in HEX) and go up to 56295. Each of the color RAM locations is 4
  bits wide, which means that it can hold any integer number from 0 to 15.
  Since there are 16 possible colors that the Commodore 64 can use, this
  works out well.
    In addition, there are 256 different characters that can be displayed
  at any time. For normal screen display, each of the 1000 locations in
  screen memory contains a code number which tells the VIC-II chip which
  character to display at that screen location.
    The various graphics modes are selected by the 47 CONTROL registers in
  the VIC-II chip. Many of the graphics functions can be controlled by
  POKEing the correct value into one of the registers. The VIC-II chip is
  located starting at 53248 ($D000 in HEX) through 53294 ($D02E in HEX)."
"[INST]In the context of the C64, What are the key characteristics of the ADSR envelope generator in the SID chip?[/INST]SID ENVELOPE GENERATORS

    The four-part ADSR (ATTACK, DECAY, SUSTAIN, RELEASE) envelope generator
  has been proven in electronic music to provide the optimum trade-off
  between flexibility and ease of amplitude control. Appropriate selection
  of envelope parameters allows the simulation of a wide range 2: of
  percussion and sustained instruments. The violin is a good example of a
  sustained instrument. The violinist controls the volume by bowing the
  instrument. Typically, the volume builds slowly, reaches a peak, then
  drops to an intermediate level. The violinist can maintain this level for
  as long as desired, then the volume is allowed to slowly die away.
    Note that the tone can be held at the intermediate SUSTAIN level for
  as long as desired. The tone will not begin to die away until GATE is
  cleared. With minor alterations, this basic envelope can be used for
  brass and woodwinds as well as strings.
    An entirely different form of envelope is produced by percussion in-
  struments such as drums, cymbals and gongs, as well as certain
  keyboards such as pianos and harpsichords. The percussion envelope is
  characterized by a nearly instantaneous attack, immediately followed by
  a decay to zero volume. Percussion instruments cannot be sustained at
  a constant amplitude. For example, the instant a drum is struck, the
  sound reaches full volume and decays rapidly regardless of how it was
  struck.

    Note that the tone immediately begins to decay to zero amplitude after
  the peak is reached, regardless of when GATE is cleared. The amplitude
  envelope of pianos and harpsichords is somewhat more complicated, but can
  be generated quite easily with the ADSR. These instruments reach full
  volume when a key is first struck. The amplitude immediately begins to
  die away slowly as long as the key remains depressed. If the key is
  released before the sound has fully died away, the amplitude will
  immediately drop to zero. 
    Note that the tone decays slowly until GATE is cleared, at which point
  the amplitude drops rapidly to zero.
    The most simple envelope is that of the organ, When a key is pressed,
  the tone immediately reaches full volume and remains there. When the key
  is released, the tone drops immediately to zero volume. 
    The real power of SID lies in the ability to create original sounds
  rather than simulations of acoustic instruments. The ADSR is capable of
  creating envelopes which do not correspond to any 'real' instruments. A
  good example would be the 'backwards' envelope. This envelope is
  characterized by a slow attack and rapid decay which sounds very much
  like an instrument that has been recorded on tape then played backwards.
 
    Many unique sounds can be created by applying the amplitude envelope of
  one instrument to the harmonic structure of another. This produces sounds
  similar to familiar acoustic instruments, yet notably different. In
  general, sound is quite subjective and experimentation with various
  envelope rates and harmonic contents will be necessary in order to
  achieve the desired sound."
"[INST]In the context of the C64, Can you suggest colors good for TVs?[/INST]SUGGESTED SCREEN AND CHARACTER COLOR COMBINATIONS

    Color TV sets are limited in their ability to place certain colors next
  to each other on the same line. Certain combinations of screen and char-
  acter colors produce blurred images. This chart shows which color com-
  binations to avoid, and which work especially well together.

 


  PROGRAMMING SPRITES - ANOTHER LOOK

    For those of you having trouble with graphics, this section has been
  designed as a more elementary tutorial approach to sprites."
"[INST]In the context of the C64, What are the different graphics display modes supported by the Commodore 64's 6567 Video Interface Chip (VIC-II chip)?[/INST]GRAPHICS OVERVIEW

  All of the graphics abilities of the Commodore 64 come from the 6567
  Video Interface Chip (also known as the VIC-II chip). This chip gives a
  variety of graphics modes, including a 40 column by 25 line text display,
  a 320 by 200 dot high resolution display, and SPRITES, small movable
  objects which make writing games simple. And if this weren't enough,
  many of the graphics modes can be mixed on the same screen. It is
  possible, for example, to define the top half of the screen to be in
  high resolution mode, while the bottom half is in text mode. And SPRITES
  will combine with anything! More on sprites later. First the other
  graphics modes.
   The VIC-II chip has the following graphics display modes:

  A) CHARACTER DISPLAY MODES

     1) Standard Character Mode
            a)ROM characters
            b)RAM programmable characters
     2) Multi-Color Character Mode
            a)ROM characters
            b)RAM programmable characters

     3) Extended Background Color Mode
            a)ROM characters
            b)RAM programmable characters


  B) BIT MAP MODES

     1) Standard Bit Map Mode
     2) Multi-Color Bit Map Mode


  C) SPRITES

     1) Standard Sprites
     2) Multi-Color Sprites"
"[INST]In the context of the C64, What is the starting point for calculating the position of a sprite in a 24x21 dot area?[/INST]The position of a sprite is calculated from the TOP LEFT corner of the
  24 dot by 21 dot area that your sprite can be designed in. It does NOT
  matter how many or how few dots you use to make up a sprite. Even if only
  one dot is used as a sprite, and you happen to want it in the middle of
  the screen, you must still calculate the exact positioning by starting at
  the top left corner location."
"[INST]In the context of the C64, What is the purpose of the OPEN function in the KERNAL routines?[/INST]B-18. Function Name: OPEN


    Purpose: Open a logical file
    Call address: $FFC0 (hex) 65472 (decimal)
    Communication registers: None
    Preparatory routines: SETLFS, SETNAM
    Error returns: 1,2,4,5,6,240, READST
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine is used to OPEN a logical file. Once the
  logical file is set up, it can be used for input/output operations. Most
  of the I/O KERNAL routines call on this routine to create the logical
  files to operate on. No arguments need to be set up to use this routine,
  but both the SETLFS and SETNAM KERNAL routines must be called before
  using this routine.


  How to Use:

    0) Use the SETLFS routine.
    1) Use the SETNAM routine.
    2) Call this routine."
"[INST]In the context of the C64, What is the purpose of the CHRIN  kernal function?[/INST]B-4. Function Name: CHRIN

    Purpose: Get a character from the input channel
    Call address: $FFCF (hex) 65487 (decimal)
    Communication registers: A
    Preparatory routines: (OPEN, CHKIN)
    Error returns: 0 (See READST)
    Stack requirements: 7+
    Registers affected: A, X

    Description: This routine gets a byte of data from a channel already
  set up as the input channel by the KERNAL routine CHKIN. If the CHKIN has
  NOT been used to define another input channel, then all your data is
  expected from the keyboard. The data byte is returned in the accumulator.
  The channel remains open after the call.
    Input from the keyboard is handled in a special way. First, the cursor
  is turned on, and blinks until a carriage return is typed on the
  keyboard. All characters on the line (up to 88 characters) are stored in
  the BASIC input buffer. These characters can be retrieved one at a time
  by calling this routine once for each character. When the carriage return
  is retrieved, the entire line has been processed. The next time this
  routine is called, the whole process begins again, i.e., by flashing the
  cursor.

  How to Use:

  FROM THE KEYBOARD

    1) Retrieve a byte of data by calling this routine.
    2) Store the data byte.
    3) Check if it is the last data byte (is it a CR?)
    4) If not, go to step 1.

  EXAMPLE:

       LDY $#00      ;PREPARE THE Y REGISTER TO STORE THE DATA
   RD  JSR CHRIN
       STA DATA,Y    ;STORE THE YTH DATA BYTE IN THE YTH
                     ;LOCATION IN THE DATA AREA.
       INY
       CMP #CR       ;IS IT A CARRIAGE RETURN?
       BNE RD        ;NO, GET ANOTHER DATA BYTE

  EXAMPLE:

    JSR CHRIN
    STA DATA

  FROM OTHER DEVICES

    0) Use the KERNAL OPEN and CHKIN routines.
    1) Call this routine (using a JSR instruction).
    2) Store the data.

  EXAMPLE:

    JSR CHRIN
    STA DATA"
"[INST]In the context of the C64, What is the primary function of the program counter in a C64?[/INST]THE PROGRAM COUNTER

    This contains the address of the current machine language instruction
  being executed. Since the operating system is always 'RUN'ning in the
  Commodore 64 (or, for that matter, any computer), the program counter is
  always changing. It could only be stopped by halting the microprocessor
  in some way."
"[INST]In the context of the C64, Explain the sid envelop generator?[/INST]SID: THE ENVELOPE GENERATOR

    The volume of a musical tone changes from the moment you first hear it,
  all the way through until it dies out and you can't hear it anymore. When
  a note is first struck, it rises from zero volume to its peak volume. The
  rate at which this happens is called the ATTACK. Then, it fails from the
  peak to some middle-ranged volume. The rate at which the fall of the note
  occurs is called the DECAY. The mid-ranged volume itself is called the
  SUSTAIN level. And finally, when the note stops playing, it fails from
  the SUSTAIN level to zero volume. The rate at which it fails is called
  the RELEASE. 


    Each of the items mentioned above give certain qualities and restric-
  tions to a note. The bounds are called parameters.
    The parameters ATTACK/DECAY/SUSTAIN/RELEASE and collectively called
  ADSR, can be controlled by your use of another set of locations in the
  sound generator chip. LOAD your first example program again. RUN it again
  and remember how it sounds."
"[INST]In the context of the C64, What is the purpose of the SEC instruction in the 6502 microprocessor?[/INST]SEC                        SEC Set carry flag                         SEC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   SEC                 |    38   |    1    |    2     |"
"[INST]In the context of the C64, What is the purpose of the LDX 6502 instruction ?[/INST]LDX                   LDX Load index X with memory                    LDX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   LDX #Oper           |    A2   |    2    |    2     |
  |  Zero Page     |   LDX Oper            |    A6   |    2    |    3     |
  |  Zero Page,Y   |   LDX Oper,Y          |    B6   |    2    |    4     |
  |  Absolute      |   LDX Oper            |    AE   |    3    |    4     |
  |  Absolute,Y    |   LDX Oper,Y          |    BE   |    3    |    4*    |
  * Add 1 when page boundary is crossed."
"[INST]In the context of the C64, What is the purpose of the STOP kernal function ?[/INST]Function Name: STOP

    Purpose: Check if <STOP> key is pressed
    Call address: $FFE1 (hex) 65505 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: None
    Stack requirements: None
    Registers affected: A, X

    Description: If the <STOP> key on the keyboard was pressed during a
  UDTIM call, this call returns the Z flag set. In addition, the channels
  will be reset to default values. All other flags remain unchanged. If the
  <STOP> key is not pressed then the accumulator will contain a byte
  representing the lost row of the keyboard scan. The user can also check
  for certain other keys this way.

  How to Use:
    0) UDTIM should be called before this routine.
    1) Call this routine.
    2) Test for the zero flag.

  EXAMPLE:

    JSR UDTIM   ;SCAN FOR STOP
    JSR STOP
    BNE *+5     ;KEY NOT DOWN
    JMP READY   ;=... STOP"
"[INST]In the context of the C64, How do I open an RS-232 communication?[/INST]OPENING AN RS-232 CHANNEL

    Only one RS-232 channel should be open at any time; a second OPEN
  statement will cause the buffer pointers to be reset. Any characters in
  either the transmit buffer or the receive buffer will be lost.
    Up to 4 characters can be sent in the filename field. The first two are
  the control and command register characters; the other two are reserved
  for future system options. Baud rate, parity, and other options can be
  selected through this feature.
    No error-checking is done on the control word to detect a non-
  implemented baud rate. Any illegal control word will cause the system
  output to operate at a very slow rate (below 50 baud).

  BASIC SYNTAX:

    OPEN lfn,2,0,'<control register><command register><opt baud low><opt
  baud high>'
    lfn-The logical file number (lfn) then can be any number from 1 through
  255. But be aware of the fact that if you choose a logical file number
  that is greater than 127, then a line feed will follow all carriage
  returns.
               
    <control register>- Is a single byte character (see Figure 6-1, Control
  Register Map) required to specify the baud rates. If the lower 4 bits of
  the baud rate is equal to zero (0), the <opt baud low><opt baud high>
  characters give you a rate based on the following:
    <opt baud low>=<system frequency/rate/2-100-<opt baud high>*256
    <opt baud high>=INT((system frequency/rate/2-100)/256

 
                    
  The formulas above are based on the fact that:

    system frequency = 1.02273E6 NTSC (North American TV standard)
                     = 0.98525E6 PAL (U.K. and most European TV standard)

    <command register>- Is a single byte character (see Figure 6-2, Command
  Register Map) that defines other terminal parameters. This character is
  NOT required.

  KERNAL ENTRY:

    OPEN ($FFC0) (See KERNAL specifications for more information on entry
  conditions and instructions.)


IMPORTANT NOTE: In a BASIC program, the RS-232 OPEN command should be
  | performed before creating any variables or arrays because an automatic|
  | CLR is performed when an RS-232 channel is OPENed (This is due to the |
  | allocation of 512 bytes at the top of memory.) Also remember that your|
  | program will be destroyed if 512 bytes of space are not available at  |
  | the time of the OPEN statement.                                       |"
"[INST]In the context of the C64, What are the common methods to add machine language programs to a BASIC program?[/INST]HOW TO ENTER MACHINE LANGUAGE

    There are 3 common methods to add the machine language programs to a
  BASIC program. They are:

  1-DATA STATEMENTS:

    By READing DATA statements, and POKEing the values into memory at the
  start of the program, machine language routines can be added. This is the
  easiest method. No special methods are needed to save the two parts of
  the program, and it is fairly easy to debug. The drawbacks include taking
  up more memory space, and the wait while the program is POKED in.
  Therefore, this method is better for smaller routines.

  EXAMPLE:

  10 RESTORE:FORX=1T09:READA:POKE12*4096+X,A:NEXT
  .
  BASIC PROGRAM
  .
  1000 DATA 161,1,204,204,204,204,204,204,96"
"[INST]In the context of the C64, How can I handle the paddles?[/INST]PADDLES

    A paddle is connected to both CIA #1 and the SID chip (MOS 6581 Sound
  Interface Device) through a game port. The paddle value is read via the
  SID registers 54297 ($D419) and 54298 ($D41A). PADDLES ARE NOT RELIABLE
  WHEN READ FROM BASIC ALONE!!!! The best way to use paddles, from BASIC or
  machine code, is to use the following machine language routine... (SYS to
  it from BASIC then PEEK the memory locations used by the subroutine).


                      ; four paddle read routine (can also be used for two)
                      ;
                      ; author - bill hindorff
                      ;
porta=$dc00
ciddra=$dc02
sid=$d400

*=$c100

buffer  *=*+1
pdlx    *=*+2
pdly    *=*+2
btna    *=*+1
btnb    *=*+1

* = $c000

pdlrd   ldx #1        ; for four paddles or two analog joysticks
pdlrd0                ; entry point for one pair (condition x 1st)
        sei
        lda ciddra    ; get current value of ddr
        sta buffer    ; save it away
        lda #$c0
        sta ciddra    ; set port a for input
        lda #$80
pdlrd1
        sta porta     ; address a pair of paddles
        ldy #$80      ; wait a while
pdlrd2
        nop
        dey
        bpl pdlrd2
        lda sid+25    ; get x value
        sta pdlx,x
        lda sid+26
        sta pdly,x    ; get y value
        lda porta     ; time to read paddle fire buttons
        ora #80       ; make it the same as other pair
        sta btna      ; bit 2 is pdl x, bit 3 is pdl y
        lda #$40
        dex           ; all pairs done?
        bpl pdlrd1    ; no
        lda buffer
        sta ciddra    ; restore previous value of ddr
        lda porta+1   ; for 2nd pair -
        sta btnb      ; bit 2 is pdl x, bit 3 is pdl y
        cli
        rts
.end"
"[INST]In the context of the C64, WHow can I output to a Commodore printer?[/INST]OUTPUT TO PRINTER

    The printer is an output device similar to the screen. Your main con-
  cern when sending output to the printer is to create a format that is
  easy on the eyes. Your tools here include reversed, double-width, capital
  and lower case letters, as well as dot-programmable graphics.
    The SPC function works for the printer in the same way it works for the
  screen. However, the TAB function does not work correctly on the printer,
  because it calculates the current position on the line based on the
  cursor's position on the screen, not on the paper.
    The OPEN statement for the printer creates the channel for communi-
  cation. It also specifies which character set will be used, either upper
  case with graphics or upper and lower case.

  EXAMPLES of OPEN Statement for Printer:

    OPEN 1,4: REM UPPER CASE/GRAPHICS
    OPEN 1,4,7: REM UPPER AND LOWER CASE

    When working with one character set, individual lines can be PRINTed
  in the opposite character set. When in upper case with graphics, the
  cursor down character (CHR$(17)) switches the characters to the upper
  and lower case set. When in upper and lower case, the cursor up char-
  acter (CHR$(145)) allows upper case and graphics characters to be
  PRINTed.
    Other special functions in the printer are controlled through character
  codes. All these codes are simply PRINTed just like any other character.

  TABLE of Printer Control Character Codes:

  | CHR$ CODE|                         PURPOSE                            |
  |    10    |   Line feed                                                |
  |    13    |   RETURN (automatic line feed on CBM printers)             |
  |    14    |   Begin double-width character mode                        |
  |    15    |   End double-width character mode                          |
  |    18    |   Begin reverse character mode                             |
  |   146    |   End reverse character mode                               |
  |    17    |   Switch to upper/lower case character set                 |
  |   145    |   Switch to upper case/graphics character set              |
  |    16    |   Tab to position in next 2 characters                     |
  |    27    |   Move to specified dot position                           |
  |     8    |   Begin dot-programmable graphic mode                      |
  |    26    |   Repeat graphics data                                     |
    See your Commodore printer's manual for details on using the command
  codes."
"[INST]In the context of the C64, What is the register A on 6502 and 6510?[/INST]THE REGISTERS INSIDE THE 6510 MICROPROCESSOR

  THE ACCUMULATOR

    This is THE most important register in the microprocessor. Various ma-
  chine language instructions allow you to copy the contents of a memory
  location into the accumulator, copy the contents of the accumulator into
  a memory location, modify the contents of the accumulator or some other
  register directly, without affecting any memory. And the accumulator is
  the only register that has instructions for performing math."
"[INST]In the context of the C64, What are the details for the ORA 6502 instruction?[/INST]ORA                 ORA 'OR' memory with accumulator                  ORA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   ORA #Oper           |    09   |    2    |    2     |
  |  Zero Page     |   ORA Oper            |    05   |    2    |    3     |
  |  Zero Page,X   |   ORA Oper,X          |    15   |    2    |    4     |
  |  Absolute      |   ORA Oper            |    0D   |    3    |    4     |
  |  Absolute,X    |   ORA Oper,X          |    10   |    3    |    4*    |
  |  Absolute,Y    |   ORA Oper,Y          |    19   |    3    |    4*    |
  |  (Indirect,X)  |   ORA (Oper,X)        |    01   |    2    |    6     |
  |  (Indirect),Y  |   ORA (Oper),Y        |    11   |    2    |    5     |
  * Add 1 on page crossing"
"[INST]In the context of the C64, What is the purpose of the ROR instruction in 6502?[/INST]ROR          ROR Rotate one bit right (memory or accumulator)         ROR

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Accumulator   |   ROR A               |    6A   |    1    |    2     |
  |  Zero Page     |   ROR Oper            |    66   |    2    |    5     |
  |  Zero Page,X   |   ROR Oper,X          |    76   |    2    |    6     |
  |  Absolute      |   ROR Oper            |    6E   |    3    |    6     |
  |  Absolute,X    |   ROR Oper,X          |    7E   |    3    |    7     |
    Note: ROR instruction is available on MCS650X microprocessors after
          June, 1976."
"[INST]In the context of the C64, What are the acceptable ranges for the X and Y coordinates for unexpanded sprites in the 40 column, 25 row mode?[/INST]SPRITE POSITIONING SUMMARY

    Unexpanded sprites are at least partially visible in the 40 column, by
  25 row mode within the following parameters:

1 < X < 343
30 < Y < 249

  In the 38 column mode, the X parameters change to she following:

 8 <= X <= 334

  In the 24 row mode, the Y parameters change to the following:

 34 <= Y <= 245

Expanded sprites are at least partially visible in the 40 column, by 25
  row mode within the following parameters:
  489 >= X <= 343
  9 >= Y <= 249

In the 38 column mode, the X parameters change to the following:
496 >= X <= 334

In the 24 row mode, the Y parameters change to the following:
13 <= Y <= 245"
"[INST]In the context of the C64, What are the three program modules that make up the Operating System?[/INST]THE OPERATING SYSTEM (OS)
    The Operating System is contained in the Read Only Memory (ROM) chips
  and is a combination of three separate, but interrelated, program
  modules.

    1) The BASIC Interpreter
    2) The KERNAL
    3) The Screen Editor

    1) The BASIC Interpreter is responsible for analysing BASIC statement
       syntax and for performing the required calculations and/or data
       manipulation. The BASIC Interpreter has a vocabulary of 65
       'keywords' which have special meanings. The upper and lower case
       alphabet and the digits 0-9 are used to make both keywords and
       variable names. Certain punctuation characters and special symbols
       also have meanings for the Interpreter. Table 1-1 lists the special
       characters and their uses.
    2) The KERNAL handles most of the interrupt level processing in the
       system (for details on interrupt level processing, see Chapter 5).
       The KERNAL also does the actual input and output of data.
    3) The Screen Editor controls the output to the video screen (tele-
       vision set) and the editing of BASIC program text. In addition, the
       Screen Editor intercepts keyboard input so that it can decide
       whether the characters put in should be acted upon immediately, or
       passed on to the BASIC Interpreter."
"[INST]In the context of the C64, how do I control the screen blanking?[/INST]SCREEN BLANKING

    Bit 4 of the VIC-II control register controls the screen blanking func-
  tion. It is found in the control register at location 53265 ($D011). When
  it is turned ON (in other words, set to a 1) the screen is normal. When
  bit 4 is set to 0 (turned OFF), the entire screen changes to border
  color.
    The following POKE blanks the screen. No data is lost, it just isn't
  displayed.

    POKE 53265,PEEK(53265)AND 239

  To bring back the screen. use the POKE shown below:

    POKE 53265,PEEK(53265)OR 16

  NOTE: Turning off the screen will speed up the processor slightly.
  This means that program RUNning is also sped up."
"[INST]In the context of the C64, What is the purpose of the CLALL function?[/INST]B-8. Function Name: CLALL

    Purpose: Close all files
    Call address: $FFE7 (hex) 65511 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: None
    Stack requirements: 11
    Registers affected: A, X

    Description: This routine closes all open files. When this routine is
  called, the pointers into the open file table are reset, closing all
  files. Also, the CLRCHN routine is automatically called to reset the I/O
  channels.

  How to Use:

    1) Call this routine.

  EXAMPLE:

    JSR CLALL   ;CLOSE ALL FILES AND SELECT DEFAULT I/O CHANNELS
    JMP RUN     ;BEGIN EXECUTION"
"[INST]In the context of the C64, What is the purpose of the LISTEN function in a serial bus communication system?[/INST]B-14. Function Name: LISTEN

    Purpose: Command a device on the serial bus to listen
    Call Address: $FFB1 (hex) 65457 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: None
    Registers affected: A

    Description: This routine will command a device on the serial bus to
  receive data. The accumulator must be loaded with a device number between
  0 and 31 before calling the routine. LISTEN will OR the number bit by bit
  to convert to a listen address, then transmits this data as a command on
  the serial bus. The specified device will then go into listen mode, and
  be ready to accept information.

  How to Use:
    1) Load the accumulator with the number of the device to command
       to LISTEN.
    2) Call this routine using the JSR instruction.

  EXAMPLE:
    ;COMMAND DEVICE #8 TO LISTEN
    LDA #8
    JSR LISTEN"
"[INST]In the context of the C64, What is the purpose of the LOAD routine in the Commodore 64 KERNAL?[/INST]B-15. Function Name: LOAD

    Purpose: Load RAM from device
    Call address: $FFD5 (hex) 65493 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: SETLFS, SETNAM
    Error returns: 0,4,5,8,9, READST
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine LOADs data bytes from any input device di-
  rectly into the memory of the Commodore 64. It can also be used for a
  verify operation, comparing data from a device with the data already in
  memory, while leaving the data stored in RAM unchanged.
    The accumulator (.A) must be set to 0 for a LOAD operation, or 1 for a
  verify, If the input device is OPENed with a secondary address (SA) of 0
  the header information from the device is ignored. In this case, the X
  and Y registers must contain the starting address for the load. If the
  device is addressed with a secondary address of 1, then the data is
  loaded into memory starting at the location specified by the header. This
  routine returns the address of the highest RAM location loaded.
    Before this routine can be called, the KERNAL SETLFS, and SETNAM
  routines must be called.


NOTE: You can NOT LOAD from the keyboard (0), RS-232 (2), or the screen (3).

  How to Use:

    0) Call the SETLFS, and SETNAM routines. If a relocated load is de-
       sired, use the SETLFS routine to send a secondary address of 0.
    1) Set the A register to 0 for load, 1 for verify.
    2) If a relocated load is desired, the X and Y registers must be set
       to the start address for the load.
    3) Call the routine using the JSR instruction."
"[INST]In the context of the C64, What is the purpose of the CLOSE kernal function?[/INST]B-9. Function Name: CLOSE

    Purpose: Close a logical file
    Call address: $FFC3 (hex) 65475 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: 0,240 (See READST)
    Stack requirements: 2+
    Registers affected: A, X, Y

    Description: This routine is used to close a logical file after all I/O
  operations have been completed on that file. This routine is called after
  the accumulator is loaded with the logical file number to be closed (the
  same number used when the file was opened using the OPEN routine).

 How to Use:

    1) Load the accumulator with the number of the logical file to be
       closed.
    2) Call this routine.

  EXAMPLE:

    ;CLOSE 15
    LDA #15
    JSR CLOSE"
"[INST]In the context of the C64, What is the purpose of the raster register in the VIC-II chip?[/INST]RASTER REGISTER

    The raster register is found in the VIC-II chip at location 53266
  ($D012). The raster register is a dual purpose register. When you read
  this register it returns the lower 8 bits of the current raster position.
  The raster position of the most significant bit is in register location
  53265 ($D011). You use the raster register to set up timing changes in
  your display so that you can get rid of screen flicker. The changes on
  your screen should be mode when the raster is not in the visible display
  area, which is when your dot positions fall between 51 and 251.
    When the raster register is written to (including the MSB) the number
  written to is saved for use with the raster compare function. When the
  actual raster value becomes the same as the number written to the raster
  register, a bit in the VIC-II chip interrupt register 53273 ($D019) is
  turned ON by setting it to 1.

   NOTE: If the proper interrupt bit is enabled (turned on), an interrupt
   (IRQ) will occur."
"[INST]In the context of the C64, What determines the order in which sprites appear in a scene?[/INST]SPRITE DISPLAY PRIORITIES

    Sprites have the ability to cross each other's paths, as well as cross
  in front of, or behind other objects on the screen. This can give you a
  truly three dimensional effect for games.
    Sprite to sprite priority is fixed. That means that sprite 0 has the
  highest priority, sprite 1 has the next priority, and so on, until we get
  to sprite 7, which has the lowest priority. In other words, if sprite 1
  and sprite 6 are positioned so that they cross each other, sprite 1 will
  be in front of sprite 6.
    So when you're planning which sprites will appear to be in the fore-
  ground of the picture, they must be assigned lower sprite numbers than
  those sprites you want to put towards the back of the scene. Those
  sprites will be given higher sprite numbers,

NOTE: A 'window' effect is possible. If a sprite with higher priority 
has 'holes' in it (areas where the dots are not set to 1 and thus     
turned ON), the sprite with the lower priority will show through. This
also happens with sprite and background data."
"[INST]In the context of the C64, What is the purpose of the ROL instruction in 6502 assembly language?[/INST]ROL          ROL Rotate one bit left (memory or accumulator)          ROL

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Accumulator   |   ROL A               |    2A   |    1    |    2     |
  |  Zero Page     |   ROL Oper            |    26   |    2    |    5     |
  |  Zero Page,X   |   ROL Oper,X          |    36   |    2    |    6     |
  |  Absolute      |   ROL Oper            |    2E   |    3    |    6     |
  |  Absolute,X    |   ROL Oper,X          |    3E   |    3    |    7     |"
"[INST]In the context of the C64, What is the instruction that performs no operation and has an opcode?[/INST]NOP                         NOP No operation                          NOP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   NOP                 |    EA   |    1    |    2     |"
"[INST]In the context of the C64, Give a rapide overview of the memory map of the Commodore 64?[/INST]SIMPLE MEMORY MAP OF THE COMMODORE 64


  ADDRESS                       DESCRIPTION                       
                                                                   
   0 & 1   -6510 Registers.                                                                                                    
    2      -Start of memory.                                       
    2-1023 -Memory used by the operating system.                   
 1024-2039 -Screen memory.                                         
 2040-2047 -SPRITE pointers.                                       
 2048-40959-This is YOUR memory. This is where your BASIC or machine language programs, or both, are stored.        
40960-49151-8K CBM BASIC Interpreter.                              
49152-53247-Special programs RAM area.                             
53248-53294-VIC-II.                                                
54272-55295-SID Registers.                                         
55296-56296-Color RAM.                                             
56320-57343-I/O Registers. (6526's)                                                                                                   
57344-65535-8K CBM KERNAL Operating System."
"[INST]In the context of the C64, What information about the SID chip's parameters can be changed dynamically during a note or sound to create many interesting and fun effects?[/INST]SOUND  ADVANCED TECHNIQUES

    The SID chip's parameters can be changed dynamically during a note or
  sound to create many interesting and fun effects. In order to make this
  easy to do, digitized outputs from oscillator three and envelope
  generator three are available for you in registers 27 and 28, respec-
  tively.
    The output of oscillator 3 (register 27) is directly related to the
  waveform selected. If you choose the sawtooth waveform of oscillator 3,
  this register will present a series of numbers incremented (increased
  step by step) from 0 to 255 at a rate determined by the frequency of
  oscillator 3. If you choose the triangle waveform, the output will incre-
  ment from 0 up to 255, then decrement (decrease step by step) back down
  to 0. If you choose the pulse wave, the output will jump back-and-forth
  between 0 and 255. Finally, choosing the noise waveform will give you a
  series of random numbers. When oscillator 3 is used for modulation, you
  usually do NOT want to hear its output. Setting bit 7 of register 24
  turns the audio output of voice 3 off. Register 27 always reflects the
  changing output of the oscillator and is not affected in any way by the
  envelope (ADSR) generator.
    Register 25 gives you access to the output of the envelope generator
  of oscillator 3. It functions in much the same fashion that the output of
  oscillator 3 does. The oscillator must be turned on to produce any output
  from this register.
    Vibrato (a rapid variation in frequency) can be achieved by adding the
  output of oscillator 3 to the frequency of another oscillator. Example
  Program 6 illustrates this idea."
"[INST]In the context of the C64, What is the format of the OPEN statement parameters?[/INST]TABLE of OPEN Statement Parameters:

    FORMAT: OPEN file#, device#, number, string


  | DEVICE | DEVICE# |       NUMBER        |            STRING            |
  |CASSETTE|    1    | 0 = Input           | File Name                    |
  |        |         | 1 = Output          |                              |
  |        |         | 2 = Output with EOT |                              |
  | MODEM  |    2    | 0                   | Control Registers            |
  | SCREEN |    3    | 0,1                 |                              |
  | PRINTER|  4 or 5 | 0 = Upper/Graphics  | Text Is PRINTed              |
  |        |         | 7 = Upper/Lower Case|                              |
  | DISK   | 8 to 11 | 2-14 = Data Channel | Drive #, File Name           |
  |        |         |                     | File Type, Read/Write        |
  |        |         | 15 = Command        | Command                      |
  |        |         |      Channel        |                              |"
"[INST]In the context of the C64, How can I read the value of the joystick?[/INST]A small machine code routine to read the joystick:


                      ; joystick - button read routine
                      ;
                      ; author - bill hindorff
                      ;
dx = $c110
dy = $c111

* = $c200

djrr    lda $dc00     ; get input from port a only
djrrb   ldy #0        ; this routine reads and decodes the
        ldx #0        ; joystick/firebutton input data in
        lsr a         ; the accumulator. this least significant
        bcs djr0      ; 5 bits contain the switch closure
        dey           ; information. if a switch is closed then it
djr0    lsr a         ; produces a zero bit. if a switch is open then
        bcs djr1      ; it produces a one bit. The joystick dir-
        iny           ; ections are right, left, forward, backward
djr1    lsr a         ; bit3=right, bit2=left, bit1=backward,
        bcs djr2      ; bit0=forward and bit4=fire button.
        dex           ; at rts time dx and dy contain 2's compliment
djr2    lsr a         ; direction numbers i.e. $ff=-1, $00=0, $01=1.
        bcs djr3      ; dx=1 (move right), dx=-1 (move left),
        inx           ; dx=0 (no x change). dy=-1 (move up screen),
djr3    lsr a         ; dy=0 (move down screen), dy=0 (no y change).
        stx dx        ; the forward joystick position corresponds
        sty dy        ; to move up the screen and the backward
        rts           ; position to move down screen.
                      ;
                      ; at rts time the carry flag contains the fire
                      ; button state. if c=1 then button not pressed.
                      ; if c=0 then pressed.
.end"
"[INST]In the context of the C64, What is the recommended location for machine language routines on the Commodore 64?[/INST]WHERE TO PUT MACHINE LANGUAGE ROUTINES

    The best place for machine language routines on the Commodore 64 is
  from $C000-$CFFF, assuming the routines are smaller than 4K bytes long.
  This section of memory is not disturbed by BASIC.
    If for some reason it's not possible or desirable to put the machine
  language routine at $C000, for instance if the routine is larger than 4K
  bytes, it then becomes necessary to reserve an area at the top of memory
  from BASIC for the routine. The top of memory is normally $9FFF. The top
  of memory can be changed through the KERNAL routine MEMTOP, or by the
  following BASIC statements:

    10 POKE51,L:POKE52,H:POKE55,1:POKE56,H:CLR

  Where H and L are the high and low portions, respectively, of the new
  top of memory. For example, to reserve the area from $9000 to $9FFF for
  machine language, use the following:

    10 POKE5110:POKE52,144:POKE5510:POKE56,144:CLR"
"[INST]In the context of the C64, how can I send data to a modem?[/INST]OUTPUT TO MODEM

    The modem is a simple device that can translate character codes into
  audio pulses and vice-versa, so that computers can communicate over
  telephone lines. The OPEN statement for the modem sets up the parameters
  to match the speed and format of the other computer you are communicating
  with. Two characters can be sent in the string at the end
  of the OPEN statement.
    The bit positions of the first character code determine the baud rate,
  number of data bits, and number of stop bits. The second code is op-
  tional, and its bits specify the parity and duplex of the transmission.
  See the RS-232 section or your VICMODEM manual for specific details on
  this device.

  EXAMPLE of OPEN Statement for Modem:

    OPEN 1,2,0,CHR$(6): REM 300 BAUD
    100 OPEN 2,2,0,CHR$(163) CHR$(112): REM 110 BAUD, ETC.

    Most computers use the American Standard Code for Information In-
  terchange, known as ASCII (pronounced ASK-KEY). This standard set of
  character codes is somewhat different from the codes used in the Com-
  modore 64. When communicating with other computers, the Commodore
  character codes must be translated into their ASCII counterparts. A table
  of standard ASCII codes is included in this book in Appendix C.
    Output to the modem is a fairly uncomplicated task, aside from the need
  for character translation. However, you must know the receiving device
  fairly well, especially when writing programs where your computer 'talks'
  to another computer without human intervention. An example of this would
  be a terminal program that automatically types in your account number and
  secret password. To do this successfully, you must carefully count the
  number of characters and RETURN characters. Otherwise, the computer
  receiving the characters won't know what to do with them."
"[INST]In the context of the C64, What is the primary purpose of the X index register in a C64?[/INST]THE X INDEX REGISTER

    This is a very important register. There are instructions for nearly
  all of the transformations you can make to the accumulator. But there are
  other instructions for things that only the X register can do. Various
  machine language instructions allow you to copy the contents of a memory
  location into the X register, copy the contents of the X register into a
  memory location, and modify the contents of the X, or some other register
  directly."
"[INST]In the context of the C64, What is the purpose of the CHKIN routine in the KERNAL?[/INST]B-2. Function Name: CHKIN

    Purpose: Open a channel for input
    Call address: $FFC6 (hex) 65478 (decimal)
    Communication registers: X
    Preparatory routines: (OPEN)
    Error returns:
    Stack requirements: None
    Registers affected: A, X


    Description: Any logical file that has already been opened by the
  KERNAL OPEN routine can be defined as an input channel by this routine.
  Naturally, the device on the channel must be an input device. Otherwise
  an error will occur, and the routine will abort.
    If you are getting data from anywhere other than the keyboard, this
  routine must be called before using either the CHRIN or the GETIN KERNAL
  routines for data input. If you want to use the input from the keyboard,
  and no other input channels are opened, then the calls to this routine,
  and to the OPEN routine are not needed.
    When this routine is used with a device on the serial bus, it auto-
  matically sends the talk address (and the secondary address if one was
  specified by the OPEN routine) over the bus.

  How to Use:

    0) OPEN the logical file (if necessary; see description above).
    1) Load the X register with number of the logical file to be used.
    2) Call this routine (using a JSR command).


  Possible errors are:

    #3: File not open
    #5: Device not present
    #6: File not an input file

  EXAMPLE:

    ;PREPARE FOR INPUT FROM LOGICAL FILE 2
    LDX #2
    JSR CHKIN"
"[INST]In the context of the C64, What is the native language of the Commodore 64?[/INST]WHAT IS MACHINE LANGUAGE?

    At the heart of every microcomputer, is a central microprocessor. It's
  a very special microchip which is the 'brain' of the computer. The
  Commodore 64 is no exception. Every microprocessor understands its own
  language of instructions. These instructions are called machine language
  instructions. To put it more precisely, machine language is the ONLY
  programming language that your Commodore 64 understands. It is the NATIVE
  language of the machine.
    If machine language is the only language that the Commodore 64
  understands, then how does it understand the CBM BASIC programming
  language? CBM BASIC is NOT the machine language of the Commodore 64.
  What, then, makes the Commodore 64 understand CBM BASIC instructions like
  PRINT and GOTO?
    To answer this question, you must first see what happens inside your
  Commodore 64. Apart from the microprocessor which is the brain of the
  Commodore 64, there is a machine language program which is stored in a
  special type of memory so that it can't be changed. And, more impor-
  tantly, it does not disappear when the Commodore 64 is turned off, unlike
  a program that you may have written. This machine language program is
  called the OPERATING SYSTEM of the Commodore 64. Your Commodore 64 knows
  what to do when it's turned on because its OPERATING SYSTEM (program) is
  automatically 'RUN.'"
"[INST]In the context of the C64, What is the instruction that pulls the accumulator from the stack in 6502?[/INST]PLA                 PLA Pull accumulator from stack                   PLA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PLA                 |    68   |    1    |    4     |"
"[INST]In the context of the C64, What are the details fot the LDY instruction in the 6502 assembly language?[/INST]LDY                   LDY Load index Y with memory                    LDY
                                                        N Z C I D V
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   LDY #Oper           |    A0   |    2    |    2     |
  |  Zero Page     |   LDY Oper            |    A4   |    2    |    3     |
  |  Zero Page,X   |   LDY Oper,X          |    B4   |    2    |    4     |
  |  Absolute      |   LDY Oper            |    AC   |    3    |    4     |
  |  Absolute,X    |   LDY Oper,X          |    BC   |    3    |    4*    |
  * Add 1 when page boundary is crossed."
"[INST]In the context of the C64, What is stored in the VIC-II chip control register at location $D01F in HEX that indicates sprite to data collisions?[/INST]SPRITE TO DATA COLLISIONS

    Sprite to data collisions are detected in the sprite to data collision
  register at location 53279 ($D01F in HEX) of the VIC-II chip control
  register.
    Each sprite has a bit in this register. If that bit is a 1 , then that
  sprite is involved in a collision. The bits in this register remain set
  until read (PEEKed). Once read, the register is automatically cleared, so
  it is a good idea to save the value in a variable until you are finished
  with it.

   NOTE: MULTI-COLOR data 01 is considered transparent for collisions,   
   even though it shows up on the screen. When setting up a background   
   screen, it is a good idea to make everything that should not cause a  
   collision 01 in multi-color mode."
"[INST]In the context of the C64, What are the two character sets available on the Commodore 64, and how can you switch between them?[/INST]The Commodore 64 has two complete character sets that you can use
  either from the keyboard or in your programs.
    In SET 1, the upper case alphabet and the numbers 0-9 are available
  without pressing the <SHIFT> key. If you hold down the <SHIFT> key
  while typing, the graphics characters on the RIGHT side of the front of
  the keys are used. If you hold down the <C=> key while typing, the
  graphics characters on the LEFT side of the front of the key are used.
  Holding down the <SHIFT> key while typing any character that doesn't
  have graphic symbols on the front of the key gives you the symbol on the
  top most part of the key.
    In SET 2, the lower case alphabet and the numbers 0-9 are available
  without pressing the <SHIFT> key. The upper case alphabet is available
  when you hold down the <SHIFT> key while typing. Again, the graphic
  symbols on the LEFT side of the front of the keys are displayed by press-
  ing the <C=> key, while the symbols on the top most part of any key
  without graphics characters are selected when you hold down the <SHIFT>
  key while typing.
    To switch from one character set to the other press the <C=> and
  the <SHIFT> keys together."
"[INST]In the context of the C64, What is the purpose and functionality of the MEMTOP routine in kernal?[/INST]B-17. Function Name: MEMTOP

    Purpose: Set the top of RAM
    Call address: $FF99 (hex) 65433 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: X, Y

    Description: This routine is used to set the top of RAM. When this
  routine is called with the carry bit of the accumulator set, the pointer
  to the top of RAM will be loaded into the X and Y registers. When this
  routine is called with the accumulator carry bit clear, the contents of
  the X and Y registers are loaded in the top of memory pointer, changing
  the top of memory.

  EXAMPLE:
    ;DEALLOCATE THE RS-232 BUFFER
    SEC
    JSR MEMTOP   ;READ TOP OF MEMORY
    DEX
    CLC
    JSR MEMTOP   ;SET NEW TOP OF MEMORY"
"[INST]In the context of the C64, what is the purpose of the GETIN subroutine in kernal?[/INST]B-11. Function Name: GETIN


    Purpose: Get a character
    Call address: $FFE4 (hex) 65508 (decimal)
    Communication registers: A
    Preparatory routines: CHKIN, OPEN
    Error returns: See READST
    Stack requirements: 7+
    Registers affected: A (X, Y)

    Description: If the channel is the keyboard, this subroutine removes
  one character from the keyboard queue and returns it as an ASCII value in
  the accumulator. If the queue is empty, the value returned in the
  accumulator will be zero. Characters are put into the queue automatically
  by an interrupt driven keyboard scan routine which calls the SCNKEY
  routine. The keyboard buffer can hold up to ten characters. After the
  buffer is filled, additional characters are ignored until at least one
  character has been removed from the queue. If the channel is RS-232, then
  only the A register is used and a single character is returned. See
  READST to check validity. If the channel is serial, cassette, or screen,
  call BASIN routine.


  How to Use:

    1) Call this routine using a JSR instruction.
    2) Check for a zero in the accumulator (empty buffer).
    3) Process the data.


  EXAMPLE:

         ;WAIT FOR A CHARACTER
    WAIT JSR GETIN
         CMP #0
         BEQ WAIT"
"[INST]In the context of the C64, What is the purpose of the CLRCHN kernal routine?[/INST]B-10. Function Name: CLRCHN

    Purpose: Clear I/O channels
    Call address: $FFCC (hex) 65484 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns:
    Stack requirements: 9
    Registers affected: A, X

    Description: This routine is called to clear all open channels and re-
  store the I/O channels to their original default values. It is usually
  called after opening other I/O channels (like a tape or disk drive) and
  using them for input/output operations. The default input device is 0
  (keyboard). The default output device is 3 (the Commodore 64 screen).
    If one of the channels to be closed is to the serial port, an UNTALK
  signal is sent first to clear the input channel or an UNLISTEN is sent to
  clear the output channel. By not calling this routine (and leaving lis-
  tener(s) active on the serial bus) several devices can receive the same
  data from the Commodore 64 at the same time. One way to take advantage
  of this would be to command the printer to TALK and the disk to LISTEN.
  This would allow direct printing of a disk file.
    This routine is automatically called when the KERNAL CLALL routine is
  executed.

  How to Use:
    1) Call this routine using the JSR instruction.

  EXAMPLE:
    JSR CLRCHN"
"[INST]In the context of the C64, What is the purpose of the MEMBOT routine?[/INST]B-16. Function Name: MEMBOT

    Purpose: Set bottom of memory
    Call address: $FF9C (hex) 65436 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: None
    Registers affected: X, Y

    Description: This routine is used to set the bottom of the memory. If
  the accumulator carry bit is set when this routine is called, a pointer
  to the lowest byte of RAM is returned in the X and Y registers. On the
  unexpanded Commodore 64 the initial value of this pointer is $0800
  (2048 in decimal). If the accumulator carry bit is clear (-O) when this
  routine is called, the values of the X and Y registers are transferred to
  the low and high bytes, respectively, of the pointer to the beginning of
  RAM.

  How to Use:
  TO READ THE BOTTOM OF RAM
    1) Set the carry.
    2) Call this routine.

  TO SET THE BOTTOM OF MEMORY
    1) Clear the carry.
    2) Call this routine.

  EXAMPLE:

    ;MOVE BOTTOM OF MEMORY UP 1 PAGE
    SEC         ;READ MEMORY BOTTOM
    JSR MEMBOT
    INY
    CLC         ;SET MEMORY BOTTOM TO NEW VALUE
    JSR MEMBOT"
"[INST]In the context of the C64, What are the key considerations and limitations when positioning sprites horizontally in a graphics system?[/INST]HORIZONTAL POSITIONING

    Positioning in the horizontal direction is more complicated because
  there are more than, 256 positions. This means that an extra bit, or 9th
  bit is used to control the X position. By adding the extra bit when
  necessary a sprite now has 512 possible positions in the left/right, X,
  direction. This makes more possible combinations than can be seen on the
  visible part of the screen. Each sprite can have a position from 0 to
  511. However, only those values between 24 and 343 are visible on the
  screen. If the X position of a sprite is greater than 255 (on the right
  side of the screen), the bit in the X MOST SIGNIFICANT BIT POSITION

  register must be set to a 1 (turned ON). If the X position of a sprite is
  less than 256 (on the left side of the screen), then the X MSB of that
  sprite must be 0 (turned OFF). Bits 0 to 7 of the X MSB register
  correspond to sprites 0 to 7, respectively."
"[INST]In the context of the C64, how sprite to sprite collision works?[/INST]SPRITE TO SPRITE COLLISIONS

    Sprite to sprite collisions are recognized by the computer, or flagged,
  in the sprite to sprite collision register at location 53278 ($D01E in
  HEX) in the VIC-II chip control register. Each sprite has a bit in this
  register. If that bit is a 1, then that sprite is involved in a
  collision. The bits in this register will remain set until read (PEEKed).
  Once read, the register is automatically cleared, so it is a good idea to
  save the value in a variable until you are finished with it.
  
   NOTE: Collisions can take place even when the sprites are off screen."
"[INST]In the context of the C64, What are the two modes of BASIC operation provided by the Operating System?[/INST]The Operating System gives you two modes of BASIC operation:
    1) DIRECT Mode
    2) PROGRAM Mode

    1) When you're using the DIRECT mode, BASIC statements don't have
       line numbers in front of the statement. They are executed whenever
       the <RETURN> key is pressed.
    2) The PROGRAM mode is the one you use for running programs.
       When using the PROGRAM mode, all of your BASIC statements must have
       line numbers in front of them. You can have more than one BASIC
       statement in a line of your program, but the number of statements is
       limited by the fact that you can only put 80 characters on a logical
       screen line. This means that if you are going to go over the 80
       character limit you have to put the entire BASIC statement that
       doesn't fit on a new line with a new line number.
         Always type NEW and hit <RETURN> before starting a new program."
"[INST]In the context of the C64, What is the purpose of the LSR instruction in 6502?[/INST]LSR          LSR Shift right one bit (memory or accumulator)          LSR

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Accumulator   |   LSR A               |    4A   |    1    |    2     |
  |  Zero Page     |   LSR Oper            |    46   |    2    |    5     |
  |  Zero Page,X   |   LSR Oper,X          |    56   |    2    |    6     |
  |  Absolute      |   LSR Oper            |    4E   |    3    |    6     |
  |  Absolute,X    |   LSR Oper,X          |    5E   |    3    |    7     |"
"[INST]In the context of the C64, What is the purpose of the instruction PLP"" in 6502?""[/INST]PLP               PLP Pull processor status from stack                PLA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PLP                 |    28   |    1    |    4     |"
"[INST]In the context of the C64, What is the purpose of the CHKOUT  kernal routine?[/INST]B-3. Function Name: CHKOUT

    Purpose: Open a channel for output
    Call address: $FFC9 (hex) 65481 (decimal)
    Communication registers: X
    Preparatory routines: (OPEN)
    Error returns: 0,3,5,7 (See READST)
    Stack requirements: 4+
    Registers affected: A, X

    Description: Any logical file number that has been created by the
  KERNAL routine OPEN can be defined as an output channel. Of course, the
  device you intend opening a channel to must be an output device.
  Otherwise an error will occur, and the routine will be aborted.
    This routine must be called before any data is sent to any output
  device unless you want to use the Commodore 64 screen as your output
  device. If screen output is desired, and there are no other output chan-
  nels already defined, then calls to this routine, and to the OPEN routine
  are not needed.
    When used to open a channel to a device on the serial bus, this routine
  will automatically send the LISTEN address specified by the OPEN routine
  (and a secondary address if there was one).

  How to Use:

REMEMBER: this routine is NOT NEEDED to send data to the screen.
    0) Use the KERNAL OPEN routine to specify a logical file number, a
       LISTEN address, and a secondary address (if needed).
    1) Load the X register with the logical file number used in the open
       statement.
    2) Call this routine (by using the JSR instruction).

  EXAMPLE:

    LDX #3        ;DEFINE LOGICAL FILE 3 AS AN OUTPUT CHANNEL
    JSR CHKOUT

    Possible errors are:
    #3: File not open
    #5: Device not present
    #7: Not an output file"
"[INST]In the context of the C64, What is the primary function of the OPERATING SYSTEM in a Commodore 64 computer?[/INST]The C64 OPERATING SYSTEM is in charge of 'organizing' all the memory in
  your machine for various tasks. It also looks at what characters you type
  on the keyboard and puts them onto the screen, plus a whole number of
  other functions. The OPERATING SYSTEM can be thought of as the
  'intelligence and personality' of the Commodore 64 (or any computer for
  that matter). So when you turn on your Commodore 64, the OPERATING SYSTEM
  takes control of your machine, and after it has done its housework, it
  then says:

    READY."
"[INST]In the context of the C64, What is the primary purpose of the Y index register in a C64?[/INST]THE Y INDEX REGISTER

    This is a very important register. There are instructions for nearly
  all of the transformations you can make to the accumulator, and the X
  register. But there are other instructions for things that only the Y
  register can do. Various machine language instructions allow you to copy
  the contents of a memory location into the Y register, copy the contents
  of the Y register into a memory location, and modify the contents of the
  Y, or some other register directly."
"[INST]In the context of the C64, describe how the ligth pen works[/INST]LIGHT PEN

    The light pen input latches the current screen position into a pair of
  registers (LPX, LPY) on a low-going edge. The X position register 19
  ($13) will contain the 8 MSB of the X position at the time of transition.
  Since the X position is defined by a 512-state counter (9 bits),
  resolution to 2 horizontal dots is provided. Similarly, the Y position is
  latched in its register 20 ($14), but here 8 bits provide single raster
  resolution within the visible display. The light pen latch may be
  triggered only once per frame, and subsequent triggers within the same
  frame will have no effect. Therefore, you must take several samples
  before turning the pen to the screen (3 or more samples average),
  depending upon the characteristics of your light pen."
"[INST]In the context of the C64, What are some key considerations when working with cassette tapes for data storage?[/INST]WORKING WITH CASSETTE TAPE

    Cassette tapes have an almost unlimited capacity for data. The longer
  the tape, the more information it can store. However, tapes are limited
  in time. The more data on the tape, the longer the time it takes to find
  the information.
    The programmer must try to minimize the time factor when working with
  tape storage. One common practice is to read the entire cassette data
  file into RAM, then process it, and then re-write all the data on the
  tape. This allows you to sort, edit, and examine your data. However, this
  limits the size of your files to the amount of available RAM.
    If your data file is larger than the available RAM, it is probably time
  to switch to using the floppy disk. The disk can read data at any
  position on the disk, without needing to read through all the other data.
  You can write data over old data without disturbing the rest of the file.
  That's why the disk is used for all business applications like ledgers
  and mailing lists.
    The PRINT# statement formats data just like the PRINT statement does.
  All punctuation works the same. But remember, you're not working with the
  screen now. The formatting must be done with the INPUT# statement
  constantly in mind.

    Consider the statement PRINT# 1, A$, B$, C$. When used with the screen,
  the commas between the variables provide enough blank space between items
  to format them into columns ten characters wide. On cassette, anywhere
  from 1 to 10 spaces will be added, depending on th length of the strings.
  This wastes space on your tape.
    Even worse is what happens when the INPUT# statement tries to read
  these strings. The statement INPUT# 1, A$, B$, C$ will discover no data
  for B$ and C$. A$ will contain all three variables, plus the spaces be-
  tween them. What happens? Here's a look at the tape file:

    A$='DOG' B$='CAT' C$='TREE'
    PRINT# 1, A$, B$, C$

    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
    D O G                 C  A  T                       T  R  E  E  RETURN

    The INPUT# statement works like the regular INPUT statement. When
  typing data into the INPUT statement, the data items are separated,
  either by hitting the <RETURN> key or using commas to separate them. The
  PRINT# statement puts a RETURN at the end of a line just like the PRINT
  statement. A$ fills up with all three values because there's no separator
  on the tape between them, only after all three.
    A proper separator would be a comma (,) or a RETURN on the tape. The
  RETURN code is automatically put at the end of a PRINT or PRINT#
  statement. One way to put the RETURN code between each item is to us only
  one item per PRINT# statement. A better way is to set a variable to the
  RETURN CHR$ code, which is CHR$(13), or use a comma. The statement for
  this is R$=',':PRINT#1, A$ R$ B$ R$ C$. Don't use commas or any other
  punctuation between the variable names, since the Commodore 64 can tell
  them apart and they'll only use up space in your program.
    A proper tape file looks like this:

    1 2 3 4 5 6 7 8 9 10 11 12 13

    D O G , C A T , T  R  E  E  RETURN

    The GET# statement will pick data from the tape one character at a
  time. It will receive each character, including the RETURN code and other
  punctuation. The CHR$(0) code is received as an empty string, not as a
  one character string with a code of 0. If you try to use the ASC function
  on an empty string, you get the error message ILLEGAL QUANTITY ERROR.

    The line GET# 1, A$: A= ASC(A$) is commonly used in programs to examine
  tape data. To avoid error messages, the line should be modified to
  GET#1, A$: A=ASC(A$+CHR$(0)). The CHR$(0) at the end acts as insurance
  against empty strings, but doesn't affect the ASC function when there are
  other characters in A$."
"[INST]In the context of the C64, What are the zero-page memory locations used for in the RS-232 system interface?[/INST]ZERO-PAGE MEMORY LOCATIONS AND USAGE FOR
  RS-232 SYSTEM INTERFACE

    $00A7-INBIT-Receiver input bit temp storage.
    $00A8-BITCI-Receiver bit count in.
    $00A9-RINONE-Receiver flag Start bit check.
    $00AA-RIDATA-Receiver byte buffer/assembly location.
    $00AB-RIPRTY-Receiver parity bit storage.
    $00B4-BITTS-Transmitter bit count out.
    $00B5-NXTBIT-Transmitter next bit to be sent.
    $00B6-RODATA-Transmitter byte buffer/disassembly location.


    All the above zero-page locations are used locally and are only given
  as a guide to understand the associated routines. These cannot be used
  directly by the BASIC or KERNAL level programmer to do RS-232 type
  things. The system RS-232 routines must be used."
"[INST]In the context of the C64, What are the values that can be POKE'd into a color memory location to change a character's color?[/INST]The actual values to POKE into a color memory location to change a
  character's color are:

             0  BLACK   4  PURPLE     8  ORANGE     12  GRAY 2
             1  WHITE   5  GREEN      9  BROWN      13  Light GREEN
             2  RED     6  BLUE      10  Light RED  14  Light BLUE
             3  CYAN    7  YELLOW    11  GRAY 1     15  GRAY 3

    For example, to change the color of a character located at the upper
  left-hand corner of the screen to red, type: POKE 55296,2."
"[INST]In the context of the C64, Describe the multi-color character mode?[/INST]MULTI-COLOR CHARACTER MODE (MCM = 1, BMM = ECM = 0 )

    Multi-color mode provides additional color flexibility allowing up to
  four colors within each character but with reduced resolution. The multi-
  color mode is selected by setting the MCM bit in register 22 ($16) to
  '1,' which causes the dot data stored in the character base to be
  interpreted in a different manner. If the MSB of the color nybble is a
  '0,' the character will be displayed as described in standard character
  mode, allowing the two modes to be inter-mixed (however, only the lower
  order 8 colors are available). When the MSB of the color nybble is a '1'
  (if MCM:MSB(CM) = 1) the character bits are interpreted in the multi-
  color mode:

                | CHARACTER  |
     FUNCTION   |  BIT PAIR  |               COLOR DISPLAYED
  --------------+------------+---------------------------------------------
    Background  |     00     |  Background #0 Color
                |            |  (register 33 ($21))
    Background  |     01     |  Background #1 Color
                |            |  (register 34 ($22)
    Foreground  |     10     |  Background #2 Color
                |            |  (register 35 ($23)
    Foreground  |     11     |  Color specified by 3 LSB
                |            |  of color nybble

  Since two bits are required to specify one dot color, the character is
  now displayed as a 4*8 matrix with each dot twice the horizontal size as
  in standard mode. Note, however, that each character region can now
  contain 4 different colors, two as foreground and two as background (see
  sprite priority)."
"[INST]In the context of the C64, can to blank the screen?[/INST]SCREEN BLANKING

    The display screen may be blanked by setting the DEN bit in register
  17 ($11) to a '0'. When the screen is blanked, the entire screen will be
  filled with the exterior color as set in register 32 ($20). When blanking
  is active, only transparent (Phase 1) memory accesses are required, per-
  mitting full processor utilization of the system bus. sprite data, however,
  will be accessed if the sprites are not also disabled. The DEN bit must be
  set to '1' for normal video display."
"[INST]In the context of the C64, Describe the EOR 6502 intstruction[/INST]EOR            EOR 'Exclusive-Or' memory with accumulator             EOR

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   EOR #Oper           |    49   |    2    |    2     |
  |  Zero Page     |   EOR Oper            |    45   |    2    |    3     |
  |  Zero Page,X   |   EOR Oper,X          |    55   |    2    |    4     |
  |  Absolute      |   EOR Oper            |    40   |    3    |    4     |
  |  Absolute,X    |   EOR Oper,X          |    50   |    3    |    4*    |
  |  Absolute,Y    |   EOR Oper,Y          |    59   |    3    |    4*    |
  |  (Indirect,X)  |   EOR (Oper,X)        |    41   |    2    |    6     |
  |  (Indirect),Y  |   EOR (Oper),Y        |    51   |    2    |    5*    |
  * Add 1 if page boundary is crossed."
"[INST]In the context of the C64, WDetail the BPL 6502 instruction[/INST]BPL                     BPL Branch on result plus                     BPL


 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
   Relative      |   BPL Oper            |    10   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
"[INST]In the context of the C64, What is the primary difference between multi-color bit map mode and standard (HI-RES) bit mapped mode?[/INST]MULTI-COLOR BET MAP MODE

    Like multi-color mode characters, multi-color bit map mode allows you
  to display up to four different colors in each 8 by 8 section of bit map.
  And as in multi-character mode, there is a sacrifice of horizontal
  resolution (from 320 dots to 160 dots).
    Multi-color bit map mode uses an 8K section of memory for the bit map.
  You select your colors for multi-color bit map mode from (1) the
  background color register 0, (the screen background color), (2) the video
  matrix (the upper 4 bits give one possible color, the lower 4 bits an-
  other), and (3) color memory.
    Multi-color bit mapped mode is turned ON by setting bit 5 of 53265
  ($D011) and bit 4 at location 53270 ($D016) to a 1. The following POKE
  does this:

    POKE 53265,PEEK(53625)OR 32: POKE 53270,PEEK(53270)OR 16
  
	Multi-color bit mapped mode is turned OFF by setting bit 5 of 53265
  ($D011) and bit 4 at location 53270 ($D016) to a 0. The following POKE
  does this:

    POKE 53265,PEEK(53265)AND 223: POKE 53270,PEEK(53270)AND 239

    As in standard (HI-RES) bit mapped mode, there is a one to one cor-
  respondence between the 8K section of memory being used for the display,
  and what is shown on the screen. However, the horizontal dots are two
  bits wide. Each 2 bits in the display memory area form a dot, which can
  have one of 4 colors."
"[INST]In the context of the C64, What should be done to minimize noise in the SID Vcc line?[/INST]VCC (Pin 25)

    As with the GND line, a separate +5 VDC line should be run between SID
  Vcc and the power supply in order to minimize noise. A bypass capacitor
  should be located close to the pin."
"[INST]In the context of the C64, Can you describe the filter register of the SID?[/INST]FILTER

  FC LO/FC HI (Registers $15,$16)

    Together these registers form an 11-bit number (bits 3-7 of FC LO are
  not used) which linearly controls the Cutoff (or Center) Frequency of the
  programmable Filter. The approximate Cutoff Frequency ranges from 30
  Hz to 12 KHz.

  RES/FILT (Register $17)

    Bits 4-7 of this register (RES0-RES3) control the resonance of the
  filter. Resonance is a peaking effect which emphasizes frequency com-
  ponents at the Cutoff Frequency of the Filter, causing a sharper sound.
  There are 16 resonance settings ranging linearly from no resonance (0) to
  maximum resonance (15 or $F). Bits 0-3 determine which signals will be
  routed through the Filter:
    FILT 1 (Bit 0): When set to a zero, Voice 1 appears directly at the
  audio output and the Filter has no effect on it. When set to a one, Voice
  1 will be processed through the Filter and the harmonic content of Voice
  1 will be altered according to the selected Filter parameters.
    FILT 2 (Bit 1): Same as bit 0 for Voice 2.
    FILT 3 (Bit 2): Same as bit 0 for Voice 3.
    FILTEX (Bit 3): Same as bit 0 for External audio input (pin 26)."
"[INST]In the context of the C64, What is the MODE/VOL (Register $18) register?[/INST]MODE/VOL (Register $18)

    Bits 4-7 of this register select various Filter mode and output
  options:
    LP (Bit 4): When set to a one, the Low-Pass output of the Filter is
  selected and sent to the audio output. For a given Filter input signal,
  all frequency components below the Filter Cutoff Frequency are passed
  unaltered, while all frequency components above the Cutoff are attenuated
  at a rate of 12 dB/Octave. The Low-Pass mode produces fullbodied sounds.
    BP (Bit 5): Same as bit 4 for the Bandpass output. All frequency
  components above and below the Cutoff are attenuated at a rate of 6
  dB/Octave. The Bandpass mode produces thin, open sounds.
    HP (Bit 6): Same as bit 4 for the High-Pass output. All frequency
  components above the Cutoff are passed unaltered, while all frequency
  components below the Cutoff are attenuated at a rate of 12 dB/Octave.
  The High-Pass mode produces tinny, buzzy sounds.
    3 OFF (Bit 7): When set to a one, the output of Voice 3 is disconnected
  from the direct audio path. Setting Voice 3 to bypass the Filter
  (FILT 3 = 0) and setting 3 OFF to a one prevents Voice 3 from reaching
  the audio output. This allows Voice 3 to be used for modulation purposes
  without any undesirable output.

  | NOTE: The Filter output modes ARE additive and multiple Filter modes  |
  | may be selected simultaneously. For example, both LP and HP modes can |
  | be selected to produce a Notch (or Band Reject) Filter response. In   |
  | order for the Filter to have any audible effect, at least one Filter  |
  | output must be selected and at least one Voice must be routed through |
  | the Filter. The Filter is, perhaps, the most important element in SID |
  | as it allows the generation of complex tone colors via subtractive    |
  | synthesis (the Filter is used to eliminate specific frequency         |
  | components from a harmonically rich input signal). The best results   |
  | are achieved by varying the Cutoff Frequency in real-time.            |


    Bits 0-3 (VOL0-VOL3) select 1 of 16 overall Volume levels for the final
  composite audio output. The output volume levels range from no output (0)
  to maximum volume (15 or $F) in 16 linear steps. This control can be used
  as a static volume control for balancing levels in multi-chip systems or
  for creating dynamic volume effects, such as Tremolo. Some Volume level
  other than zero must be selected in order for SID to produce any sound."
"[INST]In the context of the C64, What is the purpose of the EXT IN pin on the SID chip?[/INST]EXT IN (Pin 26)

    This analog input allows external audio signals to be mixed with the
  audio output of SID or processed through the Filter. Typical sources in-
  clude voice, guitar, and organ. The input impedance of this pin is on the
  order of 100 kohms. Any signal applied directly to the pin should ride at
  a DC level of 6 volts and should not exceed 3 volts p-p. In order to pre-

  vent any interference caused by DC level differences, external signals
  should be AC-coupled to EXT IN by an electrolytic capacitor in the 1-10
  uF range. As the direct audio path (FILTEX=0) has unity gain, EXT IN can
  be used to mix outputs of many SID chips by daisy-chaining. The number of
  chips that can be chained in this manner is determined by the amount of
  noise and distortion allowable at the final output. Note that the output
  Volume control will affect not only the three SID voices, but also any
  external inputs."
"[INST]In the context of the C64, How is the bit map mode works on C64?[/INST]There are two types of bit mapping available on the Commodore 64.
  They are:

    1) Standard (high-resolution) bit mapped mode (320-dot by 200-dot
       resolution)

    2) Multi-color bit mapped mode (160-dot by 200-dot resolution)

    Each is very similar to the character type it is named for: standard
  has greater resolution, but fewer color selections. On the other hand,
  multi-color bit mapping trades horizontal resolution for a greater number
  of colors in an 8-dot by 8-dot square.

  STANDARD HIGH-RESOLUTION BIT MAP MODE

    Standard bit map mode gives you a 320 horizontal dot by 200 vertical
  dot resolution, with a choice of 2 colors in each 8-dot by 8-dot section.
  Bit map mode is selected (turned ON) by setting bit 5 of the VIC-II
  control register to a 1 at location 53265 ($D011 in HEX). The following
  POKE will do this:

    POKE 53265,PEEK(53265)OR 32

    Bit map mode is turned OFF by setting bit 5 of the VIC-II control
  register to 0 at location 53265 ($D011), like this:

    POKE 53265,PEEK(53265)AND 223

    Before we get into the details of the bit map mode, there is one more
  issue to tackle, and that is where to locate the bit map area.

  HOW IT WORKS

    If you remember the PROGRAMMABLE CHARACTERS section you will recall
  that you were able to set the bit pattern of a character stored in RAM to
  almost anything you wanted. If at the same time you change the character
  that is displayed on the screen, you would be able to change a single
  dot, and watch it happen. This is the basis of bit-mapping. The entire
  screen is filled with programmable characters, and you make your changes
  directly into the memory that the programmable characters get their
  patterns from.
    Each of the locations in screen memory that were used to control what
  character was displayed, are now used for color information. For example,
  instead of POKEing a I in location 1024 to make an 'A' appear in the top
  left hand corner of the screen, location 1024 now controls the colors of
  the bits in that top left space.
    Colors of squares in bit map mode do not come from color memory, as
  they do in the character modes. Instead, colors are taken from screen
  memory. The upper 4 bits of screen memory become the color of any bit
  that is set to 1 in the 8 by 8 area controlled by that screen memory
  location. The lower 4 bits become the color of any bit that is set to
  a 0.

  EXAMPLE: Type the following:

  5 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
  10 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE

  Now RUN the program.
    Garbage appears on the screen, right? Just like the normal screen mode,
  you have to clear the HIGH-RESOLUTION (HI-RES) screen before you use it.
  Unfortunately, printing a CLR won't work in this case. Instead you have
  to clear out the section of memory that you're using for your
  programmable characters. Hit the <RUN/STOP> and <RESTORE> keys, then add
  the following lines to your program to clear the HI-RES screen:

  20 FORI=BASETOBASE+7999:POKEI,0:NEXT:REM CLEAR BIT
  30 FORI=1024TO2023:POKEI,3:NEXT:REM SET COLOR TO CYAN AND BLACK

    Now RUN the program again. You should see the screen clearing, then the
  greenish blue color, cyan, should cover the whole screen. What we want to
  do now is to turn the dots on and off on the HI-RES screen.

    To SET a dot (turn a dot ON) or UNSET a dot (turn a dot OFF) you must
  know how to find the correct bit in the character memory that you have to
  set to a 1. In other words, you have to find the character you need to
  change, the row of the character, and which bit of the row that you
  have to change. You need a formula to calculate this.
    We will use X and Y to stand for the horizontal and vertical positions
  of a dot, The dot where X=0 and Y=0 is at the upper-left of the display.
  Dots to the right have higher X values, and the dots toward the bottom
  have higher Y values."
"[INST]In the context of the C64, What feature of the VIC-II chip allows sprites to be expanded in size?[/INST]EXPANDED SPRITES

    The VIC-II chip has the ability to expand a sprite in the vertical
  direction, the horizontal direction, or both at once. When expanded, each
  dot in the sprite is twice as wide or twice as tall. Resolution doesn't
  actually increase... the sprite just gets bigger."
"[INST]In the context of the C64, What is the purpose of the BRK instruction in the context of 66502?[/INST]BRK                          BRK Force Break                          BRK

Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   BRK                 |    00   |    1    |    7     |
  1. A BRK command cannot be masked by setting I."
"[INST]In the context of the C64, What is the assembly language form of the INC instruction?[/INST]INC                    INC Increment memory by one                    INC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   INC Oper            |    E6   |    2    |    5     |
  |  Zero Page,X   |   INC Oper,X          |    F6   |    2    |    6     |
  |  Absolute      |   INC Oper            |    EE   |    3    |    6     |
  |  Absolute,X    |   INC Oper,X          |    FE   |    3    |    7     |"
"[INST]In the context of the C64, How are sprites in memory?[/INST]sprite MEMORY ACCESS

    The data for each sprite is Stored in 63 consecutive bytes of memory. Each
  block of sprite data is defined by a sprite pointer, located at the end of the
  VIDEO MATRIX. Only 1000 bytes of the video matrix are used in the normal
  display modes, allowing the video matrix locations 1016-1023 (VM base+
  $3F8 to VM base+$3FF) to be used for sprite pointers 0-7, respectively. The
  eight-bit sprite pointer from the video matrix together with the six bits
  from the sprite byte counter (to address 63 bytes) define the entire 14-bit
  address field:


     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
     MP7| MP6| MP5| MP4| MP3| MP2| MP1| MP0| MC5| MC4| MC3| MC2| MC1| MC0

  Where MPx are the sprite pointer bits from the video matrix and MCx are the
  internally generated sprite counter bits. The sprite pointers are read from the
  video matrix at the end of every raster line. When the Y position
  register of a sprite matches the current raster line count, the actual
  fetches of sprite data begin. Internal counters automatically step through
  the 63 bytes of sprite data, displaying three bytes on each raster line."
"[INST]In the context of the C64, What is the purpose of the 6566/6567 in the character display mode?[/INST]CHARACTER DISPLAY MODE

    In the character display mode, the 6566/6567 fetches CHARACTER POINTERs
  from the VIDEO MATRIX area of memory and translates the pointers to
  character dot location addresses in the 2048 byte CHARACTER BASE area of
  memory. The video matrix is comprised of 1000 consecutive locations in
  memory which each contain an eight-bit character pointer. The location of
  the video matrix within memory is defined by VM13-VM10 in register 24
  ($18) which are used as the 4 MSB of the video matrix address. The lower
  order 10 bits are provided by an internal counter (VC9-VC0) which steps
  through the 1000 character locations. Note that the 6566/6567 provides 14
  address outputs; therefore, additional system hardware may be required
  for complete system memory decodes.

                          CHARACTER POINTER ADDRESS

     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
  ------+----+----+----+----+----+----+----+----+----+----+----+----+------
    VM13|VM12|VM11|VM10| VC9| VC8| VC7| VC6| VC5| VC4| VC3| VC2| VC1| VC0


    The eight-bit character pointer permits up to 256 different character
  definitions to be available simultaneously. Each character is an 8*8 dot
  matrix stored in the character base as eight consecutive bytes. The loca-
  tion of the character base is defined by CB13-CB11 also in register 24
  ($18) which are used for the 3 most significant bits (MSB) of the char-
  acter base address. The 11 lower order addresses are formed by the 8-bit
  character pointer from the video matrix (D7-D0) which selects a
  particular character, and a 3-bit raster counter (RC2-RC0) which selects
  one of the eight character bytes. The resulting characters are formatted
  as 25 rows of 40 characters each. In addition to the 8-bit character
  pointer, a 4-bit COLOR NYBBLE is associated with each video matrix
  location (the video matrix memory must be 12 bits wide) which defines one
  of sixteen colors for each character.


                           CHARACTER DATA ADDRESS

     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
  ------+----+----+----+----+----+----+----+----+----+----+----+----+------
    CB13|CB12|CB11| D7 | D6 | D5 | D4 | D3 | D2 | D1 | D0 | RC2| RC1| RC0


  STANDARD CHARACTER MODE (MCM = BMM = ECM = 0)

    In the standard character mode, the 8 sequential bytes from the
  character base are displayed directly on the 8 lines in each character
  region. A '0' bit causes the background #0 color (from register 33 ($21))
  to be displayed while the color selected by the color nybble (foreground)
  is displayed for a '1' bit (see Color Code Table).

                | CHARACTER |
     FUNCTION   |    BIT    |               COLOR DISPLAYED
  --------------+-----------+----------------------------------------------
    Background  |     0     |  Background #0 color
                |           |  (register 33 ($21)
    Foreground  |     1     |  Color selected by 4-bit color nybble


    Therefore, each character has a unique color determined by the 4-bit
  color nybble (1 of 16) and all characters share the common background
  color."
"[INST]In the context of the C64, What are the non-zero page memory locations and their usage for the RS-232 system interface?[/INST]NONZERO-PAGE MEMORY LOCATIONS AND USAGE FOR
  RS-232 SYSTEM INTERFACE


    General RS-232 storage:

    $0293-M51CTR-Pseudo 6551 control register (see Figure 6-1).
    $0294-M51COR-Pseudo 6551 command register (see Figure 6-2) .
    $0295-M51AJB-Two bytes following the control and command registers in
          the file name field. These locations contain the baud rate for
          the start of the bit test during the interface activity, which,
          in turn, is used to calculate baud rate.
    $0297-RSSTAT-The RS-232 status register (see Figure 6-3).
    $0298-BITNUM-The number of bits to be sent/received.
    $0299-BAUDOF-Two bytes that are equal to the time of one bit cell.
          (Based on system clock/baud rate.)
    $029B-RIDBE-The byte index to the end of the receiver FIFO buffer.
    $029C-RIDBS-The byte index to the start of the receiver FIFO buffer.
    $029D-RODBS-The byte index to the start of the transmitter FIFO buffer.
    $029E-RODBE-The byte index to the end of the transmitter FIFO buffer.
    $02A1-ENABL-Holds current active interrupts in the CIA #2 ICR.
          When bit 4 is turned on means that the system is waiting for the
          Receiver Edge. When bit 1 is turned on then the system is
          receiving data. When bit 0 is turned on then the system is
          transmitting data."
"[INST]In the context of the C64, What is the primary function of the serial bus in the Commodore 64?[/INST]THE SERIAL BUS

    The serial bus is a daisy chain arrangement designed to let the Com-
  modore 64 communicate with devices such as the VIC-1541 DISK DRIVE and
  the VIC-1525 GRAPHICS PRINTER. The advantage of the serial bus is that
  more than one device can be connected to the port. Up to 5 devices can be
  connected to the serial bus at one time.
    There are three types of operation over a serial bus-CONTROL, TALK, and
  LISTEN. A CONTROLLER device is one which controls operation of the serial
  bus. A TALKER transmits data onto the bus. A LISTENER receives data from
  the bus.
    The Commodore 64 is the controller of the bus. It also acts as a TALKER
  (when sending data to the printer, for example) and as a LISTENER (when
  loading a program from the disk drive, for example). Other devices may be
  either LISTENERS (the printer), TALKERS, or both (the disk drive). Only
  the Commodore 64 can act as the controller.
    All devices connected on the serial bus will receive all the data
  transmitted over the bus. To allow the Commodore 64 to route data to its
  intended destination, each device has a bus ADDRESS. By using this device
  address, the Commodore 64 can control access to the bus. Addresses on the
  serial bus range from 4 to 31.
    The Commodore 64 can COMMAND a particular device to TALK or LISTEN.
  When the Commodore 64 commands a device to TALK, the device will begin
  putting data onto the serial bus. When the Commodore 64 commands a device
  to LISTEN, the device addressed will get ready to receive data (from the
  Commodore 64 or from another device on the bus). Only one device can TALK
  on the bus at a time; otherwise, the data will collide and the system
  will crash in confusion. However, any number of devices can LISTEN at the
  same time to one TALKER.

                         COMMON SERIAL BUS ADDRESSES
                    +--------+--------------------------+
                    | NUMBER |        DEVICE            |
                    +--------+--------------------------+
                    | 4 or 5 | VIC-1525 GRAPHIC PRINTER |
                    | 8      | VIC-1541 DISK DRIVE      |
                    +--------+--------------------------+

    Other device addresses are possible. Each device has its own address.
  Certain devices (like the Commodore 64 printer) provide a choice between
  two addresses for the convenience of the user.
    The SECONDARY ADDRESS is to let the Commodore 64 transmit setup
  information to a device. For example, to OPEN a connection on the bus to
  the printer, and have it print in UPPER/LOWER case, use the following

    OPEN 1,4,7

  where,
    1 is the logical file number (the number you PRINT# to),
    4 is the ADDRESS of the printer, and
    7 is the SECONDARY ADDRESS that tells the printer to go into UPPER/
      LOWER case mode.

    There are 6 lines used in serial bus operations - input and 3 output.
  The 3 input lines bring data, control, and timing signals into the Com-
  modore 64. The 3 output lines send data, control, and timing signals from
  the Commodore 64 to external devices on the serial bus.

  Serial I/O
                                                       ++ ++
  +-------+----------------------+                    / +-+ \
  |  Pin  |         Type         |                   /5     1\
  +-------+----------------------+                  +  O   O  +
  |   1   |  /SERIAL SRQ IN      |                  |    6    |
  |   2   |  GND                 |                  |    O    |
  |   3   |  SERIAL ATN OUT      |                  |         |
  |   4   |  SERIAL CLK IN/OUT   |                  +  O   O  +
  |   5   |  SERIAL DATA IN/OUT  |                   \4  O  2/
  |   6   |  /RESET              |                    \  3  /
  +-------+----------------------+                     +---+"
"[INST]In the context of the C64, Describe how sprite priority works[/INST]PRIORITY

    The priority of each sprite may be individually controlled with respect to
  the other displayed information from character or bit map modes. The
  priority of each sprite is set by the corresponding bit (MnDP) of register
  27 ($1B) as follows:

     REG BIT  |          PRIORITY TO CHARACTER OR BIT MAP DATA
        0     |  Non-transparent sprite data will be displayed (sprite in front)
        1     |  Non-transparent sprite data will be displayed only instead of
              |  Bkgd #0 or multi-color bit pair 01 (sprite behind)


                          sprite-DISPLAY DATA PRIORITY
                       |   MnDP = 1   |   MnDP = 0   |
                       |  spriten     |  Foreground  |
                       |  Foreground  |  spriten     |
                       |  Background  |  Background  |


  sprite data bits of '0' ('00' in multi-color mode) are transparent, always
  permitting any other information to be displayed.
    The sprites have a fixed priority with respect to each other, with sprite 0
  having the highest priority and sprite 7 the lowest. When sprite data (except
  transparent data) of two sprites are coincident, the data from the lower
  number sprite will be displayed. sprite vs. sprite data is prioritized before
  priority resolution with character or bit map data."
"[INST]In the context of the C64, What is the purpose of the instruction BNE"" in the given 6502 ASM language code?""[/INST]BNE                   BNE Branch on result not zero                   BNE


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles
 Relative      |   BMI Oper            |    D0   |    2    |    2*    
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
"[INST]In the context of the C64, What is the assembly language instruction that decrements the index register Y by one?[/INST]DEY                   DEY Decrement index Y by one                    DEY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   DEY                 |    88   |    1    |    2     |"
"[INST]In the context of the C64, What is the command that turns off extended color mode in the VIC-II register?[/INST]Extended color mode is turned OFF by setting bit 6 of the VIC-II regis-ter to a 0 at location 53265 ($D011). The following statement will do this:
    POKE 53265,PEEK(53265)AND 191"
"[INST]In the context of the C64, Give the caracteristics of the sprite multi color mode[/INST]SPRITE  MULTI-COLOR MODE

    Multi-color mode allows you to have up to 4 different colors in each
  sprite. However, just like other multi-color modes, horizontal resolution
  is cut in half. In other words, when you're working with sprite multi-
  color mode (like in multi-color character mode), instead of 24 dots
  across the sprite, there are 12 pairs of dots. Each pair of dots is
  called a BIT PAIR. Think of each bit pair (pair of dots) as a single dot
  in your overall sprite when it comes to choosing colors for the dots in
  your sprites. The table below gives you the bit pair values needed to
  turn ON each of the four colors you've chosen for your sprite:

    BIT PAIR                           DESCRIPTION
      00        TRANSPARENT, SCREEN COLOR
      01        SPRITE MULTI-COLOR REGISTER #0 (53285) ($D025)
      10        SPRITE COLOR REGISTER
      11        SPRITE MULTI-COLOR REGISTER #I (53286) ($D026)
 
  NOTE: The sprite foreground color is a 10. The character foreground   
   is a 11."
"[INST]In the context of the C64, What is the purpose of the POTY sid register?[/INST]POTY (Register $1A)

    Same as POTX for the pot tied to POTY (pin 23)."
"[INST]In the context of the C64, What is the recommended resistance for the source resistor from the AUDIO OUT to ground for proper operation?[/INST]AUDIO OUT (Pin 27)

    This open-source buffer is the final audio output of SID, comprised of
  the three SID voices, the Filter and any external input. The output level
  is set by the output Volume control and reaches a maximum of 2 volts p-p
  at a DC level of 6 volts. A source resistor from AUDIO OUT to ground is
  required for proper operation. The recommended resistance is 1 kohm for
  a standard output impedance.
    As the output of SID rides at a 6-volt DC level, it should be AC-
  coupled to any audio amplifier with an electrolytic capacitor in the 1-10
  uF range.

  VDD (Pin 28)

    As with Vcc, a separate +12 VDC line should be run to SID VDD and a
  bypass capacitor should be used.


  6581 SID CHARACTERISTICS


  ABSOLUTE MAXIMUM RATINGS

  |          RATING          |   SYMBOL   |      VALUE      |    UNITS    |
  |  Supply Voltage          |    VDD     |   -0.3 to +17   |     VDC     |
  |  Supply Voltage          |    VCC     |   -0.3 to +7    |     VDC     |
  |  Input Voltage (analog)  |    Vina    |   -0.3 to +17   |     VDC     |
  |  Input Voltage (digital) |    Vind    |   -0.3 to +7    |     VDC     |
  |  Operating Temperature   |    Ta      |      0 to +70   |   Celsius   |
  |  Storage Temperature     |    Tstg    |   -55 to +150   |   Celsius   |
  +--------------------------+------------+-----------------+-------------+"
"[INST]In the context of the C64, What is the purpose of the POTX register in the SID?[/INST]POTX (Register $19)

    This register allows the microprocessor to read the position of the
  potentiometer tied to POTX (pin 24), with values ranging from 0 at
  minimum resistance, to 255 ($FF) at maximum resistance. The value is
  always valid and is updated every 512 (02 clock cycles. See the Pin
  Description section for information on pot and capacitor values."
"[INST]In the context of the C64, how do I set multi color mode on a sprite?[/INST]SETTING A SPRITE TO MULTI-COLOR MODE

    To switch a sprite into multi-color mode you must turn ON the VIC-II
  control register at location 53276 ($D01C). The following POKE does this:

    POKE 53276,PEEK(53276)OR(2^SN)

  where SN is the sprite number (0 to 7).
    To switch a sprite out of multi-color mode you must turn OFF the VIC-II
  control register at location 53276 ($D01C). The following POKE does this:

    POKE 53276,PEEK(53276)AND(255-2^SN)

  where SN is the sprite number (0 to 7)."
"[INST]In the context of the C64, What is the primary method used to achieve high-resolution displays on the Commodore 64?[/INST]BIT MAPPED GRAPHICS

When writing games, plotting charts for business applications, or other types of programs, sooner or later you get to the point where you want
high-resolution displays.

The Commodore 64 has been designed to do just that: high resolution is available through bit mapping of the screen. Bit mapping is the method in which each possible dot (pixel) of resolution on the screen is assigned its own bit (location) in memory. If that memory bit is a one, the dot it is assigned to is on. If the bit is set to zero, the dot is off.
  
High-resolution graphic design has a couple of drawbacks, which is why it is not used all the time. First of all, it takes lots of memory to bit map the entire screen. This is because every pixel must have a memory bit to control it. You are going to need one bit of memory for each pixel (or one byte for 8 pixels). Since each character is 8 by 8, and there are 40 lines with 25 characters in each line, the resolution is 320 pixels (dots) by 200 pixels for the whole screen. That gives you 64000 separate dots, each of which requires a bit in memory. In other words, 8000 bytes of memory are needed to map the whole screen.

Generally, high-resolution operations are made of many short, simple, repetitive routines. Unfortunately, this kind of thing is usually rather slow if you are trying to write high-resolution routines in BASIC. How-ever, short, simple, repetitive routines are exactly what machine language does best. The solution is to either write your programs entirely in machine language, or call machine language, high-resolution sub-xroutines from your BASIC program using the SYS command from BASIC. That way you get both the ease of writing in BASIC, and the speed of machine language for graphics. The VSP cartridge is also available to add high-resolution commands to COMMODORE 64 BASIC.
  
All of the examples given in this section will be in BASIC to make themclear. Now to the technical details."
"[INST]In the context of the C64, What is the purpose of the JSR instruction in the C64 machine language program?[/INST]SUBROUTINES

    In machine language (in the same way as using BASIC), you can call
  subroutines. The instruction to call a subroutine is JSR (Jump to Sub-
  Routine), followed by the specified absolute address.
    Incorporated in the operating system, there is a machine language
  subroutine that will PRINT a character to the screen. The CBM ASCII code
  of the character should be in the accumulator before calling the
  subroutine. The address of this subroutine is $FFD2.
    Therefore, to print 'Hi' to the screen, the following program should be
  entered:

    .A 1400 LDA #$48     - load the CBM ASCII code of 'H'
    .A 1402 JSR $FFD2    -  print it
    .A 1405 LDA #$49     - load the CBM ASCII code of 'I'
    .A 1407 JSR $FFD2    -  print that too
    .A 140A LDA #$0D     - print a carriage return as well
    .A 140C JSR $FFD2
    .A 140F BRK          - return to 64MON
    .G 1400              - will print 'HI' and return to 64MON"
"[INST]In the context of the C64, What is the assembly language instruction that decrements the value stored in X?[/INST]DEX                   DEX Decrement index X by one                    DEX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   DEX                 |    CA   |    1    |    2     |"
"[INST]In the context of the C64, WDescribe the caracteristics of BMI 6502 instruction?[/INST]BMI                    BMI Branch on result minus                     BMI


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles
 Relative      |   BMI Oper            |    30   |    2    |    2*    
  * Add 1 if branch occurs to same page.
  * Add 1 if branch occurs to different page."
"[INST]In the context of the C64, What are the primary functions and capabilities of the 6566/6567 devices?[/INST]The 6566/6567 are multi-purpose color video controller devices for use
  in both computer video terminals and video game applications. Both
  devices contain 47 control registers which are accessed via a standard
  8-bit microprocessor bus (65XX) and will access up to 16K of memory for
  display information. The various operating modes and options within each
  mode are described."
"[INST]In the context of the C64, What is the purpose of the COLLISION DETECTION system in a sprite-based graphics system?[/INST]COLLISION DETECTION


    Two types of sprite collision (coincidence) are detected, sprite to sprite
  collision and sprite to display data collision:


    1) A collision between two sprites occurs when non-transparent output data
       of two sprites are coincident. Coincidence of sprite transparent areas
       will not generate a collision. When a collision occurs, the sprite bits
       (MnM) in the sprite-sprite COLLISION register 30 ($1E) will be set to '1'
       for both colliding spriteS. As a collision between two (or more) sprites
       occurs, the sprite-sprite collision bit for each collided sprite will be set.
       The collision bits remain set until a read of the collision
       register, when all bits are automatically cleared. sprites collisions
       are detected even if positioned off-screen.
    2) The second type of collision is a sprite-DATA collision between a sprite
       and foreground display data from the character or bit map modes. The
       sprite-DATA COLLISION register 31 ($1F) has a 'bit (MnD) for each sprite
       which is set to '1' when both the sprite and non-background display
       data are coincident. Again, the coincidence of only transparent data
       does not generate a collision. For special applications, the display
       data from the 0-1 multicolor bit pair also does not cause a
       collision. This feature permits their use as background display data
       without interfering with true sprite collisions. A sprite-DATA collision
       can occur off-screen in the horizontal direction if actual display
       data has been scrolled to an off-screen position (see scrolling).
       The sprite-DATA COLLISION register also automatically clears when read.
    The collision interrupt latches are set whenever the first bit of
   either register is set to '1'. Once any collision bit within a register
   is set high, subsequent collisions will not set the interrupt latch
   until that collision register has been cleared to all '0s' by a read."
"[INST]In the context of the C64, What are the ASCII and CHR$ codes?[/INST]ASCII AND CHR$ CODES

    This appendix shows you what characters will appear if you PRINT
  CHR$(X), for all possible values of X. It will also show the values ob-
  tained by typing PRINT ASC('x'), where x is any character you can type.
  This is useful in evaluating the character received in a GET statement,
  converting upper/lower case, and printing character based commands (like
  switch to upper/lower case) that could not be enclosed in quotes.


  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |
  |             0   |  {down}    17   |    '       34   |    3       51   |
  |             1   | {rvs on}   18   |    #       35   |    4       52   |
  |             2   |  {home}    19   |    $       36   |    5       53   |
  |             3   |  {del}     20   |    %       37   |    6       54   |
  |             4   |            21   |    &       38   |    7       55   |
  | {white}     5   |            22   |    '       39   |    8       56   |
  |             6   |            23   |    (       40   |    9       57   |
  |             7   |            24   |    )       41   |    :       58   |
  | disSHIFT+C= 8   |            25   |    *       42   |    ;       59   |
  | enaSHIFT+C= 9   |            26   |    +       43   |    <       60   |
  |            10   |            27   |    ,       44   |    =       61   |
  |            11   |  {red}     28   |    -       45   |    >       62   |
  |            12   | {right}    29   |    .       46   |    ?       63   |
  | return     13   | {green}    30   |    /       47   |    @       64   |
  | lower case 14   |  {blue}    31   |    0       48   |    A       65   |
  |            15   |  SPACE     32   |    1       49   |    B       66   |
  |            16   |    !       33   |    2       50   |    C       67   |
  |    D       68   |            97   |           126   | {grey 3}  155   |
  |    E       69   |            98   |           127   | {purple}  156   |
  |    F       70   |            99   |           128   | {left}    157   |
  |    G       71   |           100   | {orange}  129   | {yellow}  158   |
  |    H       72   |           101   |           130   |  {cyan}   159   |
  |    I       73   |           102   |           131   |  SPACE    160   |
  |    J       74   |           103   |           132   |           161   |
  |    K       75   |           104   |    f1     133   |           162   |
  |    L       76   |           105   |    f3     134   |           163   |
  |    M       77   |           106   |    f5     135   |           164   |
  |    N       78   |           107   |    f7     136   |           165   |
  |    O       79   |           108   |    f2     137   |           166   |
  |    P       80   |           109   |    f4     138   |           167   |
  |    Q       81   |           110   |    f6     139   |           168   |
  |    R       82   |           111   |    f8     140   |           169   |
  |    S       83   |           112   |shift+ret. 141   |           170   |
  |    T       84   |           113   |upper case 142   |           171   |
  |    U       85   |           114   |           143   |           172   |
  |    V       86   |           115   | {black}   144   |           173   |
  |    W       87   |           116   |   {up}    145   |           174   |
  |    X       88   |           117   | {rvs off} 146   |           175   |
  |    Y       89   |           118   | {clear}   147   |           176   |
  |    Z       90   |           119   |  {inst}   148   |           177   |
  |    [       91   |           120   | {brown}   149   |           178   |
  |  pound     92   |           121   | {lt. red} 150   |           179   |
  |    ]       93   |           122   | {grey 1}  151   |           180   |
  |    ^       94   |           123   | {grey 2}  152   |           181   |
  |{arrow left}95   |           124   | {lt.green}153   |           182   |
  |            96   |           125   | {lt.blue} 154   |           183   |
  |           184   |           186   |           188   |           190   |
  |           185   |           187   |           189   |           191   |


  CODES 192-223 SAME AS  96-127
  CODES 224-254 SAME AS 160-190
  CODE 255 SAME AS 126"
"[INST]In the context of the C64, Describe how to position a sprite[/INST]SPRITE POSlTlON

    Each sprite is positioned via its X and Y position register (see register
  map) with a resolution of 512 horizontal and 256 vertical positions. The
 position of a sprite is determined by the upper-left corner of the array. X
  locations 23 to 347 ($17-$157) and Y locations 50 to 249 ($32-$F9) are
  visible. Since not all available sprite positions are entirely visible on
  the screen, sprites may be moved smoothly on and off the display screen."
"[INST]In the context of the C64, What are the key characteristics of the bit map mode in the 6566/6567?[/INST]BIT MAP MODE

    In bit map mode, the 6566/6567 fetches data from memory in a different
  fashion, so that a one-to-one correspondence exists between each
  displayed dot and a memory bit. The bit map mode provides a screen
  resolution of 320H * 200V individually controlled display dots. Bit map
  mode is selected by setting the BMM bit in register 17 ($11) to a '1'.
  The VIDEO MATRIX is still accessed as in character mode, but the video
  matrix data is no longer interpreted as character pointers, but rather as
  color data. The VIDEO MATRIX COUNTER is then also used as an address to
  fetch the dot data for display from the 8000-byte DISPLAY BASE. The
  display base address is formed as follows:


     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
    CB13| VC9| VC8| VC7| VC6| VC5| VC4| VC3| VC2| VC1| VC0| RC2| RC1| RC0"
"[INST]In the context of the C64, What is the purpose of the BEQ"" instruction in the C64 assembly language code?""[/INST]BEQ                    BEQ Branch on result zero                      BEQ

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles
  Relative      |   BEQ Oper            |    F0   |    2    |    2*    
  * Add 1 if branch occurs to same  page.
  * Add 2 if branch occurs to next  page."
"[INST]In the context of the C64, What is the purpose of the Add 1"" and ""Add 2"" notes in the table?""[/INST]BVC                   BVC Branch on overflow clear                    BVC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Relative      |   BVC Oper            |    50   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
"[INST]In the context of the C64, What are the CMP 6502 instruction details?[/INST]CMP                CMP Compare memory and accumulator                 CMP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   CMP #Oper           |    C9   |    2    |    2     |
  |  Zero Page     |   CMP Oper            |    C5   |    2    |    3     |
  |  Zero Page,X   |   CMP Oper,X          |    D5   |    2    |    4     |
  |  Absolute      |   CMP Oper            |    CD   |    3    |    4     |
  |  Absolute,X    |   CMP Oper,X          |    DD   |    3    |    4*    |
  |  Absolute,Y    |   CMP Oper,Y          |    D9   |    3    |    4*    |
  |  (Indirect,X)  |   CMP (Oper,X)        |    C1   |    2    |    6     |
  |  (Indirect),Y  |   CMP (Oper),Y        |    D1   |    2    |    5*    |
  * Add 1 if page boundary is crossed."
"[INST]In the context of the C64, how do I turn a sprite On ?[/INST]TURNING SPRITES ON

    The VIC-II control register at location 53269 ($D015 in HEX) is known
  as the SPRITE ENABLE register. Each of the sprites has a bit in this
  register which controls whether that sprite is ON or OFF. The register
  looks like this:

                     $D015  7 6 5 4 3 2 1 0

    To turn on sprite 1, for example, it is necessary to turn that bit to
  a 1. The following POKE does this:

    POKE 53269.PEEK(53269)OR 2

  A more general statement would be the following:

    POKE 53269,PEEK(53269)OR (2^SN)

  where SN is the sprite number, from 0 to 7.

   NOTE: A sprite must be turned ON before it can be seen."
"[INST]In the context of the C64, What is the command that turns on the Extended color mode in the VIC-II register?[/INST]Extended color mode is turned ON by setting bit 6 of the VIC-II regis-ter to a 1 at location 53265 ($D011 in HEX). The following POKE does it:

    POKE 53265,PEEK(53265)OR 64"
"[INST]In the context of the C64, What are the primary functions of the D0-D7 pins in the SID and microprocessor?[/INST]D0-D7 (Pins 15-22)

    These bidirectional lines are used to transfer data between SID and the
  microprocessor. They are TTL compatible in the input mode and capable of
  driving 2 TTL loads in the output mode. The data buffers are usually in
  the high-impedance off state. During a Write operation, the data buffers
  remain in the off (input) state and the microprocessor supplies data to
  SID over these lines. During a Read operation, the data buffers turn on
  and SID supplies data to the microprocessor over these lines. The pins
  are normally connected to the corresponding data lines of the micro-
  processor.

  POTX,POTY (Pins 24,23)

    These pins are inputs to the A/D converters used to digitize the posi-
  tion of potentiometers. The conversion process is based on the time con-
  stant of a capacitor tied from the POT pin to ground, charged by a
  potentiometer tied from the POT pin to +5 volts. The component values are
  determined by:

                                RC = 4.7E-4

  Where R is the maximum resistance of the pot and C is the capacitor.
    The larger the capacitor, the smaller the POT value jitter. The recom-
  mended values for R and C are 470 komhs and 1000 pF. Note that a separate
  pot and cap are required for each POT pin."
"[INST]In the context of the C64, What is the primary limitation of using extended background color mode in terms of character display?[/INST]EXTENDED BACKGROUND COLOR MODE

Extended background color mode gives you control over the background color of each individual character, as well as over the foreground color.
For example, in this mode you could display a blue character with ayellow background on a white screen.
There are 4 registers available for extended background color mode.
Each of the registers can be set to any of the 16 colors.
Color memory is used to hold the foreground color in extended back-ground mode. It is used the same as in standard character mode.
Extended character mode places a limit on the number of different characters you can display, however. When extended color mode is on, only the first 64 characters in the character ROM (or the first 64 characters in your programmable character set) can be used. This is because two of the bits of the character code are used to select the background color.
It might work something like this:

The character code (the number you would POKE to the screen) of the letter 'A' is a 1. When extended color mode is on, if you POKED a 1 to the screen, an 'A' would appear. If you POKED a 65 to the screen normally, you would expect the character with character code (CHR$) 129 to appear, which is a reversed 'A.' This does NOT happen in extended color mode. Instead you get the same unreversed 'A' as before, but on a different background color."
"[INST]In the context of the C64, What is the formula for calculating the start of the 64 bytes of the sprite definition block?[/INST]If sprite pointer #0, at location 2040, contains the number 14, for
  example, this means that sprite 0 will be displayed using the 64 bytes
  beginning at location 14*64 = 896 which is in the cassette buffer. The
  following formula makes this clear:

    LOCATION = (BANK * 16384) + (SPRITE POINTER VALUE * 64)

  Where BANK is the 16K segment of memory that the VIC-II chip is looking
  at and is from 0 to 3.
    The above formula gives the start of the 64 bytes of the sprite
  definition block.
    When the VIC-II chip is looking at BANK 0 or BANK 2, there is a ROM
  IMAGE of the character set present in certain locations, as mentioned
  before. Sprite definitions can NOT be placed there. If for some reason
  you need more than 128 different sprite definitions, you should use one
  of the banks without the ROM IMAGE, 1 or 3."
"[INST]In the context of the C64, how can I create a smooth scrolling with the VIC-II chip on C64?[/INST]SMOOTH SCROLLING

    The VIC-II chip supports smooth scrolling in both the horizontal and
  vertical directions. Smooth scrolling is a one pixel movement of the
  entire screen in one direction. It can move either UP, or down, or left,
  or right. It is used to move new information smoothly onto the screen,
  while smoothly removing characters from the other side.
    While the VIC-II chip does much of the task for you, the actual scroll-
  ing must be done by a machine language program. The VIC-II chip features
  the ability to place the video screen in any of 8 horizontal positions,
  and 8 vertical positions. Positioning is controlled by the VIC-II
  scrolling registers. The VIC-II chip also has a 38 column mode, and a 24
  row mode. the smaller screen sizes are used to give you a place for your
  new data to scroll on from.

  The following are the steps for SMOOTH SCROLLING:
  1) Shrink the screen (the border will expand).
  2) Set the scrolling register to maximum (or minimum value depending upon
     the direction of your scroll).
  3) Place the new data on the proper (covered) portion of the screen.
  4) Increment (or decrement) the scrolling register until it reaches the
     maximum (or minimum) value.
  5) At this point, use your machine language routine to shift the entire
     screen one entire character in the direction of the scroll.
  6) Go back to step 2.

    To go into 38 column mode, bit 3 of location 53270 ($D016) must be set
  to a 0. The following POKE does this:

    POKE 53270,PEEK(53270)AND 247

    To return to 40 column mode, set bit 3 of location 53270 ($D016) to a
  1.The following POKE does this:

    POKE 53270,PEEK(53270)OR 8

    To go into 24 row mode, bit 3 of location 53265 ($D011) must be set to
  a 0. The following POKE will do this:

    POKE 53265,PEEK(53265)AND 247

    To return to 25 row mode, set bit 3 of location 53265 ($D011) to a 1.
  The following POKE does this:

    POKE 53265,PEEK(53265)OR 8

    When scrolling in the X direction, it is necessary to place the VIC-II
  chip into 38 column mode. This gives new data a place to scroll from.
  When scrolling LEFT, the new data should be placed on the right. When
  scrolling RIGHT the new data should be placed on the left. Please note
  that there are still 40 columns to screen memory, but only 38 are
  visible.
    When scrolling in the Y direction, it is necessary to place the VIC-II
  chip into 24 row mode. When scrolling UP, place the new data in the LAST
  row. When scrolling DOWN, place the new data on the FIRST row. Unlike X
  scrolling, where there are covered areas on each side of the screen,
  there is only one covered area in Y scrolling. When the Y scrolling
  register is set to 0, the first line is covered, ready for new data. When
  the Y scrolling register is set to 7 the last row is covered.
    For scrolling in the X direction, the scroll register is located in
  bits 2 to 0 of the VIC-II control register at location 53270 ($D016 in
  HEX). As always, it is important to affect only those bits. The following
  POKE does this:

    POKE 53270,(PEEK(53270)AND 248)+X

  where X is the X position of the screen from 0 to 7.
    For scrolling in the Y direction, the scroll register is located in
  bits 2 to 0 of the VIC-II control register at location 53265 ($D011 in
  HEX). As always, it is important to affect only those bits. The following
  POKE does this:

    POKE 53265,(PEEK(53265)AND 248)+Y

  where Y is the Y position of the screen from 0 to 7.
    To scroll text onto the screen from the bottom, you would step the low-
  order 3 bits of location 53265 from 0-7, put more data on the covered
  line at the bottom of the screen, and then repeat the process. To scroll
  characters onto the screen from left to right, you would step the low-
  order 3 bits of location 53270 from 0 to 7, print or POKE another column
  of new data into column 0 of the screen, then repeat the process.
    If you step the scroll bits by -1, your text will move in the opposite
  direction."
"[INST]In the context of the C64, What are the details of the CPX 6502 instruction ?[/INST]CPX                  CPX Compare Memory and Index X                   CPX
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   CPX *Oper           |    E0   |    2    |    2     |
  |  Zero Page     |   CPX Oper            |    E4   |    2    |    3     |
  |  Absolute      |   CPX Oper            |    EC   |    3    |    4     |"
"[INST]In the context of the C64, What is the purpose of the BVS instruction in the 6502 assembly language?[/INST]BVS                    BVS Branch on overflow set                     BVS


 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Relative      |   BVS Oper            |    70   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
"[INST]In the context of the C64, What is the purpose of the BIT instruction in the 6510 assembly language code?[/INST]BIT             BIT Test bits in memory with accumulator              BIT

  Bit 6 and 7 are transferred to the status register.   N Z C I D V
  If the result of A /\ M is zero then Z = 1, otherwise M7/ _ _ _ M6
  Z = 0

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Zero Page     |   BIT Oper            |    24   |    2    |    3     |
  Absolute      |   BIT Oper            |    2C   |    3    |    4     |"
"[INST]In the context of the C64, What is the extended color mode?[/INST]EXTENDED COLOR MODE (ECM = 1, Bmm = MCM = 0)

    The extended color mode allows the selection of individual, background
  colors for each character region with the normal 8*8 character
  resolution. This mode is selected by setting the ECM bit of register 17
  ($11) to '1'. The character dot data is displayed as in the standard mode
  (foreground color determined by the color nybble is displayed for a '1'

  data bit), but the 2 MSB of the character pointer are used to select the
  background color for each character region as follows:


       CHAR. POINTER  |
        MS BIT PAIR   |       BACKGROUND COLOR DISPLAYED FOR 0 BIT
  --------------------+----------------------------------------------------
           00         |  Background #0 color (register 33 ($21))
           01         |  Background #l color (register 34 ($22))
           10         |  Background #2 color (register 35 ($23))
           11         |  Background #3 color (register 36 ($24))

  Since the two MSB of the character pointers are used for color informa-
  tion, only 64 different character definitions are available. The 6566/
  6567 will force CB10 and CB9 to '0' regardless of the original pointer
  values, so that only the first 64 character definitions will be accessed.
  With extended color mode each character has one of sixteen individually
  defined foreground colors and one of the four available background
  colors.

  +-----------------------------------------------------------------------+
  | NOTE: Extended color mode and multi-color mode should not be enabled  |
  | simultaneously.                                                       |
  +-----------------------------------------------------------------------+"
"[INST]In the context of the C64, Describe how to enable sprite?[/INST]SPRITE  ENABLE

    Each sprite can be selectively enabled for display by setting its corre-
  sponding enable bit (MnE) to '1' in register 21 ($15). If the MnE bit is
  '0,' no sprite operations will occur involving the disabled sprite."
"[INST]In the context of the C64, What is the purpose of the Commodore CP/M cartridge?[/INST]Z-80 MICROPROCESSOR CARTRIDGE

  Peripherals are things like Datassette(TM) recorders, disk
  drives, printers, and modems. All these items can be added to your
  Commodore 64 through the various ports and sockets on the back of your
  machine. The thing that makes Commodore peripherals so good is the fact
  that our peripherals are 'intelligent.' That means that they don't take
  up valuable Random Access Memory space when they're in use. You're free
  to use all 64K of memory in your Commodore 64.
    Another advantage of your Commodore 64 is the fact most programs you
  write on your Commodore 64 today will be upwardly compatible with any new
  Commodore computer you buy in the future. This is partially because of
  the qualities of the computer's Operating System (OS).
    However, there is one thing that the Commodore OS can't do: make your
  programs compatible with a computer made by another company.
    Most of the time you won't even have to think about using another com-
  pany's computer, because your Commodore 64 is so easy to use. But for the
  occasional user who wants to take advantage of software that may not be
  available in Commodore 64 format we have created a Commodore CP/M(R)
  cartridge.
    CP/M(R) is not a 'computer dependent' operating system. Instead it uses
  some of the memory space normally available for programming to run its
  own operating system. There are advantages and disadvantages to this. The
  disadvantages are that the programs you write will have to be shorter
  than the programs you can write using the Commodore 64's built-in
  operating system. In addition, you can NOT use the Commodore 64's
  powerful screen editing capabilities. The advantages are that you can now
  use a large amount of software that has been specifically designed for
  CP/M(R) and the Z-80 microprocessor, and the programs that you write
  using the CP/M(R) operating system can be transported and run on any
  other computer that has CP/M(R) and a Z-80 card.
    By the way, most computers that have a Z-80 microprocessor require that
  you go inside the computer to actually install a Z-80 card. With this
  method you have to be very careful not to disturb the delicate circuitry
  that runs the rest of the computer. The Commodore CP/M& cartridge
  eliminates this hassle because our Z-80 cartridge plugs into the back of
  your Commodore 64 quickly and easily, without any messy wires that can
  cause problems later."
"[INST]In the context of the C64, What is the function of the START bit in the 6256 CRA control register?[/INST]6256 CONTROL REGISTERS

    There are two control registers in the 6526, CRA and CRB. CRA is
  associated with TIMER A and CRB is associated with TIMER B. The register
  format is as follows:

  CRA:
  Bit  Name    Function
   0  START    1=START TIMER A, 0=STOP TIMER A. This bit is automatically
               reset when underflow occurs during one-shot mode.
   1  PBON     1=TIMER A output appears on PB6, 0=PB6 normal operation.

   2  OUTMODE  1=TOGGLE, 0=PULSE
   3  RUNMODE  1=ONE-SHOT, 0=CONTINUOUS
   4  LOAD     1=FORCE LOAD (this is a STROBE input, there is no data
               storage, bit 4 will always read back a zero and writing a
               zero has no effect).
   5  INMODE   1=TIMER A counts positive CNT transitions, 0=TIMER A counts
               02 pulses.
   6  SPMODE   1=SERIAL PORT output (CNT sources shift clock),
               0=SERIAL PORT input (external shift clock required).
   7  TODIN    1=50 Hz clock required on TOD pin for accurate time,
               0=60 Hz clock required on TOD pin for accurate time.
  CRB:
  Bit  Name    Function
               (Bits CRB0-CRB4 are identical to CRA0-CRA4 for TIMER B with
               the exception that bit 1 controls the output of TIMER B on
               PB7).
  5,6 INMODE   Bits CRB5 and CRB6 select one of four input modes for
               TIMER B as:
               CRB6   CRB5
                0      0       TIMER B counts 02 pulses.
                0      1       TIMER B counts positive CNT transistions.
                1      0       TIMER B counts TIMER A underflow pulses.
                1      1       TIMER B counts TIMER A underflow pulses
                               while CNT is high.
  7   ALARM     1=writing to TOD registers sets ALARM, 0=writing to TOD
                registers sets TOD clock.

  

  All unused register bits are unaffected by a write and are forced to zero
  on a read.
  +-----------------------------------------------------------------------+
  | COMMODORE SEMICONDUCTOR GROUP reserves the right to make changes to   |
  | any products herein to improve reliability, function or design.       |
  | COMMODORE SEMICONDUCTOR GROUP does not assume any liability arising   |
  | out of the application or use of any product or circuit described     |
  | herein; neither does it convey any license under its patent rights nor|
  | the rights of others.                                                 |
  +-----------------------------------------------------------------------+"
"[INST]In the context of the C64, What is the purpose of the SERIAL ATN OUT signal in the Commodore 64?[/INST]SERIAL ATN OUT: (SERIAL ATTENTION OUT)

    The Commodore 64 uses this signal to start a command sequence for a
  device on the serial bus. When the Commodore 64 brings this signal LOW,
  all other devices on the bus start listening for the Commodore 64 to
  transmit an address. The device addressed must respond in a preset period
  of time; otherwise, the Commodore 64 will assume that the device
  addressed is not on the bus, and will return an error in the STATUS WORD."
"[INST]In the context of the C64, What are the screen display codes?[/INST]SCREEN DISPLAY CODES

    The following chart lists all of the characters built into the
  Commodore 64 character sets. It shows which numbers should be POKED into
  screen memory (locations 1024-2023) to get a desired character. Also
  shown is which character corresponds to a number PEEKed from the screen.
    Two character sets are available, but only one set at a time. This
  means that you cannot have characters from one set on the screen at the
  same time you have characters from the other set displayed. The sets are
  switched by holding down the <SHIFT> and <C=> keys simultaneously.
    From BASIC, POKE 53272,21 will switch to upper case mode and
  POKE 53272,23 switches to lower case.
    Any number on the chart may also be displayed in REVERSE. The reverse
  character code may be obtained by adding 128 to the values shown.
    If you want to display a solid circle at location 1504, POKE the code
  for the circle (81) into location 1504: POKE 1504,81.
    There is a corresponding memory location to control the color of each
  character displayed on the screen (locations 55296-56295). To change the
  color of the circle to yellow (color code 7) you would POKE the corre-
  sponding memory location (55776) with the character color: POKE 55776,7.
    Refer to Appendix D for the complete screen and color memory maps,
  along with color codes.

  | NOTE: The following POKEs display the same symbol in set 1 and 2: 1,  |
  | 27-64, 91-93, 96-104, 106-121, 123-127.                               |"
"[INST]In the context of the C64, What is the purpose of the video matrix counter?[/INST]VCx denotes the video matrix counter outputs, RCx denotes the 3-bit
  raster line counter and CB13 is from register 24 ($18). The video matrix
  counter steps through the same 40 locations for eight raster lines, con-
  tinuing to the next 40 locations every eighth line, while the raster
  counter increments once for each horizontal video line (raster line).
  This addressing results in each eight sequential memory locations being
  formatted as an 8*8 dot block on the video display."
"[INST]In the context of the C64, Describe how color works for sprites[/INST]COLOR

    Each sprite has a separate 4-bit register to determine the sprite color. The
  two sprite color modes are:

  STANDARD sprite (MnMC = 0)

    In the standard mode, a '0' bit of sprite data allows any background data
  to show through (transparent) and a '1' bit is displayed as the sprite color
  determined by the corresponding sprite Color register.

  MULTI-COLOR sprite (MnMC = 1)

    Each sprite can be individually selected as a multi-color sprite via MnMC
  bits in the sprite Multi-color register 28 ($1C). When the MnMC bit is '1',
  the corresponding sprite is displayed in the multi-color mode. In the multi-
  color mode, the sprite data is interpreted in pairs (similar to the other
  multi-color modes) as follows:

        BIT PAIR      |                   COLOR DISPLAYED
           00         |  Transparent
           01         |  sprite Multi-color #0 (register 37 ($25))
           10         |  sprite Color (registers 39-46 ($27-$2E))
           11         |  sprite Multi-color #1 (register 38 ($26))


  Since two bits of data are required for each color, the resolution of the
  sprite is reduced to 12X21, with each horizontal dot expanded to twice
  standard size so that the overall sprite size does not change. Note that up
  to 3 colors can be displayed in each sprite (in addition to transparent) but
  that two of the colors are shared among all the sprites in the multi-color
  mode."
"[INST]In the context of the C64, What are the details for the 6502 DEC instruction?[/INST]DEC                   DEC Decrement memory by one                     DEC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   DEC Oper            |    C6   |    2    |    5     |
  |  Zero Page,X   |   DEC Oper,X          |    D6   |    2    |    6     |
  |  Absolute      |   DEC Oper            |    CE   |    3    |    6     |
  |  Absolute,X    |   DEC Oper,X          |    DE   |    3    |    7     |"
"[INST]In the context of the C64, What is the purpose of the instruction CLD"" in the 6502 assembly language code?""[/INST]CLD                      CLD Clear decimal mode                       CLD


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLD                 |    D8   |    1    |    2     |"
"[INST]In the context of the C64, WHow do I set a sprite off?[/INST]TURNING SPRITES OFF

A sprite is turned off by setting its bit in the VIC-II control register at 53269 ($D015 in HEX) to a 0. The following POKE will do this:

    POKE 53269,PEEK(53269)AND(255-2^SN)

where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, What are the key features of sprites in the VIC-II chip?[/INST]SPRITES

    A SPRITE is a special type of user definable character which can be
  displayed anywhere on the screen. Sprites are maintained directly by the
  VIC-II chip. And all you have to do is tell a sprite 'what to look like,'
  'what color to be,' and 'where to appear.' The VIC-II chip will do the
  rest! Sprites can be any of the 16 colors available.
    Sprites can be used with ANY of the other graphics modes, bit mapped,
  character, multi-color, etc., and they'll keep their shape in all of
  them. The sprite carries its own color definition, its own mode (HI-RES
  or multi-colored), and its own shape.
    Up to 8 sprites at a time can be maintained by the VIC-II chip auto-
  matically. More sprites can be displayed using RASTER INTERRUPT
  techniques.

    The features of SPRITES include:

    1) 24 horizontal dot by 21 vertical dot size.
    2) Individual color control for each sprite.
    3) Sprite multi-color mode.
    4) Magnification (2x) in horizontal, vertical, or both directions.
    5) Selectable sprite to background priority.
    6) Fixed sprite to sprite priorities.
    7) Sprite to sprite collision detection.
    8) Sprite to background collision detection."
"[INST]In the context of the C64, What is the primary function of the OSC 3 register ?[/INST]OSC 3/RANDOM (Register $1B)

    This register allows the microprocessor to read the upper 8 output bits
  of Oscillator 3. The character of the numbers generated is directly re-
  lated to the waveform selected. If the Sawtooth waveform of Oscillator 3
  is selected, this register will present a series of numbers incrementing
  from 0 to 255 ($FF) at a rate determined by the frequency of Oscillator
  3. If the Triangle waveform is selected, the output will increment from 0
  up to 255, then decrement down to 0. If the Pulse waveform is selected,
  the output will jump between 0 and 255. Selecting the Noise waveform
  will produce a series of random numbers, therefore, this register can be
  used as a random number generator for games. There are numerous timing
  and sequencing applications for the OSC 3 register, however, the chief
  function is probably that of a modulation generator. The numbers
  generated by this register can be added, via software, to the Oscillator
  or Filter Frequency registers or the Pulse Width registers in real-time.
  Many dynamic effects can be generated in this manner. Siren-like sounds
  can be created by adding the OSC 3 Sawtooth output to the frequency
  control of another oscillator. Synthesizer 'Sample and Hold' effects can
  be produced by adding the OSC 3 Noise output to the Filter Frequency
  control registers. Vibrato can be produced by setting Oscillator 3 to a
  frequency around 7 Hz and adding the OSC 3 Triangle output (with proper
  scaling) to the Frequency control of another oscillator. An unlimited
  range of effects are available by altering the frequency of Oscillator 3
  and scaling the OSC 3 output. Normally, when Oscillator 3 is used for
  modulation, the audio output of Voice 3 should be eliminated (3 OFF = 1)."
"[INST]In the context of the C64, What is the SID CONTROL REGISTER (Register 04)?[/INST]CONTROL REGISTER (Register 04)

    This register contains eight control bits which select various options
  on Oscillator 1.
    GATE (Bit 0): The GATE bit controls the Envelope Generator for Voice 1.
  When this bit is set to a one, the Envelope Generator is Gated
  (triggered) and the ATTACK/DECAY/SUSTAIN cycle is initiated. When the bit
  is reset to a zero, the RELEASE cycle begins. The Envelope Generator
  controls the amplitude of Oscillator I appearing at the audio output,
  therefore, the GATE bit must be set (along with suitable envelope pa-
  rameters) for the selected output of Oscillator 1 to be audible. A de-
  tailed discussion of the Envelope Generator can be found at the end of
  this Appendix.
    SYNC (Bit 1): The SYNC bit, when set to a one, synchronizes the
  fundamental frequency of Oscillator 1 with the fundamental frequency of
  Oscillator 3, producing 'Hard Sync' effects.
    Varying the frequency of Oscillator 1 with respect to Oscillator 3 pro-
  duces a wide range of complex harmonic structures from Voice I at the
  frequency of Oscillator 3. In order for sync to occur, Oscillator 3 must
  be set to some frequency other than zero but preferably lower than the
  frequency of Oscillator 1. No other parameters of Voice 3 have any effect
  on sync.
    RING MOD (Bit 2): The RING MOD bit, when set to a one, replaces the
  Triangle waveform output of Oscillator 1 with a 'Ring Modulated'
  combination of Oscillators 1 and 3. Varying the frequency of Oscillator 1
  with respect to Oscillator 3 produces a wide range of non-harmonic
  overtone structures for creating bell or gong sounds and for special ef-
  fects. In order for ring modulation to be audible, the Triangle waveform
  of Oscillator 1 must be selected and Oscillator 3 must be set to some
  frequency other than zero. No other parameters of Voice 3 have any effect
  on ring modulation.
    TEST (Bit 3): The TEST bit, when set to a one, resets and locks Oscil-
  lator 1 at zero until the TEST bit is cleared. The Noise waveform output
  of Oscillator 1 is also reset and the Pulse waveform output is held at a
  DC level. Normally this bit is used for testing purposes, however, it can
  be used to synchronize Oscillator 1 to external events, allowing the
  generation of highly complex waveforms under real-time software control.
  (Bit 4): When set to a one, the Triangle waveform output of Oscillator
  1 is selected. The Triangle waveform is low in harmonics and has a
  mellow, flute-like quality.
    (Bit 5): When set to a one, the Sawtooth waveform output of Oscillator
  1 is selected. The Sawtooth waveform is rich in even and odd harmonics
  and has a bright, brassy quality.
    (Bit 6): When set to a one, the Pulse waveform output of Oscillator 1
  is selected. The harmonic content of this waveform can be adjusted by the
  Pulse Width registers, producing tone qualities ranging from a bright,
  hollow square wave to a nasal, reedy pulse. Sweeping the pulse width in
  real-time produces a dynamic 'phasing' effect which adds a sense of
  motion to the sound. Rapidly jumping between different pulse widths can
  produce interesting harmonic sequences.
    NOISE (Bit 7): When set to a one, the Noise output waveform of
  Oscillator 1 is selected. This output is a random signal which changes at
  the frequency of Oscillator 1. The sound quality can be varied from a low
  rumbling to hissing white noise via the Oscillator 1 Frequency registers.
  Noise is useful in creating explosions, gunshots, jet engines, wind, surf
  and other unpitched sounds, as well as snore drums and cymbals. Sweeping
  the oscillator frequency with Noise selected produces a dramatic rushing
  effect.
    One of the output waveforms must be selected for Oscillator 1 to be
  audible, however, it is NOT necessary to de-select waveforms to silence
  the output of Voice 1. The amplitude of Voice 1 at the final output is a
  function of the Envelope Generator only.


  +-----------------------------------------------------------------------+
  | NOTE: The oscillator output waveforms are NOT additive. If more than  |
  | one output waveform is selected simultaneously, the result will be a  |
  | logical ANDing of the waveforms. Although this technique can be used  |
  | to generate additional waveforms beyond the four listed above, it must|
  | be used with care. If any other waveform is selected while Noise is   |
  | on, the Noise output can 'lock up ' If this occurs, the Noise output  |
  | will remain silent until reset by the TEST bit or by bringing RES     |
  | (pin 5) low.                                                          |
  +-----------------------------------------------------------------------+"
"[INST]In the context of the C64, What features does the VIC-II chip support in terms of sprite capabilities?[/INST]These special sprite abilities make it simple to program many arcade
  style games. Because the sprites are maintained by hardware, it is even
  possible to write a good quality game in BASIC!
    There are 8 sprites supported directly by the VIC-II chip. They are
  numbered from 0 to 7. Each of the sprites has it own definition location,
  position registers and color register, and has its own bits for enable
  and collision detection."
"[INST]In the context of the C64, What are the memory locations of the color registers on C64?[/INST]SPRITE COLORS

    A sprite can be any of the 16 colors generated by the VIC-II chip. Each
  of the sprites has its own sprite color register. These are the memory
  locations of the color registers:


        53287   ($D027)     description:    SPRITE 0 COLOR REGISTER
        53288   ($D028)     description:    SPRITE 1 COLOR REGISTER
        53289   ($D029)     description:    SPRITE 2 COLOR REGISTER
        53290   ($D02A)     description:    SPRITE 3 COLOR REGISTER
        53291   ($D02B)     description:    SPRITE 4 COLOR REGISTER
        53292   ($D02C)     description:    SPRITE 5 COLOR REGISTER
        53293   ($D02D)     description:    SPRITE 6 COLOR REGISTER
        53294   ($D02E)     description:    SPRITE 7 COLOR REGISTER

    All dots in the sprite will be displayed in the color contained in the
  sprite color register. The rest of the sprite will be transparent, and
  will show whatever is behind the sprite."
"[INST]In the context of the C64, What is the purpose of the CLC instruction in the assembly language?[/INST]CLC                       CLC Clear carry flag                        CLC

Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLC                 |    18   |    1    |    2     |"
"[INST]In the context of the C64, What is the assembly language form of the CPY instruction in the Zero Page addressing mode?[/INST]CPY                  CPY Compare memory and index Y                   CPY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   CPY *Oper           |    C0   |    2    |    2     |
  |  Zero Page     |   CPY Oper            |    C4   |    2    |    3     |
  |  Absolute      |   CPY Oper            |    CC   |    3    |    4     |"
"[INST]In the context of the C64, How to control the sprite magnification?[/INST]MAGNIFICATION

    Each sprite can be selectively expanded (2X) in both the horizontal and
  vertical directions. Two registers contain the control bits (MnXE,MnYE)
  for the magnification control.


    REGISTER  |                        FUNCTION
     23 ($17) | Horizontal expand MnXE-'1'=expand; '0'=normal
     29 ($1D) | Vertical expand MnYE-'1'=expand; '0'=normal

  When sprites are expanded, no increase in resolution is realized. The same
  24*21 array (12X21 if multi-colored) is displayed, but the overall sprite
  dimension is doubled in the desired direction (the smallest sprite dot may
  be up to 4X standard dot dimension if a sprite is both multi-colored and
  expanded)."
"[INST]In the context of the C64, What is the purpose of the color nybble in standard bit map mode?[/INST]STANDARD BIT MAP MODE (BMM =1, MCM = 0)

    When standard bit map mode is in use, the color information is derived
  only from the data stored in the video matrix (the color nybble is
  disregarded). The 8 bits are divided into two 4-bit nybbles which allow
  two colors to be independently selected in each 8*8 dot block. When a bit
  in the display memory is a '0' the color of the output dot is set by the
  least significant (lower) nybble (LSN). Similarly, a display memory bit
  of '1' selects the output color determined by the MSN (upper nybble).

      BIT    |            DISPLAY COLOR
       0     |   Lower nybble of video matrix pointer
       1     |   Upper nybble of video matrix pointer"
"[INST]In the context of the C64, What is the purpose of the SRQ?[/INST]SERIAL SRQ IN: (SERIAL SERVICE REQUEST IN)

    Any device on the serial bus can bring this signal LOW when it requires
  attention from the Commodore 64. The Commodore 64 will then take care of
  the device. (See Figure 6-4)."
"[INST]In the context of the C64, describe the 6526 Interrupt Control Register?[/INST]Interrupt Control (ICR)

    There are five sources of interrupts on the 6526: underflow from TIMER
  A, underflow from TIMER B, TOD ALARM, Serial Port full/empty and /FLAG.
  A single register provides masking and interrupt information. The
  interrupt Control Register consists of a write-only MASK register and a
  read-only DATA register. Any interrupt will set the corresponding bit in
  the DATA register. Any interrupt which is enabled by the MASK register
  will set the IR bit (MSB) of the DATA register and bring the /IRQ pin
  low. In a multi-chip system, the IR bit can be polled to detect which
  chip has generated an interrupt request. The interrupt DATA register is
  cleared and the /IRQ line returns high following a read of the DATA
  register. Since each interrupt sets an interrupt bit regardless of the
  MASK, and each interrupt bit can be selectively masked to prevent the
  generation of a processor interrupt, it is possible to intermix polled
  interrupts with true interrupts. However, polling the IR bit will cause
  the DATA register to clear, therefore, it is up to the user to preserve
  the information contained in the DATA register if any polled interrupts
  were present.
    The MASK register provides convenient control of individual mask bits.
  When writing to the MASK register, if bit 7 (SET/CLEAR) of the data
written is a ZERO, any mask bit written with a one will be cleared, while
  those mask bits written with a zero will be unaffected. If bit 7 of the
  data written is a ONE, any mask bit written with a one will be set, while
  those mask bits written with a zero will be unaffected. In order for an
  interrupt flag to set IR and generate an Interrupt Request, the corre-
  sponding MASK bit must be set."
"[INST]In the context of the C64, What are the details 6510 microprocessor chip?[/INST]6510 MICROPROCESSOR CHIP
  SPECIFICATIONS

  DESCRIPTION

    The 6510 is a low-cost microcomputer system capable of solving a broad
  range of small-systems and peripheral-control problems at minimum cost to
  the user.
    An 8-bit Bi-Directional I/O Port is located on-chip with the Output
  Register at Address 0000 and the Data-Direction Register at Address 0001.
  The I/O Port is bit-by-bit programmable.
    The Three-State sixteen-bit Address Bus allows Direct Memory Accessing
  (DMA) and multiprocessor systems sharing a common memory.
    The internal processor architecture is identical to the MOS Technology
  6502 to provide software compatibility.


  FEATURES OF THE 6510...

  o Eight-Bit Bi-Directional I/O Port
  o Single +5-volt supply
  o N-channel, silicon gate, depletion load technology
  o Eight-bit parallel processing
  o 56 Instructions
  o Decimal and binary arithmetic
  o Thirteen addressing modes
  o True indexing capability
  o Programmable stack pointer
  o Variable length stack
  o Interrupt capability
  o Eight-Bit Bi-Directional Data Bus
  o Addressable memory range of up to 64K bytes
  o Direct memory access capability
  o Bus compatible with M6800
  o Pipeline architecture
  o 1-MHz and 2-MHz operation
  o Use with any type or speed memory"
"[INST]In the context of the C64, What is the 6526 handshaking?[/INST]6256 Handshaking

    Handshaking on data transfers can be accomplished using the /PC output
  pin and the FLAG input pin. PC will go low for one cycle following a read
  or write of PORT B. This signal can be used to indicate 'data ready' at
  PORT B or 'data accepted' from PORT B. Handshaking on 16-bit data
  transfers (using both PORT A and PORT B) is possible by always reading or
  writing PORT A first. /FLAG is a negative edge sensitive input which can
  be used for receiving the /PC output from another 6526, or as a general
  purpose interrupt input. Any negative transition of /FLAG will set the
  /FLAG interrupt bit.


  Interval Timers (Timer A, Timer B)

    Each interval timer consists of a 16-bit read-only Timer Counter and a
  16-bit write-only Timer Latch. Data written to the timer are latched in
  the Timer Latch, while data read from the timer are the present contents
  of the Time Counter. The timers can be used independently or linked for
  extended operations. The various timer modes allow generation of long
  time delays, variable width pulses, pulse trains and variable frequency
  waveforms. Utilizing the CNT input, the timers can count external pulses
  or measure frequency, pulse width and delay times of external signals.
  Each timer has an associated control register, providing independent
  control of the following functions:

  Start/Stop

    A control bit allows the timer to be started or stopped by the micro-
  processor at any time.

  PB On/Off:

    A control bit allows the timer output to appear on a PORT B output line
  (PB6 for TIMER A and PB7 for TIMER B). This function overrides the DDRB
  control bit and forces the appropriate PB line to an output.

  Toggle/Pulse

    A control bit selects the output applied to PORT B. On every timer
  underflow the output can either toggle or generate a single positive
  pulse of one cycle duration. The Toggle output is set high whenever the
  timer is started and is set low by /RES.

  One-Shot/Continuous

    A control bit selects either timer mode. In one-shot mode, the timer
  will count down from the latched value to zero, generate an interrupt,
  reload the latched value, then stop. In continuous mode, the timer will
  count from the latched value to zero, generate' an interrupt, reload the
  latched value and repeat the procedure continuously.

  Force Load

    A strobe bit allows the timer latch to be loaded into the timer counter
  at any time, whether the timer is running or not.

  Input Mode:

    Control bits allow selection of the clock used to decrement the timer.
  TIMER A can count 02 clock pulses or external pulses applied to the CNT
  pin. TIMER B can count (02 pulses, external CNT pulses, TIMER A underflow
  pulses or TIMER A underflow pulses while the CNT pin is held high.

    The timer latch is loaded into the timer on any timer underflow, on a
  force load or following a write to the high byte of the prescaler while
  the timer is stopped. If the timer is running, a write to the high byte
  will load the timer latch, but not reload the counter."
"[INST]In the context of the C64, describe the BCS (Branch on Carry Set) operation?[/INST]BCS                      BCS Branch on carry set                      BCS

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Relative      |   BCS Oper            |    B0   |    2    |    2*    |
  * Add 1 if branch occurs to same  page.
  * Add 2 if branch occurs to next  page."
"[INST]In the context of the C64, What is the purpose of the stack in the 6510 microprocessor?[/INST]THE STACK

    The 6510 microprocessor has what is known as a stack. This is used by
  both the programmer and the microprocessor to temporarily remember
  things, and to remember, for example, an order of events. The GOSUB
  statement in BASIC, which allows the programmer to call a subroutine,
  must remember where it is being called from, so that when the RETURN
  statement is executed in the subroutine, the BASIC interpreter 'knows'
  where to go back to continue executing. When a GOSUB statement is
  encountered in a program by the BASIC interpreter, the BASIC interpreter
  'pushes' its current position onto the stack before going to do the
  subroutine, and when a RETURN is executed, the interpreter 'pulls' off
  the stack the information that tells it where it was before the
  subroutine call was made. The interpreter uses instructions like PHA,
  which pushes the contents of the accumulator onto the stack, and PLA (the
  reverse) which pulls a value off the stack and into the accumulator. The
  status register can also be pushed and pulled with the PHP and PLP,
  respectively.

    The stack is 256 bytes long, and is located in page one of memory. It
  is therefore from $01 00 to $01 FF. It is organized backwards in memory.
  In other words, the first position in the stack is at $01 FF, and the
  last is at $0100. Another register in the 651 0 microprocessor is called
  the stack pointer, and it always points to the next available location in
  the stack. When something is pushed onto the stack, it is placed where
  the stack pointer points to, and the stack pointer is moved down to the
  next position (decremented). When something is pulled off the stack, the
  stack pointer is incremented, and the byte pointed to by the stack
  pointer is placed into the specified register.

  The implied mode means that information isimplied by an instruction itself. In other words, what registers, flags,
  and memory the instruction is referring to. The examples we have seen are
  PHA, PLA, PHP, and PLP, which refer to stack processing and the
  accumulator and status registers, respectively.


NOTE: The X register will be referred to as X from now on, and similarly A (accumulator), Y (Y index register), S (stack pointer), and P (processor status).           |"
"[INST]In the context of the C64, how do i set the multi color mode?[/INST]MULTI-COLOR MODE BIT

    To turn on multi-color character mode, set bit 4 of the VIC-II control
  register at 53270 ($D016) to a 1 by using the following POKE:

    POKE 53270,PEEK(53270)OR 16

    To turn off multi-color character mode, set bit 4 of location 53270 to
  a 0 by the following POKE:

    POKE 53270,PEEK(53270)AND 239

    Multi-color mode is set on or off for each space on the screen, so that
  multi-color graphics can be mixed with high-resolution (hi-res) graphics.
  This is controlled by bit 3 in color memory. Color memory begins at
  location 55296 ($D800 in HEX). If the number in color memory is less than
  8 (0-7) the corresponding space on the video screen will be standard
  hi-res, in the color (0-7) you've chosen. If the number located in color
  memory is greater or equal
 to 8 (from 8 to 15), then that space will be displayed in multi-color mode.

    By POKEing a number into color memory, you can change the color of the
  character in that position on the screen. POKEing a number from 0 to 7
  gives the normal character colors. POKEing a number between 8 and 15 puts
  the space into multi-color mode. In other words, turning BIT 3 ON in
  color memory, sets MULTI-COLOR MODE. Turning BIT 3 OFF in color memory,
  sets the normal, HIGH-RESOLUTION mode.
    Once multi-color mode is set in a space, the bits in the character
  determine which colors are displayed for the dots. 

    In normal or high-resolution mode, the screen color is displayed
  everywhere there is a 0 bit, and the character color is displayed where
  the bit is a 1. Multi-color mode uses the bits in pairs

  The bit pairs determine
  this, according to the following chart:


  BIT PAIR - COLOR REGISTER - LOCATION
  00 - Background #0 color (screen color) - 53281 ($D021) 
  01 - Background #l color - 53282 ($D022) 
  10 - Background #2 color - 53283 ($D023) 
  11 - Color specified by the lower 3 bits in color memory - color RAM"
"[INST]In the context of the C64, What is the purpose of the raster register in a display system?[/INST]RASTER REGISTER

    The raster register is a dual-function register. A read of the raster
  register 18 ($12) returns the lower 8 bits of the current raster position
  (the MSB-RC8 is located in register 17 ($11)). The raster register can be
  interrogated to implement display changes outside the visible area to
  prevent display flicker. The visible display window is from raster 51
  through raster 251 ($033-$0FB). A write to the raster bits (including
  RC8) is latched for use in an internal raster compare. When the current
  raster matches the written value, the raster interrupt latch is set."
"[INST]In the context of the C64, What are the key components of the 6581 synthesizer chip?[/INST]DESCRIPTION

    The 6581 consists of three synthesizer 'voices' which can be used
  independently or in conjunction with each other (or external audio
  sources) to create complex sounds. Each voice consists of a Tone
  Oscillator/Waveform Generator, an Envelope Generator and an Amplitude
  Modulator. The Tone Oscillator controls the pitch of the voice over a
  wide range. The Oscillator produces four waveforms at the selected
  frequency, with the unique harmonic content of each waveform providing
  simple control of tone color. The volume dynamics of the oscillator are
  controlled by the Amplitude Modulator under the direction of the Envelope
  Generator. When triggered, the Envelope Generator creates an amplitude
  envelope with programmable rates of increasing and decreasing volume. In
  addition to the three voices, a programmable Filter is provided for
  generating complex, dynamic tone colors via subtractive synthesis.
    SID allows the microprocessor to read the changing output of the third
  Oscillator and third Envelope Generator. These outputs can be used as a
  source of modulation information for creating vibrato, frequency/filter
  sweeps and similar effects. The third oscillator can also act as a random
  number generator for games. Two A/D converters are provided for inter-
  facing SID with potentiometers. These can be used for 'paddles' in a
  game environment or as front panel controls in a music synthesizer. SID
  can process external audio signals, allowing multiple SID chips to be
  daisy-chained or mixed in complex polyphonic systems."
"[INST]In the context of the C64, What is the purpose of the command `POKE 53270, PEEK(53270) OR 16` in the context of changing character colors?[/INST]By using the <C=> key and the COLOR keys the characters can be changed to any color, including multi-color characters. For example, type this command:

 POKE 53270,PEEK(53270)OR 16:PRINT'<CTRL+3>';: rem lt.red/ multi-color red

 The word READY and anything else you type will be displayed in multi-color mode. Another color control can set you back to regular text."
"[INST]In the context of the C64, Can you talk about the zero page addressing mode?[/INST]ADDRESSING MODES

  ZERO PAGE

  Absolute addresses are expressed in terms of a high
  and a low order byte. The high order byte is often referred to as the
  page of memory. For example, the address $1637 is in page $16 (22), and
  $0277 is in page $02 (2). There is, however, a special mode of addressing
  known as zero page addressing and is, as the name implies, associated
  with the addressing of memory locations in page zero. These addresses,
  therefore, ALWAYS have a high order byte of zero. The zero page mode of
  addressing only expects one byte to describe the address, rather than two
  when using an absolute address. The zero page addressing mode tells the
  microprocessor to assume that the high order address is zero. Therefore
  zero page addressing can reference memory locations whose addresses are
  between $0000 and $00FF. This may not seem too important at the moment,
  but you'll need the principles of zero page addressing soon."
"[INST]In the context of the C64, Describe the BCC (Branch if Carry Clear) instruction?[/INST]BCC                     BCC Branch on Carry Clear                     BCC


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Relative      |   BCC Oper            |    90   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
"[INST]In the context of the C64, What is the CP/M?[/INST]USING COMMODORE CP/M(R)

    The Commodore Z-80 cartridge let's you run programs designed for a Z-80
  microprocessor on your Commodore 64. The cartridge is provided with a
  diskette containing the Commodore CP/M(R) operating system.

  RUNNING COMMODORE CP/M(R)

    To run CP/M(R):

      1) LOAD the CP/M(R) program from your disk drive.
      2) Type RUN.
      3) Hit the <RETURN> key.
    At this point the 64K bytes of RAM in the Commodore 64 are accessible
  by the built-in 6510 central processor, OR 48K bytes of RAM are available
  for the Z-80 central processor. You can shift back and forth between
  these two processors, but you can NOT use them at the same time in a
  single program. This is possible because of your Commodore 64's
  sophisticated timing mechanism.
    Below is the memory address translation that is performed on the Z-80
  cartridge. You should notice that by adding 4096 bytes to the memory
  locations used in CP/M(R) $1000 (hex) you equal the memory addresses of
  the normal Commodore 64 operating system. The correspondence between Z-80
  and 6510 memory addresses is as follows:"
"[INST]In the context of the C64, What are the error messages generated by the Commodore-64?[/INST]ERROR MESSAGES

    This appendix contains a complete list of the error messages generated
  by the Commodore-64, with a description of causes.


  BAD DATA            String data was received from an open file, but the
                      program was expecting numeric data.
  BAD SUBSCRIPT       The program was trying to reference an element of an
                      array whose number is outside of the range specified
                      in the DIM statement.
  BREAK               Program execution was stopped because you hit the
                      <STOP> key.
  CAN'T CONTINUE      The CONT command will not work, either because the
                      program was never RUN, there has been an error, or
                      a line has been edited.
  DEVICE NOT PRESENT  The required I/O device was not available for an
                      OPEN, CLOSE, CMD, PRINT#, INPUT#, or GET#.
  DIVISION BY ZERO    Division by zero is a mathematical oddity and not
                      allowed.
  EXTRA IGNORED       Too many items of data were typed in response to an
                      INPUT statement. Only the first few items were
                      accepted.
  FILE NOT FOUND      If you were looking for a file on tape, and END-OF-
                      TAPE marker was found. If you were looking on disk,
                      no file with that name exists.
  FILE NOT OPEN       The file specified in a CLOSE, CMD, PRINT#, INPUT#,
                      or GET#, must first be OPENed.
  FILE OPEN           An attempt was made to open a file using the number
                      of an already open file.
  FORMULA TOO COMPLEX The string expression being evaluated should be split
                      into at least two parts for the system to work with,
                      or a formula has too many parentheses.
  ILLEGAL DIRECT      The INPUT statement can only be used within a pro-
                      gram, and not in direct mode.
  ILLEGAL QUANTITY    A number used as the argument of a function or
                      statement is out of the allowable range.
  LOAD                There is a problem with the program on tape.
  NEXT WITHOUT FOR    This is caused by either incorrectly nesting loops or
                      having a variable name in a NEXT statement that
                      doesn't correspond with one in a FOR statement.
  NOT INPUT FILE      An attempt was made to INPUT or GET data from a file
                      which was specified to be for output only.
  NOT OUTPUT FILE     An attempt was mode to PRINT data to a file which was
                      specified as input only.
  OUT OF DATA         A READ statement was executed but there is no data
                      left unREAD in a DATA statement.
  OUT OF MEMORY       There is no more RAM available for program or
                      variables. This may also occur when too many FOR
                      loops have been nested, or when there are too many
                      GOSUBs in effect.
  OVERFLOW            The result of a computation is larger than the
                      largest number allowed, which is 1.70141884E+38.
  REDIM'D ARRAY       An array may only be DiMensioned once. If an array
                      variable is used before that array is DIM'D, an
                      automatic DIM operation is performed on that array
                      setting the number of elements to ten, and any
                      subsequent DIMs will cause this error.
  REDO FROM START     Character data was typed in during an INPUT statement
                      when numeric data was expected. Just re-type the
                      entry so that it is correct, and the program will
                      continue by itself.
  RETURN WITHOUT GOSUB  A RETURN statement was encountered, and no GOSUB
                      command has been issued.
  STRING TOO LONG     A string can contain up to 255 characters.
  ?SYNTAX ERROR       A statement is unrecognizable by the Commodore 64. A
                      missing or extra parenthesis, misspelled keywords,
                      etc.
  TYPE MISMATCH       This error occurs when a number is used in place of a
                      string, or vice-versa.
  UNDEF'D FUNCTION    A user defined function was referenced, but it has
                      never been defined using the DEF FN statement.
  UNDEF'D STATEMENT   An attempt was made to GOTO or GOSUB or RUN a line
                      number that doesn't exist.
  VERIFY              The program on tape or disk does not match the
                      program currently in memory."
"[INST]In the context of the C64, What is the primary function of the Time of Day (TOD) clock?[/INST]Time of Day Clock (TOD)

    The TOD clock is a special purpose timer for real-time applications.
  TOD consists of a 24-hour (AM/PM) clock with 1/10th second resolution. It
  is organized into 4 registers: 10ths of seconds, Seconds, Minutes and
  Hours. The AM/PM flag is in the MSB of the Hours register for easy bit
  testing. Each register reads out in BCD format to simplify conversion for
  driving displays, etc. The clock requires an external 60 Hz or 50 Hz
  (programmable) TTL level input on the TOD pin for accurate time-keeping.
  In addition to time-keeping, a programmable ALARM is provided for
  generating an interrupt at a desired time. The ALARM registers or located
  at the same addresses as the corresponding TOD registers. Access to the
  ALARM is governed by a Control Register bit. The ALARM is write-only; any
  read of a TOD address will read time regardless of the state of the ALARM
  access bit.
    A specific sequence of events must be followed for proper setting and
  reading of TOD. TOD is automatically stopped whenever a write to the
  Hours register occurs. The clock will not start again until after a write
  to the 10ths of seconds register. This assures TOD will always start at
  the desired time. Since a carry from one stage to the next can occur at
  any time with respect to a read operation, a latching function is
  included to keep all Time Of Day information constant during a read
  sequence. All four TOD registers latch on a read of Hours and remain
  latched until after a read of 10ths of seconds. The TOD clock continues
  to count when the output registers are latched. If only one register is
  to be read, there is no carry problem and the register can be read 'on
  the fly,' provided that any read of Hours is followed by a read of 10ths
  of seconds to disable the latching."
"[INST]In the context of the C64, What is the maximum number of unique sprites that can be displayed simultaneously?[/INST]SPRITES

    The movable object block (sprite) is a special type of character which can
  be displayed at any one position on the screen without the block
  constraints inherent in character and bit map mode. Up to 8 unique sprites
  can be displayed simultaneously, each defined by 63 bytes in memory which
  are displayed as a 24*21 dot array (shown below). A number of special
  features make sprites especially suited for video graphics and game
  applications.


                              sprite DISPLAY BLOCK
                        |  BYTE  |  BYTE  |  BYTE  |
                        |   00   |   01   |   02   |
                        |   03   |   04   |   05   |
                        |    .   |    .   |    .   |
                        |    .   |    .   |    .   |
                        |    .   |    .   |    .   |
                        |   57   |   58   |   59   |
                        |   60   |   61   |   62   |"
"[INST]In the context of the C64, Can you describe the LDA?[/INST]LDA - LOAD THE ACCUMULATOR

    In 6510 assembly language, mnemonics are always three characters. LDA
  represents 'load accumulator with...', and what the accumulator should be
  loaded with is decided by the parameter(s) associated with that
  instruction. The assembler knows which token is represented by each
  mnemonic, and when it 'assembles' an instruction, it simply puts into
  memory (at whatever address has been specified), the token, and what
  parameters, are given. Some assemblers give error messages, or warnings
  when you try to assemble something that either the assembler, or the 6510
  microprocessor, cannot do.
    If you put a '#' symbol in front of the parameter associated with the
  instruction, this means that you want the register specified in the
  instruction to be loaded with the 'value' after the '#'. For example:

    LDA #$05  <----[ $=HEX ]

  This instruction will put $05 (decimal 5) into the accumulator register.
  The assembler will put into the specified address for this instruction,
  $A9 (which is the token for this particular instruction, in this mode),
  and it will put $05 into the next location after the location containing
  the instruction ($A9).
    If the parameter to be used by an instruction has '#' before it; i.e.,
  the parameter is a 'value,' rather than the contents of a memory loca-
  tion, or another register, the instruction is said to be in the
  'immediate' mode. To put this into perspective, let's compare this with
  another mode:
    If you want to put the contents of memory location $102E into the
  accumulator, you're using the 'absolute' mode of instruction:

    LDA $102E

  The assembler can distinguish between the two different modes because the
  latter does not have a '#' before the parameter. The 6510 microprocessor
  can distinguish between the immediate mode, and the absolute mode of the
  LDA instruction, because they have slightly different tokens. LDA
  (immediate) has $A9 as its token, and LDA (absolute), has $AD as its
  token."
"[INST]In the context of the C64, What is the  instruction that clears the interrupt disable bit?[/INST]CLI                  CLI Clear interrupt disable bit                  CLI


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLI                 |    58   |    1    |    2     |"
"[INST]In the context of the C64, What is the maximum addressable memory location that a sprite pointer can point to?[/INST]SPRITE POINTERS

    Even though each sprite takes only 63 bytes to define, one more byte
  is needed as a place holder at the end of each sprite. Each sprite, then,
  takes up 64 bytes. This makes it easy to calculate where in memory your
  sprite definition is, since 64 bytes is an even number and in binary it's
  an even power.
    Each of the 8 sprites has a byte associated with it called the SPRITE
  POINTER. The sprite pointers control where each sprite definition is lo-
  cated in memory. These 8 bytes are always located as the lost 8 bytes
  of the 1K chunk of screen memory. Normally, on the Commodore 64, this
  means they begin at location 2040 ($07F8 in HEX). However, if you move
  the screen, the location of your sprite pointers will also move.
    Each sprite pointer can hold a number from 0 to 255. This number points
  to the definition for that sprite. Since each sprite definition takes
  64 bytes, that means that the pointer can 'see' anywhere in the 16K
  block of memory that the VIC-II chip can access (since 256*64=16K)."
"[INST]In the context of the C64, What is the primary advantage of using multi-color mode graphics over standard high-resolution graphics?[/INST]MULTI-COLOR MODE GRAPHICS

    Standard high-resolution graphics give you control of very small dots
  on the screen. Each dot in character memory can have 2 possible values,
  1 for on and 0 for off. When a dot is off, the color of the screen is
  used in the space reserved for that dot. If the dot is on, the dot is
  colored with the character color you have chosen for that screen posi-
  tion. When you're using standard high-resolution graphics, all the dots
  within each 8X8 character can either have background color or foreground
  color. In some ways this limits the color resolution within that space.
  For example, problems may occur when two different colored lines cross.
    Multi-color mode gives you a solution to this problem. Each dot in
  multi-color mode can be one of 4 colors: screen color (background color
  register #0), the color in background register #1, the color in back-
  ground color register #2, or character color. The only sacrifice is in
  the horizontal resolution, because each multi-color mode dot is twice as
  wide as a high-resolution dot. This minimal loss of resolution is more
  than compensated for by the extra abilities of multi-color mode."
"[INST]In the context of the C64, What is the purpose of the interrupt register?[/INST]INTERRUPT REGISTER

    The interrupt register shows the status of the four sources of
  interrupt. An interrupt latch in register 25 ($19) is set to '1' when an
  interrupt source has generated an interrupt request. The four sources of
  interrupt are:

   LATCH |ENABLE|
    BIT  | BIT  |                       WHEN SET
    IRST | ERST | Set when (raster count) = (stored raster count)
    IMDC | EMDC | Set by sprite-DATA collision register (first collision only)
    IMMC | EMMC | Set by sprite-sprite collision register (first collision only)
    ILP  | ELP  | Set by negative transition of LP input (once per frame)
    IRQ  |      | Set high by latch set and enabled (invert of /IRQ output)

    To enable an interrupt request to set the /IRQ output to '0', the
  corresponding interrupt enable bit in register 26 ($1A) must be set to
  '1'. Once an interrupt latch has been set, the latch may be cleared only
  by writing a '1' to the desired latch in the interrupt register. This
  feature allows selective handling of video interrupts without software
  required to 'remember' active interrupts."
"[INST]In the context of the C64, given the SID register description[/INST]SID REGISTER DESCRIPTION

  VOICE 1

  FREQ LO/FREQ HI (Registers 00,01)

    Together these registers form a 16-bit number which linearly controls
  the frequency of Oscillator 1 . The frequency is determined by the
  following equation:

                       Fout = (Fn*Fclk/16777216) Hz

    Where Fn is the 16-bit number in the Frequency registers and Fclk is
  the system clock applied to the 02 input (pin 6). For a standard 1.0-MHz
  clock, the frequency is given by:

                       Fout = (Fn*0.059604645) Hz

    A complete table of values for generating 8 octaves of the equally
  tempered musical scale with concert A (440 Hz) tuning is provided in
  Appendix E. It should be noted that the frequency resolution of SID is
  sufficient for any tuning scale and allows sweeping from note to note
  (portamento) with no discernable frequency steps."
"[INST]In the context of the C64, What is the primary function of the built-in dynamic RAM refresh controller in the 6566/6567 devices?[/INST]DYNAMIC RAM REFRESH

    A dynamic ram refresh controller is built in to the 6566/6567 devices.
  Five 8-bit row addresses are refreshed every raster line. This rate
  guarantees a maximum delay of 2.02 ms between the refresh of any single
  row address in a 128 refresh scheme. (The maximum delay is 3.66 ms in a
  256 address refresh scheme.) This refresh is totally transparent to the
  system, since the refresh occurs during Phase 1 of the system clock. The
  6567 generates both /RAS and /CAS which are normally connected directly
  to the dynamic rams. /RAS and /CAS are generated for every Phase 2 and
  every video data access (including refresh) so that external clock
  generation is not required.


  RESET"
"[INST]In the context of the C64, What is the size of a standard (HI-RES) sprite in terms of dots?[/INST]DEFINING A SPRITE

    Sprites are defined like programmable characters are defined. However,
  since the size of the sprite is larger, more bytes are needed. A sprite
  is 24 by 21 dots, or 504 dots. This works out to 63 bytes (504/8 bits)

    A way to view how a sprite is created is to take a look at the
  sprite definition block on the bit level. 

  In a standard (HI-RES) sprite, each bit set to I is displayed in that
  sprite's foreground color. Each bit set to 0 is transparent and will
  display whatever data is behind it. This is similar to a standard
  character.
    Multi-color sprites are similar to multi-color characters. Horizontal
  resolution is traded for extra color resolution. The resolution of the
  sprite becomes 12 horizontal dots by 21 vertical dots. Each dot in the
  sprite becomes twice as wide, but the number of colors displayable in the
  sprite is increased to 4."
"[INST]In the context of the C64, What is the assembly language instruction that sets the carry flag to 0 and clears the overflow flag?[/INST]CLV                      CLV Clear overflow flag                      CLV


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLV                 |    B8   |    1    |    2     |"
"[INST]In the context of the C64, What is the instruction that performs a bitwise left shift of the value in the specified memory location or accumulator by one bit?[/INST]ASL          ASL Shift Left One Bit (Memory or Accumulator)           ASL

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Accumulator   |   ASL A               |    0A   |    1    |    2     |
  Zero Page     |   ASL Oper            |    06   |    2    |    5     |
  Zero Page,X   |   ASL Oper,X          |    16   |    2    |    6     |
  Absolute      |   ASL Oper            |    0E   |    3    |    6     |
  Absolute, X   |   ASL Oper,X          |    1E   |    3    |    7     |"
"[INST]In the context of the C64, What is the list of user-callable kernel routines in the KERNAL?[/INST]USER CALLABLE KERNAL ROUTINES
  
  
  NOM - ADDRESS - FUNCTION
  | ACPTR  |  $FFA5  |  65445  |  Input byte from serial port             |
  | CHKIN  |  $FFC6  |  65478  |  Open channel for input                  |
  | CHKOUT |  $FFC9  |  65481  |  Open channel for output                 |
  | CHRIN  |  $FFCF  |  65487  |  Input character from channel            |
  | CHROUT |  $FFD2  |  65490  |  Output character to channel             |
  | CIOUT  |  $FFA8  |  65448  |  Output byte to serial port              |
  | CINT   |  $FF81  |  65409  |  Initialize screen editor                |
  | CLALL  |  $FFE7  |  65511  |  Close all channels and files            |
  | CLOSE  |  $FFC3  |  65475  |  Close a specified logical file          |
  | CLRCHN |  $FFCC  |  65484  |  Close input and output channels         |
  | GETIN  |  $FFE4  |  65508  |  Get character from keyboard queue       |
  |        |         |         |  (keyboard buffer)                       |
  | IOBASE |  $FFF3  |  65523  |  Returns base address of I/O devices     |
  | IOINIT |  $FF84  |  65412  |  Initialize input/output                 |
  | LISTEN |  $FFB1  |  65457  |  Command devices on the serial bus to    |
  |        |         |         |  LISTEN                                  |
  | IOBASE |  $FFF3  |  65523  |  Returns base address of I/O devices     |
  | IOINIT |  $FF84  |  65412  |  Initialize input/output                 |
  | LISTEN |  $FFB1  |  65457  |  Command devices on the serial bus to    |
  |        |         |         |  LISTEN                                  |
  | LOAD   |  $FFD5  |  65493  |  Load RAM from a device                  |
  | MEMBOT |  $FF9C  |  65436  |  Read/set the bottom of memory           |
  | MEMTOP |  $FF99  |  65433  |  Read/set the top of memory              |
  | OPEN   |  $FFC0  |  65472  |  Open a logical file                     |
  | PLOT   |  $FFF0  |  65520  |  Read/set X,Y cursor position            |
  | RAMTAS |  $FF87  |  65415  |  Initialize RAM, allocate tape buffer,   |
  |        |         |         |  set screen $0400                        |
  | RDTIM  |  $FFDE  |  65502  |  Read real time clock                    |
  | READST |  $FFB7  |  65463  |  Read I/O status word                    |
  | RESTOR |  $FF8A  |  65418  |  Restore default I/O vectors             |
  | SAVE   |  $FFD8  |  65496  |  Save RAM to device                      |
  | SCNKEY |  $FF9F  |  65439  |  Scan keyboard                           |
  | SCREEN |  $FFED  |  65517  |  Return X,Y organization of screen       |
  | SECOND |  $FF93  |  65427  |  Send secondary address after LISTEN     |
  | SETLFS |  $FFBA  |  65466  |  Set logical, first, and second addresses|
  | SETMSG |  $FF90  |  65424  |  Control KERNAL messages                 |
  | SETNAM |  $FFBD  |  65469  |  Set file name                           |
  | SETTIM |  $FFDB  |  65499  |  Set real time clock                     |
  | SETTMO |  $FFA2  |  65442  |  Set timeout on serial bus               |
  | STOP   |  $FFE1  |  65505  |  Scan stop key                           |
  | TALK   |  $FFB4  |  65460  |  Command serial bus device to TALK       |
  | TKSA   |  $FF96  |  65430  |  Send secondary address after TALK       |
  | UDTIM  |  $FFEA  |  65514  |  Increment real time clock               |
  | UNLSN  |  $FFAE  |  65454  |  Command serial bus to UNLISTEN          |
  | UNTLK  |  $FFAB  |  65451  |  Command serial bus to UNTALK            |
  | VECTOR |  $FF8D  |  65421  |  Read/set vectored I/O                   |"
"[INST]In the context of the C64, Describe the multicolor Bitmap mode[/INST]MULTI-COLOR BIT MAP MODE (BMM = MCM = 1)

    Multi-colored bit map mode is selected by setting the MCM bit in
  register 22 ($16) to a '1' in conjunction with the BMM bit. Multi-color
  mode uses the same memory access sequences as standard bit map mode, but
  interprets the dot data as follows:

        BIT PAIR      |                   DISPLAY COLOR
           00         |  Background #0 color (register 33 ($21))
           01         |  Upper nybble of video matrix pointer
           10         |  Lower nybble of video matrix pointer
           11         |  Video matrix color nybble

  Note that the color nybble (DB11-DB8) IS used for the multi-color bit map
  mode. Again, as two bits are used to select one dot color, the horizontal
  dot size is doubled, resulting in a screen resolution of 160H*200V.
  Utilizing multi-color bit map mode, three independently selected colors
  can be displayed in each 8*8 block in addition to the background color."
"[INST]In the context of the C64, What is the primary function of the Serial Port (SDR)?[/INST]Serial Port (SDR)

    The serial port is a buffered, 8-bit synchronous shift register system.
  A control bit selects input or output mode. In input mode, data on the SP
  pin is shifted into the shift register on the rising edge of the signal
  applied to the CNT pin. After 8 CNT pulses, the data in the shift
  register is dumped into the Serial Data Register and an interrupt is
  generated. In the output mode, TIMER A is used for the baud rate
  generator. Data is shifted out on the SP pin at 1/2 the underflow rate of
  TIMER A. The maximum baud rate possible is 02 divided by 4, but the
  maximum useable baud rate will be determined by line loading and the
  speed at which the receiver responds to input data. Transmission will
  start following a write to the Serial Data Register (provided TIMER A is
  running and in continuous mode). The clock signal derived from TIMER A
  appears as an output on the CNT pin. The data in the Serial Data Register
  will be loaded into the shift register then shift out to the SP pin when
  a CNT pulse occurs. Data shifted out becomes valid on the falling edge of
  CNT and remains valid until the next falling edge. After 8 CNT pulses, an
  interrupt is generated to indicate more data can be sent. If the Serial
  Data Register was loaded with new information prior to this interrupt,
  the new data will automatically be loaded into the shift register and
  transmission will continue. If the microprocessor stays one byte ahead of
  the shift register, transmission will be continuous. If no further data
  is to be transmitted, after the 8th CNT pulse, CNT will return high and
  SP will remain at the level of the last data bit transmitted. SDR data is
  shifted out MSB first and serial input data should also appear in this
  format.
    The bidirectional capability of the Serial Port and CNT clock allows
  many 6526 devices to be connected to a common serial communication bus on
  which one 6526 acts as a master, sourcing data and shift clock, while all
  other 6526 chips act as slaves. Both CNT and SP outputs are open drain to
  allow such a common bus. Protocol for master/slave selection can be
  transmitted over the serial bus, or via dedicated handshaking lines."
"[INST]In the context of the C64, What is the meaning of each bit in the PROCESSOR STATUS REG 'P' register?[/INST]Status Register
                        +-+-+-+-+-+-+-+-+
                        |N|V| |B|D|I|Z|C|  PROCESSOR STATUS REG 'P'
                        +-+-+-+-+-+-+-+-+
                         | |   | | | | |
                         | |   | | | | +>  CARRY         1=TRUE
                         | |   | | | +-->  ZERO          1=RESULT ZERO
                         | |   | | +---->  IRQ DISABLE   1=DISABLE
                         | |   | +------>  DECIMAL MODE  1=TRUE
                         | |   +-------->  BRK COMMAND
                         | |
                         | +------------>  OVERFLOW      1=TRUE
                         +-------------->  NEGATIVE      1=NEG"
"[INST]In the context of the C64, What is the number of rows and columns displayed on the screen when the RSEL bit is set to 1 and the CSEL bit is set to 1?[/INST]ROW/COLUMN SELECT

    The normal display consists of 25 rows of 40 characters (or character
  regions) per row. For special display purposes, the display window may be
  reduced to 24 rows and 38 characters. There is no change in the format of
  the displayed information, except that characters (bits) adjacent to the
  exterior border area will now be covered by the border. The select bits
  operate as follows:


    RSEL |      NUMBER OF ROWS        |  CSEL |     NUMBER OF COLUMNS
     0   |          24 rows           |   0   |         38 columns
     1   |          25 rows           |   1   |         40 columns

  The RSEL bit is in register 17 ($11) and the CSEL bit is in register 22
  ($16). For standard display the larger display window is normally used,
  while the smaller display window is normally used in conjunction with
  scrolling."
"[INST]In the context of the C64, What is the assembly language instruction that increments the index Y by one?[/INST]INY                    INY Increment Index Y by one                   INY


  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   INY                 |    C8   |    1    |    2     |"
"[INST]In the context of the C64, What is the indirect indexed addressing mode?[/INST]INDIRECT INDEXED

    This only allows usage of the Y register as the index. The actual ad-
  dress can only be in zero page, and the mode of instruction is called
  indirect because the zero page address specified in the instruction con-
  tains the low byte of the actual address, and the next byte to it
  contains the high order byte.

 EXAMPLE:

    Let us suppose that location $02 contains $45, and location $03 con-
  tains $1E. If the instruction to load the accumulator in the indirect
  indexed mode is executed and the specified zero page address is $02, then
  the actual address will be:

    Low order = contents of $02
    High order = contents of $03
    Y register = $00

  Thus the actual address = $1E45 + Y = $1E45.
    The title of this mode does in fact imply an indirect principle,
  although this may be difficult to grasp at first sight. Let's look at it
  another way:
    'I am going to deliver this letter to the post office at address $02,
  MEMORY ST., and the address on the letter is $05 houses past $1600,
  MEMORY street.' This is equivalent to the code:

    LDA #$00      - load low order actual base address
    STA $02       - set the low byte of the indirect address
    LDA #$16      - load high order indirect address
    STA $03       - set the high byte of the indirect address
    LDY #$05      - set the indirect index (Y)
    LDA ($02),Y   - load indirectly indexed by Y"
"[INST]In the context of the C64, What is the primary strategy for approaching a large task in machine language programming?[/INST]APPROACHING A LARGE TASK

    When approaching a large task in machine language, a certain amount of
  subconscious thought has usually taken place. You think about how certain
  processes are carried out in machine language. When the task is started,
  it is usually a good idea to write it out on paper. Use block diagrams of
  memory usage, functional modules of code required, and a program flow.
  Let's say that you wanted to write a roulette game in machine language.
  You could outline it something like this:

    o Display title
    o Ask if player requires instructions
    o YES - display them-Go to START
    o NO - Go to START
    o START Initialize everything
    o MAIN display roulette table
    o Take in bets
    o Spin wheel
    o Slow wheel to stop
    o Check bets with result
    o Inform player
    o Player any money left?
    o YES - Go to MAIN
    o NO - Inform user!, and go to START


    This is the main outline. As each module is approached, you can break
  it down further. If you look at a large indigestable problem as something
  that can be broken down into small enough pieces to be eaten, then you'll
  be able to approach something that seems impossible, and have it all fall
  into place.
    This process only improves with practice, so KEEP TRYING."
"[INST]In the context of the C64, How do I unexpand a sprite in horizontal direction ?[/INST]To unexpand a sprite in the horizontal direction, the corresponding bit
  in the VIC-II control register at location 53277 ($D01D in HEX) must be
  turned OFF (set to a 0). The following POKE 'unexpands' a sprite in the
  X direction:

    POKE 53277,PEEK(53277)AND (255-2^SN)

  where SN is the sprite number from 0 to 7.
    To expand a sprite in the vertical direction, the corresponding bit in
  the VIC-II control register at location 53271 ($D017 in HEX) must be
  turned ON (set to a 1). The following POKE expands a sprite in the Y
  direction:

    POKE 53271,PEEK(53271)OR(2^SN)

  where SN is the sprite number from 0 to 7.

     
   To expand a sprite in the horizontal direction, the corresponding bit
  in the VIC-II control register at location 53277 ($D01D in HEX) must be
  turned ON (set to a 1). The following POKE expands a sprite in the X
  direction:

    POKE 53277,PEEK(53277)OR(2^SN)

  where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, What is the condition required for accessing the device registers?[/INST]DATA BUS (DB7-DB0)

    The eight data bus pins are the bidirectional data port, controlled by
  /CS, RW, and Phase 0. The data bus can only be accessed while AEC and
  Phase 0 are high and /CS is low.

  CHIP SELECT (/CS)

    The chip select pin, /CS, is brought low to enable access to the device
  registers in conjunction with the address and RW pins. /CS low is recog-
  nized only while AEC and Phase 0 are high."
"[INST]In the context of the C64, What is the primary function of the 6581 Sound Interface Device (SID)?[/INST]6581 SOUND INTERFACE DEVICE (SID)
  CHIP SPECIFICATIONS
  CONCEPT

    The 6581 Sound Interface Device (SID) is a single-chip, 3-voice elec-
  tronic music synthesizer/sound effects generator compatible with the 65XX
  and similar microprocessor families. SID provides wide-range, high-
  resolution control of pitch (frequency), tone color (harmonic content),
  and dynamics (volume). Specialized control circuitry minimizes software
  overhead, facilitating use in arcade/home video games and low-cost
  musical instruments.


  FEATURES

  o 3 TONE OSCILLATORS
        Range: 0-4 kHz
  o 4 WAVEFORMS PER OSCILLATOR
        Triangle, Sawtooth,
        Variable Pulse, Noise
  o 3 AMPLITUDE MODULATORS
        Range: 48 dB
  o 3 ENVELOPE GENERATORS
        Exponential response
        Attack Rate: 2 ms-8 s
        Decay Rate: 6 ms-24 s
        Sustain Level: 0-peak volume
        Release Rate: 6 ms-24 s
  o OSCILLATOR SYNCHRONIZATION
  o RING MODULATION
  o PROGRAMMABLE FILTER
        Cutoff range: 30 Hz-12 kHz
        12 dB/octave Rolloff
        Low pass, Bandpass,
        High pass, Notch outputs
        Variable Resonance
  o MASTER VOLUME CONTROL
  o 2 A/D POT INTERFACES
  o RANDOM NUMBER/MODULATION GENERATOR
  o EXTERNAL AUDIO INPUT"
"[INST]In the context of the C64, How do you unexpand a sprite in the vertical direction?[/INST]To unexpand a sprite in the vertical direction, the corresponding bit
  in the VIC-II control register at location 53271 ($D017 in HEX) must be
  turned OFF (set to a 0). The following POKE 'unexpands' a sprite in the
  Y direction:

    POKE 53271,PEEK(53271)AND (255-2^SN)

  where SN is the sprite number from 0 to 7."
"[INST]In the context of the C64, What is the standard character mode ?[/INST]STANDARD CHARACTER MODE

    Standard character mode is the mode the Commodore 64 is in when you
  first turn it on. It is the mode you will generally program in.
    Characters can be taken from ROM or from RAM, but normally they are
  taken from ROM. When you want special graphics characters for a program,
  all you have to do is define the new character shapes in RAM, and tell
  the VIC-II chip to get its character information from there instead of
  the character ROM. This is covered in more detail in the next section.
    In order to display characters on the screen in color, the VIC-II chip
  accesses the screen memory to determine the character code for that
  location on the screen. At the same time, it accesses the color memory to
  determine what color you want for the character displayed. The character
  code is translated by the VIC-II into the starting address of the 8-byte
  block holding your character pattern. The 8-byte block is located in
  character memory.
    The translation isn't too complicated, but a number of items are com-
  bined to generate the desired address. First the character code you use
  to POKE screen memory is multiplied by 8. Next add the start of char-
  acter memory (see CHARACTER MEMORY section). Then the Bank Select Bits
  are taken into account by adding in the base address (see VIDEO BANK
  SELECTION section). Below is a simple formula to illustrate what happens:
  CHARACTER ADDRESS = SCREEN CODE*8+(CHARACTER SET*2048)+(BANK*16384)"
"[INST]In the context of the C64, What are some essential tips and strategies for a beginner to learn and master machine language programming?[/INST]USEFUL TIPS FOR THE BEGINNER

    One of the best ways to learn machine language is to look at other
  peoples' machine language programs. These are published all the time in
  magazines and newsletters. Look at them even if the article is for a
  different computer, which also uses the 6510 (or 6502) microprocessor.
  You should make sure that you thoroughly understand the code that you
  look at. This will require perseveres I ce, especially when you see a new
  technique that you have never come across before. This can be infuriat-
  ing, but if patience prevails, you will be the victor.
    Having looked at other machine language programs, you MUST write your
  own. These may be utilities for your BASIC programs, or they may be an
  all machine language program.
    You should also use the utilities that are available, either IN your
  computer, or in a program, that aid you in writing, editing, or tracking
  down errors in a machine language program. An example would be the
  KERNAL, which allows you to check the keyboard, print text, control
  peripheral devices like disk drives, printers, modems, etc., manage
  memory and the screen. It is extremely powerful and it is advised
  strongly that it is used (refer to KERNAL section, Page 268).
    Advantages of writing programs in machine language:

    1. Speed - Machine language is hundreds, and in some cases thousands of
       times faster than a high level language such as BASIC.

    2. Tightness - A machine language program can be made totally
       'watertight,' i.e., the user can be made to do ONLY what the program
        allows, and no more. With a high level language, you are relying on
        the user not 'crashing' the BASIC interpreter by entering, for
        example, a zero which later causes a:


  ?DIVISION BY ZERO ERROR IN LINE 830

  READY.


  In essence, the computer can only be maximized by the machine language
  programmer."
"[INST]In the context of the C64, What is indexing in the context of the 6510 microprocessor?[/INST]INDEXING

    Indexing plays an extremely important part in the running of the 6510
  microprocessor. It can be defined as 'creating an actual address from a
  base address plus the contents of either the X or Y index registers.'
    For example, if X contains $05, and the microprocessor executes an LDA
  instruction in the 'absolute X indexed mode' with base address (e.g.,
  $9000), then the actual location that is loaded into the A register is
  $9000 + $05 = $9005. The mnemonic format of an absolute indexed
  instruction is the same as an absolute instruction except a ',X' or ',Y'
  denoting the index is added to the address.

  EXAMPLE:

    LDA $9000,X

    There are absolute indexed, zero page indexed, indirect indexed, and
  indexed indirect modes of addressing available on the 6510
  microprocessor."
"[INST]In the context of the C64, What is the assembly language instruction that increments the index register by one?[/INST]INX                    INX Increment Index X by one                   INX
                                                        N Z C I D V
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   INX                 |    E8   |    1    |    2     |"
"[INST]In the context of the C64, How can I scroll the screen?[/INST]SCROLLING

    The display data may be scrolled up to one entire character space in
  both the horizontal and vertical direction. When used in conjunction with
  the smaller display window (above), scrolling can be used to create a
  smooth panning motion of display data while updating the system memory
  only when a new character row (or column) is required. Scrolling is also
  used to center a fixed display within the display window.

           BITS         |      REGISTER      |          FUNCTION
         X2,X1,X0       |      22 ($16)      |     Horizontal Position
         Y2,Y1,Y0       |      17 ($11)      |     Vertical Position"
"[INST]In the context of the C64, What is the list of instructions in the 6502 microprocessor?[/INST]INSTRUCTION SET - ALPHABETIC SEQUENCE

          ADC   Add Memory to Accumulator with Carry
          AND   'AND' Memory with Accumulator
          ASL   Shift left One Bit (Memory or Accumulator)
          BCC   Branch on Carry Clear
          BCS   Branch on Carry Set
          BEQ   Branch on Result Zero
          BIT   Test Bits in Memory with Accumulator
          BMI   Branch on Result Minus
          BNE   Branch on Result not Zero
          BPL   Branch on Result Plus
          BRK   Force Break
          BVC   Branch on Overflow Clear
          BVS   Branch on Overflow Set
          CLC   Clear Carry Flag
          CLD   Clear Decimal Mode
          CLI   Clear Interrupt Disable Bit
          CLV   Clear Overflow Flag
          CMP   Compare Memory and Accumulator
          CPX   Compare Memory and Index X
          CPY   Compare Memory and Index Y
          DEC   Decrement Memory by One
          DEX   Decrement Index X by One
          DEY   Decrement Index Y by One
          EOR   'Exclusive-OR' Memory with Accumulator
          INC   Increment Memory by One
          INX   Increment Index X by one
          INY   Increment Index Y by one
          JMP   Jump to New location
          JSR   Jump to New Location Saving Return Address
          LDA   Load Accumulator with Memory
          LDX   Load Index X with Memory
          LDY   Load Index Y with Memory
          LSR   Shift One Bit Right (Memory or Accumulator)
          NOP   No Operation
          ORA   'OR' Memory with Accumulator
          PHA   Push Accumulator on Stack
          PHP   Push Processor Status on Stack
          PLA   Pull Accumulator from Stack
          PLP   Pull Processor Status from Stack
          ROL   Rotate One Bit Left (Memory or Accumulator)
          ROR   Rotate One Bit Right (Memory or Accumulator)
          RTI   Return from Interrupt
          RTS   Return from Subroutine
          SBC   Subtract Memory from Accumulator with Borrow
          SEC   Set Carry Flag
          SED   Set Decimal Mode
          SEI   Set Interrupt Disable Status
          STA   Store Accumulator in Memory
          STX   Store Index X in Memory
          STY   Store Index Y in Merrory
          TAX   Transfer Accumulator to Index X
          TAY   Transfer Accumulator to Index Y
          TSX   Transfer Stack Pointer to Index X
          TXA   Transfer Index X to Accumulator
          TXS   Transfer Index X to Stack Register
          TYA   Transfer Index Y to Accumulator"
"[INST]In the context of the C64, What is the purpose of the Reset signal in the 6510 microprocessor?[/INST]SIGNAL DESCRIPTION

  Clocks (01, 02)

    The 6510 requires a two-phase non-overlapping clock that runs at the
  Vcc voltage level.

  Address Bus (A0-A15)

    These outputs are TTL compatible, capable of driving one standard TTL
  load and 130 pf.

  Data Bus (D0-D7)

    Eight pins are used for the data bus. This is a Bi-Directional bus,
  transferring data to and from the device and peripherals. The outputs are
  tri-state buffers capable of driving one standard TTL load and 130 pf.

  Reset

    This input is used to reset or start the microprocessor from a power
  down condition. During the time that this line is held low, writing to or
  from the microprocessor is inhibited. When a positive edge is detected on
  the input, the microprocessor will immediately begin the reset sequence.
    After a system initialization time of six clock cycles, the mask
  interrupt flag will be set and the microprocessor will load the program
  counter from the memory vector locations FFFC and FFFD. This is the start
  location for program control.
    After Vcc reaches 4.75 volts in a power-up routine, reset must be held
  low for at least two clock cycles. At this time the R/W signal will
  become valid.
    When the reset signal goes high following these two clock cycles, the
  microprocessor will proceed with the normal reset procedure detailed
  above.

  Interrupt Request (/IRQ)

    This TTL level input requests that an interrupt sequence begin within
  the microprocessor. The microprocessor will complete the current in-
  struction being executed before recognizing the request. At that time,
  the interrupt mask bit in the Status Code Register will be examined. If
  the interrupt mask flag is not set, the microprocessor will begin an

   interrupt sequence. The Program Counter and Processor Status Register are
  stored in the stack. The microprocessor will then set the interrupt mask
  flag high so that no further interrupts may occur. At the end of this
  cycle, the program counter low will be loaded from address FFFE, and
  program counter high from location FFFF, therefore transferring program
  control to the memory vector located at these addresses.

  Address Enable Control (AEC)

    The Address Bus is valid only when the Address Enable Control line is
  high. When low, the Address Bus is in a high-impedance state. This
  feature allows easy DMA and multiprocessor systems.

  I/O Port (P0-P7)

    Six pins are used for the peripheral port, which can transfer data to
  or from peripheral devices. The Output Register is located in RAM at
  address 0001, and the Data Direction Register is at Address 0000. The
  outputs are capable at driving one standard TTL load and 130 pf.

  Read/Write (R/W)

    This signal is generated by the microprocessor to control the direction
  of data transfers on the Data Bus. This line is high except when the
  microprocessor is writing to memory or a peripheral device."
"[INST]In the context of the C64, What are the key features of the 6526 Complex Interface Adapter (CIA) chip?[/INST]6526 COMPLEX INTERFACE ADAPTER
  (CIA) CHIP SPECIFICATIONS

  DESCRIPTION

    The 6526 Complex Interface Adapter (CIA) is a 65XX bus compatible
  peripheral interface device with extremely flexible timing and I/O
  capabilities.


  FEATURES

  o 16 Individually programmable 110 lines
  o 8 or 16-Bit handshaking on read or write
  o 2 independent, linkable 16-Bit interval timers
  o 24-hour (AM/PM) time of day clock with programmable alarm
  o 8-Bit shift register for serial I/O
  o 2 TTL load capability
  o CMOS compatible I/O lines
  o 1 or 2 MHz operation available"
"[INST]In the context of the C64, What is the purpose of the Indexed Indirect addressing mode in 6502 assembly language?[/INST]INDEXED INDIRECT

    Indexed indirect only allows usage of the X register as the index. This
  is the some as indirect indexed, except it is the zero page address of
  the pointer that is indexed, rather than the actual base address.
  Therefore, the actual base address IS the actual address because the
  index has already been used for the indirect. Index indirect would also
  be used if a table of indirect pointers were located in zero page memory,
  and the X register could then specify which indirect pointer to use.

 EXAMPLE:

    Let us suppose that location $02 contains $45, and location $03 con-
  tains $10. If the instruction to load the accumulator in the indexed
  indirect mode is executed and the specified zero page address is $02,
  then the actual address will be:

    Low order = contents of ($02+X)
    High order = contents of ($03+X)
    X register = $00

  Thus the actual pointer is in = $02 + X = $02.
    Therefore, the actual address is the indirect address contained in $02
  which is again $1045.
    The title of this mode does in fact imply the principle, although it
  may be difficult to grasp at first sight. Look at it this way:
    'I am going to deliver this letter to the fourth post office at address
  $01,MEMORY ST., and the address on the letter will then be delivered to
  $1600, MEMORY street.' This is equivalent to the code:


    LDA #$00    - load low order actual base address
    STA $06     - set the low byte of the indirect address
    LDA #$16    - load high order indirect address
    STA $07     - set the high byte of the indirect address
    LDX #$05    - set the indirect index (X)
    LDA ($02,X) - load indirectly indexed by X"
"[INST]In the context of the C64, How can you create your own character sets on the Commodore 64?[/INST]PROGRAMMABLE CHARACTERS

    Since the characters are stored in ROM, it would seem that there is no
  way to change them for customizing characters. However, the memory
  location that tells the VIC-II chip where to find the characters is a
  programmable register which can be changed to point to many sections of
  memory. By changing the character memory pointer to point to RAM, the
  character set may be programmed for any need.
    If you want your character set to be located in RAM, there are a few
  VERY IMPORTANT things to take into account when you decide to actually
  program your own character sets. In addition, there are two other
  important points you must know to create your own special characters:

    1) It is an all or nothing process. Generally, if you use your own
       character set by telling the VIC-II chip to get the character
       information from the area you have prepared in RAM, the standard
     Commodore 64 characters are unavailable to you. To solve this, you
     must copy any letters, numbers, or standard Commodore 64 graphics you
     intend to use into your own character memory in RAM. You can pick and
     choose, take only the ones you want, and don't even have to keep them
     in order!

    2) Your character set takes memory space away from your BASIC program.
       Of course, with 38K available for a BASIC program, most applications
       won't have problems.
   WARNING: You must be careful to protect the character set from being  
   overwritten by your BASIC program, which also uses the RAM.           

    There are two locations in the Commodore 64 to start your character set
  that should NOT be used with BASIC: location 0 and location 2048. The
  first should not be used because the system stores important data on
  page 0. The second can't be used because that is where your BASIC program
  starts! However, there are 6 other starting positions for your custom
  character set.
    The best place to put your character set for use with BASIC while
  experimenting is beginning at 12288 ($3000 in HEX). This is done by
  POKEing the low 4 bits of location 53272 with 12."
"[INST]In the context of the C64, What is the purpose of the AEC signal in the 6566/6567 video controller devices?[/INST]THEORY OF OPERATION

  SYSTEM INTERFACE

    The 6566/6567 video controller devices interact with the system data
  bus in a special way. A 65XX system requires the system buses only during
  the Phase 2 (clock high) portion of the cycle. The 6566/6567 devices take
  advantage of this feature by normally accessing system memory during the
  Phase 1 (clock low) portion of the clock cycle. Therefore, operations
  such as character data fetches and memory refresh are totally transparent
  to the processor and do not reduce the processor throughput. The video
  chips provide the interface control signals required to maintain this bus
  sharing.
    The video devices provide the signal AEC (address enable control) which
  is used to disable the processor address bus drivers allowing the video
  device to access the address bus. AEC is active low which, permits direct
  connection to the AEC input of the 65XX family. The AEC signal is
normally activated during Phase 1 so that processor operation is not
  affected. Because of this bus 'sharing', all memory accesses must be
  completed in 1/2 cycle. Since the video chips provide a 1-MHz clock
  (which must be used as system Phase 2), a memory cycle is 500 ns
  including address setup, data access and, data setup to the reading
  device.
    Certain operations of the 6566/6567 require data at a faster rate than
  available by reading only during the Phase 1 time; specifically, the ac-
  cess of character pointers from the video matrix and the fetch of sprite
  data. Therefore, the processor must be disabled and the data accessed
  during the Phase 2 clock. This is accomplished via the BA (bus available)
  signal. The BA line is normally high but is brought low during Phase 1 to
  indicate that the video chip will require a Phase 2 data access. Three
  Phase-2 times are allowed after BA low for the processor to complete any
  current memory accesses. On the fourth Phase 2 after BA low, the AEC
  signal will remain low during Phase 2 as the video chip fetches data. The
  BA line is normally connected to the RDY input of a 65XX processor. The
  character pointer fetches occur every eighth raster line during the
  display window and require 40 consecutive Phase 2 accesses to fetch the
  video matrix pointers. The sprite data fetches require 4 memory accesses as
  follows:


     PHASE 1   | sprite Pointer |   CONDITION: Every raster
     PHASE  2   | sprite Byte 1  | CONDITION : Each raster while sprite is displayed
     PHASE  1   | sprite Byte 2  | CONDITION :  Each raster while sprite is displayed
     PHASE  2   | sprite Byte 3  | CONDITION : Each raster while sprite is displayed


  The sprite pointers are fetched every other Phase 1 at the end of each
  raster line. As required, the additional cycles are used for sprite data
  fetches. Again, all necessary bus control is provided by the 6566/6567
  devices."
"[INST]In the context of the C64, What are the key differences in address output configurations between the 6566 and 6567 video interface chips?[/INST]MEMORY INTERFACE

    The two versions of the video interface chip, 6566 and 6567, differ in
  address output configurations. The 6566 has thirteen fully decoded
  addresses for direct connection to the system address bus. The 6567 has
  multiplexed addresses for direct connection to 64K dynamic RAMS. The
  least significant address bits, A06-A00, are present on A06-A00 while
  /RAS is brought low, while the most significant bits, A13-A08, are pres-
  ent on A05-A00 while /CAS is brought low. The pins A11-A07 on the 6567
  are static address outputs to allow direct connection of these bits to a
  conventional 16K (2K*8) ROM. (The lower order addresses require external
  latching.)"
"[INST]In the context of the C64, How are characters defined on the Commodore 64?[/INST]CHARACTER DEFINITIONS

    Each character is formed in an 8 by 8 grid of dots, where each dot may
  be either on or off. The Commodore 64 character images are stored in the
  Character Generator ROM chip. The characters are stored as a set of 8
  bytes for each character, with each byte representing the dot pattern of
  a row in the character, and each bit representing a dot. A zero bit means
  that dot is off, and a one bit means the dot is on.
    The character memory in ROM begins at location 53248 (when the I/O
  is switched off). The first 8 bytes from location 53248 ($D000) to 53255
  ($D007) contain the pattern for the @ sign, which has a character code
  value of zero in the screen memory. The next 8 bytes, from location
  53256 ($D008) to 53263 ($D00F), contain the information for forming the
  letter A.

    Each complete character set takes up 2K (2048 bits) of memory, 8 bytes
  per character and 256 characters. Since there are two character sets, one
  for upper case and graphics and the other with upper and lower case, the
  character generator ROM takes up a total of 4K locations."
"[INST]In the context of the C64, Wcan you talk about branches and testing in 6502 and 6510?[/INST]BRANCHES AND TESTING

    Another very important principle in machine language is the ability to
  test, and detect certain conditions, in a similar fashion to the 'IF...
  THEN, IF... GOTO' structure in CBM BASIC.
    The various flags in the status register are affected by different in-
  structions in different ways. For example, there is a flag that is set
  when an instruction has caused a zero result, and is reset when a result
  is not zero. The instruction:

    LDA #$00

  will cause the zero result flag to be set, because the instruction has
  resulted in the accumulator containing a zero.
    There are a set of instructions that will, given a particular
  condition, branch to another part of the program. An example of a branch
  instruction is BEQ, which means Branch if result EQual to zero. The
  branch instructions branch if the condition is true, and if not, the
  program continues onto the next instruction, as if nothing had occurred.
  The branch instructions branch not by the result of the previous
  instructions), but by internally examining the status register. As was
  just mentioned, there is a zero result flag in the status register. The
  BEQ instruction branches if the zero result flag (known as Z) is set.
  Every branch instruction has an opposite branch instruction. The BEQ
  instruction has an opposite instruction BNE, which means Branch on result
  Not Equal to zero (i.e., Z not set).
  
    The index registers have a number of associated instructions which
  modify their contents. For example, the INX instruction INcrements the X
  index register. If the X register contained $FF before it was incremented
  (the maximum number the X register can contain), it will 'wrap around'
  back to zero. If you wanted a program to continue to do something until
  you had performed the increment of the X index that pushed it around to
  zero, you could use the BNE instruction to continue 'looping' around,
  until X became zero.
  
    The reverse of INX, is DEX, which is DEcrement the X index register. If
  the X index register is zero, DEX wraps around to $FF. Similarly, there
  are INY and DEY for the Y index register.
 But what if a program didn't want to wait until X or Y had reached (or
  not reached) zero? Well there are comparison instructions, CPX and CPY,
  which allow the machine language programmer to test the index registers
  with specific values, or even the contents of memory locations. If you
  wanted to see if the X register contained $40, you would use the
  instruction:

    CPX #$40         - compare X with the 'value' $40.
    BEQ              - branch to somewhere else in the
    (some other        program, if this condition is 'true.'
     part of the
     program)


  The compare, and branch instructions play a major part in any machine
  language program.
    The operand specified in a branch instruction when using 64MON is the
  address of the part of the program that the branch goes to when the
  proper conditions are met. However, the operand is only an offset, which
  gets you from where the program currently is to the address specified.
  This offset is just one byte, and therefore the range that a branch
  instruction can branch to is limited. It can branch from 128 bytes back-
  ward, to 127 bytes forward.

 
  NOTE: This is a total range of 255 bytes which is, of course, the
  maximum range of values one byte can contain.
  
    64MON will tell you if you 'branch out of range' by refusing to 'as-
  semble' that particular instruction. But don't worry about that now be-
  cause it's unlikely that you will have such branches for quite a while.
  The branch is a 'quick' instruction by machine language standards because
  of the 'offset' principle as opposed to an absolute address. 64MON allows
  you to type in an absolute address, and it calculates the correct offset.
  This is just one of the 'comforts' of using an assembler."
"[INST]In the context of the C64, What is the purpose of the ADC instruction in the given table?[/INST]ADC               Add memory to accumulator with carry                ADC


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Immediate     |   ADC #Oper           |    69   |    2    |    2     |
 Zero Page     |   ADC Oper            |    65   |    2    |    3     |
 Zero Page,X   |   ADC Oper,X          |    75   |    2    |    4     |
 Absolute      |   ADC Oper            |    60   |    3    |    4     |
 Absolute,X    |   ADC Oper,X          |    70   |    3    |    4*    |
 Absolute,Y    |   ADC Oper,Y          |    79   |    3    |    4*    |
 (Indirect,X)  |   ADC (Oper,X)        |    61   |    2    |    6     |
 (Indirect),Y  |   ADC (Oper),Y        |    71   |    2    |    5*    |
   * Add 1 if page boundary is crossed."
"[INST]In the context of the C64, What are the 6526 interface signals?[/INST]6526 INTERFACE SIGNALS

  02-Clock Input

    The 02 clock is a TTL compatible input used for internal device opera-
  tion and as a timing reference for communicating with the system data
  bus.

  /CS-Chip Select Input

    The /CS input controls the activity of the 6526. A low level on /CS
  while 02 is high causes the device to respond to signals on the R/W and
  address (RS) lines. A high on /CS prevents these lines from controlling
  the 6526. The /CS line is normally activated (low) at 02 by the
  appropriate address combination.

  R/W-Read/Write Input

    The R/W signal is normally supplied by the microprocessor and controls
  the direction of data transfers of the 6526. A high on R/W indicates
  a read (data transfer out of the 6526), while a low indicates a write
  (data transfer into the 6526).

  RS3-RS0-Address Inputs

    The address inputs select the internal registers as described by the
  Register Map.

  DB7-DB0-Data Bus Inputs/Outputs

    The eight data bus pins transfer information between the 6526 and the
  system data bus. These pins are high impedance inputs unless CS is low
  and R/W and 02 are high to read the device. During this read, the data
  bus output buffers are enabled, driving the data from the selected
  register onto the system data bus.

  IRQ-Interrupt Request Output

    IRQ is an open drain output normally connected to the processor inter-
  rupt input. An external pullup resistor holds the signal high, allowing
  multiple IRQ outputs to be connected together. The IRQ output is normally
  off (high impedance) and is activated low as indicated in the functional
  description.

  /RES-Reset Input

    A low on the RES pin resets all internal registers. The port pins are
  set as inputs and port registers to zero (although a read of the ports
  will return all highs because of passive pullups). The timer control
  registers are set to zero and the timer latches to all ones. All other
  registers are reset to zero."
"[INST]In the context of the C64, What are the 9 addressing modes supported by the 6502/ 6510 CPU?[/INST]ADDRESSING MODES

  ACCUMULATOR ADDRESSING - This form of addressing is represented with a
  one byte instruction, implying an operation on the accumulator.

  IMMEDIATE ADDRESSING - In immediate addressing, the operand is contained
  in the second byte of the instruction, with no further memory addressing
  required.

  ABSOLUTE ADDRESSING - In absolute addressing, the second byte of the
  instruction specifies the eight low order bits of the effective address
  while the third byte specifies the eight high order bits. Thus, the
  absolute addressing mode allows access to the entire 64K bytes of
  addressable memory.

  ZERO PAGE ADDRESSING - The zero page instructions allow for shorter code
  and execution times by only fetching the second byte of the instruction
  and assuming a zero high address byte. Careful use of the zero page can
  result in significant increase in code efficiency.

  INDEXED ZERO PAGE ADDRESSING - (X, Y indexing)-This form of addressing is
  used in conjunction with the index register and is referred to as 'Zero
  Page, X' or 'Zero Page, Y.' The effective address is calculated by adding
  the second byte to the contents of the index register. Since this is a
  form of 'Zero Page' addressing, the content of the second byte references
  a location in page zero. Additionally, due to the 'Zero Page' addressing
  nature of this mode, no carry is added to the high order 8 bits of memory
  and crossing of page boundaries does not occur.

  INDEXED ABSOLUTE ADDRESSING - (X, Y indexing)-This form of addressing is
  used in conjunction with X and Y index register and is referred to as
  'Absolute, X,' and 'Absolute, Y.' The effective address is formed by
  adding the contents of X and Y to the address contained in the second and
  third bytes of the instruction. This mode allows the index register to
  contain the index or count value and the instruction to contain the base
  address. This type of indexing allows any location referencing and the
  index to modify multiple fields resulting in reduced coding and execution
  time.

  IMPLIED ADDRESSING - In the implied addressing mode, the address
  containing the operand is implicitly stated in the operation code of the
  instruction.

  RELATIVE ADDRESSING - Relative addressing is used only with branch
  instructions and establishes a destination for the conditional branch.
  The second byte of the instruction becomes the operand which is an
  'Offset' added to the contents of the lower eight bits of the program
  counter when the counter is set at the next instruction. The range of the
  offset is -128 to +127 bytes from the next instruction.

  INDEXED INDIRECT ADDRESSING - In indexed indirect addressing (referred to
  as [Indirect, X]), the second byte of the instruction is added to the
  contents of the X index register, discarding the carry. The result of
  this addition points to a memory location on page zero whose contents is
  the low order eight bits of the effective address. The next memory loca-
  tion in page zero contains the high order eight bits of the effective ad-
  dress. Both memory locations specifying the high and low order bytes of

  the effective address must be in page zero.

  INDIRECT INDEXED ADDRESSING - In indirect indexed addressing (referred to
  as [Indirect], Y), the second byte of the instruction points to a memory
  location in page zero. The contents of this memory location is added to
  the contents of the Y index register, the result being the low order
  eight bits of the effective address. The carry from this addition is
  added to the contents of the next page zero memory location, the result
  being the high order eight bits of the effective address.

  ABSOLUTE INDIRECT - The second byte of the instruction contains the low
  order eight bits of a memory location. The high order eight bits of that
  memory location is contained in the third byte of the instruction. The
  contents of the fully specified memory location is the low order byte of
  the effective address. The next memory location contains the high order
  byte of the effective address which is loaded into the sixteen bits of
  the program counter."
"[INST]In the context of the C64, What is the purpose of the SCREEN kernal function in Commodore 64 programming?[/INST]B-26. Function Name: SCREEN

    Purpose: Return screen format
    Call address: $FFED (hex) 65517 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Stack requirements: 2
    Registers affected: X, Y

    Description: This routine returns the format of the screen, e.g., 40
  columns in X and 25 lines in Y. The routine can be used to determine what
  machine a program is running on. This function has been implemented on
  the Commodore 64 to help upward compatibility of your programs.
  How to Use:

    1) Call this routine.

  EXAMPLE:

    JSR SCREEN
    STX MAXCOL
    STY MAXROW"
"[INST]In the context of the C64, Give the list of kernal error codes?[/INST]KERNAL ERROR CODES

    The following is a list of error messages which can occur when using
  the KERNAL routines. If an error occurs during a KERNAL routine , the
  carry bit of the accumulator is set, and the number of the error message
  is returned in the accumulator.

  | NOTE: Some KERNAL I/O routines do not use these codes for error       |
  | messages. Instead, errors are identified using the KERNAL READST      |
  | routine.                                                              |


ERROR VALUES
  | NUMBER|                          MEANING                              |
  |   0   |  Routine terminated by the <STOP> key                         |
  |   1   |  Too many open files                                          |
  |   2   |  File already open                                            |
  |   3   |  File not open                                                |
  |   4   |  File not found                                               |
  |   5   |  Device not present                                           |
  |   6   |  File is not an input file                                    |
  |   7   |  File is not an output file                                   |
  |   8   |  File name is missing                                         |
  |   9   |  Illegal device number                                        |
  |  240  |  Top-of-memory change RS-232 buffer allocation/deallocation   |"
"[INST]In the context of the C64, What are the five main activities performed by the KERNAL during its power-up sequence?[/INST]KERNAL POWER-UP ACTIVITIES

  1) On power-up, the KERNAL first resets the stack pointer, and clears
     decimal mode.
  2) The KERNAL then checks for the presence of an autostart ROM cartridge
     at location $8000 HEX (32768 decimal). If this is present, normal
     initialization is suspended, and control is transferred to the car-
     tridge code. If an autostart ROM is not present, normal system ini-
     tialization continues.
  3) Next, the KERNAL initializes all INPUT/OUTPUT devices. The serial bus
     is initialized. Both 6526 CIA chips are set to the proper values for
     keyboard scanning, and the 60-Hz timer is activated. The SID chip is
     cleared. The BASIC memory map is selected and the cassette motor is
     switched off.
  4) Next, the KERNAL performs a RAM test, setting the top and bottom of
     memory pointers. Also, page zero is initialized, and the tape buffer
     is set up.
       The RAM TEST routine is a nondestructive test starting at location
     $0300 and working upward. Once the test has found the first non-RAM
     location, the top of RAM has its pointer set. The bottom of memory is
     always set to $0800, and the screen setup is always set at $0400.
  5) Finally, the KERNAL performs these other activities. I/O vectors are
     set to default values. The indirect jump table in low memory is estab-
     lished. The screen is then cleared, and all screen editor variables
     reset. Then the indirect at $A000 is used to start BASIC."
"[INST]In the context of the C64, What is the detail for the instruction STA?[/INST]STA                  STA Store accumulator in memory                  STA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   STA Oper            |    85   |    2    |    3     |
  |  Zero Page,X   |   STA Oper,X          |    95   |    2    |    4     |
  |  Absolute      |   STA Oper            |    80   |    3    |    4     |
  |  Absolute,X    |   STA Oper,X          |    90   |    3    |    5     |
  |  Absolute,Y    |   STA Oper, Y         |    99   |    3    |    5     |
  |  (Indirect,X)  |   STA (Oper,X)        |    81   |    2    |    6     |
  |  (Indirect),Y  |   STA (Oper),Y        |    91   |    2    |    6     |"
"[INST]In the context of the C64, What is the purpose of the instruction PHA in 6502?[/INST]PHA                   PHA Push accumulator on stack                   PHA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PHA                 |    48   |    1    |    3     |"
"[INST]In the context of the C64, What feature of the VIC-II chip allows for the detection of collisions between sprites and background data?[/INST]COLLISION DETECTS

    One of the more interesting aspects of the VIC-II chip is its collision
  detection abilities. Collisions can be detected between sprites, or be-
  tween sprites and background data. A collision occurs when a non-zero
  part of a sprite overlaps a non-zero portion of another sprite or char-
  acters on the screen."
"[INST]In the context of the C64, What is the primary way to access and modify the memory locations used for music synthesis in the Commodore 64?[/INST]Your Commodore computer is equipped with one of the most sophisticated
  electronic music synthesizers available on any computer. It comes
  complete with three voices, totally addressable, ATTACK/DECAY/SUSTAIN/
  RELEASE (ADSR), filtering, modulation, and 'white noise.' All of these
  capabilities are directly available for you through a few easy to use
  BASIC and/or assembly language statements and functions. This means that
  you can make very complex sounds and songs using programs that are
  relatively simple to design.
    This section of your Programmer's Reference Guide has been created to
  help you explore all the capabilities of the 6581 'SID' chip, the sound
  and music synthesizer inside your Commodore computer. We'll explain both
  the theory behind musical ideas and the practical aspects of turning
  those ideas into real finished songs on your Commodore computer.
    You need not be an experienced programmer nor a music expert to achieve
  exciting results from the music synthesizer. This section is full of
  programming examples with complete explanations to get you started.
    You get to the sound generator by POKEing into specified memory
  locations. A full list of the locations used is provided in Appendix O.
  We will go through each concept, step by step. By the end you should be
  able to create an almost infinite variety of sounds, and be ready to
  perform experiments with sound on your own.
    Each section of this chapter begins by giving you an example and a full
  line-by-line description of each program, which will show you how to use
  the characteristic being discussed. The technical explanation is for you
  to read whenever you are curious about what is actually going on. The
  workhorse of your sound programs is the POKE statement. POKE sets the
  indicated memory location (MEM) equal to a specified value (NUM).
    POKE MEM,NUM
    The memory locations (MEM) used for music synthesis start at 54272
  ($D400) in the Commodore 64. The memory locations 54272 to 54296
  inclusive are the POKE locations you need to remember when you're using
  the 6581 (SID) chip register map. Another way to use the locations above
  is to remember only location 54272 and then add a number from 0 through
  24 to it. By doing this you can POKE all the locations from 54272 to
  54296 that you need from the SID chip. The numbers (NUM) that you use in
  your POKE statement must be between 0 and 255, inclusive.
    When you've had a little more practice with making music, then you can
  get a little more involved, by using the PEEK function. PEEK is a
  function that is equal to the value currently in the indicated memory
  location.
    X=PEEK(MEM)

    The value of the variable X is set equal to the current contents of
  memory location MEM.
    Of course, your programs include other BASIC commands, but for a full
  explanation of them, refer to the BASIC Statements section of this
  manual."
"[INST]In the context of the C64, HWhat is the process for positioning a sprite beyond the 255th pixel across the screen in a Commodore 64 game?[/INST]POKEING AN X POSITION: The possible values of X are 0 to 255, counting
  from left to right. Values 0 to 23 place all or part of the sprite OUT OF
  THE VIEWING AREA off the left side of the screen... values 24 to 255
  place the sprite IN THE VIEWING AREA up to the 255th position (see next
  paragraph for settings beyond the 255th X position). To place the sprite
  at one of these positions, just type the X-POSITION POKE for the sprite
  you're using. For example, to POKE sprite I at the farthest left X
  position IN THE VIEWING AREA, type: POKE V+2,24.

    X VALUES BEYOND THE 255TH POSITION: To get beyond the 255th position
  across the screen, you need to make a SECOND POKE using the numbers in
  the 'RIGHT X' row of the chart (Figure 3-5). Normally, the horizontal (X)
  numbering would continue past the 255th position to 256, 257, etc., but
  because registers only contain 8 bits we must use a 'second register' to
  access the RIGHT SIDE of the screen and start our X numbering over again
  at 0. So to get beyond X position 255, you must POKE V+16 and a number
  (depending on the sprite). This gives you 65 additional X positions
  (renumbered from 0 to 65) in the viewing area on the RIGHT side of the
  viewing screen. (You can actually POKE the right side X value as high as
  255, which takes you off the right edge of the viewing screen.)

    POKEING A Y POSITION: The possible values of Y are 0 to 255, counting
  from top to bottom. Values 0 to 49 place all or part of the sprite OUT
  OF THE VIEWING AREA off the TOP of the screen. Values 50 to 229 place the
  sprite IN THE VIEWING AREA. Values 230 to 255 place all or part of the
  sprite OUT OF THE VIEWING AREA off the BOTTOM of the screen.

    Let's see how this X-Y positioning works, using sprite 1. Type this
  program:
start tok64 page159.prg
  10 print'{clear}':v=53248:pokev+21,2:poke2041,13
  20 fors=832to895:pokes,255:next:pokev+40,7
  30 pokev+2,24
  40 pokev+3,50
stop tok64

  This simple program establishes sprite 1 as a solid box and positions it
  at the upper left corner of the screen. Now change line 40 to read:

    40 POKE V+3,229

  This moves the sprite to the bottom left corner of the screen. Now let's
  test the RIGHT X LIMIT of the sprite. Change line 30 as shown:

    30 POKE V+2,255

  This moves the sprite to the RIGHT but reaches the RIGHT X LIMIT, which
  is 255. At this point, the 'most significant bit' in register 16 must be
  SET. In other words, you must type POKE V+ 16 and the number shown in the
  'RIGHT X' column in the X-Y POKE CHART above to RESTART the X position
  counter at the 256th pixel/position on the screen. Change line 30 as
  follows:

    30 POKE V+16,PEEK(V+16)OR 2:POKE V+2,0

  POKE V+16,2 sets the most significant bit of the X position for sprite 1
  and restarts it at the 256th pixel/position on the screen. POKE V+2,0
  displays the sprite at the NEW POSITION ZERO, which is now reset to the
  256th pixel.
    To get back to the left side of the screen, you must reset the most
  significant bit of the X position counter to 0 by typing (for sprite 1):

    POKE V+16, PEEK(V+16)AND 253

    TO SUMMARIZE how the X positioning works... POKE the X POSITION for any
  sprite with a number from 0 to 255. To access a position beyond the 255th
  position/pixel across the screen, you must use an additional POKE (V+16)
  which sets the most significant bit of the X position and start counting
  from 0 again at the 256th pixel across the screen.

  This POKE starts the X numbering over again from 0 at the 256th position
  (Example: POKE V+16,PEEK(V+16)OR 1 and POKE V,1 must be included to place
  sprite 0 at the 257th pixel across the screen.) To get back to the left
  side X positions you have to TURN OFF the control setting by typing
  POKE V+16,PEEK(V+16)AND 254."
"[INST]In the context of the C64, How do you control sprite to background priority?[/INST]Sprite to background priority is controllable by the SPRITE-BACK-GROUND priority register located at 53275 ($D01B).
  Each sprite has a bit in this register. If that bit is 0, that sprite has a higher priority
  than the background on the screen. In other words, the sprite appears in
  front of background data. If that bit is a 1, that sprite has a lower
  priority than the background. Then the sprite appears behind the back-
  ground data."
"[INST]In the context of the C64, What is the PHP instruction in 6502?[/INST]PHP                 PHP Push processor status on stack                PHP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PHP                 |    08   |    1    |    3     |"
"[INST]In the context of the C64, What is the instruction for storing the value in the X register in memory?[/INST]STX                    STX Store index X in memory                    STX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   STX Oper            |    86   |    2    |    3     |
  |  Zero Page,Y   |   STX Oper,Y          |    96   |    2    |    4     |
  |  Absolute      |   STX Oper            |    8E   |    3    |    4     |"
"[INST]In the context of the C64, What are the three simple steps to follow when using the KERNAL?[/INST]HOW TO USE THE KERNAL


    When writing machine language programs it is often convenient to use
  the routines which are already part of the operating system for input/
  output, access to the system clock, memory management, and other similar
  operations. It is an unnecessary duplication of effort to write these
  routines over and over again, so easy access to the operating system
  helps speed machine language programming.
    As mentioned before, the KERNAL is a jump table. This is just a col-
  lection of JMP instructions to many operating system routines.
    To use a KERNAL routine you must first make all of the preparations
  that the routine demands. If one routine says that you must call another
  KERNAL routine first, then that routine must be called. If the routine
  expects you to put a number in the accumulator, then that number must be
  there. Otherwise your routines have little chance of working the way you
  expect them to work.
    After all preparations are made, you must call the routine by means of
  the JSR instruction. All KERNAL routines you can access are structured as
  SUBROUTINES, and must end with an RTS instruction. When the KERNAL
  routine has finished its task, control is returned to your program at the
  instruction after the JSR.
    Many of the KERNAL routines return error codes in the status word or
  the accumulator if you have problems in the routine. Good programming
  practice and the success of your machine language programs demand that
  you handle this properly. If you ignore an error return, the rest of your
  program might 'bomb.'
    That's all there is to do when you're using the KERNAL. Just these
  three simple steps:

    1) Set up
    2) Call the routine
    3) Error handling

    The following conventions are used in describing the KERNAL routines:

  - FUNCTION NAME: Name of the KERNAL routine.

  - CALL ADDRESS: This is the call address of the KERNAL routine, given in
    hexadecimal.

  - COMMUNICATION REGISTERS: Registers listed under this heading are used
    to pass parameters to and from the KERNAL routines.

  - PREPARATORY ROUTINES: Certain KERNAL routines require that data be set
    up before they can operate. The routines needed are listed here.

  - ERROR RETURNS: A return from a KERNAL routine with the CARRY set
    indicates that an error was encountered in processing. The accumulator
    will contain the number of the error.

  - STACK REQUIREMENTS: This is the actual number of stack bytes used by
    the KERNAL routine.

  - REGISTERS AFFECTED: All registers used by the KERNAL routine are listed
    here.

  - DESCRIPTION: A short tutorial on the function of the KERNAL routine is
    given here.

                       USER CALLABLE KERNAL ROUTINES
  +--------+-------------------+------------------------------------------+
  |        |      ADDRESS      |                                          |
  |  NAME  +---------+---------+                 FUNCTION                 |
  |        |   HEX   | DECIMAL |                                          |
  +--------+---------+---------+------------------------------------------+"
"[INST]In the context of the C64, On can I mix 6502 assembler and Basic on the Commodore 64?[/INST]There are several methods of using BASIC and machine language on the
  Commodore 64, including special statements as part of CBM BASIC as well
  as key locations in the machine. There are five main ways to use machine
  language routines from BASIC on the Commodore 64. They are:


                1) The BASIC SYS statement
                2) The BASIC USR function
                3) Changing one of the RAM I/O vectors
                4) Changing one of the RAM interrupt vectors
                5) Changing the CHRGET routine


    1) The BASIC statement SYS X causes a JUMP to a machine language
       subroutine located at address X. The routine must end with an RTS
       (ReTurn from Subroutine) instruction. This will transfer control
       back to BASIC.
         Parameters are generally passed between the machine language
       routine and the BASIC program using the BASIC PEEK and POKE
       statements, and their machine language equivalents.
         The SYS command is the most useful method of combining BASIC with
       machine language. PEEKs and POKEs make multiple parameter passing
       easy. There can be many SYS statements in a program, each to a
       different (or even the same) machine language routine.

    2) The BASIC function USR(X) transfers control to the machine language
       subroutine located at the address stored in locations 785 and 786.
       (The address is stored in standard low-byte/high-byte format.) The
       value X is evaluated and passed to the machine language subroutine
       through floating point accumulator #1, located beginning at address
       $61 (see memory map for more details). A value may be returned back
       to the BASIC program by placing it in the floating point
       accumulator. The machine language routine must end with an RTS
       instruction to return to BASIC.
         This statement is different from the SYS, because you have to set
       up an indirect vector. Also different is the format through which
       the variable is passed (floating point format). The indirect vector
       must be changed if more than one machine language routine is used.


    3) Any of the inpUt/OUtPUT or BASIC internal routines accessed through
       the vector table located on page 3 (see ADDRESSING MODES, ZERO PAGE)
       can be replaced, or amended by user code. Each 2-byte vector
       consists of a low byte and a high byte address which is used by the
       operating system.
         The KERNAL VECTOR routine is the most reliable way to change any
       of the vectors, but a single vector can be changed by POKES. A new
       vector will point to a user prepared routine which is meant to
       replace or augment the standard system routine. When the appropriate
       BASIC command is executed, the user routine will be executed. If
       after executing the user routine, it is necessary to execute the
       normal system routine, the user program must JMP (JUMP) to the
       address formerly contained in the vector. If not, the routine must
       end with a RTS to transfer control back to BASIC.

    4) The HARDWARE INTERRUPT (IRQ) VECTOR can be changed. Every 1/60th of
       a second, the operating system transfers control to the routine
       specified by this vector. The KERNAL normally uses this for timing,
       keyboard scanning, etc. If this technique is used, you should always
       transfer control to the normal IRQ handling routine, unless the
       replacement routine is prepared to handle the CIA chip. (REMEMBER to
       end the routine with an RTI (ReTurn from Interrupt) if the CIA is
       handled by the routine).
         This method is useful for tasks which must happen concurrently
       with a BASIC program, but has the drawback of being more difficult.


NOTE: ALWAYS DISABLE INTERRUPTS BEFORE CHANGING THIS VECTOR!

    5) The CHRGET routine is used by BASIC to get each character/token.
       This makes it simple to add new BASIC commands. Naturally, each new
       command must be executed by a user written machine language
       subroutine. A common way to use this method is to specify a
       character (@ for example) which will occur before any of the new
       commands. The new CHRGET routine will search for the special
       character. If none is present, control is passed to the normal BASIC
       CHRGET routine. If the special character is present, the new command
       is interpreted and executed by your machine language program. This
       minimizes the extra execution time added by the need to search for
       additional commands. This technique is often called a wedge."
"[INST]In the context of the C64, What is the purpose of the kernal SECOND routine ?[/INST]B-27. Function Name: SECOND

    Purpose: Send secondary address for LISTEN
    Call address: $FF93 (hex) 65427 (decimal)
    Communication registers: A
    Preparatory routines: LISTEN
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine is used to send a secondary address to an
  I/O device after a call to the LISTEN routine is made, and the device is
  commanded to LISTEN. The routine canNOT be used to send a secondary
  address after a call to the TALK routine.
    A secondary address is usually used to give setup information to a
  device before I/O operations begin.
    When a secondary address is to be sent to a device on the serial bus,
  the address must first be ORed with $60.

  How to Use:

    1) load the accumulator with the secondary address to be sent.
    2) Call this routine.

  EXAMPLE:

    ;ADDRESS DEVICE #8 WITH COMMAND (SECONDARY ADDRESS) #15
    LDA #8
    JSR LISTEN
    LDA #15
    JSR SECOND"
"[INST]In the context of the C64, What is the purpose of the VECTOR kernal function?[/INST]Function Name: VECTOR

    Purpose: Manage RAM vectors
    Call address: $FF8D (hex) 65421 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y


    Description: This routine manages all system vector jump addresses
  stored in RAM. Calling this routine with the the accumulator carry bit
  set stores the current contents of the RAM vectors in a list pointed to
  by the X and Y registers. When this routine is called with the carry
  clear, the user list pointed to by the X and Y registers is transferred
  to the system RAM vectors. The RAM vectors are listed in the memory map.


 NOTE: This routine requires caution in its use. The best way to use it
 is to first read the entire vector contents into the user area, alter 
 the desired vectors, and then copy the contents back to the system    
 vectors.                                                              

  How to Use:

  READ THE SYSTEM RAM VECTORS

    1) Set the carry.
    2) Set the X and y registers to the address to put the vectors.
    3) Call this routine.

  LOAD THE SYSTEM RAM VECTORS

    1) Clear the carry bit.
    2) Set the X and Y registers to the address of the vector list in RAM
       that must be loaded.
    3) Call this routine.


  EXAMPLE:
    ;CHANGE THE INPUT ROUTINES TO NEW SYSTEM
    LDX #<USER
    LDY #>USER
    SEC
    JSR VECTOR      ;READ OLD VECTORS
    LDA #<MYINP     ;CHANGE INPUT
    STA USER+10
    LDA #>MYINP
    STA USER+11
    LDX #<USER
    LDY #>USER
    CLC
    JSR VECTOR      ;ALTER SYSTEM
    ...
    USER *=*+26"
"[INST]In the context of the C64, What is the purpose of the SCNKEY kernal function in the Commodore 64?[/INST]B-25. Function Name: SCNKEY

    Purpose: Scan the keyboard
    Call address: $FF9F (hex) 65439 (decimal)
    Communication registers: None
    Preparatory routines: IOINIT
    Error returns: None
    Stack requirements: 5
    Registers affected: A, X, Y

    Description: This routine scans the Commodore 64 keyboard and checks
  for pressed keys. It is the same routine called by the interrupt handler.
  If a key is down, its ASCII value is placed in the keyboard queue. This
  routine is called only if the normal IRQ interrupt is bypassed.

  How to Use:

  1) Call this routine.

  EXAMPLE:

    GET  JSR SCNKEY      ;SCAN KEYBOARD
         JSR GETIN       ;GET CHARACTER
         CMP #0          ;IS IT NULL?
         BEQ GET         ;YES... SCAN AGAIN
         JSR CHROUT      ;PRINT IT"
"[INST]In the context of the C64, What is the purpose of the two 9-pin Game Ports on the Commodore 64?[/INST]THE GAME PORTS

    The Commodore 64 has two 9-pin Game Ports which allow the use of
  joysticks, paddies, or a light pen. Each port will accept either one joy-
  stick or one paddle pair. A light pen can be plugged into Port A (only)
  for special graphic control, etc. This section gives you examples of how
  to use the joysticks and paddies from both BASIC and machine language.
    The digital joystick is connected to CIA #1 (MOS 6526 Complex Interface
  Adapter). This input/output device also handles the paddle fire buttons
  and keyboard scanning. The 6526 CIA chip has 16 registers which are in
  memory locations 56320 through 56335 inclusive ($DC00 to $DC0F). Port A
  data appears at location 56320 (DC00) and Port B data is found at
  location 56321 ($DC01).
    A digital joystick has five distinct switches, four of the switches are
  used for direction and one of the switches is used for the fire button.



    These switches correspond to the lower 5 bits of the data in location
  56320 or 56321. Normally the bit is set to a one if a direction is NOT
  chosen or the fire button is NOT pressed. When the fire button is
  pressed, the bit (bit 4 in this case) changes to a 0. 
  
  
  
  
  To read the
  joystick from BASIC, the following subroutine should be used:


start tok64 page344.prg
  10 fork=0to10:rem set up direction string
  20 readdr$(k):next
  30 data'','n','s','','w','nw'
  40 data'sw','','e','ne','se'
  50 print'going...';
  60 gosub100:rem read the joystick
  65 ifdr$(jv)=''then80:rem check if a direction was chosen
  70 printdr$(jv);' ';:rem output which direction
  80 iffr=16then60:rem check if fire button was pushed
  90 print'-----f-----i-----r-----e-----!!!':goto60
  100 jv=peek(56320):rem get joystick value
  110 fr=jvand16:rem form fire button status
  120 jv=15-(jvand15):rem form direction value
  130 return
stop tok64

  +-----------------------------------------------------------------------+
  | NOTE: For the second joystick, set JV = PEEK (56321).                 |
  +-----------------------------------------------------------------------+

    The values for JV correspond to these directions:

                       +-------------+---------------+
                       | JV EQUAL TO |   DIRECTION   |
                       +-------------+---------------+
                       |      0      |          NONE |
                       |      1      |            UP |
                       |      2      |          DOWN |
                       |      3      |             - |
                       |      4      |          LEFT |
                       |      5      |     UP & LEFT |
                       |      6      |   DOWN & LEFT |
                       |      7      |             - |
                       |      8      |         RIGHT |
                       |      9      |    UP & RIGHT |
                       |     10      |  DOWN & RIGHT |
                       +-------------+---------------+"
"[INST]In the context of the C64, What is the purpose of the instruction TAX in the 6502 assembly language?[/INST]TAX                TAX Transfer accumulator to index X                TAX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TAX                 |    AA   |    1    |    2     |"
"[INST]In the context of the C64, WHAT DOES MACHINE CODE LOOK LIKE?[/INST]WHAT DOES MACHINE CODE LOOK LIKE?

    You should be familiar with the PEEK and POKE commands in the CBM BASIC
  language for changing memory locations. You've probably used them for
  graphics on the screen, and for sound effects. Each memory location has
  its own number which identifies it. This number is known as the 'address'
  of a memory location. If you imagine the memory in the Commodore 64 as a
  street of buildings, then the number on each door is, of course, the
  address. Now let's look at which parts of the street are used for what
  purposes."
"[INST]In the context of the C64, What is the purpose of the ACPTR  kernal routine in a Commodore 64 system?[/INST]Description: This is the routine to use when you want to get informa-
  tion from a device on the serial bus, like a disk. This routine gets a
  byte of data off the serial bus using full handshaking. The data is
  returned in the accumulator. To prepare for this routine the TALK routine
  must be called first to command the device on the serial bus to send data
  through the bus. If the input device needs a secondary command, it must
  be sent by using the TKSA KERNAL routine before calling this routine.
  Errors are returned in the status word. The READST routine is used to
  read the status word.


  How to Use:

    0) Command a device on the serial bus to prepare to send data to
       the Commodore 64. (Use the TALK and TKSA KERNAL routines.)
    1) Call this routine (using JSR).
    2) Store or otherwise use the data.


  EXAMPLE:

    ;GET A BYTE FROM THE BUS
    JSR ACPTR
    STA DATA"
"[INST]In the context of the C64, how do I display a sprite beyond the 255TH X-POSITION?[/INST]DISPLAYING A SPRITE BEYOND THE 255TH X-POSITION

    Displaying a sprite beyond the 255th X position requires a special POKE
  which SETS the most significant bit of the X position and starts over at
  the 256th pixel position across the screen. Here's how it works...
    First, you POKE V+16 with the number for the sprite you're using (check
  the 'RIGHT X' row in the X-Y chart... we'll use sprite 0). Now we assign
  an X position, keeping in mind that the X counter starts over from 0 at
  the 256th position on the screen. Change line 50 to read as follows:
    50 POKE V+16,1:POKE V,24:POKE V+1,75

  This line POKEs V+ 16 with the number required to 'open up' the right
  side of the screen... the new X position 24 for sprite 0 now begins 24
  pixels to the RIGHT of position 255. To check the right edge of the
  screen, change line 60 to:

    60 POKE V+16,1:POKE V,65:POKE V+1,75

    Some experimentation with the settings in the sprite chart will give
  you the settings you need to position and move sprites on the left and
  right sides of the screen. The section on 'moving sprites' will also
  increase your understanding of how sprite positioning works."
"[INST]In the context of the C64, What is the range of values that the volume control can be set to?[/INST]VOLUME CONTROL

    Chip register 24 contains the overall volume control. The volume can be
  set anywhere between 0 and 15. The other four bits are used for purposes
  we'll get into later. For now it is enough to know volume is 0 to 15.
  Look at line 30 to see how it's set in Example Program 1."
"[INST]In the context of the C64, What is the purpose of the IOBASE routine in the Commodore 64 KERNAL?[/INST]B-12. Function Name: IOBASE

    Purpose: Define I/O memory page
    Call address: $FFF3 (hex) 65523 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns:
    Stack requirements: 2
    Registers affected: X, Y


    Description: This routine sets the X and Y registers to the address of
  the memory section where the memory mapped 110 devices are located. This
  address can then be used with an offset to access the memory mapped I/O
  devices in the Commodore 64. The offset is the number of locations from
  the beginning of the page on which the I/O register you want is located.
  The X register contains the low order address byte, while the Y register
  contains the high order address byte.
    This routine exists to provide compatibility between the Commodore 64,
  VIC-20, and future models of the Commodore 64. If the J/0 locations for
  a machine language program are set by a call to this routine, they should
  still remain compatible with future versions of the Commodore 64, the
  KERNAL and BASIC.


  How to Use:

    1) Call this routine by using the JSR instruction.
    2) Store the X and the Y registers in consecutive locations.
    3) Load the Y register with the offset.
    4) Access that I/O location.

  EXAMPLE:

    ;SET THE DATA DIRECTION REGISTER OF THE USER PORT TO 0 (INPUT)
    JSR IOBASE
    STX POINT       ;SET BASE REGISTERS
    STY POINT+1
    LDY #2
    LDA #0          ;OFFSET FOR DDR OF THE USER PORT
    STA (POINT),Y   ;SET DDR TO 0"
"[INST]In the context of the C64, What is the purpose of the IOINIT function?[/INST]B-13. Function Name: IOINIT

    Purpose: Initialize I/O devices
    Call Address: $FF84 (hex) 65412 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns:
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine initializes all input/output devices and
  routines. It is normally called as part of the initialization procedure
  of a Commodore 64 program cartridge.

  EXAMPLE:
    JSR IOINIT"
"[INST]In the context of the C64, What determines the order in which sprites appear on the screen when they overlap?[/INST]SPRITE PRIORITIES

    You can actually make different sprites seem to move IN FRONT OF or
  BEHIND each other on the screen. This incredible three dimensional illu-
  sion is achieved by the built-in SPRITE PRIORITIES which determine which
  sprites have priority over the others when 2 or more sprites OVERLAP on
  the screen.
    The rule is 'first come, first served' which means lower-numbered
  sprites AUTOMATICALLY have priority over higher-numbered sprites. For
  example, if you display sprite 0 and sprite 1 so they overlap on the
  screen, sprite 0 will appear to be IN FRONT OF sprite 1. Actually, sprite
  0 always supersedes all the other sprites because it's the lowest num-
  bered sprite. In comparison, sprite 1 has priority over sprites 2-7;
  sprite 2 has priority over sprites 3-7, etc. Sprite 7 (the last sprite)
  has LESS PRIORITY than any of the other sprites, and will always appear
  to be displayed 'BEHIND' any other sprites which overlap its position.
    To illustrate how priorities work, change lines 50, 60, and 70 in the
  program above to the following:


  50 POKEV,24:POKEV+1,50:POKEV+16,0
  60 POKEV+2,34:POKEV+3,60
  70 POKEV+4,44:POKEV+5,70


  You should see a white sprite on top of a yellow sprite on top of an
  orange sprite. Of course, now that you see how priorities work, you can
  also MOVE SPRITES and take advantage of these priorities in your ani-
  mation."
"[INST]In the context of the C64, What is the primary function of the built-in program that interprets and executes CBM BASIC commands on the Commodore 64?[/INST]The C64 OPERATING SYSTEM of the Commodore 64 then allows you to type on the
  keyboard, and use the built-in SCREEN EDITOR on the Commodore 64. The
  SCREEN EDITOR allows you to move the cursor, DELete, INSert, etc., and
  is, in fact, only one part of the operating system that is built in for
  your convenience.
    All of the commands that are available in CBM BASIC are simply
  recognized by another huge machine language program built into your
  Commodore 64. This huge program 'RUNS' the appropriate piece of machine
  language depending on which CBM BASIC command is being executed. This
  program is called the BASIC INTERPRETER, because it interprets each
  command, one by one, unless it encounters a command it does not
  understand, and then the familiar message appears:

    ?SYNTAX ERROR

    READY."
"[INST]In the context of the C64, What is the purpose of the ACPTR kernal function?[/INST]Function Name: ACPTR

    Purpose: Get data from the serial bus
    Call address: $FFA5 (hex) 65445 (decimal)
    Communication registers: A
    Preparatory routines: TALK, TKSA
    Error returns: See READST
    Stack requirements: 13
    Registers affected: A, X"
"[INST]In the context of the C64, What is the assembly language instruction that stores the value in the accumulator into memory at the specified address?[/INST]STY                    STY Store index Y in memory                    STY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   STY Oper            |    84   |    2    |    3     |
  |  Zero Page,X   |   STY Oper,X          |    94   |    2    |    4     |
  |  Absolute      |   STY Oper            |    8C   |    3    |    4     |"
"[INST]In the context of the C64, What forms of data storage do floppy diskettes allow?[/INST]DATA STORAGE ON FLOPPY DISKETTES

    Diskettes allow 3 different forms of data storage. Sequential files are
  similar to those on tape, but several can can be used at the same time.
  Relative files let you organize the data into records, and then read and
  replace individual records within the file. Random files let you work
  with data anywhere on the disk. They are organized into 256 byte sections
  called blocks.
    The PRINT# statement's limitations are discussed in the section on
  cassette tape. The same limitations to format apply on the disk. RETURNs
  or commas are needed to separate your data. The CHR$(0) is still read by
  the GET# statement as an empty string.
    Relative and random files both make use of separate data and command
  'channels.' Data written to the disk goes through the data channel, where
  it is stored in a temporary buffer in the disk's RAM. When the record or
  block is complete, a command is sent through the command channel that
  tells the drive where to put the data, and the entire buffer is written.
    Applications that require large amounts of data to be processed are
  best stored in relative disk files. These will use the least amount of
  time and provide the best flexibility for the programmer. Your disk drive
  manual gives a complete programming guide to use of disk files."
"[INST]In the context of the C64, HWhat is the purpose of the SAVE routine in the  kernal?[/INST]B-24. Function Name: SAVE

    Purpose: Save memory to a device
    Call address: $FFD8 (hex) 65496 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: SETLFS, SETNAM
    Error returns: 5,8,9, READST
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine saves a section of memory. Memory is saved
  from an indirect address on page 0 specified by the accumulator to the
  address stored in the X and Y registers. It is then sent to a logical
  file on an input/output device. The SETLFS and SETNAM routines must be
  used before calling this routine. However, a file name is not required to
  SAVE to device 1 (the Datassette(TM) recorder). Any attempt to save to
  other devices without using a file name results in an error.

  
  NOTE: Device 0 (the keyboard), device 2 (RS-232), and device 3 (the 
  screen) cannot be SAVEd to. If the attempt is made, an error occurs,
  and the SAVE is stopped.                                            

  How to Use:

    0) Use the SETLFS routine and the SETNAM routine (unless a SAVE with no
       file name is desired on 'a save to the tape recorder'),
    1) Load two consecutive locations on page 0 with a pointer to the start
       of your save (in standard 6502 low byte first, high byte next
       format).
    2) Load the accumulator with the single byte page zero offset to the
       pointer.
    3) Load the X and Y registers with the low byte and high byte re-
       spectively of the location of the end of the save.
    4) Call this routine.

  EXAMPLE:

    LDA #1              ;DEVICE = 1:CASSETTE
    JSR SETLFS
    LDA #0              ;NO FILE NAME
    JSR SETNAM
    LDA PROG            ;LOAD START ADDRESS OF SAVE
    STA TXTTAB          ;(LOW BYTE)
    LDA PROG+1
    STA TXTTA B+1       ;(HIGH BYTE)
    LDX VARTAB          ;LOAD X WITH LOW BYTE OF END OF SAVE
    LDY VARTAB+1        ;LOAD Y WITH HIGH BYTE
    LDA #<TXTTAB        ;LOAD ACCUMULATOR WITH PAGE 0 OFFSET
    JSR SAVE"
"[INST]In the context of the C64, What is the purpose of the UNTLK kernal function?[/INST]Function Name: UNTLK

    Purpose: Send an UNTALK command
    Call address: $FFAB (hex) 65451 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine transmits an UNTALK command on the serial
  bus. All devices previously set to TALK will stop sending data when this
  command is received.

  How to Use:
    1) Call this routine.

  EXAMPLE:
    JSR UNTALK"
"[INST]In the context of the C64, What happens when you close an RS-232 data channel?[/INST]CLOSING AN RS-232 DATA CHANNEL

    Closing an RS-232 file discards all data in the buffers at the time of
  execution (whether or not it had been transmitted or printed out), stops
  all RS-232 transmitting and receiving, sets the RTS and transmitted data
  (Sout) lines high, and removes both RS-232 buffers.


  BASIC SYNTAX:

    CLOSE lfn


  KERNAL ENTRY:

    CLOSE ($FFC3)-See Memory Map for more information on entry and exit
  conditions.

  | NOTE: Care should be taken to ensure all data is transmitted before   |
  | closing the channel. A way to check this from BASIC is:               |
  |                                                                       |
  | 100 SS=ST: IF(SS=0 OR SS=8) THEN 100                                  |
  | 110 CLOSE lfn                                                         |"
"[INST]In the context of the C64, What is the purpose of the TALK kernal function?[/INST]Function Name: TALK

    Purpose: Command a device on the serial bus to TALK
    Call address: $FFB4 (hex) 65460 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: To use this routine the accumulator must first be loaded
  with a device number between 0 and 31. When called, this routine then
  ORs bit by bit to convert this device number to a talk address. Then this
  data is transmitted as a command on the serial bus.

  How to Use:

    1) Load the accumulator with the device number.
    2) Call this routine.

  EXAMPLE:

    ;COMMAND DEVICE #4 TO TALK
    LDA #4
    JSR TALK"
"[INST]In the context of the C64, What is the purpose of the SETLFS kernal routine?[/INST]B-28. Function Name: SETLFS

    Purpose: Set up a logical file
    Call address: $FFBA (hex) 65466 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: None


    Description: This routine sets the logical file number, device address,
  and secondary address (command number) for other KERNAL routines.
    The logical file number is used by the system as a key to the file
  table created by the OPEN file routine. Device addresses can range from 0
  to 31. The following codes are used by the Commodore 64 to stand for the
  CBM devices listed below:


                  ADDRESS          DEVICE

                     0            Keyboard
                     1            Datassette(TM)
                     2            RS-232C device
                     3            CRT display
                     4            Serial bus printer
                     8            CBM serial bus disk drive


    Device numbers 4 or greater automatically refer to devices on the
  serial bus.
    A command to the device is sent as a secondary address on the serial
  bus after the device number is sent during the serial attention
  handshaking sequence. If no secondary address is to be sent, the Y index
  register should be set to 255.

  How to Use:

    1) Load the accumulator with the logical file number.
    2) Load the X index register with the device number.
    3) Load the Y index register with the command.


  EXAMPLE:

    FOR LOGICAL FILE 32, DEVICE #4, AND NO COMMAND:
    LDA #32
    LDX #4
    LDY #255
    JSR SETLFS"
"[INST]In the context of the C64, What is a common method used to write machine language programs?[/INST]HOW DO YOU WRITE MACHINE LANGUAGE PROGRAMS?

    Since machine language programs reside in memory, and there is no
  facility in your Commodore 64 for writing and editing machine language
  programs, you must use either a program to do this, or write for yourself
  a BASIC program that 'allows' you to write machine language.
    The most common methods used to write machine language programs are
  assembler programs. These packages allow you to write machine language
  instructions in a standardized mnemonic format, which makes the machine
  language program a lot more readable than a stream of numbers! Let's
  review: A program that allows you to write machine language programs in
  mnemonic format is called an assembler. Incidentally, a program that
  displays a machine language program in mnemonic format is called a
  disassembler. Available for your Commodore 64 is a machine language
  monitor cartridge (with assembler/disassembler, etc.) made by Commodore."
"[INST]In the context of the C64, What is the assembly language instruction that transfers the value of the index register X to the accumulator in 6502?[/INST]TXA                TXA Transfer index X to accumulator                TXA
  
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TXA                 |    8A   |    1    |    2     |"
"[INST]In the context of the C64, What is the breakdown of the Commodore 64's memory map?[/INST]I/O BREAKDOWN

    D000-D3FF   VIC (Video Controller)                     1 K Bytes
    D400-D7FF   SID (Sound Synthesizer)                    1 K Bytes
    D800-DBFF   Color RAM                                  1 K Nybbles
    DC00-DCFF   CIA1 (Keyboard)                            256 Bytes
    DD00-DDFF   CIA2 (Serial Bus, User Port/RS-232)        256 Bytes
    DE00-DEFF   Open I/O slot #l (CP/M Enable)             256 Bytes
    DF00-DFFF   Open I/O slot #2 (Disk)                    256 Bytes

    The two open I/O slots are for general purpose user I/O, special pur-
  pose I/O cartridges (such as IEEE), and have been tentatively designated
  for enabling the Z-80 cartridge (CP/M option) and for interfacing to a
  low-cost high-speed disk system.
    The system provides for 'auto-start' of the program in a Commodore 64
  Expansion Cartridge. The cartridge program is started if the first nine
  bytes of the cartridge ROM starting at location 32768 ($8000) contain
  specific data. The first two bytes must hold the Cold Start vector to be
  used by the cartridge program. The next two bytes at 32770 ($8002) must
  be the Warm Start vector used by the cartridge program. The next three
  bytes must be the letters, CBM, with bit 7 set in each letter. The last
  two bytes must be the digits '80' in PET ASCII."
"[INST]In the context of the C64, What is the method for turning on and off individual sprites without affecting others?[/INST]SPRITEMAKING NOTES

            Alternative Sprite Memory Pointers and Memory Locations
                            Using Cassette Buffer
  
  TURNING ON SPRITES:

    You can turn on any individual sprite by using POKE V+21 and the number
  from the chart... BUT... turning on just ONE sprite will turn OFF any
  others. To turn on TWO OR MORE sprites, ADD TOGETHER the numbers of the
  sprites you want to turn on (Example: POKE V+21, 6 turns on sprites 1 and
  2). Here is a method you can use to turn one sprite off and on without
  affecting any of the others (useful for animation).

  EXAMPLE:

    To turn off just sprite 0 type: POKE V+21,PEEK V+21AND(255-1). Change
  the number 1 in (255-1) to 1,2,4,8,16,32,64, or 128 (for sprites 0-7). To
  re-enable the sprite and not affect the other sprites currently turned
  on, POKE V+21, PEEK(V+21)OR 1 and change the OR 1 to OR 2 (sprite 2), OR
  4 (sprite 3), etc."
"[INST]In the context of the C64, What is the purpose of the RESTOR kernal function?[/INST]B-23. Function Name: RESTOR

    Purpose: Restore default system and interrupt vectors
    Call address: $FF8A (hex) 65418 (decimal)
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: This routine restores the default values of all system
  vectors used in KERNAL and BASIC routines and interrupts. (See the Memory
  Map for the default vector contents). The KERNAL VECTOR routine is used
  to read and alter individual system vectors.

  How to Use:
    1) Call this routine.

  EXAMPLE:
    JSR RESTOR"
"[INST]In the context of the C64, How you detect when a sprite collides with another?[/INST]SPRITE COLLISION:

    You can detect whether a sprite has collided with another sprite by
  using this line: IF PEEK(V+30)ANDX=XTHEN [insert action here]. This line
  checks to see if a particular sprite has collided with ANY OTHER SPRITE,
  where X equals 1 for sprite 0, 2 for sprite 1, 4 for sprite 2, 8 for
  sprite 3, 16 for sprite 4, 32 for sprite 5, 64 for sprite 6, and 128 for
  sprite 7. To check to see if the sprite has collided with a 'BACKGROUND
  CHARACTER' use this line: IF PEEK(V+31)ANDX=XTHEN [insert action here]."
"[INST]In the context of the C64, What is the range of memory locations where color memory is always located?[/INST]COLOR MEMORY

    Color memory can NOT move. It is always located at locations 55296
  ($D800) through 56295 ($DBE7). Screen memory (the 1000 locations starting
  at 1024) and color memory are used differently in the different graphics
  modes. A picture created in one mode will often look completely different
  when displayed in another graphics mode."
"[INST]In the context of the C64, What is the primary requirement for creating multi-colored sprites in a specific mode?[/INST]USING MULTI-COLOR:

    You can create multi-colored sprites although using multi-color mode
  requires that you use PAIRS of pixels instead of individual pixels in
  your sprite picture (in other words each colored 'dot' or 'block' in the
  sprite will consist of two pixels side by side). You have 4 colors to
  choose from: Sprite Color (chart,above), Multi-Color 1, Multi-Color 2 and
  'Background Color' (background is achieved by using zero settings which
  let the background color 'show through'). Consider one horizontal 8-pixel
  block in a sprite picture. The color of each PAIR of pixels is determined
  according to whether the left, right, or both pixels are solid."
"[INST]In the context of the C64, What is the Kernal?[/INST]THE KERNAL


    One of the problems facing programmers in the microcomputer field is
  the question of what to do when changes are made to the operating system
  of the computer by the company. Machine language programs which took much
  time to develop might no longer work, forcing major revisions in the
  program. To alleviate this problem, Commodore has developed a method of
  protecting software writers called the KERNAL.
    Essentially, the KERNAL is a standardized JUMP TABLE to the input,
  output, and memory management routines in the operating system. The
  locations of each routine in ROM may change as the system is upgraded.
  But the KERNAL jump table will always be changed to match. If your
  machine language routines only use the system ROM routines through the
  KERNAL, it will take much less work to modify them, should that need ever
  arise.
    The KERNAL is the operating system of the Commodore 64 computer. All
  input, output, and memory management is controlled by the KERNAL.
    To simplify the machine language programs you write, and to make sure
  that future versions of the Commodore 64 operating system don't make your
  machine language programs obsolete, the KERNAL contains a jump table for
  you to use. By taking advantage of the 39 input/output routines and other
  utilities available to you from the table, not only do you save time, you
  also make it easier to translate your programs from one Commodore
  computer to another.
    The jump table is located on the last page of memory, in read-only
  memory (ROM).
    To use the KERNAL jump table, first you set up the parameters that the
  KERNAL routine needs to work. Then JSR (Jump to SubRoutine) to the proper
  place in the KERNAL jump table. After performing its function, the KERNAL
  transfers control back to your machine language program. Depending on
  which KERNAL routine you are using, certain registers may pass parameters
  back to your program. The particular registers for each KERNAL routine
  may be found in the individual descriptions of the KERNAL subroutines.

    A good question at this point is why use the jump table at all? Why not
  just JSR directly to the KERNAL subroutine involved? The jump table is
  used so that if the KERNAL or BASIC is changed, your machine language
  programs will still work. In future operating systems the routines may
  have their memory locations moved around to a different position in the
  memory map... but the jump table will still work correctly!"
"[INST]In the context of the C64, What is 64Mon?[/INST]64MON

    The 64MON cartridge available from your local dealer, is a program that
  allows you to escape from the world of CBM BASIC, into the land of
  machine language. It can display the contents of the internal registers
  in the 6510 microprocessor, and it allows you to display portions of mem-
  ory, and change them on the screen, using the screen editor. It also has
  a built-in assembler and disassembler, as well as many other features
  that allow you to write and edit machine language programs easily. You
  don't HAVE to use an assembler to write machine language, but the task is
  considerably easier with it. If you wish to write machine language
  programs, it is strongly suggested that you purchase an assembler of some
  sort. Without an assembler you will probably have to 'POKE' the machine
  language program into memory, which is totally unadvisable. This manual
  will give its examples in the format that 64MON uses, from now on. Nearly
  all assembler formats are the same, therefore the machine language
  examples shown will almost certainly be compatible with any assembler.
  But before explaining any of the other features of 64MON, the hexadecimal
  numbering system must be explained."
"[INST]In the context of the C64, What is the purpose of the 6502 instruction TXS?[/INST]TXS              TXS Transfer index X to stack pointer                TXS
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TXS                 |    9A   |    1    |    2     |"
"[INST]In the context of the C64, What is the purpose of the SETMSG kernal routine?[/INST]B-29. Function Name: SETMSG

    Purpose: Control system message output
    Call address: $FF90 (hex) 65424 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A

    Description: This routine controls the printing of error and control
  messages by the KERNAL. Either print error messages or print control mes-
  sages can be selected by setting the accumulator when the routine is
  called. FILE NOT FOUND is an example of an error message. PRESS PLAY ON
  CASSETTE is an example of a control message.
    Bits 6 and 7 of this value determine where the message will come from.
  If bit 7 is 1, one of the error messages from the KERNAL is printed. If
  bit 6 is set, control messages are printed.

  How to Use:

    1) Set accumulator to desired value.
    2) Call this routine.

  EXAMPLE:

    LDA #$40
    JSR SETMSG          ;TURN ON CONTROL MESSAGES
    LDA #$80
    JSR SETMSG          ;TURN ON ERROR MESSAGES
    LDA #0
    JSR SETMSG          ;TURN OFF ALL KERNAL MESSAGES"
"[INST]In the context of the C64, What is the purpose of the TKSA kernal function in a serial communication protocol?[/INST]Function Name: TKSA

    Purpose: Send a secondary address to a device commanded to TALK
    Call address: $FF96 (hex) 65430 (decimal)
    Communication registers: A
    Preparatory routines: TALK
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine transmits a secondary address on the serial
  bus for a TALK device. This routine must be called with a number between
  0 and 31 in the accumulator. The routine sends this number as a secondary
  address command over the serial bus. This routine can only be called
  after a call to the TALK routine. It will not work after a LISTEN.

  How to Use:

    0) Use the TALK routine.
    1) Load the accumulator with the secondary address.
    2) Call this routine.

  EXAMPLE:

    ;TELL DEVICE #4 TO TALK WITH COMMAND #7
    LDA #4
    JSR TALK
    LDA #7
    JSR TALKSA"
"[INST]In the context of the C64, What is the purpose of the two-byte pointers $00F7 and $00F9 in the system?[/INST]RECEIVER/TRANSMITTER BUFFER BASE LOCATION POINTERS


    $00F7-REBUF-A two-byte pointer to the Receiver Buffer base location.
    $00F9-ROBUF-A two-byte pointer to the Transmitter Buffer base location.

    The two locations above are set up by the OPEN KERNAL routine, each
  pointing to a different 256-byte buffer. They are de-allocated by writing
  a zero into the high order bytes ($00F8 and $00FA), which is done by the
  CLOSE KERNAL entry. They may also be allocated/de-allocated by the
  machine language programmer for his/her own purposes, removing/creating
  only the buffer(s) required. When using a machine language program that
  allocates these buffers, care must be taken to make sure that the top of
  memory pointers stay correct, especially if BASIC programs are expected
  to run at the same time."
"[INST]In the context of the C64, What is the purpose of the SETTIM kernal function?[/INST]B-31. Function Name: SETTIM

    Purpose: Set the system clock
    Call address: $FFDB (hex) 65499 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: None

    Description: A system clock is maintained by an interrupt routine that
  updates the clock every 1/60th of a second (one 'jiffy'). The clock is
  three bytes long, which gives it the capability to count up to 5,184,000
  jiffies (24 hours). At that point the clock resets to zero. Before
  calling this routine to set the clock, the accumulator must contain the
  most significant byte, the X index register the next most significant
  byte, and the Y index register the least significant byte of the initial
  time setting (in jiffies).

  How to Use:
    1) Load the accumulator with the MSB of the 3-byte number to set the
       clock.
    2) Load the X register with the next byte.
    3) Load the Y register with the LSB.
    4) Call this routine.

  EXAMPLE:
   ;SET THE CLOCK TO 10 MINUTES = 3600 JIFFIES
   LDA #0               ;MOST SIGNIFICANT
   LDX #>3600
   LDY #<3600           ;LEAST SIGNIFICANT
   JSR SETTIM"
"[INST]In the context of the C64, What is the purpose of the UNLSN kernal function?[/INST]Function Name: UNLSN

    Purpose: Send an UNLISTEN command
    Call address: $FFAE (hex) 65454 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine commands all devices on the serial bus to
  stop receiving data from the Commodore 64 (i.e., UNLISTEN). Calling this
  routine results in an UNLISTEN command being transmitted on the serial
  bus. Only devices previously commanded to listen are affected. This
  routine is normally used after the Commodore 64 is finished sending data
  to external devices. Sending the UNLISTEN commands the listening devices
  to get off the serial bus so it can be used for other purposes.

  How to Use:
    1) Call this routine.

  EXAMPLE:
    JSR UNLSN"
"[INST]In the context of the C64, What is the instruction for disabling the interrupt in the 6502 microprocessor?[/INST]SEI                 SEI Set interrupt disable status                  SED

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   SEI                 |    78   |    1    |    2     |"
"[INST]In the context of the C64, What is the purpose of the TSX instruction in the 6502 assembly ?[/INST]TSX              TSX Transfer stack pointer to index X                TSX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TSX                 |    BA   |    1    |    2     |"
"[INST]In the context of the C64, What are some important considerations when setting sprite pointer settings in RAM memory?[/INST]DIFFERENT SPRITE POINTER SETTINGS:

    These sprite pointer settings are RECOMMENDATIONS ONLY.
    Caution: you can set your sprite pointers anywhere in RAM memory but if
  you set them too 'low' in memory a long BASIC program may overwrite your
  sprite data, or vice versa. To protect an especially LONG BASIC PROGRAM
  from overwriting sprite data, you may want to set the sprites at a higher
  area of memory (for example, 2040,192 for sprite 0 at locations 12288 to
  12350... 2041,193 at locations 12352 to 12414 for sprite 1 and so on...
  by adjusting the memory locations from which sprites get their 'data,'
  you can define as many as 64 different sprites plus a sizable BASIC
  program. To do this, define several sprite 'shapes' in your DATA
  statements and then redefine a particular sprite by changing the
  'pointer' so the sprite you are using is 'pointed' at different areas of
  memory containing different sprite picture data. See the 'Dancing Mouse'
  to see how this works. If you want two or more sprites to have THE SAME
  SHAPE (you can still change position and color of each sprite), use the
  same sprite pointer and memory location for the sprites you want to match
  (for example, you can point sprites 0 and 1 to the same location by using
  POKE 2040,192 and POKE 2041, 192)."
"[INST]In the context of the C64, What is the purpose of crunching"" a program in the context of sprite programming?""[/INST]CRUNCHING YOUR SPRITE PROGRAMS                                        

                                                                         
   Here's a helpful 'crunching' tip: The program described above is      
   already short, but it can be made even shorter by 'crunching' it      
   smaller. In our example we list the key sprite settings on separate   
   program lines so you can see what's happening in the program. In      
   actual practice, a good programmer would probably write this program  
   as a TWO LINE PROGRAM... by 'crunching' it as follows:                
                                                                         
   10 PRINTCHR$(147):V=53248:POKEV+21,1:POKE2040.13:POKEV+39,1           
   20 FORS=832TO894:POKES,255:NEXT:POKEV,24:POKEV+1,100                  
                                                                         
   For more tips on how to crunch your programs so they fit in less      
  memory and run more efficiently, see the 'crunching guide' on Page 24."
"[INST]In the context of the C64, Ho do you position a sprite on the screen?[/INST]POSITIONING SPRITES ON THE SCREEN

    The entire display screen is divided into a grid of X and Y coordi-
  nates, like a graph. The X COORDINATE is the HORIZONTAL position across
  the screen and the Y COORDINATE is the VERTICAL position up and down (see
  Figure 3-4).
    To position any sprite on the screen, you must POKE TWO SETTINGS...
  the X position and the Y position... these tell the computer where to
  display the UPPER LEFT HAND CORNER of the sprite. Remember that a sprite
  consists of 504 individual pixels, 24 across by 21 down... so if you POKE
  a sprite onto the upper left corner of your screen, the sprite will be
  displayed as a graphic image 24 pixels ACROSS and 21 pixels DOWN starting
  at the X-Y position you defined. The sprite will be displayed based on
  the upper left corner of the entire sprite, even if you define the sprite
  using only a small part of the 24X21-pixel sprite area.
    To understand how X-Y positioning works, study the following diagram
  (Figure 3-5), which shows the X and Y numbers in relation to your display
  screen. Note that the GREY AREA in the diagram shows your television
  viewing area... the white area represents positions which are OFF your
  viewing screen...

    To display a sprite in a given location, You must POKE the X and Y
  settings for each SPRITE... remembering that every sprite has its own
  unique X POKE and Y POKE."
"[INST]In the context of the C64, What is the step-by-step guide for creating a sprite?[/INST]CREATING A SPRITE... STEP BY STEP

    To make this as easy as possible for you, we've put together this
  simple step by step guide to help you draw your own sprites.

  STEP 1:

  Write the spritemaking program shown here ON A PIECE OF PAPER... note
  that line 100 starts a special DATA section of your program which will
  contain the 63 numbers you need to create your sprite.

  STEP 2:

  Color in the pixels on the spritemaking grid on Page 162 (or use a piece
  of graph paper... remember, a sprite has 24 squares across and 21 squares
  down). We suggest you use a pencil and draw lightly so you can reuse this
  grid. You can create any image you like, but for our example we'll draw
  a simple box.

  STEP 3:

  Look at the first EIGHT pixels. Each column of pixels has a number (128,
  64, 32, 16, 8, 4, 2, 1). The special type of addition we are going to
  show you is a type of BINARY ARITHMETIC which is used by most computers
  as a special way of counting. 
  STEP 4:

  Add up the numbers of the SOLID pixels. This first group of eight pixels
  is completely solid, so the total number is 255.

  STEP 5:

  Enter that number as the FIRST DATA STATEMENT in line 100 of the
  Spritemaking Program below. Enter 255 for the second and third groups
  of eight.

  STEP 6:

  Look at the FIRST EIGHT PIXELS IN THE SECOND ROW of the sprite. Add up
  the values of the solid pixels. Since only one of these pixels is solid,
  the total value is 128. Enter this as the first DATA number in line 101.


  STEP 7:

  Add up the values of the next group of eight pixels (which is 0 because
  they're all BLANK) and enter in line 101. Now move to the next group of
  pixels and repeat the process for each GROUP OF EIGHT PIXELS (there are
  3 groups across each row, and 21 rows). This will give you a total of 63
  numbers. Each number represents ONE group of 8 pixels, and 63 groups of
  eight equals 504 total individual pixels. Perhaps a better way of looking
  at the program is like this... each line in the program represents ONE
  ROW in the sprite. Each of the 3 numbers in each row represents ONE GROUP
  OF EIGHT PIXELS. And each number tells the computer which pixels to make
  SOLID and which pixels to leave blank.

  STEP 8:

  CRUNCH YOUR PROGRAM INTO A SMALLER SPACE BY RUNNING TOGETHER ALL THE DATA
  STATEMENTS, AS SHOWN IN THE SAMPLE PROGRAM BELOW. Note that we asked you
  to write your sprite program on a piece of paper. We did this for a good
  reason. The DATA STATEMENT LINES 100-120 in the program in STEP 1 are
  only there to help you see which numbers relate to which groups of pixels
  in your sprite. Your final program should be 'crunched' like this:

start tok64 page165.prg
  10 print'{clear}':poke53280,5:poke53281,6
  20 v=53248:pokev+34,3
  30 poke 53269,4:poke2042,13
  40 forn=0to62:readq:poke832+n,q:next
  100 data255,255,255,128,0,1,128,0,1,128,0,1,144,0,1,144,0,1,144,0,1,144,0
  101 data1,144,0,1,144,0,1,144,0,1,144,0,1,144,0,1,144,0,1,128,0,1,128,0,1
  102 data128,0,1,128,0,1,128,0,1,128,0,1,255,255,255
  200 x=200:y=100:poke53252,x:poke53253,y
stop tok64"
"[INST]In the context of the C64, What is the priority of a sprite that will always appear in front of or on top of all other sprites?[/INST]SPRITE PRIORITY:

    Priority means one sprite will appear to move 'in front of' or 'behind'
  another sprite on the display screen. Sprites with more priority always
  appear to move 'in front of' or 'on top of' sprites with less priority.
  The rule is that lower numbered sprites have priority over higher
  numbered sprites. Sprite 0 has priority over all other sprites. Sprite 7
  has no priority in relation to the other sprites. Sprite 1 has priority
  over sprites 2-7, etc. If you put two sprites in the some position, the
  sprite with the higher priority will appear IN FRONT OF the sprite with
  the lower priority. The sprite with lower priority will either be
  obscured, or will 'show through' (from 'behind') the sprite with higher
  priority."
"[INST]In the context of the C64, What is the instruction that transfers the accumulator to index Y in 6502?[/INST]TAY                TAY Transfer accumulator to index Y                TAY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TAY                 |    A8   |    1    |    2     |"
"[INST]In the context of the C64, Can you talk about the C64 memory management?[/INST]MEMORY MANAGEMENT ON THE
  COMMODORE 64

    The Commodore 64 has 64K bytes of RAM. It also has 20K bytes of ROM,
  containing BASIC, the operating system, and the standard character set.
  It also accesses input/output devices as a 4K chunk of memory. How is
  this all possible on a computer with a 16-bit address bus, that is
  normally only capable of addressing 64K?
    The secret is in the 6510 processor chip itself. On the chip is an
  input/output port. This port is used to control whether RAM or ROM or I/O
  will appear in certain portions of the system's memory. The port is also
  used to control the Datassette(TM), so it is important to affect only the
  proper bits.
    The 6510 input/output port appears at location 1. The data direction
  register for this port appears at location 0. The port is controlled like
  any of the other input/output ports in the system... the data direction
  controls whether a given bit will be an input or an output, and the
  actual data transfer occurs through the port itself. The lines in the
  6510 control port are defined as follows:


  |  NAME   |BIT| DIRECTION  |                 DESCRIPTION                |
  |  LORAM  | 0 |   OUTPUT   | Control for RAM/ROM at $A000-$BFFF         |
  |  HIRAM  | 1 |   OUTPUT   | Control for RAM/ROM at $E000-$FFFF         |
  |  CHAREN | 2 |   OUTPUT   | Control for I/O/ROM at $D000-$DFFF         |
  |         | 3 |   OUTPUT   | Cassette write line                        |
  |         | 4 |   INPUT    | Cassette switch sense (0=play button down) |
  |         | 5 |   OUTPUT   | Cassette motor control (0=motor spins)     |


    The proper value for the data direction register is as follows:

                              BITS 5 4 3 2 1 0
                              ----------------
                                   1 0 1 1 1 1

  (where 1 is an output, and 0 is an input).

    This gives a value of 47 decimal. The Commodore 64 automatically sets
  the data direction register to this value.
    The control lines, in general, perform the function given in their de-
  scriptions. However, a combination of control lines are occasionally used
  to get a particular memory configuration.
    LORAM (bit 0) can generally be thought of as a control line which banks
  the 8K byte BASIC ROM in and out of the microprocessor address space.
  Normally, this line is HIGH for BASIC operation. If this line is
  programmed LOW, the BASIC ROM will disappear from the memory map and be
  replaced by 8K bytes of RAM from $A000-$BFFF.
    HIRAM (bit 1) can generally be thought of as a control line which banks
  the 8K byte KERNAL ROM in and out of the microprocessor address space.
  Normally, this line is HIGH for BASIC operation. If this line is
  programmed LOW, the KERNAL ROM will disappear from the memory map and be
  replaced by 8K bytes of RAM from $E000-$FFFF.
    CHAREN (bit 2) is used only to bank the 4K byte character generator ROM
  in or out of the microprocessor address space. From the processor point
  of view, the character ROM occupies the same address space as the I/O
  devices ($D000-$DFFF). When the CHAREN line is set to 1 (as is normal),
  the I/O devices appear in the microprocessor address space, and the
  character ROM is not accessable. When the CHAREN bit is cleared to 0, the
  character ROM appears in the processor address space, and the I/O devices
  are not accessable. (The microprocessor only needs to access the
  character ROM when downloading the character set from ROM to RAM. Special
  care is needed for this... see the section on PROGRAMMABLE CHARACTERS in
  the GRAPHICS chapter). CHAREN can be overridden by other control lines in
  certain memory configurations. CHAREN will have no effect on any memory
  configuration without I/O devices. RAM will appear from $D000-$DFFF
  instead.


  | NOTE: In any memory map containing ROM, a WRITE (a POKE) to a ROM     |
  | location will store data in the RAM 'under' the ROM. Writing to a ROM |
  | location stores data in the 'hidden' RAM. For example, this allows a  |
  | hi-resolution screen to be kept underneath a ROM, and be changed      |
  | without having to bank the screen back into the processor address     |
  | space. Of course a READ of a ROM location will return the contents of |
  | the ROM, not the 'hidden' RAM.                                        |"
"[INST]In the context of the C64, What is the OP CODE for the instruction SED in 6502?[/INST]SED                       SED Set decimal mode                        SED
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   SED                 |    F8   |    1    |    2     |"
"[INST]In the context of the C64, What is the purpose of the UDTIM kernal function?[/INST]Function Name: UDTIM

    Purpose: Update the system clock
    Call address: $FFEA (hex) 65514 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X

    Description: This routine updates the system clock. Normally this
  routine is called by the normal KERNAL interrupt routine every 1/60th of
  a second. If the user program processes its own interrupts this routine
  must be called to update the time. In addition, the <STOP> key routine
  must be called, if the <STOP> key is to remain functional.

  How to Use:
    1) Call this routine.

  EXAMPLE:

    JSR UDTIM"
"[INST]In the context of the C64, What is the purpose of the SETNAM kernal routine?[/INST]B-30. Function Name: SETNAM

    Purpose: Set file name
    Call address: $FFBD (hex) 65469 (decimal)
    Communication registers: A, X, Y
    Preparatory routines:
    Stack requirements: 2
    Registers affected:

    Description: This routine is used to set up the file name for the OPEN,
  SAVE, or LOAD routines. The accumulator must be loaded with the length of
  the file name. The X and Y registers must be loaded with the address of
  the file name, in standard 6502 low-byte/high-byte format. The address
  can be any valid memory address in the system where a string of
  characters for the file name is stored. If no file name is desired, the
  accumulator must be set to 0, representing a zero file length. The X and
  Y registers can be set to any memory address in that case.

  How to Use:

    1) Load the accumulator with the length of the file name.
    2) Load the X index register with the low order address of the file
       name.
    3) Load the Y index register with the high order address.
    4) Call this routine.

  EXAMPLE:

    LDA #NAME2-NAME     ;LOAD LENGTH OF FILE NAME
    LDX #<NAME          ;LOAD ADDRESS OF FILE NAME
    LDY #>NAME
    JSR SETNAM"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E6A8?[/INST]address              $E6A8
Return from Outputting a Character to the Screen

This is the common exit point for the screen portion of the CHROUT
routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A437-$A468?[/INST]address   $A437-$A468    ERROR
General Error Handler

The error number is passed to this routine in the .X register, and it
displays the appropriate error message.  Since this routine is
vectored through RAM at 768 ($300), you can divert this vector to the
address of your own routine, which would allow error trapping, or the
addition of new commands."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A7AE?[/INST]address         $A7AE          NEWSTT
Set Up Next Statement for Execution

This routine tests for the STOP key, updates the pointer to the
current line number, and positions the text pointer to read the
beginning of the statement."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E8A1?[/INST]address              $E8A1
If at the Beginning of a Screen Line, Move Cursor to Previous Line"
"[INST]In the context of the C64, What is the purpose of the memory location at address $ED0C?[/INST]address              $ED0C          LISTEN

This is a documented Kernal routine whose entry in the jump table is
65457 ($FFB1).  When called, it ORs the device number in the
Accumulator with the LISTEN code (32, $20) and sends it on the serial
bus.  This commands the device to LISTEN."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EDEF?[/INST]address              $EDEF          UNTLK
Send UNTALK to a Device on the Serial Bus

This is a documented Kernal routine whose entry in the jump table is
65451 ($FFAB).  When called, it sends the UNTALK code (95, $5F) on the
serial bus.  This commands any TALKer on the bus to stop sending data."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EEA9?[/INST]address              $EEA9
Get Serial Bus Data Input Bit and Clock Pulse Input Bit

This subroutine reads the serial bus data input bit and clock pulse
input bit (Bits 7 and 6 of CIA #2 Data Port A at 56576 ($DD00)), and
returns the data bit in the Carry flag and the clock bit in the
Negative flag."
"[INST]In the context of the C64, What is the purpose of the memory location at address $295-$296?[/INST]address       $295-$296      M51AJB
RS-232: Nonstandard Bit Timing

These locations are provided for storing a nonstandard user-defined
baud rate, to be used when the low nybble of the control register at
659 ($293) is set to 0.  They were presumable provided to conform to
the nodel of the 6551 UART device, which allows a nonstandard baud
rate to be generated from an external reference crystal.  However, the
software emulation of that feature is not provided in the current
version of the Kernal, and thus these locations are currently
nonfunctional.

Nonetheless, Commodore has specified that if the nonstandard baud rate
feature is implemented, the value placed here should equal the system
clock frequency divided by the baud rate divided by 2 minus 100,
stored in low byte, high byte order.  The system clock frequency for
American television monitors (NTSC standard) is 1.02273 MHz, and for
European monitors (PAL standard) .98525 MHz."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F7EA?[/INST]address              $F7EA
Search Tape for a Filename"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F6ED?[/INST]address              $F6ED          STOP
Test STOP Key

STOP is a documented Kernal routine which can be entered from the jump
table at location 65505 ($FFE1).

It is vectored through RAM at 808 ($328).  The routine checks to see
if the STOP key was pressed during the last UDTIM call.  If it was,
the Zero flag is set to 1, the CLRCHN routine is called to set the
input and output devices back to the keyboard and screen, and the
keyboard queue is emptied."
"[INST]In the context of the C64, What is the purpose of the memory location at address $0286?[/INST]address           $286           COLOR
Current Foreground Color for Text

The process of PRINTing a character to the screen consists of both
placing the screen code value for the character in screen memory and
placing a foreground color value in the corresponding location in
color RAM.  Whenever a character is PRINTed, the Operating System
fetches the value to be put in color RAM from this location.

The foreground color may be changed in a number of ways.  Pressing the
CTRL or Commodore logo key and numbers 1-8 at the same time will
change the value stored here, and thus the color being printed.
PRINTing the PETASCII equivalent character with the CHR$ command will
have the same effect.  But probably the easiest method is to POKE the
color value directly to this location.  The table below lists the
possible colors that may be produced, and shows how to produce them
using all three methods.

POKE
COLOR #   COLOR     CHR$   KEYS TO PRESS
 0        Black     144    CTRL-1
 1        White       5    CTRL-2
 2        Red        28    CTRL-3
 3        Cyan      159    CTRL-4
 4        Purple    156    CTRL-5
 5        Green      30    CTRL-6
 6        Blue       31    CTRL-7
 7        Yellow    158    CTRL-8
 8        Orange    129    Logo-1
 9        Brown     149    Logo-2
10        Lt Red    150    Logo-3
11        Dark Gray 151    Logo-4
12        Med Gray  152    Logo-5
13        Lt Green  153    Logo-6
14        Lt Blue   154    Logo-7
15        Lt Gray   155    Logo-8"
"[INST]In the context of the C64, What is the purpose of the memory location at address $2A6?[/INST]address          $2A6
PAL/NTSC Flag

At power-on, a test is performed to see if the monitor uses the NTSC
(North American) or PAL (European) television standard.

This test is accomplished by setting a raster interrupt for scan line
311, and testing if the interrupt occurs.  Since NTSC monitors have
only 262 raster scan lines per screen, the interrupt will occur only
if a PAL monitor is used.  The results of that test are stored here,
with a 0 indicating an NTSC system in use, and one signifying a PAL
system.

This information is used by the routines which set the prescaler
values for the system IRQ timer, so that the IRQ occurs every 1/60
second.  Since the PAL system 02 clock runs a bit slower than the NTSC
version, this prescaler value must be adjusted accordingly."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BB-$BC?[/INST]address       $BB-$BC        FNADR
Pointer: Current Filename

This location holds a pointer to the address of the current filename.
If an operation which OPENs a tape file does not specify a filename,
this pointer is not used.

When a disk filename contains a shifted space character, the remainder
of the name will appear outside the quotes in the directory, and may
be used for comments.  For example, if you SAVE 'ML[shifted
space]SYS828', the directory entry will read 'ML'SYS 828.  You may
reference the program either by the portion of the name that appears
within quotes, or by the full name, including the shifted space.  A
program appearing later in the directory as 'ML'SYS 900 would not be
found just by reference to 'ML', however.

A filename of up to four characters may be used when opening the
RS-232 device.  These four characters will be copied to 659-662
($293-$296), where they are used to control such parameters as baud
rate, parity, and word length."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A8?[/INST]address           $A8            BITCI
RS-232 Input Bit Count/Cassete Temporary Storage

This location is used to count the number of bits of serial data that
has been received.  This is necessary so that the serial routines will
know when a full word has been received.  It is also used as an error
flag during tape loads."
"[INST]In the context of the C64, What is the purpose of the memory location at address $32A-$32B ?[/INST]address       $32A-$32B      IGETIN
Vector to Kernal GETIN Routine (Currently at 61758 ($F13E))"
"[INST]In the context of the C64, What is the purpose of the memory location at address $96?[/INST]address           $96            SYNO
Cassette Block Synchronization Number"
"[INST]In the context of the C64, What is the purpose of the memory location at address $311-$312?[/INST]address      $311-$312      USRADD
Address of USR Routine (Low Byte First)

These locations contain the target address of the USR command.  They
are initialized by the Operating System to point to the BASIC error
message handler routine, so that if you try to execute a USR call
without changing these values, you wil receive an ILLEGAL QUANTITY
error message.

In order to successfully execute a USR call, you must first POKE in
the target address in low-byte, high-byte order.  You can calculate
these two values for any address with the formula:

HI=INT(AD/256):LO=AD-(HI*256)

For example, if the USR routine started at 49152 ($C000), you would
POKE 786, INT(49152/256):POKE 785,49152-(PEEK(786)*256 before
executing the USR command.

What makes the USR command different from SYS is that you can pass a
parameter into the machine language routine by placing it in
parenthesis after the USR keyword, and you can pass a parameter back
to a variable by assigning its value to the USR function.

In other words, the statement X=USR(50) will first put the number 50
in floating point format into the Floating Point Accumulator (FAC1) at
97-102 ($61-$66).  Then, the machine language program designated by
the address at this vector will be executed.  Finally, the variable X
will be assigned the floating point value which ends up in FAC1 after
the user-written routine is finished.

Since floating point representation is difficult to work with, it is
handy to change these floating point parameters into integers before
working with them.  Fortunately, there are vectored routines which
will do the conversions for you.  The routine vectored at locations
3-4 converts the number in FAC1 to a two-byte signed integer, with the
low byte in the .Y register (and location 101 ($65)) and the high byte
in the Accumulator (.A).  Remember, that number is converted to a
signed integer in the range between 32767 and -32768, with Bit 7 of
the high byte used to indicate the sign.

To pass a value back through the USR function, you need to place the
number into FAC1.  To conert a signed integer to floating point
format, place the high byte into the Accumulator (.A), the low byte
into the .Y register, and jump through the vector at locations 5-6
with a JMP ($0005) instruction.  The floating point result will be
left in FAC1."
"[INST]In the context of the C64, What is the purpose of the memory location at address $7?[/INST]address            $7             CHARAC
Search Character for Scanning BASIC Text Input

This location and the next are used heavily by the BASIC routines that
scan the text that comes into the buffer at 512 ($200), in order to
detect significant characters such as quotes, comma, the colon which
separates BASIC statements, and end-of-line.  The ASCII values of such
special characters are usually stored here.

This location is also used as a work area by other BASIC routines that
do not involve scanning text."
"[INST]In the context of the C64, What is the purpose of the memory location at address $69?[/INST]address           $69            ARGEXP
Floating Point Accumulator #2: Exponent"
"[INST]In the context of the C64, What is the purpose of the memory location at address $4B-$4C?[/INST]address         $4B-$4C        OPPTR
Math Operator Table Displacement

This location is used during the evaluation of mathematical
expressions to hold the displacement of the current math operator in
an operator table.  It is also used as a save area for the pointer to
the address of program text which is currently being read."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D408?[/INST]address              $D408          FREHI2
Voice 2 Frequency Control (high byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BC9B?[/INST]address         $BC9B          QINT
Convert FAC1 into Integer Within FAC1

This routine converts the value in FAC1 into a four-byte signed
integer in 98- 101 ($62-$65), with the most significant byte first."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BAF9?[/INST]address         $BAF9          TENC
The Constant 10 in Five-Byte Floating Format"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D402?[/INST]address              $D402          PWLO1
Voice 1 Pulse Waveform Width (low byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D01C?[/INST]address              $D01C          SP5COL
Sprite 5 Color Register (the default color value is 6, blue)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D010?[/INST]address              $D010          MSIGX
Most Significant Bits of Sprites 0-7 Horizontal Position

Bit 0:  Most significant bit of Sprite 0 horizontal position
Bit 1:  Most significant bit of Sprite 1 horizontal position
Bit 2:  Most significant bit of Sprite 2 horizontal position
Bit 3:  Most significant bit of Sprite 3 horizontal position
Bit 4:  Most significant bit of Sprite 4 horizontal position
Bit 5:  Most significant bit of Sprite 5 horizontal position
Bit 6:  Most significant bit of Sprite 6 horizontal position
Bit 7:  Most significant bit of Sprite 7 horizontal position

Setting one of these bites to 1 adds 256 to the horizontal position of
the corresponding sprite.  Resetting one of these bits to 0 restricts
the horizontal position of the corresponding sprite to a value of 255
or less"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D001?[/INST]address         $D001          SP0Y
Sprite 0 Vertical Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D002?[/INST]address         $D002          SP1X
Sprite 1 Horizontal Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D011?[/INST]address              $D011          SCROLY
Vertical Fine Scrolling and Control Register

Bits 0-2:  Fine scroll display vertically by X scan lines (0-7)
Bit 3:  Select a 24-row or 25-row text display (1=25 rows, 0=24 rows)
Bit 4:  Blank the entire screen to the same color as the background
  (0=blank)
Bit 5:  Enable bitmap graphics mode (1=enable)
Bit 6:  Enable extended color text mode (1=enable)
Bit 7:  High bit (Bit 8) of raster compare register at 53266 ($D012)

This is one of the two important multifunction control registers on
the VIC-II chip.  Its defaule value is 155, which sets the high bit of
the raster compare to 1, selects a 25-row display, disables the
blanking feature, and uses a vertical scrolling offset of three scan
lines.

Bits 0-2.  These bits control vertical fine scrolling of the screen
display.  This feature allows you to move the entire text display
smoothly up and down, enabling the display area to act as a window,
scrolling over a larger text or character graphics display.

Since each row of text is eight scan lines high, if you simply move
each line of text up one row, the characters travel an appreciable
distance each time they move, which gives the motion a jerky quality.
This is called coarse scrolling, and you can see an example of it when
LISTing a program that is too long to fit on the screen all at one
time.

By placing a number from 1 to 7 into these three bits, you can move
the whole screen display down by from 1 to 7 dot spaces.  Stepping
through the values 1 to 7 allows you to smoothly make the transition
from having a character appear in one row on the screen to having it
appear in the next row.  To demonstrate this, type in the following
sample program, LIST it, and RUN.

10 FOR I= 1 TO 50:FOR J=0 TO 7
20 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I
30 FOR I= 1 TO 50:FOR J=7 TO 0 STEP-1
40 POKE 53265, (PEEK(53265)AND248) OR J:NEXTJ,I

As you can see, after the display has moved seven dot positions up or
down, it starts over at its original position.  In order to continue
the scroll, you must do a coarse scroll every time the value of the
scroll bits goes from 7 to 0, or from 0 to 7.  This is accomplished by
moving the display data for each line by 40 bytes in either direction,
overwriting the data for the last line, and introducing a line of data
at the opposite end of screen memory to replace it.  Obviously, ony a
machine language program can move all of these lines quickly enough to
maintain the effect of smooth motion.  The following BASIC program,
however, will give you an iea of what vertical fine scrolling is like:

10 POKE 53281,0:PRINTCHR$(5);CHR$(147)
20 FORI=1 TO 27:
30 PRINTTAB(15)CHR$(145)'            ':POKE 53265,PEEK(53265)AND248
40 WAIT53265,128:PRINTTAB(15)'I'M FALLING'
50 FOR J=1 TO 7
60 POKE53265,(PEEK(53265)AND248)+J
70 FORK=1TO50
80 NEXT K,J,I:RUN

Bit 3.  This bit register allows you to select either the normal
25-line text display (by setting the bit to 1), or a shortened 24-row
display (by resetting that bit to 0).  This shortened display is
created by extending the border to overlap the top or bottom row.  The
characters in these rows are still there; they are just covered up.

The shortened display is designed to aid vertical fine scrolling.  It
covers up the line into which new screen data is introduced, so that
the viewer does not see the new data being moved into place.

However, unlink the register at 53270 ($D016) which shortens the
screen by one character space on either side to aid horizontal
scrolling in either direction, this register can blank only one
vertical line at a time.  In order to compensate, it blanks the top
line when the three scroll bits in this register are set to 0, and
shifts the blanking one scan line at a time as the value of thee bits
increases.  Thus the bottom line is totally blanked when these bits
are set to 7.

Bit 4.  Bit 4 of this register controls the screen blanking feature.
When this bit is set to 0, no data can be displayed on the screen.
Instead, the whole screen will be filled with the color of the frame
(which is controlled by th eBorder Color Register at 53280 ($D020)).

Screen blanking is useful because of the way in which the VIC-II chip
interacts with the 6510 microprocessor.  Since the VIC-II and the 6510
both have to address the same memory, they must share the system data
bus.  Sharing the data bus means that they must take turns whenever
they want to address memory.

The VIC-II chip was designed so that it fetches most of the data it
needs during the part of the cycle in which the 6510 is not using the
data bus.  But certain operations, such as reading the 40 screen codes
needed for each line of text from video mmeory, or fetching sprite
data, require that the VIC-II chip get data at a faster rate than is
possible just by using the off half of the 6510 cycle.

Thus, the VIC-II chip must delay the 6510 for a short amount of time
while it is using the data bus to gather display information for text
or bitmap graphics, and must delay it a little more if sprites are
also enabled.  When you set the screen blanking bit to 0, these delays
are eliminated, and the 6510 processor is allowed to run at its full
speed.  This speeds up any processing task a little.

To demonstrate this, run the following short program.  As you will
see, leaving the screen on makes the processor run about 7 percent
slower than when you turn it off.  If you perform the same timing test
on the VIC-20, you will find that it runs at the same speed with its
screen on as the 64 does with its screen off.  And the same test on a
PET will run substantially slower.

10 PRINT CHR$(147);TAB(13);'TIMING TEST':PRINT:TI$='000000':GOTO 30
20 FOR I=1 TO 10000:NEXT I:RETURN
30 GOSUB 20:DISPLAY=TI
40 POKE 53265,11:TI$='000000'
50 GOSUB 20:NOSCREEN=TI:POKE 53265,27
60 PRINT 'THE LOOP TOOK';DISPLAY;' JIFFIES'
70 PRINT 'WITH NO SCREEN BLANKING':PRINT
80 PRINT 'THE LOOP TOOK';NOSCREEN;' JIFFIES'
90 PRINT 'WITH SCREEN BLANKING':PRINT
100 PRINT 'SCREEN BLANKING MAKE THE PROCESSOR'
110 PRINT 'GO';DISPLAY/NOSCREEN*100-100;'PERCENT FASTER'

The above explanation accounts for the screen being turned off during
tape read and write operations.  The timing of these operations is
rather critical, and would be affected by even the relatively small
delay caused by the video chip.  It also explains why the 64 has
difficulty loading programs from an unmodified 1540 Disk Drive, since
the 1540 was set up to transfer data from the VIC-20, which does not
have to contend with these slight delays.

If you turn off the 64 display with a POKE 53265,PEEEK(53265) AND 239,
you will be able to load programs correctly from an old 1540 drive.
The new 1541 drive transfers data at a slightly slower rate in the
default setting, and can be set from software to transfer it at the
higher rate for the VIC-20.

Bit 5.  Setting Bit 5 of this register to 1 enables the bitmap
graphics mode.  In this mode, the screen area is broken down into
64,000 separate dots of light, 320 dots across by 200 dots high.  Each
dot corresponds to one bit of display memory.  If the bit is set to 1,
the dot will be displayed in the foreground color.  If the bit is
reset to 0, it will be displayed in the background color.  This allows
the display of high-resolution graphics images for games, charts, and
graphs, etc.

Bitmapping is a common technique for implementing high-resolution
graphics on a microcomputer.  There are some features of the Commodore
system which are unusual, however.

Most systems display screen memory sequentially; that is, the first
byte controls the display of the first eight dots in the upper-left
corner of the screen, the second byte controls the eight dots to the
right of that, etc.  In the Commodore system, display memory is laid
out more along the lines of how character graphics dot-data is
arranged.

The first byte controls the row of eight dots in the top-left corner
of the screen, but the next byte controls the eight dots below that,
and so on until the ninth byte.  The ninth byte controls the eight
dots directly to the right of those controlled by the first byte of
display memory.  It is exactly the same as if the screen were filled
with 1000 programmable characters, with display memory taking the
place of the character dot-data.

The 64's bitmap graphics mode also resembles character graphics in
that the foreground color of the dots is set by a color map (although
it does not use the Color RAM for this purpose).  Four bits of each
byte of this color memory control the foreground color of one of these
eight-byte groups of display memory (which form an 8 by 8 grid of 64
dots).  Unlike character graphics, however, the other four bits
control the background color that will be seen in the eight-byte
display group where a bit has a value of 0.

Setting up a bitmap graphics screen is somewhat more complicated than
just setting this register bit to 1.  You must first choose a location
for the display memory area, and for the color memory area.  The
display memory area will be 8192 bytes long (8000 of which are
actually used for the display) and can occupy only the first or the
second half of the 16K space which the VIC-II chip can address.

Each byte of bitmap graphics color memory uses four bits for the
background color as well as four bits for the foreground color.
Therefore, the Color RAM nybbles at 55296 ($D800), which are wired for
four bits only, cannot be used.  Another RAM location must therefore
be found for color memory.

This color memory area will take up 1K (1000 bytes of which are
actually used to control the foreground and background colors of the
dots), and must be in the opposite half of VIC-II memory as the
display data.  Since bitmap graphics require so much memory for the
display, you may want to select a different 16K bank for VIC-II memory
(see the discussion of things to consider in selecting a VIC-II memory
bank at location 56576 ($DD00)).

To keep things simple, however, let's assume that you have selected to
use the default bank of VIC-II memory, which is the first 16K.  You
would have to select locations 8192-16383 ($2000-$3FFF) for screen
memory, because the VIC-II chip sees an image of the character ROM in
the first half of the 16K block (at locations 4096-8192
($1000-$1FFF)).  Color memory could be placed at the default location
of text display memory, at 1024-2047 ($400-$7FF).  Placement of bitmap
display and color memory is controlled by the VIC Memory Control
Register at 53272 ($D018).

When in bitmap mode, the lower four bits of this register, which
normally control the base address of character dot-data, now control
the location of the 8K bitmap.  Only Bit 3 is significant.  If it is
set to 1, the graphics display memory will be in the second 8K of
VIC-II memory (in this case, starting at 8192 ($2000)).  If that bit
contains a 0, the first 8K will be used for the bitmap.  The upper
four bits of this register, which normally control the location of the
Video Display Matrix, are used in bitmap mode to establish the
location of the color map within the VIC-II address space.  These four
bits can hold a number from 0 to 15, which indicates on which 1K
boundary the color map begins.  For example, if color memory began at
1024 (1K), the value of these four bits would be 0001.

Once the bitmap mode has been selected, and the screen and color
memory areas set up, you must establish a method for turning each
individual dot on and off.  The conventional method for identifying
each dot is to assign it to a horizontal (X) position coordinate and a
vertical (Y) coordinate.

Horizontal position values will range from 0 to 319, where dot 0 is at
the extreme left-hand side of the screen, and dot 319 at the extreme
right.  Vertical positions will range from 0 to 199, where dot 0 is on
the top line, and dot 199 is on the bottom line.

Because of the unusual layout of bitmap screen data on the 64, it is
fairly easy to transfer text characters to a bitmap screen, but it is
somewhat awkward finding the bit which affects the screen dot having a
given X-Y coordinate.  First, you must find the byte BY in which the
bit resides, and then you must POKE a vlue into that byte which turns
the desired bit on or off.  Given that the horizontal position of the
dot is stored in the variable X, its vertical position is in the
variable Y, and the base address of the bitmap area is in the variable
BASE, you can find the desired byte with the formula:

BY=BASE+40*(Y AND 256)+(Y AND 7)+(X AND 504)

To turn on the desired dot,

POKE BY, PEEK(BY) OR (2^(NOTX AND 7)

To turn the dot off,

POKE BY, PEEK(BY) AND (255-2^(NOTX AND 7))

The exponentation function takes a lot of time.  To speed things up,
an array can be created, each of whose elements corresponds to a power
of two.

FOR I=0 TO 7:BIT(I)=2^1:NEXT

After this is done, the expression 2^(I) can be replaced by BI(I).

The following sample program illustrates the bit-graphics concepts
explained above, and serves as a summary of that information.

10 FOR I=0 TO 7:BI(I)=2^I:NEXT: REM SET UP ARRAY OF POWERS OF 2 (BIT VALUE)
20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
30 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE
40 A$='':FOR I=1 TO 37:A$=A$+'C':NEXT:PRINT CHR$(19);
50 FOR I=1 TO 27:PRINTA$;:NEXT:POKE2023,PEEK(2022): REM SET COLOR MAP
60 A$='':FOR I=1 TO 27:A$=A$+'@':NEXT:FOR I=32 TO 63 STEP 2
70 POKE648,I:PRINT CHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLEAR HI-RES SCREEN
80 FORY=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM
90 X=INT(160+40*SIN(Y/10)): REM SINE WAVE SHAPE
100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504): REM FIND HI-RES BYTE
110 POKEBY,PEEK(BY)OR(BI(NOT X AND 7)):NEXT Y:REM POKE IN BIT VALUE
120 GOTO 120: REM LET IT STAY ON SCREEN

As you can see, using BASIC to draw in bit-graphics mode is somewhat
slow and tedious.  Machine language is much more suiable for
bit-graphics plotting.  For a program that lets you replace some BASIC
ommands with high-res drawing commands, see the article 'Hi-Res
Graphics Made Simple,' by Paul F. Schatz, in COMPUTE!'s First Book of
Commodore 64 Sound and Graphics.

There is a slightly lower resolution bitmap graphics mode available
which offers up to four colors per 8 by 8 dot matrix.  To enable this
mode, you must set the multicolor bit (Bit 4 of 53270 ($D016)) while
in bitmap graphics mode.  For more information on this mode, see the
entry for the multicolor enable bit.

Bit 6.  This bit of this register enables extended background color
mode.  This mode lets you select the background color of each text
character, as well as its foreground color.  It is able to increase
the number of background colors displayed, by reducing the number of
characters that can be shown on the screen.

Normally, 256 character shapes can be displayed on the screen.  You
can use them either by using the PRINT statement or by POKEing a
display code from 0 to 255 into screen memory.  If the POKEing method
is used, you must also POKE a color code from 0 to 15 into color
memory (for example, if you POKE 1024,1, and POKE 55296,1, a white A
appears in the top-left corner of the screen).

The background color of the screen is determined by Background Color
Register 0, and you can change this color by POKEing a new value to
that register, which is located at 53281 ($D021).  For example, POKE
53281,0 creates a black background.

When extended background color mode is activated, however, only the
first 64 shapes found in the table of the screen display codes can be
displayed on the screen.  This group includes the letters of the
alphabet, numerals, and punctuation marks.  If you try to print on the
screen a character having a higher display code, the shape displayed
will be from the first group of 64, but that character's background
will no longer be determined by the register at 53281 ($D021).
Instead, it will be determined by one of the other background color
registers.

When in extended background color mode, characters having display
codes 64- 127 will take their background color from register 1, and
location 53282 ($D022).  These characters include various SHIFTed
characters.  Those with codes 128-191 will have their background
colors determined by register 2, at 53283 ($D023).  These include the
reversed numbers, letters, and punctuation marks.  Finally, characters
with codes 192-255 will use register 4, at 53284 ($D024).  These are
the reversed graphics characters.

Let's try an experiment to see just how this works.  First, we will
put the codes for four different letters in screen memory:

FOR I=0 TO 3:POKE 1230+(I*8),I*64+I:POKE 55502+(I*8),1:NEXT

Four white letters should appear on the screen, an A, a shifted A, a
reversed A, and a reversed, shifted A, all on a blue background.
Next, we will put colors in the other background color registers:

POKE 53282,0:POKE53283,2:POKE53284,5

This sets the registers to black, red, and green, respectively.
Finally, we will activate extended color mode by setting Bit 6 of the
VIC-II register at location 53265 to a 1.  The BASIC statement that
turns this mode on is:

POKE 53265,PEEK(53265) OR 64

Notice that two things happened.  First, all of the letters took on
the same shape, that of the letter A.  Second, each took on the
background color of a different color register.  To get things back to
normal, turn off extended color mode with this statement:

POKE 53265,PEEK(53265) AND 191

Extended color mode can be a very useful enhancement for your text
displays.  It allows the creation of windows.  These windows, because
of their different background colors, make different bodies of text
stand out as visually distinct from one another.  For example, a text
adventure program could have one window to display the player's
current location, one to show an inventory of possessions, and one to
accept commands for the next move.

In this mode the background color of these windows can be changed
instantly, just by POKEing a new value to the color register.  This
technique lends itself to some dramatic effects.  A window can be
flashed to draw attention to a particular message at certain times.
And varying the foreground color can make either the window or the
message vanish and reappear later.

There are, however, a couple of problems involved in using these
windows.  The character shape that you want to use might not have a
screen code of less than 64.  In that case, the only solution is to
define your own character set, with the shape you want in one of the
first 64 characters.

Another problem is that characters within a PRINT statement in your
program listing are not always going to look the same on the screen.
Having to figure out what letter to print to get the number 4 with a
certain background color can be very inconvenient.  The easiest
solution to this problem is to have a subroutine to the translation
for you.  Since letters will appear normally in window 1, and window 3
characters are simply window 1 characters reversed, you will only have
problems with characters in windows 2 and 4.  To conver these
characters, put your message in A$, and use the following subroutine:

500 B$='':FOR I=1 TO LEN(A$):B=ASC(MID$(A$,I,1))
510 B=B+32:IF B<96 THEN B=B+96
520 B$=B$+CHR$(B):NEXT I:RETURN

This subroutine converts each letter to its ASCII equivalent, adds the
proper offset, and converts it back to part of the new string, B$.
When the conversion is complete, B$ will hold the characters necessary
to PRINT that message in window 2.  For window 4, PRINT
CHR$(18);B$;CHR$(146).  This will turn reverse video on before
printing the string, and turn it off afterwards.



Bit 7.  Bit 7 of this register is the high-order bit (Bit 8) of the
Raster Compare register at 53266 ($D012).  Even though it is located
here, it functions as part of that register (see the description below
for more information on the Raster Compare register).

Machine language programmers should note that its position here at Bit
7 allows testing this bit with the Negative flag.  Since scan lines
above number 256 are all off the screen, this provides an easy way to
delay changing the graphics display until the scan is in the vertical
blanking interval and the display is no longer being drawn:

LOOP  LDA $D011
      BPL LOOP

Sprites should always be moved when the raster is scanning off-screen,
because if they are moved while they are being scanned, their shapes
will waver slightly.

The BASIC equivalent of the program fragment above is the statement
WAIT 53265,128, but BASIC is usually not fast enough to execute the
next statement while still in the blanking interval.

53266          $D012         RASTER
Read Current Raster Scan Line/Write Line to Compare for Raster IRQ

The Raster Compare register has two different functions, depending on
whether you are reading from it or writing to it.  When this register
is read, it tells which screen line the electron beam is currently
scanning.

There are 262 horizontal lines which make up the American (NTSC)
standard display screen (312 lines in the European or PAL standard
screen).  Every one of these lines is scanned and updated 60 times per
second.  Only 200 of these lines (numbers 50-249) are part of the
visible display.

It is sometimes helpful to know just what line is being scanned,
because changing screen graphics on a particular line while that line
is being scanned may cause a slight disruption on the screen.  By
reading this register, it is possible for a machine language program
to wait until the scan is off the bottom of the screen before changing
the graphics display.

It is even possible for a machine language program to read this
register, and change the screen display when a certain scan line is
reached.  The program below uses this technique to change the
background color in midscreen, in order to show all 256 combinations
of foreground and background text colors at once.

40 FOR I=49152 TO 49188:READ A:POKE I,A:NEXT:POKE 53280,11
50 PRINT CHR$(147):FOR I=1024 TO I+1000:POKE I,160:POKE I+54272,11:NEXT I
60 FOR I=0 TO 15:FOR J=0 TO 15
70 P=1196+(48*I)+J:POKE P,J+I:POKE P+54272,J:NEXT J,I
80 PRINT TAB(15)CHR$(5)'COLOR CHART':FOR I=1 TO 19:PRINT:NEXT
85 PRINT 'THIS CHART SHOWS ALL COMBINATIONS OF   '
86 PRINT 'FOREGROUND AND BACKGROUND COLORS.      '
87 PRINT 'FOREGROUND INCREASES FROM LEFT TO RIGHT'
88 PRINT 'BACKGROUND INCREASES FROM TOP TO BOTTOM'
90 SYS 12*4096
100 DATA 169,90,133,251,169,0,141,33,208,162,15,120,173,17,208,48
105 DATA 251,173,18,208
110 DATA 197,251,208,249,238,33,208,24,105,8,133,251,202,16,233,48,219

Writing to this register designates the comparison value for the
Raster Compare Interrupt.  When that interrupt is enabled, a maskable
interrupt request will be issued every time the electron beam scan
reaches the scan line whose number was written here.  This is a much
more flexible technique for changing the display in midscreen than
reading this register as the sample program above does.  That
technique requires that the program continuously watch the Raster
Register, while the interrupt method will call the program when the
time is right to act.  For more information on raster interrupts, see
the entry for the Interrupt Mask Register (53274, $D01A).

It is very important to remember that this register requires nine
bits, and that this location only holds eight of those bits (the ninth
is Bit 7 of 53265 ($D011)).  If you forget to read or write to the
ninth bit, your results could be in error by a factor of 256.

For example, some early programs written to demonstrate the raster
interrupt took for granted that the ninth bit of this register would
be set to 0 on power-up.  When a later version of the Kernal changed
this initial value to a 1, their interrupt routines, which were
supposed to set the raster interrupt to occur at scan line number 150,
ended up setting it for line number 406 instead.  Since the scan line
numbers do not go up that high, no interrupt request was ever issued
and the program did not work.

Location Range: 53267-53268 ($D013-$D014)
Light Pen Registers

A light pen is an input device that can be plugged into joystick
Control Port #1.  It is shaped like a pen and has a light-sensitive
device at its tip that causes the trigger switch of the joystick port
to close at the moment the electron beam that updates the screen
display strikes it.  The VIC-II chip keeps track of where the beam is
when that happens, and records the corresponding horizontal and
vertical screen coordinates in the registers at these locations.

A program can read the position at which the light pen is held up to
the screen.  The values in these registers are updated once every
screen frame (60 times per second).  Once the switch is closed and a
value written to these registers, the registers are latched, and
subsequent switch closings during the same screen frame will not be
recorded.

A given light pen may not be entirely accurate (and the operator may
not have a steady hand).  It is probably wise to average the positions
returned from a number of samplings, particularly when using a machine
language driver."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D01B?[/INST]address              $D01B          SP4COL
Sprite 4 Color Register (the default color value is 5, green)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BAE2?[/INST]address         $BAE2          MUL10
Multiply FAC1 by 10

This subroutine is called to help convert a floating point number to a
series of ASCII numerals."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D401?[/INST]address              $D401          FREHI1
Voice 1 Frequency Control (high byte)

Location Range: 54274-54275 ($D402-$D403)
Voice 1 Pulse Waveform Width Control

As you will see below under the description of the Control Register at
54276 ($D404), you can select one of four different waveforms for the
output of each voice.  If the pulse waveform is selected, these
registers must be set to establish the pulse width.

The pulse width has a 12-bit resolution, being made up of the value in
the first register and the value in the lower nybble of the second
register.  The pulse width determines the duty cycle, or proportion of
the time that the rectangular wave will stay at the high part of the
cycle.

The following formula shows the relationship between the value in the
Pulse Width Register and the proportion of time that the wave stays at
the high part of the cycle:

PULSE WIDTH=(REGISTER VALUE/40.95)%

The possible range of the register values (0-4095) covers the range of
the duty cycles from 0 to 100 percent in 4096 steps.  Changing the
pulse width will vastly change the sound created with the pulse
waveform."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D407?[/INST]address              $D407          FRELO2
Voice 2 Frequency Control (low byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BC5B?[/INST]address         $BC5B          FCOMP
Compare FAC1 to Memory

On entry to this routine, .A and .Y point to a five-byte floating
point number to be compared to FAC1.  After the comparison, .A holds 0
if the two are equal, a 1 if the value of FAC1 is greater than that in
the memory location, and 255 ($FF) if the value of FAC1 is less than
that in the memory location."
"[INST]In the context of the C64, What is the purpose of the memory location at address $4D?[/INST]address           $4D            OPMASK
Mask for Comparison Operation

The expression evaluation routine creates a mask here which lets it
know whether the current comparieson operation is a less-than (1),
equals (2), or greater-than (4) comparison."
"[INST]In the context of the C64, What is the purpose of the memory location at address $8?[/INST]address            $8             ENDCHR
Search Character for Statement Termination or Quote

Like location 7, this location is used as a work byte during the
tokenization of a BASIC statement.  Most of the time, its value is 0
or 34."
"[INST]In the context of the C64, What is the purpose of the memory location at address $6A-$6D?[/INST]address       $6A-$6D        ARGHO
Floating Point Accumulator #2: Mantissa"
"[INST]In the context of the C64, What is the purpose of the memory location at address $313?[/INST]address          $313
Unused"
"[INST]In the context of the C64, What is the purpose of the memory location at address $32C-$32D?[/INST]address       $32C-$32D      ICLALL
Vector to Kernal CLALL Routine (Currently at 62255 ($F32F))"
"[INST]In the context of the C64, What is the purpose of the memory location at address $97?[/INST]address          $97            XSAV
Temporary .X Register Save Area

This .X register save area is used by the routines that get and put an
ASCII character."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A7?[/INST]address           $A7            INBIT
RS-232 Input Bits/Cassette Temporary Storage Area

This location is used to temporarily store each bit of serial data
that is received, as well as for miscellaneous tasks by tape I/O."
"[INST]In the context of the C64, What is the purpose of the memory location at address $2A5?[/INST]address           $2A5
Temporary Index to the Next 40-Column Line for Screen Scrolling"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BA?[/INST]address           $BA            FA
Current Device Number

This location holds the number of the device that is currently being
used.  Device number assignments are as follows:

0    = Keyboard
1    = Datasette Recorder
2    = RS-232/User Port
3    = Screen
4-5  = Printer
8-11 = Disk"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F6E4?[/INST]address              $F6E4          SETTIM
Set the Software Clock from the .A, .X, and .Y Registers

This documented Kernal routine can be entered from location 65499
($FFDB).

It performs the reverse operation from RDTIM, storing the value in the
.Y register into location 160 ($A0), the .X register into 161 ($A1),
and the Accumulator into 162 ($A2).  Interrupts are first disabled, to
make sure that the clock will not be updated while being set."
"[INST]In the context of the C64, What is the purpose of the memory location at address $285?[/INST]address           $285           TIMOUT
Flag: Kernal Variable for IEEE Time-Out

This location is used only with the external IEEE interface card
(which was not yet available from Commodore at the time of writing).
For more information, see the entry for the Kernal SETTMO routine at
65057 ($FE21)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $294?[/INST]address           $294           M51CDR
RS-232: Mock 6551 Command Register

This location performs the same function as the 6551 UART chip's
command register, which specifies type of parity, duplex mode, and
handshaking protocol.

The type of parity used determines how the 64 will check that RS-232
data is received correctly.

The duplex mode can be either full duplex (the 64 will be able to
transmit at the same time it is receiving) or half duplex (it will
take turns sending and receiving).

The handshaking protocol has to do with the manner in which the
sending device lets the receiver know that it is ready to send data,
and the receiver lets the sender know that it has gotten the data
correctly.  The meanings of the bit patterns in this register are as
follows:

Bits 7-5: Parity
XX0 (bit value of
     0,64,128, or 192) = No Parity Generated or Received
001 (bit value of 32)  = Odd Parity Transmitted and Received
011 (bit value of 96)  = Even Parity Transmitted and Received
101 (bit value of 160) = Mark Parity Transmitted and Received
111 (bit value of 224) = Space Parity Transmitted and Received

Bit 4: Duplex
0 (bit value of 0)  = Full Duplex
1 (bit value of 16) = Half Duplex

Bits 3-1: Unused

Bit 0: Handshake Protocol
0 (bit value of 0) = 3 Line
1 (bit value of 1) = X Line

This register can be set at the user's option when opening RS-232
device (number 2).  The second character of the filename will be
stored here.  For example, the statement

OPEN 2,2,0,CHR$(6+32)+CHR$(32+16)

will set the value of this location to 48, which is the value of the
second character in the filename portion of the statement.  As you can
see from the above chart, this configures the RS-232 device for half
duplex data transfer using odd parity and three-line handshaking."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F7D7?[/INST]address              $F7D7
Set I/O Area Start and End Pointers to Tape Buffer Start and End
Address"
"[INST]In the context of the C64, What is the purpose of the memory location at address $EEB3?[/INST]address              $EEB3
Perform a One-Millisecond Delay"
"[INST]In the context of the C64, What is the purpose of the memory location at address $EDFE?[/INST]address              $EDFE          UNLSN
Send UNLISTED to a Device on the Serial Bus

This is a documented Kernal routine whose entry in the jump table is
65454 ($FFAE).  It sends the UNLISTEN code (63, $3F) on the serial
bus.  This commands any LISTENers to get off the serial bus, and frees
up the bus for other users."
"[INST]In the context of the C64, What is the purpose of the memory location at address $ED09?[/INST]address              $ED09          TALK
Send TALK to a Device on the Serial Bus

This is a documented Kernal routine whose entry in the jump table is
65460 ($FFB4).  When called, it ORs the device number in the
Accumulator with the TALK code (64, $40) and sends it on the serial
bus.  This commands the device to TALK."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A742?[/INST]address         $A742          FOR
Perform FOR

FOR is performed mostly by saving the needed information for the NEXT
part of the command on the stack (see the entry for 256 ($100) for
details).  This includes the TO termination value, so if the upper
limit is a variable, the current value of the variable will be stored,
and you cannot end the loop early by decreasing the value of the TO
variable within the loop (although you can end it early by increasing
the value of the FOR variable within the loop).

Also, since the TO expression is evaluated only once, at the time FOR
is performed, a statement such as FOR I=1 TO I+100 is valid.  The
terminating value is not checked until NEXT is executed, so the loop
statements always execute at least once.  The variable used by FOR
must be a nonarray floating point variable.  Reusing the same FOR
variable in a loop that is still active will cause the previous FOR
loop and all intervening loops to be cancelled."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E891?[/INST]address              $E891
Output a Carriage Return

A carriage return is performed by clearing insert mode, reverse video,
and quote mode, and moving the cursor to the next line."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E691?[/INST]address              $E691
Add a Character to the Screen

This is part of the routine that outputs a character to the screen.
It puts printable characters into screen memory."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A435-$A468?[/INST]address   $A435-$A468    OMERR
OUT OF MEMORY Error Handler

This routine just sets the error message code, and falls through to
the general error handler."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E8B3?[/INST]address              $E8B3
If at the End of a Screen Line, Move Cursor to the Next Line"
"[INST]In the context of the C64, What is the purpose of the memory location at address $A69C?[/INST]address         $A69C          LIST
Perform LIST

This routine saves the range of lines to be printed in pointers at
95-96 ($5F- $60) and 20-21 ($14-$15), and then prints them out,
translating any tokens back to their ASCII equivalent."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A3FB-$A407?[/INST]address   $A3FB-$A407    GETSTK
Check for Space on Stack

Before undertaking an operation that requires stack space, this
routine is used to check if there is enough room on the stack.  If
there is not, an OUT OF MEMORY error is issued.

4"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E6B6?[/INST]address              $E6B6
Advance the Cursor

This routine advances the cursor, and provides for such things as
scrolling at the end of the screen, and inserting a blank line in
order to add another physical line to the current logical line."
"[INST]In the context of the C64, What is the purpose of the memory location at address $8000?[/INST]address        $8000
Autostart ROM Cartridge

An 8K or 16K autostart ROM cartridge designed to use this as a
starting memory address may be plugged into the Expansion Port on the
back.  If the cartridge ROM at locations 32772-32776 ($8004-$8008)
contains the numbers 195, 194, 205, 56, 48 ($C3, $C2, $CD, $38, $30)
when the computer powers up, it will start the program pointed to by
the vector at locations 32768-32769 ($8000-$8001), and will use
32770-32771 ($8002-$8003) for a warm start vector when the RESTORE key
is pressed.  These characters are PETASCII for the inverse letters
CBM, followed by the digits 80.  An autostart cartridge may also be
addressed at 40960 ($A000), where it would replace BASIC, or at 61440
($F000), where it would replace the Kernal.

It is possible to have a 16K cartridge sitting at 32768 ($8000), such
as Simon's BASIC, which can be turned on and off so that the BASIC ROM
underneath can also be used.  Finally, it is even possible to have
bank-selected cartridges, which turn banks of memory in the cartidge
on and off alternately, so that a 32K program could fit into only 16K
of addressing space."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EE97?[/INST]address              $EE97
Set Serial Bus Data Output Line Low

This subroutine clears the serial bus data output to 0 (Bit 5 of CIA
#2 Data Port A at 56576 ($DD00))."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EDDD?[/INST]address              $EDDD          CIOUT
Send a Byte to an I/O Device over the Serial Bus

This is a documented Kernal routine which can be entered from the jump
table at 65448 ($FFA8).  Its purpose is to send a byte of data over
the serial bus.  In order for the data to be received, the serial
device must have first been commanded to LISTEN and been given a
secondary address if necessary.  This routine always buffers the
current character, and defers sending it until the next byte is
buffered.  When the UNLISTEN command is sent, the last byte will be
sent with an End or Identify (EOI)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $287?[/INST]address           $287           GDCOL
Color of Character under Cursor

This location is used to keep track of the original color code of the
character stored at the present cursor location.  Since the blinking
cursor uses the current foreground color at 646 ($286), the original
value must be stored here so that if the cursor moves on without
changing that character, its color code can be restored to its
original value."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F69B?[/INST]address              $F69B          UDTIM
Update the Software Clock and Check for the STOP Key

UDTIM is a documented Kernal routine which can be entered through the
jump table at 65514 ($FFEA).

It is normally called by the IRQ interrupt handler once every sixtieth
of a second.  It adds one to the value in the three-byte software
jiffy clock at 160-162 ($A0-$A2), and sets the clock back to zero when
it reaches the 24 hour point.  In addition, it scans the keyboard row
in which the STOP key is located, and stores the current value of that
key in location 145 ($91).  This variable is used by the STOP routine
which checks for the STOP key."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F76A?[/INST]address              $F76A
Write Tape File Header Block"
"[INST]In the context of the C64, What is the purpose of the memory location at address $0297?[/INST]address           $297           $RSSTAT
RS-232: Mock 6551 Status Register

The contents of this register indicate the error status of RS-232 data
transmission.  That status can be determined by PEEKing this location
directly, by referencing the BASIC reserved variable ST, or by using
the Kernal READST (65031, $FE07) routine.

Note that if you use ST or Kernal, this location will be set to 0
after it is read.  Therefore, if you need to test more than one bit,
make sure that each test preserves the original value, because you
won't be able to read it again.  The meaning of each bit value is
specified below:

Bit 7: 1 (bit value of 128) = Break Detected
Bit 6: 1 (bit value of 64)  = DTR (Data Set Ready) Signal Missing
Bit 5: Unused
Bit 4: 1 (bit value of 16)  = CTS (Clear to Send) Signal Missing
Bit 3: 1 (bit value of 8)   = Receiver Buffer Empty
Bit 2: 1 (bit value of 4)   = Receiver Buffer Overrun
Bit 1: 1 (bit value of 2)   = Framing Error
Bit 0: 1 (bit value of 1)   = Parity Error

The user is responsible for checking these errors and taking
appropriate action.  If, for example, you find that Bit 0 or 1 is set
when you are sending, indicating a framing or parity error, you should
resend the last byte.  If Bit 2 is set, the GET#2 command is not being
executed quickly enough to empty the buffer (BASIC should be able to
keep up at 300 baud, but not higher).  If Bit 7 is set, you will want
to stop sending, and execute a GET#2 to see what is being sent."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A5?[/INST]address           $A5            CNTDN
Cassette Synchronization Character Countdown

Used to count down the number of synchronization characters that are
sent before the actual data in a tape block."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F34A?[/INST]address              $F34A          OPEN
Open a Logical I/O File

OPEN is a documented Kernal I/O routine.  It can be entered from the
jump table at 65472 ($FFC0).

The routine jumps through a RAM vector at 794 ($31A).  This routine
assigns a logical file to a device, so that it can be used for
Input/Output operations.  In order to specify the logical file number,
the device number, and the secondary address if any, the SETLFS
routine must first be called.  Likewise, in order to designate the
filename, the SETNAM routine must be used first.  After these two
routines are called, OPEN is then called."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B8?[/INST]address           $B8            LA
Current Logical File Number

This location holds the logical file number of the device currently
being used.  A maximum of five disk files, and ten files in total, may
be open at any one time.

File numbers range from 1 to 255 (a 0 is used to indicate system
defaults).  When printing to a device with a file number greater than
127, an ASCII linefeed character will be sent following each carriage
return, which is useful for devices like serial printers that require
linefeeds in addition to carriage returns.

The BASIC OPEN command calls the Kernal OPEN routine, which sets the
value of this location.  In the BASIC statement OPEN 4,8,15, the
logical file number corresponds to the first parameter 4."
"[INST]In the context of the C64, What is the purpose of the memory location at address $310?[/INST]address          $310           USRPOK
Jump Instruction for User Function ($4C)

The value here (67, $4C) is first part of the 6510 machine language
JuMP instruction for the USR command."
"[INST]In the context of the C64, What is the purpose of the memory location at address $0328-$0329?[/INST]address       $328-$329      ISTOP
Vector to Kernal STOP Routine (Currently at 63213 ($F6ED))

This vector points to the address of the routine that tests the STOP
key.  The STOP key can be disabled by changing this with a POKE
808,239.  This will not disable the STOP/RESTORE combination, however.
To disable both STOP and STOP/ RESTORE, POKE 808,234 (POKEing 234 here
will cause the LIST command not to function properly).  To bring
things back to normal in either case, POKE 808, 237."
"[INST]In the context of the C64, What is the purpose of the memory location at address $50-$52?[/INST]address         $50-$52        DSCPNT
Temporary Pointer to the Current String Descriptor

The string assignment and handling routines use the first two bytes as
a temporary pointer to the current string descriptor, and the third to
hold the value of the string length."
"[INST]In the context of the C64, What is the purpose of the memory location at address $6F?[/INST]address           $6F            ARISGN
Result of a Signed Comparison of Accumulator #1 to Accumulator #2

Used to indicate whether the two Floating Point Accumulators have like
or unlike signs.  A 0 indicates like signs, a 255 ($FF) indicates
unlike signs."
"[INST]In the context of the C64, What is the purpose of the memory location at address $5-$6?[/INST]address          $5-$6          ADRAY2
Vector: Routine to Convert a Number from Integer to Floating Point

This vector points to the address of the BASIC routine which converts
an integer to a floating point number.  This routine is currently
located at 45969 ($B391).  BASIC does not appear to reference this
location.  It is available for use by the programmer who needs to make
such a conversion for a machine language program that interacts with
BASIC.  For an explanation of how to use this routine in connection
with the USR command, see the entry for the USR vector at 785 ($311)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D403?[/INST]address              $D403          PWHI1
Voice 1 Pulse Waveform Width (high nybble)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BAB7?[/INST]address         $BAB7          MULDIV
Add Exponent of FAC1 to Exponent of FAC2"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BC39?[/INST]address         $BC39          SGN
Perform SGN

The SGN routine calls the above routine to put the sign of FAC1 into
.A, and then converts that value into a floating point number in FAC1."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D409?[/INST]address              $D409          PWLO2
Voice 2 Pulse Waveform Width (low byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BF52?[/INST]address         $BF52
Unused area

This unused area is filled with byts of 170 ($AA)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D004?[/INST]address         $D004          SP2X
Sprite 2 Horizontal Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D014?[/INST]address              $D014          LPENY
Light Pen Vertical Position

This location holds the vertical position of the light pen.  Since
there are only 200 visible scan lines on the screen, the value in this
register corresponds exactly to the current raster scan line."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D013?[/INST]address              $D013          LPENX
Light Pen Horizontal Position

This location holds the horizontal position of the light pen.  Since
there are only eight bits available (which give a range of 256 values)
for 320 possible horizontal screen positions, the value here is
accurate only to every second dot position.  The number here will
range from 0 to 160 and must be multiplied by 2 in order to get a
close approximation of the actual horizontal dot position of the light
pen."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D003?[/INST]address         $D003          SP1Y
Sprite 1 Vertical Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BF71?[/INST]address         $BF71          SQR
Perform SQR

This routine moves the contents of FAC1 to FAC2, moves the constant
0.5 to FAC1, and falls through to the exponentation routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BC58?[/INST]address         $BC58          ABS
Perform ABS

The FAC1 sign byte at 102 ($66) is shifted right by this command, so
that the top bit is a 0 (positive)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D40A?[/INST]address              $D40A          PWHI2
Voice 2 Pulse Waveform Width (high nybble)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D404?[/INST]address              $D404          VCREG1
Voice 1 Control Register

Bit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release
Bit 1:  Sync Bit:  1=Synchronize Oscillator with Oscillator 3 frequency
Bit 2:  Ring Modulation:  1=Ring modulate Oscillators 1 and 3
Bit 3:  Test Bit:  1=Disable Oscillator 1
Bit 4:  Select triangle waveform
Bit 5:  Select sawtooth waveform
Bit 6:  Select pulse waveform
Bit 7:  Select random noise waveform


Bit 0.  Bit 0 is used to gate the sound.  Setting this bit to a 1
while selecting one of the four waveforms will start the
attack/decay/sustain part of the cycle.  Setting this bit back to 0
(while keeping the same waveform setting) anytime after a note has
started playing will begin the release cycle of the note.  Of course,
in order for the gate bit to have an effect, the frequency and
attack/decay/sustain/release (ADSR) registers must be set, as well as
the pulse width, if necessary, and the volume control set to a nonzero
value.

Bit 1.  This bit is used to synchronize the fundamental frequency of
Oscillator 1 with the fundamental frequency of Oscillator 3, allowing
you to create a wide range of complex harmonic structures from voice
1.  Synchronization occurs when this bit is set to 1.  Oscillator 3
must be set to some frequency other than zero, but no other voice 3
parameters will affect the output from voice 1.

Bit 2.  When Bit 2 is set to 1, the triangle waveform output of voice
1 is replaced with a ring modulated combination of Oscillators 1 and
3.  This ring modulation produces nonharmonic overtone structures that
are useful for creating bell or gong effects.

Bit 3.  Bit 3 is the test bit.  When set to 1, it disables the output
of the oscillator.  This can be useful in generating very complex
waveforms (even speech synthesis) under software control.

Bit 4.  When set to 1, Bit 4 selects the triangle waveform output of
Oscillator 1.  Bit 0 must also be set for the note to be sounded.

Bit 5.  This bit selects the sawtooth waveform when set to 1.  Bit 0
must also be set for the sound to begin.

Bit 6.  Bit 6 chooses the pulse waveform when set to 1.  The harmonic
content of sound produced using this waveform may be varied using the
Pulse Width Registers.  Bit 0 must be set to begin the sound.

Bit 7.  When Bit 7 is set to 1, the noise output waveform for
Oscillator 1 is set.  This creates a random sound output whose
waveform varies with a frequency proportionate to that of Oscillator
1.  It can be used to imitate the sound of explosions, drums, and
other unpitched noises.

One of the four waveforms must be chosed in order to create a sound.
Setting more than one of these bits will result in a logical ANDing of
the waveforms.  Particularly, the combination of the noise waveform
and another is not recommended.

Location Range: 54277-54278 ($D405-$D406)
Voice 1 Envelop (ADSR) Control

When a note is played on a musical instrument, the volume does not
suddenly rise to a peak and then cut off to zero.  Rather, the volume
builds to a peak, levels off to an intermediate value, and then fades
away.  This creates what is known as a volume envelope.

The first phase of the envelope, in which the volume builds to a peak,
is known as the attack phase.  The second, in which it declines to an
intermediate level, is called the decay phase.  The third, in which
the intermediate leve of volume is held, is known as the sustain
period.  The final interval, in which the sound fades away, is called
the release part of the cycle.

The SID chip allows the volume envelope of each voice to be
controlled, so that specific instruments may be imitated, or new
sounds created.  This is done via the attack/decay and sustain/release
registers.  Each register devotes four bits (which can store a number
from 0 to 15) to each phase of the cycle.  When a note is gated by
writing a 1 to a waveform bit and to Bit 0 of the Control Register,
the attack cycle begins.

The volume of the sound builds to a peak over the period of time
specified by the high nybble of the attack/decay register.  Once it
has reached the peak volume, it falls to the intermediate level during
the period indicated by the low nybble of the attack/decay register
(this is the decay phase).  The volume of this intermediate or sustain
level is selected by placing a value in the high nybble of the
sustain/release register.  This volume level is held until a 0 is
written to the gate bit of the control register (while leaving the
waveform bit set).  When that happens, the release phase begins, and
the volume of the sound begins to taper off during the period
indicated by the low nybble of the sustain/release register.

You may notice the volume of the sound does not quite get to 0 at the
end of the release cycle, and you may need to turn off the sound to
get rid of the residual noise.  You can do this either by setting the
waveform bit back to 0, changing the frequency to 0, or setting the
volume to 0."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BAD4?[/INST]address         $BAD4          MLDVEX
Handle Underflow or Overflow"
"[INST]In the context of the C64, What is the purpose of the memory location at address $6E?[/INST]address           $6E            ARGSGN
Floating Point Accumulator #2: Sign"
"[INST]In the context of the C64, What is the purpose of the memory location at address $3-$4?[/INST]address           $3-$4          ADRAY1
Vector: Routine to Convert a Number from Floating Point to Signed
Integer

This vector points to the address of the BASIC routine which converts
a floating point number to an integer.  In the current Kernal version,
the address that it points to is 45482 ($B1AA).  Disassembly of the
ROMs indicates that BASIC does not use this vector.  However, it may
be of real assistance to the programmer who wishes to use data that is
stored in floating point format.  The parameter that is passed by the
USR command is available only in that format, for example.

Since it is extremely difficult to decipher and use a floating point
number, the simplest way to deal with such data is to use the
conversion routines that are built into BASIC to change it into a
two-byte signed integer.  This could be accomplished by jumping
directly into the BASIC ROM, if you know the location of the routine.
Therefore, if the address changes in future versions of the 64 or
future Commodore computers, you won't have to modify your program to
make it work with them.

See the entry for the USR vector at 785 ($311) for an explanation of
how to use this routine in connection with the USR command."
"[INST]In the context of the C64, What is the purpose of the memory location at address $4E-$4F?[/INST]address         $4E-$4F        DEFPNT
Pointer to the Current FN Descriptor

During function definition (DEF FN) this location is used as a pointer
to the descriptor that is created.  During function execution (FN) it
points to the FN descriptor in which the evaluation results should be
saved."
"[INST]In the context of the C64, What is the purpose of the memory location at address $326-$327?[/INST]address      $326-$327      IBSOUT
Vector to Kernal CHROUT Routine (Currently at 61898 ($F1CA))"
"[INST]In the context of the C64, What is the purpose of the memory location at address $30F?[/INST]address           $30F           SPREG
Storage Area for .P (Status) Register

The Status (.P) register has seven different flags.  Their bit
assignments are as follows:

Bit 7 (bit value of 128) = Negative
Bit 6 (bit value of 64)  = Overflow
Bit 5 (bit value of 32)  = Not Used
Bit 4 (bit value of 16)  = BREAK
Bit 3 (bit value of 8)   = Decimal
Bit 2 (bit value of 4)   = Interrupt Disable
Bit 1 (bit value of 2)   = Zero
Bit 0 (bit value of 1)   = Carry

If you wish to clear any flag before a SYS, it is safe to clear them
all with a POKE 783,0.  The reverse is not true, however, as you must
watch out for the Interrupt disable flag.

A 1 in this flag bit is equal to an SEI instruction, which turns off
all IRQ interrupts (like the one that reads the keyboard, for
example).  Turning off the keyboard could make the computer very
difficult to operate!  To set all flags except for Interrupt disable
to 1, POKE 783,247."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B9?[/INST]address           $B9            SA
Current Secondary Address

This location holds the secondary address of the device currently
being used.  The range of valid secondary address numbers is 0 through
31 for serial devices, and 0 through 127 for other devices.

Secondary device numbers mean something different to each device that
they are used with.  The keyboard and screen devices ignore the
secondary address completely.  But any device which can have more than
one file open at the same time, such as the disk drive, distinguishes
between these files by using the secondary address when opening a disk
file.  Secondary address numbers 0, 1, and 15-31 have a special
significance to the disk drive, and therefore device numbers 2-14 only
should be used as secondary addresses when opening a disk file.

OPENing a disk file with a secondary address of 15 enables the user to
communicate with the Disk Operating System through that channel.  A
LOAD command which specifies a secondary address of 0 (for example,
LOAD 'AT BASIC',8,0) results in the program being loaded not to the
address specified on the file as the starting address, but rather to
the address pointed to by the start of BASIC pointer (43, $2B).

A LOAD with a secondary address of 1 (for example, LOAD 'HERE',8,1)
results in the contents of the file being loaded to the address
specified in the file.  A disk file that has been LOADed using a
secondary address of 1 can be successfully SAVEd in the same manner
(SAVE 'DOS 5.1',8,1).

LOADs and SAVEs that do not specify a secondary address will default
to a secondary address of 0.

When OPENing a Datasette recorder file, a secondary address of 0
signifies that the file will be read, while a secondary address of 1
signifies that the file will be written to.  A value of 2 can be added
to indicate that an End of Tape marker should be written as well.
This marker tells the Datasette not to search past it for any more
files on the tape, though more files can be written to the tape if
desired.

As with the disk drive, the LOAD and SAVE commands use secondary
addresses of 0 and 1 respectively to indicate whether the operation
should be relocating or nonrelocating.

When the 1515 or 1525 Printer is opened with a secondary address of 7,
the uppercase/lowercase character set is used.  If it is openend with
a secondary address of 0, or without a secondary address, the
uppercase/graphics character set will be used."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F49E?[/INST]address              $F49E          LOAD
Load RAM from a Device

This is a documented Kernal routine, whose entry in the jump table
appears at 65493 ($FFD5).

The routine jumps through a RAM vector at 816 ($330).  LOAD is used to
transfer data froma device directly to RAM.  It can also be used to
verify RAM, comparing its contents to those of a disk or tape file.
To choose between these operations you must set the Accumulator with a
0 for LOAD, or a 1 for VERIFY.

Since the LOAD routine performs an OPEN, it must be preceded by a call
to the SETLFS routine to specify the logical file number, device
number, and secondary address, and a call to the SETNAM routine to
specify the filename (a LOAD from tape can be performed without a
filename being specified).  Then the .X and .Y registers should be set
with the starting address for the load, and the LOAD routine called.
If the secondary address specified was a 1, this starting address will
be ignored, and the header information will be used to supply the load
address.  If the secondary address was a 0, the address supplied by
the call will be used.  In either case, upon return from the
subroutine, the .X and .Y registers will contain the address of the
highest RAM location that was loaded."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A6?[/INST]address           $A6            BUFPNT
Count of Characters in Tape I/O Buffer

This location is used to count the number of bytes that have been read
in or written to the tape buffer.  Since on a tape write, no data is
sent until the 192 byte buffer is full, you can force output of the
buffer with the statement POKE 166,191."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F7D0?[/INST]address              $F7D0
Put Pointer to Tape Buffer in .X and .Y Registers"
"[INST]In the context of the C64, What is the purpose of the memory location at address $298?[/INST]address          $298           BITNUM
RS-232: Number of Bits Left to be Sent/Received

This location is used to determine how many zero bits must be added to
the data character to pad its length out to the word length specified
in 659 ($293)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $288?[/INST]address          $288           HIBASE
Top Page of Screen Memory

This location contains the value used by the Operating System routines
that print to the screen as the base address for screen RAM.  The top
of screen memory can be found by multiplying this location by 256.
The default value for screen RAM is set on power-up to location 1024
($400), and this location therefore usually contains a 4.

Screen display memory on the Commodore 64 can be moved to start on any
1K boundary (location evenly divisible by 1024).  This is done by
manipulating the VIC-II chip memory bank select at location 56576
($DD00).

It is important to note, however, that while any area may be
displayed, the Operating System will look here to find out where it
should PRINT characters.  Therefore, if you change the screen location
by altering the contents of one of the two addresses listed above, the
Operating System will still not know where to PRINT characters unless
you also change this address as well.  The result will be that
characters entered from the keyboard or PRINTed will not appear on the
screen.

Examples of how to properly relocate the screen can be found at the
entries for location 53272 ($D018) and 43 ($2B).

Since the PRINT command in essence just POKEs a lot of values to
screen and color memory, by changing this pointer you can print a
string of characters to memory locations other than screen RAM.  For
example, you could PRINT a sprite shape to memory without having to
READ a lot of DATA statements.  The program below PRINTs different
sprite shapes into the sprite data area:

10 SP=53248:POKESP,170:POKESP+1,125:POKESP+21,1:POKE 2040,13:PRINT CHR$(147)
20 A$='THIS TEXT WILL BE PRINTED TO THE SPRITE SHAPE DATA AREA AND DISPLAYED'
30 GOSUB 100
40 A$='THIS IS SOME DIFFERENT TEXT TO BE PRINTED TO THE SPRITE SHAPE AREA'
50 GOSUB 100
60 COUNT=COUNT+1:IF COUNT<15 THEN 20
70 END
100 POKE 648,3:PRINT CHR$(19);CHR$(17);SPC$(24);A$;:POKE 648,4:RETURN

Since PRINTing also changes color memory, you can change the pointer
to print the characters harmlessly to ROM, while changing a lot of
screen RAM at one time, as the following program demonstrates:

10 D$=CHR(94):FOR I=1 TO 4:D$=D$+D$:NEXT
20 PRINT CHR$(147);:FOR I=1 TO 7:PRINT TAB(10) D$:NEXT:PRINT:PRINT:PRINT:PRINT
30 PRINT TAB(9);CHR$(5);'HIT ANY KEY TO STOP'
40 DIM C(15):FOR I=0TO14:READ A:C(I)=A:NEXT:DATA2,8,7,5,6,4,1,2,8,7,5,6,4,1,2
50 POKE 53281,0:POKE 648,212:FOR J=0 TO 6:PRINT CHR$(19);
60 FOR I=J TO J+6:POKE 646,C(I):PRINT TAB(10) D$:NEXT I,J
70 GET A$:IF A$='' THEN 50
80 POKE 648,4:POKE 646,1"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F6DD?[/INST]address              $F6DD          RDTIM
Read the Time From the Software Clock into the .A, .X, and .Y
Registers

This is a documented Kernal routine whose entry point in the jump
table is 65502 ($FFDE).

It reads the software clock (which counts sixtieths of a second) into
the internal registers.  The .Y register contains the most significant
byte (from location 160 ($A0)), the .X register contains the middle
byte (from location 161 ($A1)), and the Accumulator contains the least
significant byte (from location 162 ($A2))."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EDC7?[/INST]address              $EDC7          TKSA
Send a Secondary Address to a Device on the Serial Bus after TALK

This is a documented Kernal routine that can be entered from the jump
table at 65430 ($FF96).  It sends a secondary address from the
Accumulator to the device on the serial bus that has just been
commanded to TALK.  This is usually done to give the device more
particular instructions on how the I/O is to be carried out before
information is sent."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EE8E?[/INST]address              $EE8E
Set the Serial Clock Line High (Inactive)

This subroutine sets the serial bus clock pulse output bit to 1 (Bit 4
of CIA #2 Data Port A at 56576 ($DD00))."
"[INST]In the context of the C64, What is the purpose of the memory location at address $9000-$9FFF?[/INST]address   $9000-$9FFF
Character ROM Image for VIC-II Chip When Using Memory Bank 2

When the VIC-II chip is set up to use the third 16K block of memory
for graphics (as would be the case when the 64 is set up to emulate
the PET, which has its text screen memory at 32768 ($8000), it sees
the character generator ROM at this address (see entry at 4096 ($1000)
above for more details).

It should be noted that the character ROM is available only when the
VIC-II chip is using banks 0 or 2.  When using one of the other two
banks, the user must supply all of the character shape data in a RAM
table."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A408-$A434?[/INST]address   $A408-$A434    REASON
Check for Space in Memory

This is the subroutine that checks to see if there is enough space in
free memory for proposed additions such as new lines of program text.
If not, it calls for garbage collection, and if this still does not
produce enough space, an OUT OF MEMORY error is issued."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E701?[/INST]address              $E701
Move Cursor Back over a 40-Column Line Boundary"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E8CB?[/INST]address              $E8CB
Check for a Color Change

This routine is used by the screen CHROUT routine to check if the
character to be printed is one that causes the current foreground
color to change (such as the CTRL-1 combination)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A717?[/INST]address         $A717          QPLOP
Print BASIC Tokens as ASCII Characters

This is the part of the LIST routine that chagnes one-byte program
tokens back to their ASCII text characters.  The routine is vectored
through RAM at 774 ($306), so it is possible to list out new command
words that you have added by changing this vector to detour through
your own routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A3B8?[/INST]address         $A3B8          BLTU
Open a Space in Memory for a New Program Line or Variable

When a new nonarray variable is being created, or when a BASIC program
line is being added or replaced, this routine is used to make room for
the addition.  It first checks to see if space is available, and then
moves the program text and/or variables to make room."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A642?[/INST]address        $A642          SCRTCH
Perform NEW

The NEW command stores two zeros in the link address of the first
program line to indicate the end of program, and sets the end of
program pointer at 45-46 ($2D-$2E) to point to the byte past those
zeros.  It continues through to the CLR command code."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E9C8?[/INST]address              $E9C8
Move Screen Line

This subroutine is used by the scroll routine to move one screen line
(and its associated Color RAM) up a line."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E684?[/INST]address              $E684
Test for Quote Marks

This subroutine checks if the current character is a quotation mark,
and if it is, toggles the quote switch at 212 ($D4)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A480-$A49B?[/INST]address   $A480-$A49B    MAIN
Main Loop, Receives Input and Executes Immediately or Stores as
Program Line

This is the main BASIC program loop.  It jumps through the RAM vector
at 770 ($302), so this routine can be diverted.  The routine gets a
line of input from the keyboard, and checks for a line number.  If
there is a line number, the program branches to the routine that
stores a line of program text.  If there is no line number, it
branches to the routine that executes statements."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EEBB?[/INST]address              $EEBB
Send Next RS-232 Bit (NMI)

This subroutine is called by the NMI interrupt handler routine to send
the next bit of data to the RS-232 device."
"[INST]In the context of the C64, What is the purpose of the memory location at address $ED11?[/INST]address              $ED11
Send Command Code to a Device on the Serial Bus

This subroutine is used in common by many Kernal routines to send the
command code in the Accumulator to a device on the serial bus."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AA?[/INST]address           $AA            RIDATA
RS-232 Input Byte Buffer/Cassette Temporary Storage

Serial routines use this area to reassemble the bits received into a
byte that will be stored in the receiving buffer pointer to by 247
($F7).  Tape routines use this as a flag to help determine whether a
received character should be treated as data or as a synchronization
character."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F157?[/INST]address     83         $F157          CHRIN
Input a Character from the Current Device

This is a documented Kernal routine whose jump table entry point is at
65487 ($FFCF).

The routine jumps through a RAM vector at 804 ($324).  Its function is
to get a character from the current input device (whose device number
is stored at 153 ($99)).  This device must first have been OPENed and
then designated as the input channel by the CHKIN routine.

When this routine is called, the next byte of data available from this
device is returned in the Accumulator.  The only exception is the
routine for the keyboard device (which is the default input device).
It the keyboard is the current input device, this routine blinks the
cursor, fetches characters from the keyboard buffer, and echoes them
to the screen until a carriage return is encountered.  When a carriage
return is round, the routine sets a flag to indicate the length of the
last logical line before the return character, and reads the first
character of this logical line from the screen.

Subsequent calls to this routine will cause the next character in the
line to be read from the screen and returned in the Accumulator, until
the carriage return character is returned to indicate the end of the
line.  Any call after this character is received will start the whole
process over again.

Note that only the last logical line before the carriage return is
used.  Any time you type in more than 80 characters, a new logical
line is started.  This routine will ignore any characters on the old
logical line, and process only the most recent 80-character group."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B5?[/INST]address          $B5            NXTBIT
RS-232 Next Bit to Send/Tape EOT Flag

This location is used by the RS-232 routines to hold the next bit to
be sent, and by the tape routines to indicate what part of a block the
read routine is currently reading."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F5D2?[/INST]address              $F5D2
Print LOADING or VERIFYING"
"[INST]In the context of the C64, What is the purpose of the memory location at address $28C?[/INST]address          $28C           DELAY
Counter for Timing the Delay Until the First Key Repeat Begins

This location is used as a delay counter to determine how long a key
must be held down before the entry of that key should be repeated.

The initial value of 16 is counted down every 1/60 second, as long as
the same key remains pressed.  When the value gets to 0, location 651
($28B) is counted down from 6, and the key is repeated when the value
there reaches 0.  Thus a total of 22/60, or approximately 1/3, second
will elapse before the first repeat of a key.  The value here will be
held to 0 after the first repeat, so that subsequent keystroke
repititions occur much more quickly."
"[INST]In the context of the C64, What is the purpose of the memory location at address $293?[/INST]address          $293           M51CTR
RS-232: Mock 6551 Control Register

This location is used to control the RS-232 serial I/O baud rate
(speed at which data is transmitted and received), the word length
(number of bits per data character), and the number of stop bits used
to mark the end of a transmitted character.  It uses the same format
as that of the 6551 UART control register to set these parameters,
although, as you will see, some of the 6551 configurations are not
implemented by the software that emulates the UART device.  For
example, the standard baud rates which are higher than 2400 baud are
not implemented, presumably because the software cannot keep up at
higher rates.  The meanings of the various bit patterns are as
follows:

Bit 7: STOP Bits
0    (bit value of 0)   = 1 STOP Bit
1    (bit value of 128) = 0 STOP Bits

Bits 6-5: WORD LENGTH
00   (bit value of 0)   = 8 DATA Bits
01   (bit value of 32)  = 7 DATA Bits
10   (bit value of 64)  = 6 DATA Bits
11   (bit value of 96)  = 5 DATA Bits

Bit 4: Unused

Bits 3-0: BAUD RATE
0000 (bit value of 0)   = Nonstandard (User-Defined) Rate (Not Implemented)
0001 (bit value of 1)   = 50 Baud
0010 (bit value of 2)   = 75 Baud
0011 (bit value of 3)   = 110 Baud
0100 (bit value of 4)   = 134.5 Baud
0101 (bit value of 5)   = 150 Baud
0110 (bit value of 6)   = 300 Baud
0111 (bit value of 7)   = 600 Baud
1000 (bit value of 8)   = 1200 Baud
1001 (bit value of 9)   = 1800 Baud
1010 (bit value of 10)  = 2400 Baud
1011 (bit value of 11)  = 3600 Baud (Not Implemented on the Commodore 64)
1100 (bit value of 12)  = 4800 Baud (Not Implemented on the Commodore 64)
1101 (bit value of 13)  = 7200 Baud (Not Implemented on the Commodore 64)
1110 (bit value of 14)  = 9600 Baud (Not Implemented on the Commodore 64)
1111 (bit value of 15)  = 19200 Baud (Not Implemented on the Commodore 64)

This register is the only one which must be set when opening RS-232
device (number 2).  The first character of the filename will be stored
here.  For example, the statement OPEN 2,2,0,CHR$(6+32) will set the
value of this location to 38.  As you can see from the above chart,
this sets up the RS-232 device for a data transfer rate of 300 baud,
using seven data bits per character and one stop bit."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F82E?[/INST]address              $F82E
Check Cassette Switch

This subroutine is used to check if a button on the recorder has been
pressed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $57-$60?[/INST]address         $57-$60
BASIC Numeric Work Area

This is a very busy work area, used by many routines."
"[INST]In the context of the C64, What is the purpose of the memory location at address 0-255?[/INST]Page zero
Memory locations 0-255 ($0-$FF) have a special significance in 6502
machine language programming (the 6510 microprocessor in the Commodore
64 shares the same instruction set as the 6502).  Since these
addresses cn be expressed using just one byte, instructions which
access data stored in these locations are shorter and execute more
quickly than do instructions which operate on addresses in higher
memory, which requires two bytes.

Because of this relatively fast execution time, most 6502 software
makes heavy use of zero-page locations.  The 64 is no exception, and
uses this area for many important system variables and pointers.

In addition, locations 0 and 1 have special Input/Output functions on
the 6510.  In the case of the 64, this on-chip I/O port is used to
select the possible combinations of ROM, as we will se below, and to
control cassette I/O."
"[INST]In the context of the C64, What is the purpose of the memory location at address $68?[/INST]address          $68            BITS
Floating Point Accumulator #1: Overflow Digit

This location contains the overflow byte.  The overflow byte is used
in an intermediate step of conversion from an integer or text string
to a floating point number."
"[INST]In the context of the C64, What is the purpose of the memory location at address $314-$315?[/INST]address       $314-$315      CINV
Vector to IRQ Interrupt Routine

This vector points to the address of the routine that is executed when
an IRQ interrupt occurs (normally 59953 ($FA31)).

At power on, the CIA #1 Timer B is set to cause an IRQ interrupt to
occur every 1/60 second.  This vector is set to point to the routine
which updates the software clock and STOP key check, blinks the
cursor, maintains the tape interlock, and reads the keyboard.  By
changing this vector, the user can add or substitute a machine
language routine that will likewise execute every 1/60 second.  The
user who is writing IRQ interrupt routines should consider the
following:

1.  It is possible for an IRQ interrupt to occur while you are
changing this vector, which would cause an error from which no
recovery could be made.  Therefore, you must disable all IRQ
interrupts before changing the contents of this location, and reenable
them afterwards, by using the 6510 SEI and CLI instructions, or by
using the Kernal VECTOR routine (64794, $FD1A) to set this vector.

2.  There is some code in ROM that is executed before the interrupt
routine is directed through this vector.  This code checks whether the
source of the interrupt was an IRQ or BRK instruction.  If first
preserves the contents of all the registers by pushing them onto the
stack in the following sequence:  PHA, TXA, PHA, TYA, PHA.  It is up
to the user to restore the stack at the end of his routine, either by
exiting through the normal IRQ, or with the sequence:  PLA, TAY, PLA,
TAX, PLA, RTI.

3.  There is only one IRQ vector, but there are many sources for IRQ
interrupts (two CIA chips, and several VIC chip IRQs).  If you plan to
enable IRQs from more than one source, the IRQ routine here must
determine the source, and continue the routine in the appropriate
place for an IRQ from that source.

In the same vein, if you replace the normal IRQ routine with your own,
you should be aware that the keyboard's scanning and clock update will
not occur unless you call the old interrupt routine once every 1/60
second.  It is suggested that if you plan to use that routine, you
save the old vector address in some other location.  In that way, you
can JuMP to the keyboard interrupt routine through this alternate
vector, rather than assuming that the ROM address will never change
and that it is safe to jump into the ROM directly."
"[INST]In the context of the C64, What is the purpose of the memory location at address $31E-$31F?[/INST]address      $31E-$31F      ICHKIN
Vector to Kernal CHKIN Routine (Currently at 61966 ($F20E))"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D000?[/INST]address         $D000          SP0X
Sprite 0 Horizontal Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BB0F?[/INST]address         $BB0F          FDIV
Divide a Number in Memory by FAC1

This number in memory is stored to FAC2, and this routine falls
through to the next."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D400?[/INST]address              $D400          FRELO1
Voice 1 Frequency Control (low byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D40E?[/INST]address              $D40E          FRELO3
Voice 3 Frequency Control (low byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BC0F?[/INST]address         $BC0F          MOVEF
Copy FAC1 to FAC2 Without Rounding"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D007?[/INST]address         $D007          SP3Y
Sprite 3 Vertical Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D00E?[/INST]address              $D00E          SP7X
Sprite 7 Horizontal Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D00F?[/INST]address              $D00F          SP7Y
Sprite 7 Vertical Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D008?[/INST]address         $D008          SP4X
Sprite 4 Horizontal Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D40D?[/INST]address              $D40D          SUREL2
Voice 2 Sustain/Release Control Register

Bits 0-3:  Select release cycle duration (0-15)
Bits 4-7:  Select sustain volume level (0-15)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BC0C?[/INST]address         $BC0C          MOVAF
Round and Move a Floating Point Number from FAC1 to FAC2"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BAFE?[/INST]address         $BAFE          DIV10
Divide FAC1 by 10"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D400-$D41C?[/INST]address        $D400-$D41C
Sound Interface Device (SID) Registers

Mmeory locations 54272-54300 ($D400-$D41C) are used to address the
6581 Sound Interface Device (SID).

SID is a custom music synthesizer and sound effects generator chip
that gives the 64 its impressive musical capabilities.  It provides
three separate music channels, or voices, as they are called.  Each
voice has 16-bit frequency resolution, waveform control, envelope
shaping, oscillator synchronization, and ring modulation.  In
addition, programmable high-pass, low-pass, and band-pass filters can
be set and enabled or disabled for each sound channel.

Since quite a few of these locations must be used in concert to
produce sound, a brief summary of the interplay between some of these
registers may be helpful.

Often the first step is to select an overall volume level using the
Volume Register.  Then, the desired frequency or pitch of the note is
chosen by writing to each of the two bytes which make up the 16-bit
Frequency Register.

An ADSR envelope setting must be chosen by writing values to the
Attack/ Decay and Sustain/Release Register.  These determine the rate
of the rise and fall of the volume of the note from zero volume to
peak volume and back again.  These rates have a great influence on the
character of the sound.

Finally, the waveform must be selected, and the note started (or the
oscillator gated, as we say).  This is done by writing certain bits to
the Control Register.  The waveform control lets you select one of
four different waveforms, each of which has varying harmonic content
that affects the tone quality of the sound.  By writing a 1 to the
gate bit, you start the Attack/ Delay/Sustain cycle.  Afer rising to a
peak and declining to the Sustain volume, the volume will continue at
the same level until you write a 0 to the gate bit.  Then, the Release
cycle will start.  Make sure that you keep the same waveform bit set
to 1 while you write the 0 to the gate bit, so that the Release cycle
starts.  Otherwise, the sound will stop entirely, as it also will if
the Volume Register or the Frequency Register is set to 0.

It should be noted that except for the last four SID chip registers,
these addresses are write-only.  That means that their values cannot
be determined by PEEKing these locations.

Location Range: 54272-54273 ($D400-$D401)
Voice 1 Frequency Control

Together, these two locations control the frequency or pitch of the
musical output of voice 1.  Some frequency must be selected in order
for voice 1 to be heard.  This frequency may be changed in the middle
of a note to achieve special effects.  The 16-bit range of the
Frequency Control Register covers over eight full octaves, and allows
you to vary the pitch from 0 (very low) to about 4000 Hz (very high),
in 65536 steps.  The exact frequency of the output can be determined
by the equation

FREQUENCY=(REGISTER VALUE*CLOCK/16777216)Hz

where CLOCK equals the system clock frequency, 1022730 for American
(NTSC) systems, 985250 for European (PAL), and REGISTER VALUE is the
combined value of these frequency registers.  That combined value
equals the value of the low byte plus 256 times the value of the high
byte.  Using the American (NTSC) clock value, the equation works out
to

FREQUENCY=REGISTER VALUE*.060959458 Hz"
"[INST]In the context of the C64, What is the purpose of the memory location at address 53248-53264 ($D000-$D010)?[/INST]address 53248-53264 ($D000-$D010)
Sprite Horizontal and Vertical Position Registers

These locations determine the horizontal and vertical position at
which each sprite will be displayed on the screen.  Each sprite has
its own horizontal and vertical position register.  In addition, all
of the sprites share a common register which is used to extend the
range of horizontal positions.

Vertical positions for each sprite range from 0 to 255, and these
indicate the vertical position of the top line of the sprite's 21-line
length.  Since there are only 200 visible scan lines in the screen
display, some of these vertical positions will result in the sprite
being partially or wholly offscreen.

The visible viewing area starts at line 50 and extends to line 249.
Therefore, any sprite whose vertical psition is 29 ($1D) or less will
be completely above the visible picture.  At vertical position 30
($1E), the bottom line of the sprite display becomes visible at the
top of the screen.  At position 230 ($E6), the bottom line of the
sprite is lost from view off the bottom of the screen, and at vertical
position 250 ($FA), the entire sprite disappears from view off the
bottom edge of the screen.

Horizontal positioning is somewhat trickier, because the visible
display area is 320 dots wide, and one eight-bit register can hold
only 256 position values.  Therefore, an additional register is needed
to hold the ninth bit of each sprite's horizontal position.

Each sprite is assigned a single bit in the Most Significant Bit of
Horizontal Position register (MSB register) at 53264 ($D010).  If that
bit is set to 1, the value 256 is added to the horizontal position.
This extends the range of possible horizontal positions to 511.

In order to set a sprite's horizontal position, you must make sure
that both the values in the horizontal position register and the MSB
Register are correct.  For example, if you wish to set the horizontal
position of Sprite 5 to a value of 30, you must place a value of 30 in
the Sprite 5 Horizontal Position Register (POKE 53258,30 will do it
from BASIC), and you must also clear Bit 5 of the MSB Register (POKE
53264,PEEK(53264)AND(255-16)).  If you forget the MSB register, and
Bit 5 is set to 1, you will end up with position 286 instead of 30.

The horizontal position value indicates the position of the leftmost
dot of the sprite's 24-dot width.  The visible display is restricted
to the 320 dot positions between positions 24 and 344.  At position 0
the whole sprite is past the left edge of the visible screen.  At
position 1 the righmost dot enters the display area, and at position
24 ($18) the entire sprite is displayed on screen.  At position 321
($141) the rightmost dot goes past the right edge of the visible
display area, and a position 355 ($158) the whole sprite has moved out
of sight, off the right edge of the screen.

These registers are all intialized to 0 at power-up."
"[INST]In the context of the C64, What is the purpose of the memory location at address $320-$321?[/INST]address       $320-$321      ICKOUT
Vector to Kernal CKOUT Routine (Currently at 62032 ($F250))"
"[INST]In the context of the C64, What is the purpose of the memory location at address $316-$317?[/INST]address       $316-$317      CBINV
Vector: BRK Instruction Interrupt

This vector points to the address of the routine which will be
executed anytime that a 6510 BRK instruction (00) is encountered.

The default value points to a routine that calls several of the Kernal
initialization routines such as RESTOR, IOINIT and part of CINT, and
then jumps through the BASIC warm start vector at 40962.  This is the
same routine that is used when the STOP and RESTORE keys are pressed
simultaneously, and is currently located at 65126 ($Fe66).

A machine language monitor program will usually change this vector to
point to the monitor warm start address, so that break points may be
set that will return control to the monitor for debugging purposes."
"[INST]In the context of the C64, What is the purpose of the memory location at address $0?[/INST]Location Range: 0-143 ($0-$8F)
BASIC Working Storage

This portion of zero page is used by BASIC only.  Therefore, a program
written entirely in machine language that does not interact with BASIC
can freely use this area.

address            $0             D6510
6510 On-Chip I/O DATA Direction Register

Bit 0: Direction of Bit 0 I/O on port at next address.  Default = 1 (output)
Bit 1: Direction of Bit 1 I/O on port at next address.  Default = 1 (output)
Bit 2: Direction of Bit 2 I/O on port at next address.  Default = 1 (output)
Bit 3: Direction of Bit 3 I/O on port at next address.  Default = 1 (output)
Bit 4: Direction of Bit 4 I/O on port at next address.  Default = 0 (input)
Bit 5: Direction of Bit 5 I/O on port at next address.  Default = 1 (output)
Bit 6: Direction of Bit 6 I/O on port at next address.  Not used.
Bit 7: Direction of Bit 7 I/O on port at next address.  Not used.

This location is the first of a number of hardware registers that we
will discuss.  Although they can be written to and/or read like RAM,
they are connected to hardware devices, and their contents affect the
operation of the devices.

Each bit of this Data Direction Register determines whether the
contents of the corresponding bit on the Internal I/O Port (see
location 1) can be written to by peripheral devices.  If the bit is
set to 0, it indicates the direction of data flow as Input, which
means that the corresponding bit of the I/O port will be affected by
peripheral defices.  If the bit is set to 1, it indicates Output.  On
the 64, only Bits 0-5 are significant.  On power-up, this register is
set to 239 ($EF), which indicates that all bits, except for Bit 4
(which senses the cassette switch), are set up for Output."
"[INST]In the context of the C64, What is the purpose of the memory location at address $69-$6E?[/INST]address       $69-$6E        FAC2
Floating Point Accumulator #2

A second Floating Point Accumulator, used in conjunction with Floating
Point Accumulator #1 in the evaluation of products, sums,
differences--in short, any operation requiring more than one value.
The format of this accumulator is the same as FAC1."
"[INST]In the context of the C64, What is the purpose of the memory location at address $61-$66?[/INST]address        $61-$66        FAC1
Floating Point Accumulator #1

The Floating Point Accumulator is central to the execution of any
BASIC mathematical operation.  It is used in the conversion of
integers to floating point numbers, strings to floating point numbers,
and vice versa.  The results of most evaluations are stored in this
location.

The internal format of floating point numbers is not particularly easy
to understand (or explain).  Generally speaking, the number is broken
into the normalized mantissa, which represents a number between 1 and
1.99999..., and an exponent value, which represents a power of 2.
Multiplying the mantissa by 2 raised to the value of the exponent
gives you the value of the floating point number.

Fortunately, the BASIC interpreter contains many routines for the
manipulation and conversion of floating point number, and these
routines can be called by the user.  See the entries for locations 3
and 5

Floating Point Accumulator #1 can be further divided into the
following locations:"
"[INST]In the context of the C64, What is the purpose of the memory location at address $293-$297?[/INST]address ($293-$297)
RS-232 Pseudo 6551 Registers

For serial Input/Output via the RS-232 port, the internal software of
the Commodore 64 emulates the operation of a 6551 UART chip (that's
Universal Asynchronous Receiver/Transmitter, for you acronym buffs),
also known as an ACIA (Asynchronous Communications Interface Adapter).

These RAM locations are used to mimic the functions of that chip's
hardware command, control, and status registers.  Although RAM
locations are allocated for mimicking the 6551's ability to use either
an on-board baud rate generator or an external clock crystal, this
function is not implemented by the internal software.

Provisions have been made for the user to communicate with these
registers through the RS-232 OPEN command.  When device 2 is opened, a
filename of up to four characters may be appended.  These four
characters are copied to locations 659-662 ($293-$296), although the
last two, which specify a nonstandard baud rate, are not used because
that feature is not implemented."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F817?[/INST]address              $F817
Test Cassette Buttons and Handle Messages for Tape Read

This routine tests the sense switch, and if no buttons are depressed
it prints the PRESS PLAY ON TAPE message, and loops until a cassette
button is pressed, or until the STOP key is pressed.  If a button is
pressed, it prints the message OK.

Since the message printing routine is entered after the test for
direct mode, these messages cannot be superseded by changing the flag
at 157 ($9D).  You could have them harmlessly printed to ROM, however,
by changing the value of HIBASE at 648 ($288) temporarily to 160, and
then back to 4."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F5A5?[/INST]address              $F5A5
Print SEARCHING Message if in Direct Mode"
"[INST]In the context of the C64, What is the purpose of the memory location at address $28B?[/INST]address          $28B           KOUNT
Counter for Timing the Delay Between Key Repeats

This location is used as a delay counter to determine how long to wait
while a key is being held down until the next repeat printing of that
key.

The value here starts at 6.  If location 652 ($28C) contains a 0, the
value in this location is counted down once every 1/60 second, so long
as the same key is held down.  When this counter gets to 0, and if the
repeat flag at 650 ($28A) allows that key to repeat, its ASCII
equivalent will once again be placed in the keyboard buffer.  A value
of 4 is then placed in location 651, allowing subsequent repeats to
occur at a rate of 15 per second."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B4?[/INST]address           $B4            BITTS
RS-232 Output Bit Count/Cassette Temporary Storage

RS-232 routines use this to count the number of bits transmitted, and
for parity and stop bit manipulation.  Tape load routines use this
location to flag when they are ready to receive data bytes."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F13E?[/INST]address              $F13E          GETIN
Get One Byte from the Input Device

This is a documented Kernal routine whose jump table entry point is at
65508 ($FFE4).  The routine jumps through a RAM vector at 810 ($32A).
Its function is to get a character from the current input device
(whose device number is stored at 153 ($99)).  In practive, it
operates identically to the CHRIN routine below for all devices except
for the keyboard.  If the keyboard is the current input device, this
routine gets one character from the keyboard buffer at 631 ($277).  It
depends on the IRQ interrupt routine to rad the keyboard and put
characters into the buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A9?[/INST]address          $A9            RINONE
RS-232 Flag: Check for Start Bit

This flag is used when checking for a start bit.  A 144 ($90) here
indicates that no start bit was received, while a 0 means that a start
bit was received."
"[INST]In the context of the C64, What is the purpose of the memory location at address $ED40?[/INST]address              $ED40
Send a Byte on the Serial Bus

This subroutine is used in common by several Kernal routines to send
the byte in the serial bus character buffer at 149 ($95) on the serial
bus."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EF2E?[/INST]address              $EF2E
Handle RS-232 Errors

This subroutine sets the appropriate error bits in the status register
at 663 ($297)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E632?[/INST]address              $E632
Input a Character from Screen or Keyboard

This routine is the portion of the Kernal CHRIN routine that handles
input from the keyboard and screen devices.  CHRIN gets one byte at a
time from the current screen position, or inputs a whole line from the
keyboard and returns it one byte at a time."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A474-$A47F?[/INST]address   $A474-$A47F    READY
Print READY

This routine displays the word READY, sets the Kernal message flag to
show that direct mode is operative, and falls through to the main
BASIC loop."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A613?[/INST]address        $A613          FINDLN
Search for Line Number

This routine searches through the program text, trying to match the
two-byte integer line number that is stored in 20-21 ($14-$15).  If it
is found, 95-96 ($5F-$60) will be set as a pointer to the address of
the link field for that line, and the Carry flag will be set.  If it
is not found, the Carry flag will be cleared."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E965?[/INST]address              $E965
Insert a Blank Line on the Screen

This subroutine is used when INSERTing to add a blank physical line to
a logical line."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A38A-$A3B7 ?[/INST]address   $A38A-$A3B7    FNDFOR
Find FOR on Stack

This routine searches the stack for the blocks of data entries which
are stored by each FOR command.  For more information on the data that
FOR places on the stack, see location 256 ($100)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EB79?[/INST]address              $EB79
Keyboard Decode Table Vectors

This table contains the two-byte addresses of the four keyboard decode
tables in low-byte, high-byte format."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A49C?[/INST]address        $A49C          MAIN1
Add or Replace a Line of Program Text

This routine calls subroutines to get the line number, tokenize
keywords, and then looks for a line with the same line number.

If it finds a line with the same number, the routine deletes that line
by moving all higher program text and variables down to where it
started.  The new line is then added.  Since the CLR routine is
called, the value of all current program variables is lost."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E5B4?[/INST]address              $E5B4          LP2
Get a Character from the Keyboard Buffer

This routine transfers the first character from the keybard buffer to
the .A register, bumps the rest of the characters one place up in
line, and decrements the pointer, showing how many characters are
waiting in the buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E8D1?[/INST]address              $E8D1
PETASCII Color Code Equivalent Table

This table gives the PETASCII values of the color change characters
for each of the 16 possible colors.  These values are:

144 ($90)  Change to color 0 (black)
  5 ($05)  Change to color 0 (white)
 28 ($1C)  Change to color 0 (red)
159 ($9F)  Change to color 0 (cyan)
156 ($9C)  Change to color 0 (purple)
 30 ($1E)  Change to color 0 (green)
 31 ($1F)  Change to color 0 (blue)
158 ($9E)  Change to color 0 (yellow)
129 ($81)  Change to color 0 (orange)
149 ($95)  Change to color 0 (brown)
150 ($96)  Change to color 0 (light red)
151 ($97)  Change to color 0 (dark gray)
152 ($98)  Change to color 0 (medium gray)
153 ($99)  Change to color 0 (light green)
154 ($9A)  Change to color 0 (light blue)
155 ($9B)  Change to color 0 (light gray)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $A65E?[/INST]address         $A65E          CLEAR
Perform CLR

The CLR command closes all I/O files with the Kernal CLALL routine
(62255, $F32F).  It eliminates string variables by copying the end of
memory pointer at 55-56 ($37-$38) to the bottom of strings pointer at
51-52 ($33-$34).  It also copies the pointer to the end of BASIC
program text at 49-50 ($31-$31) to the pointer to the start of
nonarray variables at 45-46 ($2D-$2E) and the start of array variables
at 47-48 ($2F-$30).  This makes these variables unusable (although the
contents of these areas are not actually erased).  RESTORE is called
to set the data pointer back to the beginning, and the stack is
cleared."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FF93?[/INST]address              $EDB9          SECOND
Send a Secondary Address to a Device on the Serial Bus after LISTEN

This is a documented Kernal routine that can be entered from the jump
table at 65427 ($FF93).  It sends a secondary address from the
Accumulator to the device on the serial bus that has just been
commanded to LISTEN.  This is usually done to give the device more
particular instructions on how the I/O is to be carried out before
information is sent."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EF59?[/INST]address              $EF59
Receive Next RS-232 Bit (NMI)

This routine is called by the NMI interrupt handler routine to receive
the next bit of data from the RS-232 device."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B6?[/INST]address           $B6            RODATA
RS-232 Output Byte Buffer

RS-232 routines use this area to disassemble each byte to be sent from
the transmission buffer pointed to by 249 ($F9)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $30D?[/INST]address          $30D           SXREG
Storage Area for .X Index Register"
"[INST]In the context of the C64, What is the purpose of the memory location at address $AB?[/INST]address          $AB            RIPRTY
RS-232 Input Parity/Cassete Leader Counter

This location is used to help detect if data was lost during RS-232
transmission, or if a tape leader is completed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F838?[/INST]address              $F838
Test Cassette Buttons and Handle Messages for Tape Write

This routine tests the sense switch, and if no buttons are depressed
it prints the PRESS PLAY & RECORD message, and loops until a cassette
button is pressed, or until the STOP key is pressed.  If a button is
pressed, it prints the message OK.  These messages cannot be supressed
by changing the flag at 157 ($9D).  See the entry for 63511 ($F817)
for more information."
"[INST]In the context of the C64, What is the purpose of the memory location at address $0291?[/INST]address           $291           MODE
Flag: Enable or Disable Changing Character Sets with SHIFT/Logo
Keypress

This flag is used to enable or disable the feature which lets you
switch between the uppercase/graphics and upper/lowercase character
sets by pressing the SHIFT and Commodore logo keys simultaneously.

This flag affects only this special SHIFT key function, and does not
affect the printing of SHIFTed characters.  POKEing a value of 128
($80) here will disable this feature, while POKEing a value of 0 will
enable it once more.  The same effect can be achieved by PRINTing
CHR$(8) or CTRL-H to disable the switching of character sets, and
CHR$(9) or CTRL-I to enable it.  See entries for locations 53272
($D018) and 49152 ($C000) for more information on switching character
sets."
"[INST]In the context of the C64, What is the purpose of the memory location at address $289?[/INST]address           $289           XMAX
Maximum Keyboard Buffer Size

The value here indicates the maximum number of characters that the
keyboard buffer at 631 ($277) may hold at any one time.  Anytime that
the current buffer length in location 198 ($C6) matches the value
here, further keypresses will be ignored.

Although the maximum size of the keyboard buffer is usually 10
characters, it may be possible to extend it up to 15 characters by
changing the number here.  This could cause the Operating System
pointers to the bottom and top of memory at 641-644 ($281-$284) to be
overwritten, but no real harm should result."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F5DD?[/INST]address              $F5DD          SAVE
Save RAM to a Device

This is a documented Kernal routine, whose entry in the jump table
appears at 65496 ($FFD8).

The routine jumps through a RAM vector at 818 ($332).  SAVE is used to
transfer data directly from RAM to an I/O device.  Since the SAVE
routine performs an OPEN, it must be preceded by a call to the SETLFS
routine to specify the logical file number, device number, and
secondary address, and a call to the SETNAM routine to specify the
filename (although a SAVE to the cassette can be performed without
giving a filename).  A Page 0 pointer to the starting address of the
area to be saved should be set up, with the low byte of the address
first.  The accumulator should be loaded with the Page 0 offset of
that pointer, then the .X and .Y registers should be set with the
ending address for the save, and the SAVE routine called."
"[INST]In the context of the C64, What is the purpose of the memory location at address $67?[/INST]address          $67            SGNFLG
Number of Terms in a Series Evaluation

This location is used by mathematical formula evaluation routines.  It
indicates the number of separate evaluations that must be done to
resolve a complex expression down to a single term."
"[INST]In the context of the C64, What is the purpose of the memory location at address $2?[/INST]address             $2
Unused"
"[INST]In the context of the C64, What is the purpose of the memory location at address $54-$56?[/INST]address         $54-$56        JMPER
Jump to Function Instruction

The first byte is the 6502 JMP instruction ($4C), followed by the
address of the required function taken from the table at 41042
($A052)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $$324-$325?[/INST]address      $324-$325      IBASIN
Vector to Kernal CHRIN Routine (Currently at 61783 ($F157))"
"[INST]In the context of the C64, What is the purpose of the memory location at address $31A-$32D?[/INST]address ($31A-$32D)
Kernal Indirect Vectors

There are 39 Kernal routines for which there are vectors in the jump
table located at the top of the ROM (65409, $FF81).  For ten of these
routines, the jump table entry contains a machine language instruction
to jump to the address pointed to by the RAM vector in this table.
The addresses in this table are initialized to point to the
corresponding routines in the Kernal ROM.  Since these addresses are
in RAM, however, any entry in this table may be changed.  This enables
the user to add to these routines, or to replace them completely.

You will notice, for example, that many of these routines involve
Input/ Output functions.  By changing the vectors  to these routines,
it is possible to support new I/O devices, such as an IEEE disk drive
used through an adapter.

The user should be cautioned that since some of these routines are
interrupt-driven, it is dangerous to change these vectors without
first turning off all interrupts.  For a safe method of changing all
of these vectors at one time, along with the interrupt vectors above,
see the entry for the Kernal VECTOR routine at 64794 ($FD1A).

More specific information about the individual routines can be found
in the descriptions given for their ROM locations."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A3-$A4?[/INST]address       $A3-$A4
Temporary Data Storage Area

These locations are used temporarily by the tape and serial I/O
routines."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D021?[/INST]address              $D021          BGCOL0
Background Color 0

This register sets the background color for all text modes, sprite
graphics, and multicolor bitmap graphics.  The default color value is
6 (blue)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BC1B?[/INST]address         $BC1B          ROUND
Round Accumulator #1 by Adjusting the Rounding Byte

If doubling the rounding byte at location 112 ($70) makes it greater
than 128, the value of FAC1 is increased by 1."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D40B?[/INST]address              $D40B          VCREG2
Voice 2 Control Register

Bit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release
Bit 1:  Sync Bit:  1=Synchronize oscillator with Oscillator 1 frequency
Bit 2:  Ring Modulation:  1=Ring modulate Oscillators 2 and 1
Bit 3:  Test Bit:  1=Disable Oscillator 2
Bit 4:  Select triangle waveform
Bit 5:  Select sawtooth waveform
Bit 6:  Select pulse waveform
Bit 7:  Select noise waveform"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D01D?[/INST]address              $D01D          SP6COL
Sprite 6 Color Register (the default color value is 7, yellow)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BB12?[/INST]address         $BB12          FDIVT
Divide FAC2 by FAC1

This routine is used to divide the contents of FAC2 by the contents of
FAC1, with the result being stored in FAC1.  A check for division by 0
is made before dividing."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D00D?[/INST]address              $D00D          SP6Y
Sprite 6 Vertical Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D006?[/INST]address         $D006          SP3X
Sprite 3 Horizontal Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D005?[/INST]address         $D005          SP2Y
Sprite 2 Vertical Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D00C?[/INST]address              $D00C          SP6X
Sprite 6 Horizontal Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D01E?[/INST]address              $D01E          SP7COL
Sprite 7 Color Register (the default color value is 12, medium gray)

Location Range: 53295-53311 ($D02F-$D03F)
Not Connected

The VIC-II chip has only 47 registers for 64 bytes of possible address
space.  Therefore, the remaining 17 addresses do not access any
memory.  When read, they will always give a value of 255 ($FF).  This
value will not change after writing to them.

Location Range: 53312-54271 ($D040-$D3FF)
VIC-II Register Images

Since the VIC-II requires only enough addressing lines to handle 64
locations (the minimum possible for its 47 registers), none of the
higher bits are decoded when addressing this 1K area.  The result is
that every 64 byte area in this 1K block is a mirror of every other.
POKE53281+64,1 has the same effect as POKE53281,1 or
POKE53281+10*64,1; they all turn the screen background to white.  For
the sake of clarity in your programs it is advisable to use the base
address of the chip."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BBA2?[/INST]address         $BBA2          MOVFM
Move a Floating Point Number from Memory to FAC1

This routine loads FAC1 with the five-byte floating point number
pointed to by the address stored in the Accumulator (low byte) and the
.Y register (high byte)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BC2B?[/INST]address         $BC2B          SIGN
Put the Sign of Accumulator #1 into .A Register

On exit from this routine the Accumulator will hold a 0 if FAC1 is 0,
a 1 if it is positive, and a value of 255 ($FF) if it is negative."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D40C?[/INST]address              $D40C          ATDCY2
Voice 2 Attack/Decay Register

Bits 0-3:  Select decay cycle duration (0-15)
Bits 4-7:  Select attack cycle duration (0-15)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D022?[/INST]address              $D022          BGCOL1
Background Color 1

This register sets the color for the 01 bit-pair of multicolor
character graphics, and the background color for characters having
screen codes 64-127 in extended background color text mode.  The
default color value is 1 (white)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $318-$319?[/INST]address      $318-$319      NMINV
Vector: Non-Maskable Interrupt

This vector points to the address of the routine that will be executed
when a Non-Maskable Interrupt (NMI) occurs (currently at 65095
($FE47)).

There are two possible sources for an NMI interrupt.  The first is the
RESTORE key, which is connected directly to the 6510 NMI line.  The
second is CIA #2, the interrupt line of which is connected to the 6510
NMI line.

When an NMI interrupt occurs, a ROM routine sets the Interrupt disable
flag, and then jumps through this RAM vector.  The default vector
points to an interrupt routine which checks to see what the cause of
the NMI was.

If the cause was CIA #2, the routine checks to see if one of the
RS-232 routines should be called.  If the source was the RESTORE key,
it checks for a cartridge, and if present, the cartridge is entered at
the warm start entry point.  If there is no cartridge, the STOP key is
tested.  If the STOP key was pressed at the same time as the RESTORE
key, several of the Kernal initialization routines such as RESTOR,
IOINIT and part of CINT are executed, and BASIC is entered through its
warm start vector at 40962.  If the STOP key was not pressed
simultaneously with the RESTORE, the interrupt will end without
letting the user know that anything happened at all when the RESTORE
key was pressed.

Since this vector controls the outcome of pressing the RESTORE key, it
can be used to disable the STOP/RESTORE sequence.  A simple way to do
this is to change this vector to point to the RTI instruction.  A
simple POKE 792,193 will accomplish this.  To set the vector back,
POKE 792,71.  Note that this will cut out all NMIs, including those
required for RS-232 I/O."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A0-$A02?[/INST]address       $A0-$A2        TIME
Software Jiffy Clock

These three locations are updated 60 times a second, and serve as a
software clock which counts the number of jiffies (sixtieths of a
second) that have elapsed since the computer was turned on.

The value of location 162 ($A2) is increased every jiffy (0.1667
second), 161 ($A1) is updated every 256 jiffies (4.2267 seconds), and
160 ($A0) changes every 65536 jiffies (or every 18.2044 minutes).
After 24 hours, these locations are set back to 0.

The jiffy clock is used by the BASIC reserved variables TI and TI$.
These are not ordinary variables that are stored in the RAM variable
area, but are functions that call the Kernal routines RDTIM (63197,
$F6DD), and SETTIM (63204, $F6E4).  Assigning the value of TI or TI$
to another variable reads these locations, while assigning a given
value to TI$ alters these locations.

To illustrate the relationship between these locations and TI$, try
the following program.  The program sets the jiffy clock to 23 hours,
50 minutes.  After the program has been running for one minute, all
these locations will be reset to 0.

100 TI$='235900'
110 PRINT TI$,PEEK(160),PEEK(161),PEEK(162)
120 GOTO 110

Since updating is done by the IRQ interrupt that reads the keyboard,
anything which affects the operation of that interrupt routine will
also interfere with this clock.  A typical example is tape I/O
operations, which steal the IRQ vector for their own use, and restore
it afterwards.  Obviously, user routines which redirect the IRQ and do
not send it back to the normal routine will upset software clock
operation as well."
"[INST]In the context of the C64, What is the purpose of the memory location at address $$322-$323?[/INST]address       $322-$323      ICLRCH
Vector to Kernal CLRCHN Routine (Currently at 62259 ($F333))"
"[INST]In the context of the C64, What is the purpose of the memory location at address $53?[/INST]address           $53            FOUR6
Constant for Garbage Collection

The constant contained here lets the garbage collection routines know
whether a three- or seven-byte string descriptor is being collected."
"[INST]In the context of the C64, What is the purpose of the memory location at address $66?[/INST]address          $66            FACSGN
Floating Point Accumulator #1: Sign

A value of 0 here indicates a positive number, while a value of 255
($FF) indicates a negative number."
"[INST]In the context of the C64, What is the purpose of the memory location at address 1?[/INST]address             $1             R6510

Bit 0: LORAM signal.  Selects ROM or RAM at 40960 ($A000).  1=BASIC, 0=RAM
Bit 1: HIRAM signal.  Selects ROM or RAM at 57344 ($E000).  1=Kernal, 0=RAM
Bit 2: CHAREN signal.  Selects character ROM or I/O devices.  1=I/O, 0=ROM
Bit 3: Cassette Data Output line.
Bit 4: Cassette Switch Sense.  Reads 0 if a button is pressed, 1 if not.
Bit 5: Cassette Motor Switch Control.  A 1 turns the motor on, 0 turns it off.
Bits 6-7: Not connected--no function presently defined.

The chief function of this register is to determine which blocks of
RAM and ROM the 6510 microprocessor will address.  The Commodore 64
comes with 64K RAM, even though it normally does not use all of that
RAM at once.  In addition, it has an 8K BASIC Interpreter ROM, an 8K
Operating System Kernal ROM, a 4K Character Generator ROM, a Sound
Interface Device (SID), a 6566 Video Interface Controller (VIC-II),
and two 6526 Complex Interface adapter chips.

To address all of these at once would require 88K, 24K past the
addressing limit of the 6510 microprocessor.  In order to allocate
address space, the I/O Port is used to affect the addressing lines,
and thus determine which segments of RAM and ROM will be addressed at
any one time.

Bit 0.  This bit controls the LORAM signal.  A 0 in this bit position
switches the BASIC ROM out, and replaces it with RAM at addresses
40960-49151 ($A000-$BFFF).  The default value of this bit is 1.

Bit 1.  Bit 1 controls the HIRAM signal.  A 0 in this bit position
switches the Kernal ROM out, and replaces it with RAM at 57344-65535
($E000-$FFFF).  As the BASIC interpreter uses the Kernal, it is also
switched out and replaced by RAM.  The default value of this bit is 1.

The system allows a wide range of combinations of RAM and ROM to be
utilized.  Of course, the BASIC programmer will have little need, in
the ordinary course of events, to switch out the BASIC ROM and the
Kernal.  To do so would just hang the system up.  But one way to make
use of this feature is to move the contents of ROM to the
corresponding RAM addresses.  That way, you can easily modify and
customize the BASIC interpreter and OS Kernal routines, which are
ordinarily fixed in ROM.  For examples, to move BASIC into RAM, just
type:

FOR I=40960 TO 49151:POKE I,PEEK(I):NEXT

Though it appears that such a program would not do anything, it in
fact copies bytes from ROM to RAM.  This is because any data which is
written to a ROM location is stored in the RAM which resides at the
same address.  So while you are PEEKing ROM, you are POKEing RAM.  To
switch to your RAM copy of BASIC, type in:

POKE 1,PEEK(1) AND 254.

Now you are ready to make modifications.  Examples of simple
modifications include changing the text which the interpreter prints,
such as the READY prompt, the power-up message, or the keyword table.

An example of the latter would be POKE 41122,69.  This changes the FOR
keyword to FER, so that BASIC would respond normally to a FER-NEXT
loop, but fail to recognize FOR as syntactically correct.

On the more practical side, you could change the prompt that INPUT
issues to a colon, rather than a question mark:

POKE 43846,58

You are not limited to just cosmetic changes of text.  Jim Butterfield
has given an example in COMPUTE! magazine of changing the interpreter
so that it assigns a null string the ASCII value 0.  In the ROM
version, the command PRINT ASC('') will return ?ILLEGAL QUANTITY
ERROR.  This is inconvenient when INPUTting a string, because if the
user presses RETURN and you try to check the ASCII value of the string
that has been entered, you will get this error.  By entering POKE
46991,5, this is changed so that PRINT ASC('') now responds with a
zero.

For the more serious machine language programmer, it is quite feasible
to add new commands or modify existing ones by diverting the vectors
which are discussed in the section covering the BASIC interpreter ROM.
For a good example of this technique, see the article 'Hi-Res Graphics
Made Simple' by Paul Schatz in COMPUTE!'s First Book of Commodore 64
Sound and Graphics.  The program example there inserts new graphics
commands into a RAM version of BASIC.  When you want to switch back to
the ROM BASIC, enter POKE 1,PEEK(1) OR 1.

For machine language applications, it would be possible to replace the
ROM programs with an entirely different operating system, or an
application that has its own screen editing and I/O functions
included.  Such an application would first have to be loaded from disk
into RAM.  A language other than BASIC could be loaded, and could then
just switch out the BASIC ROM, while still using the OS Kernal.

Or a spreadsheet application that contained its own I/O routines could
switch out all ROMs and have the use of all of RAM that is not
actually needed for the program itself, for data.  It should be
remembered, however, that before switching the Kernal out, it is
necessary to disable interrupts, as the vectors for these interrupts
are contained in the Kernal.

Bit 2.  This bit controls the CHAREN signal.  A 0 in this position
switches the character generator ROM in, so that it can be read by the
6510 at addresses 53248-57343 ($D000-$DFFF).  Normally, this bit is
set to 1, so that while the VIC-II chip has access to the character
generator ROM for purposes of creating the screen display, the user
cannot PEEK into it.  Since this ROM is switched into the system in
the same location as the I/O devices (SID chip, VIC-II chip, and 6526
CIA's), o I/O can occur when this ROM is switched in.

The ability to switch in the character generator ROM is very useful to
the programmer who wishes to expirement with user-defined characters.
Modified character graphics is one of the  more powerful graphics
tools available, but often the user will not want to redefine a whole
character set at one time.  By reading the character ROM and
duplicating its contents in RAM, the user can replace only a few
characters in the set.  The method for reading this ROM into RAM from
BASIC is as follows:

10 POKE 56333,127:POKE1,PEEK(1) AND 251:FOR I=0 TO 2048
20 POKE BASE+I,PEEK(53248+I):NEXT:POKE 1,PEEK(1) OR 4:POKE 56333,129

The first POKE is necessary to turn off the system timer interrupt.
Since the I/O devices are addressed in the same space as the character
ROM, switching that ROM in switches all I/O out, making it necessary
to turn off any interrupts which use these devices.

The second POKE is the one which switches in the character ROM.  The
program loop then reads this ROM memory into RAM, starting with the
address BASE.  Note that this address should start on an even 2K
boundary (an address evenly divisible by 2048) within the block of
memory presently being addresses by the VIC-II chip (for more
information on where to put user-defined character sets, and how to
use them, see the section on the VIC-II chip, under location 53272
($D018), the section on the character ROM at 49152 ($C000), and the
section on banking VIC-II memory at 56576 ($DD00)).  After reading the
contents of ROM into RAM, the next POKEs switch out the character ROM
and restore the interrupt.

It should be noted that while Bits 0-2 of this register allow software
control of some signals that determine the memory configuration that
is used by the Commodore 64 at any given time, they are not the only
determining factor.  Signals can also be generated by means of plug-in
expansion cartridges which are connected to the expansion port, and
these can change the memory map.

Two lines located on the exapansion port are called GAME and EXROM.
When used in conjunction with the software-controlled lines noted
above, these two hardware lines can enable cartridge ROM to replace
various segments of ROM and/or RAM.

Possible configurations include 8K of cartridge ROM to be switched in
at $8000-$9FFF, for a BASIC enhancement program; an 8K cartridge ROM
at $A000-$BFFF, replacing BASIC, or at $E000-$FFFF, replacing the
Kernal, or a 16k cartridge at $8000-$C000.

When cartridge ROM is selected to replace the Kernal, a Max emulator
mode is entered, which mimics the specification of the ill-fated Max
Machine, a game machine which Commodore never produced for sale int he
U.S.  In this mode, only the first 6K of RAM are used, there is no
access to the character ROM, and graphics data such as charactger
dot-data is mapped down from 57344 ($E000) to 8192 ($2000).  Further
hardware information may be obtained from the Commodore 64
Programmer's Reference Guide.

Bits 3-5 of this register have functions connected with the Datasette
recorder.  These are as follows:

Bit 3.  This is the Cassette Data Output line.  This line is connected
to the Cassette Data Write line on the cassette port, and is used to
send the data which is written to tape.

Bit 4.  This bit is the Cassette Switch Sense line.  This bit enables
a program to tell whether or not one of the buttons that moves the
recorder is pressed down.  If the switch on the recorder is down, this
bit will have a value of 1.  Remember that Bit 4 of the data direction
register at location 0 must contain a 0 for this bit to properly
reflect the status of the switch.

Bit 5.  Bit 5 is the Cassette Motor Control.  Setting this bit to zero
allows the motor to turn when you press one of the buttons on the
recorder, while setting it to one disables it from turning.

Most of the time, the setting of this bit will be controlled by the
interrupt routine that is used to read the keyboard every sixtieth of
a second.  If none of the buttons on the recorder is pressed, that
interrupt routine shuts the motor off and sets the interlock at
location 192 ($C0) to zero.  When a button is pressed, if the
interlock location is zero, Bit 5 of this register is set to zero to
turn the motor on.

When the interlock location contains a zero, the keyscan routine will
not let you control the setting of this bit of the register (and the
interlock is always set to zero when no buttons are pressed).  In
order for you to gain control of the motor, you must POKE a nonzero
value into 192 after a button on the recorder has been pressed.  You
can then shut off the motor and turn it back on as you please, by
manipulating this bit, so long as a button stays pressed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $28A?[/INST]address          $28A           RPTFLAG
Flag: Which Keys Will Repeat?

The flag at this location is used to determine whether to continue
printing a character as long as its key is held down, or whether to
wait until the key is let up before allowing it to be printed again.
The default value here is 0, which allows only the cursor movement
keys, insert/delete key, and the space bar to repeat.

POKEing this location with 128 ($80) will make all keys repeating,
while a value of 64 ($40) will disable all keys from repeating."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F68F?[/INST]address              $F68F
If in Direct Mode, Print SAVING and Filename"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F841?[/INST]address              $F841
Start Reading a Block of Data from the Cassette

This subroutine tests the cassette switch and initializes various
flags for reading a block of data from cassette."
"[INST]In the context of the C64, What is the purpose of the memory location at address $292?[/INST]address           $292           AUTODN
Flag: Screen Scrolling Enabled

This location is used to determine whether moving the cursor past the
fortieth column of a logical line will cause another physical line to
be added to the logical line.

A value of 0 enables the screen to scroll the following lines down in
order to add that line; any nonzero value will disable the scroll.
This flag is set to disable the scroll temporarily when there are
characters waiting in the keyboard buffer (these may include cursor
movement characters that would eliminate the need for a scroll)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $30E?[/INST]address           $30E           SYREG
Storage Area for .Y Index Register"
"[INST]In the context of the C64, What is the purpose of the memory location at address $AC-$AD?[/INST]address       $AC-$AD        SAL
Pointer to the Starting Address of a Load/Screen Scrolling

The pointer to the start of the RAM area to be SAVEd or LOADed at 193
($C1) is copied here.  This pointer is used as a working version, to
be increased as the data is received or transmitted.  At the end of
the operation, the initial value is restored here.  Screen management
routines temporarily use this as a work pointer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B7?[/INST]address          $B7            FNLEN
Length of Current Filename

This location holds the number of characters in the current filename.
Disk filenames may have from 1 to 16 characters, while tape filenames
range from 0 to 187 characters in length.

If the tape name is longer than 16 characters, the excess will be
truncated by the SEARCHING and FOUND messages, but will still be
present on the tape.  This means that machine language programs meant
to run in the cassette buffer may be saved as tape filenames.

A disk file is always referred to be a name, whether full or generic
(containing the wildcard characters * or ?).  This location will
always be greater than 0 if the current file is a disk file.  Tape
LOAD, SAVE, and VERIFY operations do not require that a name be
specified, and this location can therefore contain a 0.  If this is
the case, the contents of the pointer to the filename at 187 will be
irrelevant.

An RS-232 OPEN command may specify a filename of up to four
characters.  These characters are copied to locations 659-662
($293-$296), and determine baud rate, word length, and parity."
"[INST]In the context of the C64, What is the purpose of the memory location at address $#F4A?[/INST]address              $#F4A
Set the Word Length For the Current RS-232 Character

This routine takes the number of data bits to send per RS-232
character from the control register and puts it into the .X register
for use by the RS-232 routines."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EDB0?[/INST]address              $EDB0
Time-Out Error on Serial Bus

This subroutine handles the case when the device does not respond by
setting the DEVICE NOT PRESENT error code and exiting."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E8EA?[/INST]address              $E8EA
Scroll Screen

This subroutine moves all of the screen lines up, so that a blank line
is created at the bottom of the screen and the top screen line is
lost.  If the top logical line is two physical lines long, all lines
are moved up two lines.  Holding down the CTRL key will cause a brief
pause after the scroll."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A68E?[/INST]address         $A68E          RUNC
Reset Pointer to Current Text Character to the Beginning of Program
Text

This routine resets the CHRGET pointer TXTPTR (122-123, $7A-$7B) so
that the next byte of text that the interpreter will read comes from
the beginning of program text."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A533?[/INST]address         $A533          LINKPRG
Relink Lines of Tokenized Program Text

Each line of program text starts with a pointer to the address of the
next line (link address).  This routine scans each line to the end
(which is marked with a 0), and calculates the new link address by
adding the offset to the address of the current statement."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E5CA?[/INST]address              $E5CA
Wait for a Carriage Return from the Keyboard

This subroutine is called by the portion of the CHKIN routine that
handles keyboard input.  It turns the cursor on, gets characters, and
echoes them to the screen until a carriage return has been entered.
It also looks for the shifted RUN/STOP key, and forces the output of
the commands LOAD and RUN if it finds it."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EB81?[/INST]address              $EB81
Standard Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the standard keyboard,
one for each key which is struck by itself.  The table is in keycode
order (see the keycode table in Appendix H for the correspondence of
keycode to key).  A 65th byte with the value of 255 ($FF) marks the
end of the table (this corresponds to a keypress value of 64, no key
pressed)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A82C?[/INST]address         $A82C
Test STOP Key for Break in Program

The Kernal STOP routine is called from here, and if the key is
pressed, the STOP (63213, $F6ED) command, below, is executed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E460?[/INST]address              $E460          WORDS
Power-Up Messages

The ASCII text of the start-up messages '**** COMMODORE 64 BASIC V2
****' and 'BYTES FREE' is stored here.

Location Range: 58551-58623 ($E4B7-E4FF)
Patches Added to Later Kernal Versions

This area contains code that was not found in the original version of
the Kernal.  These additions were made to fix some bugs and to
increase Kernal compatibility between U.S. and European 64s."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E500?[/INST]address              $E500          IOBASE
Store Base Address of Memory-Mapped I/O Devices in .X and .Y Registers

This is one of the documented Kernal routines for which there is a
vector in the jump table at 65523 ($FFF3).

When called, this routine sets the .X register to the low byte of the
base address of the memory-mapped I/O devices, and puts the high byte
in the .Y register.  This allows a user to set up a zero-page pointer
to the device, and to load and store indirectly through that pointer.
A program which uses this method, rather than directly accessing such
devices could be made to function without change on future Commodore
models, even though the I/O chips may be addressed at different
locations.  This of course assumes that the CIA or a similar chip will
be used.  This routine is of limited value for creating software that
is compatible with both the VIC-20 and the 64 because of the
differences in the VIA I/O chip that the VIC uses.

The current version of this routine loads the .X register with a 0,
and the .Y register with 220 ($DC), thus pointing to CIA #1, which is
at 56320 ($DC00)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AA80?[/INST]address         $AA80          PRINTN
Perform PRINT#

The PRINT# statement calls CMD and then closes the output channel with
the Kernal CLRCHN routine (62259, $F333)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AEA8?[/INST]address         $AEA8          PIVAL
PI Expressed as a Five-Byte Floating Point Number

The value of PI is stored here as a five-byte floating point number."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B185[/INST]address         $B185          FINPTR
Return the Address of the Variable That Was Found or Created

This routine stores the address of the variable that was found or
created by the preceding routines in a pointer at 71-72 ($47-$48)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B3B3?[/INST]address         $B3B3          DEF
Perform DEF

DEF performs some syntax checking, and pushes five bytes onto the
stack:  the first byte of the function statement, a two-byte pointer
to the dependent variable (the X in FN(X)), and the address of the
first character of the definition itself, where it resides in the
program text.

The DEF statement must fit on one line, but functions can be extended
by nesting them (having one function call another)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FCB8?[/INST]address              $FCB8
Terminate Cassette I/O

This routine calls the subroutine above and returns from the
interrupt."
"[INST]In the context of the C64, What is the purpose of the memory location at address $26D-$276?[/INST]address       $26D-$276      SAT
Kernal Table of Secondary Addresses for Each Logical File"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F3-$F4?[/INST]address       $F3-$F4        USER
Pointer to the Address of the Current Screen Color RAM Location

This poitner is synchronized with the pointer to the address of the
first byte of screen RAM for the current line kept in location 209
($D1).  It holds the address of the first byte of color RAM for the
corresponding screen line."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FB8E?[/INST]address              $FB8E
Move the Tape SAVE/LOAD Address into the Pointer at 172"
"[INST]In the context of the C64, What is the purpose of the memory location at address $FF6E?[/INST]address              $FF6E
End of Routine to Set Timer for Sixtieth of a Second IRQ

This appears to be a patch added to compensate for the extra length of
the current version of this routine, which chooses either the PAL or
NTSC prescaler values for the timer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $45-$46?[/INST]address        $45-$46        VARNAM
Current BASIC Variable Name

The current variable name being searched for is stored here, in the
same two- byte format as in the variable value storage area located at
the address pointed to by 45 ($2D).  See that location for an
explanation of the format."
"[INST]In the context of the C64, What is the purpose of the memory location at address $26-$2A?[/INST]address        $26-$2A        RESHO
Floating Point Multiplication Work Area

This location is used by BASIC multiplication and division routines.
It is also used by the routines which compute the size of the area
required to store an array which is being created."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B9BC?[/INST]address         $B9BC          FONE
Floating Point Constant with a Value of 1

This five-byte floating point representation of the number 1 is stored
here for use by the floating point routines.  It is also used as the
default STEP value for the FOR statement."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D420-$D7FF?[/INST]address     $D420-$D7FF
SID Register Images

Since the SID chip requires enough addressing lines for only 32
locations (the minimum possible for its 29 registers), none of the
higher bits are decoded when addressing the 1K area that has been
assigned to it.  The result is that every 32-byte area in this 1K
block is a mirror of every other.  For the sake of clarity in your
programs, it is advisable not to use these addresses at all."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D417?[/INST]address              $D417          RESON
Filter Resonance Control Register

Bit 0:  Filter the output of voice 1?  1=yes
Bit 1:  Filter the output of voice 2?  1=yes
Bit 2:  Filter the output of voice 3?  1=yes
Bit 3:  Filter the output from the external input?  1=yes
Bits 4-7:  Select filter resonance 0-15

Bits 0-3 are used to control which of the voices will be altered by
the filters.  If one of these bits is set to 1, the corresponding
voice will be processed through the filter, and its harmonic content
will be changed accordingly.  If the bit is set to 0, the voice will
pass directly to the audio output.  Note that there is also a
provision for processing an external audio signal which is brought
through pin 5 of the Audio/Video Port.

Bits 4-7 control the resonance of the filter.  By placing a number
from 0 to 15 in these four bits, you may peak the volume of those
frequencies nearest the cutoff.  This creates an even sharper
filtering effect.  A setting of 0 causes no resonance, while a setting
of 15 gives maximum resonance."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B7F7?[/INST]address         $B7F7          GETADR
Convert a Floating Point Number to an Unsigned Two-Byte Integer

This routine checks the number in the Floating Point Accumulator to
make sure that it is a positive number less than 65536, and then calls
the subroutine which conerts floatin point to integer.  It is used to
get address parameters, for commands such as PEEK."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B6A3?[/INST]address         $B6A3          FRESTR
Discard a Temporary String

This routine calls the following routine which clears an entry from
the temporary descriptor stack.  If the descriptor was on the stack,
it exits after setting pointers to the string and its length.  If it
wasn't on the temporary stack and is at the bottom of string text
storage, the pointer to the bottom is moved up to deallocate the
string."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E043?[/INST]address              $E043          POLY1
Function Series Evaluation Subroutine 1

This routine is used to evaluate more comples expressions, and calls
the following routine to do the intermediate evaluation."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD0C?[/INST]address              $DD0C          CI2SDR
Serial Data Port

The CIA chip has an on-chip serial port, which allows you to send or
receive a byte of data one bit at a time, with the most significant
bit (Bit 7) being transferred first.  For more information about its
use, see the entry for location 56332 ($DC0C).  The 64's Operating
System does not use this facility."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD0B?[/INST]address              $DD0B          TO2HRS
Time of Day Clock Hours

Bits 0-3:  Second digit of Time of Day hours (BCD)
Bit 4:  First digit of Time of Day hours (BCD)
Bits 5-6:  Unused
Bit 7:  AM/PM flag (1=PM, 0=AM)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E000?[/INST]address              $E000
Continuation of EXP Routine

This routine is split, with part on the BASIC ROM and the other part
here.  Since the two ROMs do not occupy contiguous memory as on most
Commodore machines, the BASIC ROM ends with a JMP $E000 instruction.
Thus, while the BASIC interpreter on the 64 is for the most part the
same as on the VIC, the addresses for routines in this ROM are
displaced by three bytes from their location on the VIC."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B6DB?[/INST]address         $B6DB          FRETMS
Remove an Entry from the String Descriptor Stack

If the descriptor of a currently valid string is the same as one of
the entries on the temporary string descriptor stack, the stack entry
is removed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D418?[/INST]address              $D418          SIGVOL
Volume and Filter Select Register

Bits 0-3:  Select output volume (0-15)
Bit 4:  Select low-pass filter, 1=low-pass on
Bit 5:  Select band-pass filter, 1=band-pass on
Bit 6:  Select high-pass filter, 1=high-pass on
Bit 7:  Disconnect output of voice 4, 1=voice 3 off

Bits 0-3 control the volume of all outputs.  The possible volume
levels range from 0 (no volume) to 15 (maximum volume).  Some level of
volume must be set here before any sound can be heard.

Bits 4-6 control the selection of the low-pass, band-pass, or
high-pass filter.  A 1 in any of these bits turns the corresponding
filter on.  These filters can be combined, although only one cutoff
frequency can be chosen.  In order for the filter to have any effect,
at least one of the voices must be routed through it using the Filter
Resonance Control Register at 54295 ($D417).

When Bit 7 is set to 1,  it disconnects the output of voice 3.  This
allows you to use the output of the oscillator for modulating the
frequency of the other voices, or for generating random number,
without any undesired audio output.

Location Range: 54297-54298 ($D419-$D41A)
Game Paddle Inputs

These registers allow you to read the game paddles that plug into
joystick Controller Ports 1 and 2.  Each paddle uses a variable
resistor (also known as a potentiometer or pot), whose resistance is
controlled by turning a knob.  The varying resistance is used to vary
the voltage to two pins of the SID chip between 0 and +5 volts.
Analog-to-digital (A/D) converters in the chip interpret these voltage
levels as binary values and store the values in these registers.
These registers return a number from 0 (minumum resistance) to 255
(maximum resistance) for each paddle in either of the ports, depending
on the position of the paddle knob.

Since these registers will read the paddle values for only one
controller port, there is a switching mechanism which allows you to
select which of the two ports to read.  By writing a bit-pair of 01
(bit value of 64) to the last two bits of CIA #1 Data Port A (56320,
$DC00), you select the paddles on joystick Controller Port 1.  By
writing a bit-pair of 10 (bit value of 128), you select the paddles on
Controller Port 2.

If you look at the description of Data Port A (56320, $DC00), however,
you will notice that it is also used in the keyboard scanning process.
By writing to this port, you determine which keyboard column will be
read.

Since the IRQ interrupt keyboard scan routine and the routine that
checks for the STOP key are putting values into this location 60 times
per second, you cannot reliable select the pair of paddles you wish to
read from BASIC without first turning off the keyboard IRQ.  This can
be done with a POKE 56333,127.  You can then read the paddles with the
statements A=PEEK(54297) and B=PEEK(54298).  The IRQ can be restored
after a paddle read with a POKE 56333,129.  It may, however, be easier
and more accurate in the long run to use a machine language paddle
read subroutine such as that presented on page 347 of the Commodore 64
Programmer's Reference Guide.

The paddle fire buttons are read as Bits 2 and 3 of the Data Ports A
(56320, $DC00) and B (56321, $DC01).  On Port A, if Bit 2 is set to 0,
button 1 is pushed, and if Bit 3 is set to 0, button 2 is pushed.  On
Port B, if Bit 2 is set to 0, button 3 is pushed, and if Bit 3 is set
to 0, button 4 is pushed.

The BASIC statements to test these buttons, thereore, are:

PB(1)=(PEEK(56321)AND4)/4
PB(2)=(PEEK(56321)AND8)/8
PB(3)=(PEEK(56320)AND4)/4
PB(4)=(PEEK(56320)AND8)/8

If a 0 is returned by the PEEK statement, the button is pushed, and if
a 1 is returned, it is not."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B80D?[/INST]address         $B80D          PEEK
Perform PEEK

PEEK reads the address parameter and converts it to a pointer.  Then
it gets the byte pointed to into the .Y register, and calls the part
of POS that converts a single integer in .Y to a floating point
number."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B9C1?[/INST]address         $B9C1          LOGCN2
Table of Floating Point Constants for the LOG Function

This table of eight numeric constants in five-byte floating point
representation is used by the LOG function."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D800-$DBFF?[/INST]address        $D800-$DBFF
Color RAM

The normal Commodore 64 text graphics system uses a screen RAM area to
keep track of the character shapes that are to be displayed.  But
since each character can be displayed in any of 16 foreground colors,
there must also be a parallel area which keeps track of the foreground
color.  This 1024-byte area is used for that purpose (actually, since
there are only 1000 screen positions, only 1000 byte actually affect
screen color).

These 1000 bytes each control the foreground color of one character,
with the first byte controlling the foreground color of the character
in the upper- left corner, and subsequent bytes controlling the
characters to the right and below that character.

Because only four bits are needed to represent the 16 colors
available, only the low four bits of each Color RAM location are
connected (this is why they are sometimes referred to as Color RAM
Nybbles).  Writing to the high bits will not affect them, and these
four bits will usually return a random value when read (a small number
of 64s return a constant value).

Therefore, in order to read Color RAM correctly, you must mask out the
top bits by using the logical AND function.  In BASIC, you can read
the first byte of Color RAM with the statement CR=PEEK(55296)AND15.
This will always return a color value between 0 and 15.  These color
values correspond to the following colors:

 0 = BLACK
 1 = WHITE
 2 = RED
 3 = CYAN (LIGHT BLUE-GREEN)
 4 = PURPLE
 5 = GREEN
 6 = BLUE
 7 = YELLOW
 8 = ORANGE
 9 = BROWN
10 = LIGHT RED
11 = DARK GRAY
12 = MEDIUM GRAY
13 = LIGHT GREEN
14 = LIGHT BLUE
15 = LIGHT GRAY

Color mapping affords a convenient method of changing the color of the
text display without changing the letters.  By POKEing the appropriate
section of Color RAM, you can change the color of a whole section of
text on the screen without affecting the content of the text.  You can
even use this method to make letters disappear by changing their
foreground colors to match the background (or by changing the
background to match the foreground), and later make them reappear by
changing them back, or by changing the background to a contrasting
color.  An interesting example program which changes Color RAM quickly
in BASIC can be found under the entry for 648 ($288).

A change in the Operating System causes newer 64s to set all of the
Color RAM locations to the same value as the current background color
whenever the screen is cleared.  Therefore, POKEing character codes to
the Screen RAM area will not appear to have any effect, because the
letters will be the same color as the background.  This can easily be
turned to your advantage, however, because it means that all you have
to do to set all of Color RAM to a particular value is to set the
background color to that value (using the register at 53281 ($D021)),
clear the screen, and return the background color in the desired
value.

The various garphics modes use this area differently than does the
regular text mode.  In high-resolution bitmap mode, this area is not
used at all, but in multicolor bitmap mode it is used to determine the
color of the 11 bit-pair for a given 8 by 8 dot area.

In multicolor text mode, only the lowest three bits are used, so only
colors 0-7 may be selected.  The fourth bit is used to determine
whether a character will be displayed in regular text or multicolor
text.  Characters with a color value over 7 are displayed as
multicolor characters, with the color of the 11 bit-pair determined by
the color value minus 8.  Characters with a color value under 8 are
displayed normally.

It should be noted that unlike the Screen RAM area, which can be moved
to any RAM location, the Color RAM area is fixed, and will function
normally regardless of where screen memory is located."
"[INST]In the context of the C64, What is the purpose of the memory location at address $22-$25?[/INST]address        $22-$25        INDEX
Miscellaneous Temporary Pointers and Save Area

This area is used by many BASIC routines to hold temporary pointers
and calculation results."
"[INST]In the context of the C64, What is the purpose of the memory location at address $43-$44?[/INST]address         $43-$44        INPPTR
Pointer in the Source of GET, READ, or INPUT Information

READ, INPUT and GET all use this as a pointer to the address of the
source of incoming data, such as DATA statements, or the text input
buffer at 512 ($200)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FF80?[/INST]address              $FF80
Kernal Version Identifier Byte

This last byte before the jump table can be used to identify the
version of the Kernal.  The first version has a 170 ($AA) stored here,
while the most current version at the time of this writing has a zero
in this location.

The PET 64, a one-piece version with an integrated monochrome display,
has an identifier byte of 100 ($64).  The Commodore 64 logo uses this
byte to recognize the PET 64, and adjust its display accordingly.

Location Range: 65409-65525 ($FF81-$FFF5)
Kernal Jump Table

The following jump table is provided by Commodore in an effort to
maintain stable entry points for key I/O routines.  Each three-byte
table entry consists of a 6510 JMP instruction and the actual address
of the routine in the ROM.  Although the actual address of the routine
may vary from machine to machine, or in later versions of the Kernal,
these addresses will stay where they are.  By jumping to the entry
point provided by this table, rather than directly into the ROM, you
insure your programs against changes in the Operating System.  In
addition, this jump table may help you write programs that will
function on more than one Commodore machine.  The 15 table entries
from 65472-65514 ($FFC0-$FFEA) are the same for all Commodore
machines, from the earliest PET on.

As an additional aid, some of these routines are also vectored through
the table which starts at 788 ($314).  Since this table is in RAM, you
can change those vectors to point to your own routines which support
additional I/O devices.  Programs that use the jump table entry points
to the I/O routines will be able to use these I/O devices without a
problem.

The following table will give the entry point, routine name, RAM
vector if any, its current address, and a brief summary of its
function.

65409 ($FF81) CINT   (65371, $FF5B) initialize screen editor and video chip
65412 ($FF84) IOINIT (64931, $FDA3) initialize I/O devices
65415 ($FF87) RAMTAS (64848, $FD50) initialize RAM, tape buffer, screen
65418 ($FF8A) RESTOR (64789, $FD15) restore default I/O vectors
65421 ($FF8D) VECTOR (64794, $FD1A) read/set I/O vector table
65424 ($FF90) SETMSG (65048, $FE18) set Kernal message control flag
65427 ($FF93) SECOND (60857, $EDB9) send secondary address after LISTEN
65430 ($FF96) TKSA   (60871, $EDC7) send secondary address after TALK
65433 ($FF99) MEMTOP (65061, $FE25) read/set top of memory pointer
65436 ($FF9C) MEMBOT (65076, $FE34) read/set bottom of memory pointer
65439 ($FF9F) SCNKEY (60039, $EA87) scan the keyboard
65442 ($FFA2) SETTMO (65057, $FE21) set time-out flag for IEEE bus
65445 ($FFA5) ACPTR  (60947, $FE13) input byte from serial bus
65448 ($FFA8) CIOUT  (60893, $EDDD) output byte to serial bus
65451 ($FFAB) UNTLK  (60911, $EDEF) command serial bus device to UNTALK
65454 ($FFAE) UNLSN  (60926, $EDFE) command serial bus device to UNLISTEN
65457 ($FFB1) LISTEN (60684, $ED0C) command serial bus device to LISTEN
65460 ($FFB4) TALK   (60681, $ED09) command serial bus device to TALK
65463 ($FFB7) READST (65031, $FE07) read I/O status word
65466 ($FFBA) SETLFS (65024, $FE00) set logical file parameters
65469 ($FFBD) SETNAM (65017, $FDF9) set filename parameters
65472 ($FFC0) OPEN   (via 794 ($31A) to 62282, $F34A) open a logical file
65475 ($FFC3) CLOSE  (via 796 ($31C) to 62097, $F291) close a logical file
65478 ($FFC6) CHKIN  (via 798 ($31E) to 61966, $F20E) define an input channel
65481 ($FFC9) CHKOUT (via 800 ($320) to 62032, $F250) define an output channel
65484 ($FFCC) CLRCHN (via 802 ($322) to 62259, $F333) restore default devices
65487 ($FFCF) CHRIN  (via 804 ($324) to 61783, $F157) input a character
65490 ($FFD2) CHROUT (via 806 ($326) to 61898, $F1CA) output a character
65493 ($FFD5) LOAD   (via 816 ($330) to 62622, $F49E) load from device
65496 ($FFD8) SAVE   (via 818 ($332) to 62941, $F5DD) save to a device
65499 ($FFDB) SETTIM (63204, $F6E4) set the software clock
65502 ($FFDE) RDTIM  (63197, $F6DD) read the software clock
65505 ($FFE1) STOP   (via 808 ($328) to 63213, $F6ED) check the STOP key
65508 ($FFE4) GETIN  (via 810 ($32A) to 61758, $F13E) get a character
65511 ($FFE7) CLALL  (via 812 ($32C) to 62255, $F32F) close all files
65514 ($FFEA) UDTIM  (63131, $F69B) update the software clock
65517 ($FFED) SCREEN (58629, $E505) read number of screen rows and columns
65520 ($FFF0) PLOT   (58634, $E50A) read/set position of cursor on screen
65523 ($FFF3) IOBASE (58624, $E500) read base address of I/O devices"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F5-$F6?[/INST]address      $F5-$F6        KEYTAB
Vector: Keyboard Decode Table

KEYTAB points to the address of the keyboard matrix lookup table
currently being used.  Although there are only 64 keys on the keyboard
matrix, each key can be used to print up to four different characters,
depending on whether it is struck by itself or in combination with the
SHIFT, CTRL, or Commodore logo keys.

The tables pointed to y this address hold the ASCII value of each of
the 64 keys for one of these possible combinations of keypresses.
When it comes time to print the character, the table that is used
determines which character is printed.

The addresses of the four tables are:

60289 ($EB81) = default uppercase/graphics characters (unshifted)
60354 ($EBC2) = shifted characters
60419 ($EC03) = Commodore logo key characters
60536 ($EC78) = CTRL characters

The concept of the keyboard matrix tables should not be confused with
changing the character sets from uppercase/graphics to
upper/lowercase.  The former involves determining what character is to
be placed into screen memory, while the latter involves determining
which character data table is to be used to decode the screen memory
into individual dots for the display of characters on the screen.
That character base is determined by location 53272 ($D018) of the
VIC-II chip."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FB97?[/INST]address              $FB97
Reset Counters for Reading or Writing a New Byte of Cassette Data"
"[INST]In the context of the C64, What is the purpose of the memory location at address $FCCA?[/INST]address              $FCCA
Turn Off the Tape Motor"
"[INST]In the context of the C64, What is the purpose of the memory location at address $277-$280?[/INST]address       $277-$280      KEYD
Keyboard Buffer (Queue)

This buffer, sometimes also referred to as the keyboard queue, holds
the ASCII values of the characters entered from the keyboard.  The
interrupt routine which scans the keyboard deposits a character here
each time a key is pressed.  When BASIC sees that there are characters
waiting, it removes and prints them, one by one, in the order in which
they were entered.

This kind of a buffer is known as FIFO, for First In, First Out.  The
buffer will hold up to ten characters, allowing you to type faster
than the computer prints characters, without losing characters.  The
maximum number of characters this buffer can hold at one time is ten
(as determined by the value at 649 ($289)).  Characters entered after
the buffer is full will be ignored.

The commands GET and INPUT retrieve characters from this buffer.  If
one of these is executed while there are already characters waiting in
the buffer, those characters will be fetched as if they were part of
the data being input.  To prevent this from happening, you can clear
the buffer by POKEing a 0 into location 198 ($C6), which holds the
number of characters that are waiting in the buffer.

One of the most interesting and useful techniques for programming
Commodore computers is to have a program simulate direct entry of
commands from the keyboard.  This dynamic keyboard trick is achieved
by first POKEing PETASCII characters, usually cursor movement
characters and carriage returns, into the buffer, and setting location
198 ($C6) to show how many characters are waiting in the buffer.

Next, you clear the screen, and PRINT the statements that you wish to
have executed on the screen, carefully positioning them so that the
first statement to be entered is on the fourth line of the screen.

You then home the cursor and execute an END statement.  This causes
the keyboard buffer to be read, and the carriage returns to be
executed, thus entering the printed lines as if they had been typed in
immediate or direct mode.  The program can be continued by including a
GOTO statement in the last line entered.

Many interesting effects can be achieved using this method.  Examples
of a few of these are included below.  For example, program lines can
be added, modified, or deleted, while the program is running.  The
following example shows how this is done:

10 REM THIS LINE WILL BE DELETED
20 REM A NEW LINE 30 WILL BE CREATED
40 PRINT CHR$(147):PRINT:PRINT
50 PRINT '80 LIST':PRINT'30 REM THIS LINE WASN'T HERE BEFORE'
60 PRINT '10':PRINT 'GOTO 80'CHR$(19)
70 FOR I=631 TO 634:POKE I,13:NEXT:POKE 198,4:END
80 REM THIS LINE WILL BE REPLACED

You can use this technique to enter numbered DATA statements
automatically, using values in memory.  These statements become a
permanent part of the program.

Another interesting application is taking ASCII program lines from a
tape data file, or sequential disk file, and having them entered
automatically.  This can be used for merging programs, or for
transferring programs between computers with a modem and a terminal
program.  To create the ASCII program file, you use CMD to direct a
LISTing to the desired device as follows:

For tape: OPEN 1,1,1,'ASCII':CMD 1:LIST
After the listing has ended: PRINT #1:CLOSE 1

For disk: OPEN 8,8,8,'ASCII,S,W':CMD 8:LIST
After the listing has ended: PRINT #8:CLOSE 8

This file can then be uploaded using a modem and appropriate terminal
software, entered by itself or merged with another program by using
the following program.  Be sure to save this program before you run
it, because it will erase itself when it is done.

60000 OPEN 1,8,8,'ASCII'
60010 POKE 152,1:B=0:GOSUB 60170
60020 GET #1,A$:IF A$=''THEN60020
60030 IF ST AND 64 THEN 60120
60040 IF A$=CHR$(13)AND B=0THEN60020
60050 PRINT A$;:B=1:IF A$=CHR$(34)THEN POKE 212,0
60060 IF A$<>CHR$(13) THEN 60020
60070 PRINT CHR$(5);'GOTO 60010';CHR$(5):PRINT:PRINT:POKE 198,0
60080 PRINT 'RETURN=KEEP LINE    S=SKIP LINE':B=0
60090 GET A$:IF A$=''THEN 60090
60100 IF A$='S' THEN 60010
60110 GOTO 60180
60120 PRINT 'END OF FILE--HIT RETURN TO FINISH MERGE'
60130 IF PEEK(197)<>1THEN60130
60140 A=60000
60150 GOSUB 60170:FOR I=A TO A+60 STEP10:PRINTI:NEXT
60160 PRINT 'A='I':GOTO 60150':GOTO 60180
60170 PRINT CHR$(147):PRINT:PRINT:RETURN
60180 FOR I=631TO640:POKEI,13:NEXT:POKE198,10:PRINTCHR$(19);:END

If you wish to merge additional programs at the same time, when it
indicates that the file has ended, press the STOP key rather than
RETURN, enter the name of the new file in line 60000, and RUN 60000"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B3A6?[/INST]address         $B3A6          ERRDIR
Check If the Program is Running in Direct Mode, and If So Issue an Error

This routine is called by statements that prohibit execution in direct
mode.  It checks a flag that is set when a line without a linenumber
is entered, and causes an ILLEGAL DIRECT error if the flag is set."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B11D?[/INST]address         $B11D          NOTFNS
Create a New BASIC Variable

This routine makes space for a seven-byte descriptor by moving the
variable storage area seven bytes higher in memory, and then creates
the descriptor."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AEF1?[/INST]address         $AEF1          PARCHK
Evaluate Expression Within Parentheses

This routine evaluates an expression within parentheses by calling the
syntax checking routines that look for opening and closing
parentheses, and then calling FRMEVL (4446, $AD9E) for each level of
parentheses."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E505?[/INST]address              $E505          SCREEN
Store Number of Screen Rows and Columns in .Y and .X

This is a documented Kernal routine which is vectored in the jump
table at 65517 ($FFED), and is provided to allow for program
compatibility between computers.

When called, this subroutine returns the number of screen columns in
the .X register, and the number of screen rows in .Y.  Thus, a program
can detect the screen format of the machine on which it is running,
and make sure that text output is formatted accordingly.

The present version of this routine loads the .X register with 40
($28) and the .Y register with 25 ($19)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AA86?[/INST]address        $AA86          CMD
Perform CMD

This routine calls the Kernal CHKOUT routine (62032, $F250), and calls
PRINT to send any included text to the device.  Unlike PRINT# it
leaves the output channel open, so that output continues to go to that
device."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A831?[/INST]address        $A831          END
Perform END

The current line number and text pointers are preserved for a possible
CONT command, and the READY prompt is printed.  If a STOP key break
occured, the BREAK message is printed first."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E4AD?[/INST]address              $E4AD
Patch for BASIC Call of CHKOUT

This patch was made to preserve the .A register if there was no error
returned from BASIC's call of the Kernal CHKOUT routine.  Apparently,
the first version could cause a malfunction of the CMD and PRINT#
commands."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AB1E?[/INST]address         $AB1E          STROUT
Print Message from a String Whose Address Is in the .Y and .A
Registers

This part of the PRINT routine outputs a string whose address is in
the Accumulator (low byte) and .Y register (high byte), and which ends
in a zero byte."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E4EC?[/INST]address              $E4EC
Baud Rate Table for European (PAL) Standard Monitors

This table of prescaler values was added to later Kernal versions to
allow the same Kernal software to be used with either U.S. or European
64s.  It contains the values which are required to obtain interrupts
at the proper frequency for the standard RS-232 baud rates, and
corresponds exactly in format to the table of values for the U.S.
(NTSC) monitor format at 65218 ($FEC2).  Separate tables are required
because the prescaler values are derived from dividing the system
clock rate by the baud rate, and PAL machines operate with a slightly
slower clock frequency."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E453?[/INST]address              $E453
Copy BASIC Vectors to RAM

The cold start routine calls this subroutine to copy the table of
vectors to important BASIC routines to RAM, starting at location 768
($300)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A871?[/INST]address         $A871          RUN
Perform RUN

RUN is executed by calling the Kernal SETMSG (65048, $FE18) routine to
set the message flag for RUN mode and performing a CLR to start the
program.  If a line followed RUN, a GOTO is executed after the CLR."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E394?[/INST]address              $E394
Cold Start BASIC

This initialization routine is executed at the time of power-up.  The
RAM vectors to important BASIC routines are set up starting at 768
($300), the interpreter is initialized, the start-up messages are
printed, and the main loop entered through the end of the warm start
routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B391?[/INST]address         $B391          GIVAYF
Convert 16-Bit Signed Integer to Floating Point

This routine treats the value in the Accumulator as the high byte of a
16-bit signed integer, and the value in the .Y register as the low
byte, and converts the signed integer into a floating point number in
the Floating Point Accumulator.

The address of this routine is pointed to by the RAM vector at 5-6,
and the routine can be used to return an argument from the USR call in
the Floating Point Accumulator."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B08B?[/INST]address         $B08B          PTRGET
Search for a Variable and Set It Up If It Is Not Found

This routine attempts to locate a variable by searching for its name
in the variable area.  If an existing variable of that name cannot be
found, one is created with the NOTFNS routine below."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FBC8?[/INST]address              $FBC8
Write Data to Cassette--Part 2 (IRQ)

This IRQ handler routine is one part of the write data to cassette
routine"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D9-$F2?[/INST]address       $D9-$F2        LDTB1
Screen Line Link Table/Editor Temporary Storage

This table contains 25 entries, one for each row of the screen
display.  Each entry has two functions.  Bits 0-3 indicate on which of
the four pages of screen memory  the first byte of memory for that row
is located.  This is used in calculating the pointer to the starting
address of a screen line at 209 ($D1).

While earlier PETs used one table for the low bytes of screen rows and
another for the high bytes, this is not possible on the 64, where
screen memory is not fixed in any one spot.  Therefore, the Operating
System uses a table of low bytes at 60656 ($ECF0), but calculates the
high byte by adding the value of the starting page of screen memory
held in 648 ($288) to the displacement page held here.

The other function of this table is to establish the makeup of logical
lines on the screen.  While each screen line is only 40 characters
long, BASIC allows the entry of program lines that contain up to 80
characters.  Therefore, some method must be used to determine which
pairs of physical lines are linked into a longer logical line, so that
this longer logical line may be edited as a unit.

The high bit of each byte here is used as a flag by the screen editor.
That bit is set (leaving the value of the byte over 128 ($80)) when a
line is the first or only physical line in a logical line.  The high
bit is reset to 0 only when a line is the second half of a logical
line."
"[INST]In the context of the C64, What is the purpose of the memory location at address $263-$26C?[/INST]address       $263-$26C      FAT
Kernal Table of Device Numbers for Each Logical File"
"[INST]In the context of the C64, What is the purpose of the memory location at address $FCDB?[/INST]address              $FCDB
Advance the Tape Read/Write Pointer

This routine is used to move the pointer to the current read/write
address up a byte."
"[INST]In the context of the C64, What is the purpose of the memory location at address $CC?[/INST]address          $CC            BLNSW
Cursor Blink Enable: 0=Flash Cursor

When this flag is set to a nonzero value, it indicates to the routine
that normally flashes the cursor not to do so.  The cursor blink is
turned off when there are characters in the keyboard buffer, or when
the program is running.

You can use this location to turn the cursor on during a program (for
a series of GET operations, for example, to show the user that input
is expected) by using the statement POKE 204,0."
"[INST]In the context of the C64, What is the purpose of the memory location at address $17-$18?[/INST]address         $17-$18        LASTPT
Pointer to the Address of the Last String in the Temporary String
Stack

This pointer indicates the last slot used in the temporary string
descriptor stack.  Therefore, the value stored at 23 ($17) should be 3
less than that stored at 22 ($16), while 24 ($18) will contain a 0."
"[INST]In the context of the C64, What is the purpose of the memory location at address $3F-$40?[/INST]address         $3F-$40        DATLIN
Current DATA Line Number

This location holds the line number of the current DATA statement
being READ.  It should be noted that this information is not used to
determine where the next DATA item is read from (that is the job of
the pointer at 65-66 ($41-$42) below).  But if an error concerning the
DATA occurs, this number will be moved to 57 ($39), so that the error
message will show that the error occurred in the line that contains
the DATA statement, rather than in the line that contains the READ
statement."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B82D?[/INST]address         $B82D          FUWAIT
Perform WAIT

WAIT gets an address parameter and an integer parameter to use as a
mask.  WAIT then looks for an optional parameter to use as a pattern
for the exclusive OR.  Then, the address location is read, its value
is exclusive ORed with the optional pattern value (or 0 if there is
none).  This value is ANDed with the mask value.  The command loops
continuously until the result is not- zero.

The purpose of this command is to allow the program to watch a
location which can be changed by the system or by outside hardware
(such as the software clock or keycode value locations).

The AND function lets you check if a bit changes from 0 to 1, while
the EOR function allows you to check if a bit changes from 1 to 0.
For more information, see the article 'All About the Wait
Instruction,' by Louis Sander and Doug Ferguson, in COMPUTE!'s First
Book of Commodore 64."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D416?[/INST]address              $D416          CUTHI
Filter Cutoff Frequency (high byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D41C?[/INST]address              $D41C          ENV3
Envelope Generator 3 Output

This register allows you to read the output of the voice 3 Envelope
generator, in much the same way that the preceding register lets you
read the output of Oscillator 3.  This output can also be added to
another oscillator's Frequency Control Registers, Pulse Width
Registers, or the Filter Frequency Control Register.  In order to
produce any output from this register, however, the gate bit in
Control Register 3 must be set to 1.  Just as in the production of
sound, setting the gate bit to 1 starts the attack/decay/sustain
cycle, and setting it back to 0 starts the release cycle.

Location Range: 54301-54303 ($D41D-$D41F)
Not Connected

The SID chip has been provided with enough addresses for 32 different
registers, but as it has only 29, the remaining three addresses are
not used.  Reading them will always return a value of 255 ($FF), and
writing to them will have no effect."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BA28?[/INST]address         $BA28          FMULT
Multiply FAC1 with FAC2

This routine multiplies the contents of FAC1 by the contents of FAC2
and stores the result in FAC1"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD06?[/INST]address              $DD06          TI2BLO
Timer B (low byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD0D?[/INST]address              $DD0D          CI2ICR
Interrupt Control Register

Bit 0:  Read / did Timer A count down to 0?  (1=yes)
        Write/ enable or disable Timer A interrupt (1=enable, 0=disable)
Bit 1:  Read / did Timer B count down to 0?  (1=yes)
        Write/ enable or disable Timer B interrupt (1=enable, 0=disable)
Bit 2:  Read / did Time of Day Clock reach the alarm time?  (1=yes)
        Write/ enable or disable TOD clock alarm interrupt (1=enable,
        0=disable)
Bit 3:  Read / did the serial shift register finish a byte?  (1=yes)
        Write/ enable or disable serial shift register interrupt (1=enable,
        0=disable)
Bit 4:  Read / was a signal sent on the FLAG line?  (1=yes)
        Write/ enable or disable FLAG line interrupt (1=enable, 0=disable)
Bit 5:  Not used
Bit 6:  Not used
Bit 7:  Read / did any CIA #2 source cause an interrupt?  (1=yes)
        Write/ set or clear bits of this register (1=bits written with 1 will
        be set, 0=bits written with 1 will be cleared)

This register is used to control the five interrupt sources on the
6526 CIA chip.  For details on its operation, see the entry for 56333
($DC0D).  The main difference between these two chips pertaining to
this register is that on CIA #2, the FLAG line is connected to Pin B
of the User Port, and thus is available to the user who wishes to take
advantage of its ability to cause interrupts for handshaking purposes.

Location Range: 56590-$56591 ($DD0E-$DD0F)
See locations 56334 and 56334 for details"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E059?[/INST]address              $E059          POLY2
Function Series Evaluation Subroutine 2

This is the main series evaluation routine, which evaluates
expressions by using a table of the various values that must be
operated on in sequence to obtain the proper result."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E08D?[/INST]address              $E08D          RMULC
Multiplicative Constant for RND

A five-byte floating point number which is multiplied by the seed
value as part of the process of obtaining the next value for RND>"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD0E?[/INST]address              $DD0E          CI2CRA
Control Register A

Bit 0:  Start Timer A (1=start, 0=stop)
Bit 1:  Select Timer A output on Port B (1=Timer A output appears on
        Bit 6 of Port B)
Bit 2:  Port B output mode (1=toggle Bit 6, 0=pulse Bit 6 for one
        cycle)
Bit 3:  Timer A run mode (1=one-shot, 0=continuous)
Bit 4:  Force latched value to be loaded to Timer A counter (1=force
        load strobe)
Bit 5:  Timer A input mode (1=count microprocessor cycles, 0=count
        signals on CNT line at pin 4 of User Port)
Bit 6:  Serial Port (56588, $DD0C) mode (1=output, 0=input)
Bit 7:  Time of Day Clock frequency (1=50 Hz required on TOD pin,
        0=60 Hz)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD05?[/INST]address              $DD05          TI2AHI
Timer A (high byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D41B?[/INST]address              $D41B          RANDOM
Read Oscillator 3/Random Number Generator

This register lets you read the upper eight bits of the waveform
output of Oscillator 3.  The kinds of numbers generated by this output
depend on the type of waveform selected.

If the sawtooth waveform is chosen, the output read by this register
will be a series of numbers which start at 0 and increase by 1 to a
maximum of 255, at which time they start over at 0.

When the triangle waveform is chosen, they increase from 0 to 255, at
which time they decrease to 0 again.  The rate at which these numbers
change is determined by the frequency of Oscillator 3.

If the pulse waveform is selected, the output here will be either 255
or 0.

Finally, selecting the noise waveform will produce a random series of
numbers between 0 and 255.  This allows you to use the register as a
random number generator for games.

There are many other uses for reading Oscillator 3, however,
particularly for modulation of the other voices through machine
language software.  For example, the output of this register could be
added to the frequency of another voice.  If the triangle waveform
were selected for this purpose, it would cause the frequency of the
other voice to rise and fall, at the frequency of Oscillator 3
(perhaps for vibrato effects).  This output can also be combined with
the Filter Frequency or Pulse Width Registers to vary the values in
these registers quickly over a short period of time.

Normally, when using Oscillator 3 for modulation, the audio output of
voice 3 should be turned off by setting Bit 7 of the Volume and Filter
Select Register at 54296 ($d418) to 1.  It is not necessary to gate
Bit 0 of Control Register 3 to use the oscillator, however, as its
output is not affected by the ADSR envelope cycle."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B9EA?[/INST]address         $B9EA          LOG
Perform LOG to Base E

The LOG to the base e of the number in FAC1 is performed here, and the
result left in FAC1."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B824?[/INST]address         $B824          POKE
Perform POKE

POKE gets a pointer to the address parameter, and stores the next
parameter there."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D415?[/INST]address              $D415          CUTLO

Bits 0-2:  Low portion of filter cutoff frequency
Bits 5-7:  Unused"
"[INST]In the context of the C64, What is the purpose of the memory location at address $41-$42?[/INST]address         $41-$42        DATPTR
Pointer to the Address of the Current DATA Item

This location points to the address (not the line number) within the
BASIC program text area where DATA is currently being READ.  RESTORE
sets this pointer back to the address indicated by the start of BASIC
pointer at location 43 ($2B).

The sample program below shows how the order in which DATA statements
are READ can be changed using this pointer.  The current address of
the statement before the DATA statement is stored in a variable, and
then used to change this pointer.

10 A1=PEEK(61):A2=PEEK(62)
20 DATA THIS DATA WILL BE USED SECOND
30 B1=PEEK(61):B2=PEEK(62)
40 DATA THIS DATA WILL BE USED FIRST
50 C1=PEEK(61):C2=PEEK(62)
60 DATA THIS DATA WILL BE USED THIRD
70 POKE 65,B1:POKE 66,B2:READ A$:PRINT A$
80 POKE 65,A1:POKE 66,A2:READ A$:PRINT A$
90 POKE 65,C1:POKE 66,C2:READ A$:PRINT A$"
"[INST]In the context of the C64, What is the purpose of the memory location at address $19-$21?[/INST]address        $19-$21        TEMPST
Descriptor Stack for Temporary Strings

The temporary string descriptor stack contains information about
temporary strings which hve not yet been assigned to a string
variable.  An examples of such a temporary string is the literal
string 'HELLO' in the statement PRINT 'HELLO'.

Each three-byte descriptor in this stack contains the length of the
string, and its starting and ending locations, expresses as
displacements within the BASIC storage area."
"[INST]In the context of the C64, What is the purpose of the memory location at address $CB?[/INST]address           $CB            SFDX
Matrix Coordinate of Current Key Pressed

The keyscan interrupt routine uses this location to indicate which key
is currently being pressed.  The value here is then used as an index
into the appropriate keyboard table to determine which character to
print when a key is struck.

The correspondence between the key pressed and the number stored here
is as follows:

0  = INST/DEL                34 = J
1  = RETURN                  35 = 0
2  = CRSR RIGHT              36 = M
3  = F7                      37 = K
4  = F1                      38 = O
5  = F3                      39 = N
6  = F5                      40 = +
7  = CRSR DOWN               41 = P
8  = 3                       42 = L
9  = W                       43 = -
10 = A                       44 = .
11 = 4                       45 = :
12 = Z                       46 = @
13 = S                       47 = ,
14 = E                       48 = LIRA (BRITISH POUND SIGN)
15 = NOT USED                49 = *
  (WOULD BE LEFT SHIFT)      50 = ;
16 = 5                       51 = CLR/HOME
17 = R                       52 = NOT USED
18 = D                         (WOULD BE RIGHT SHIFT)
19 = 6                       53 = =
20 = C                       54 = UP ARROW
21 = F                         (EXPONENTATION SIGN)
22 = T                       55 = /
23 = X                       56 = 1
24 = 7                       57 = LEFT ARROW
25 = Y                       58 = NOT USED
26 = G                         (WOULD BE CTRL)
27 = 8                       59 = 2
28 = B                       60 = SPACE BAR
29 = H                       61 = NOT USED
30 = U                         (WOULD BE COMMODORE LOGO)
31 = V                       62 = Q
32 = 9                       63 = RUN/STOP
33 = I                       64 = NO KEY PRESSED

The RESTORE key is not accounted for, because it is not part of the
normal keyboard matrix.  Instead, it is connected directly to the
microprocessor NMI line, and causes an NMI interrupt whenever it is
pressed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $259-$262?[/INST]address      $259-$262      LAT
Kernal Table of Active Logical File Numbers"
"[INST]In the context of the C64, What is the purpose of the memory location at address $FCD1?[/INST]address              $FCD1
Check the Tape Read/Write Pointer

This routine compares the current tape read/write address with the
ending read/write address."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FBA6?[/INST]address              $FBA6
Toggle the Tape Data Output Line

This routine sets the CIA #1 Timer B, and toggles the Tape Data Output
line on the 6510 on-chip I/O port (Bit 3 of location 1)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D8?[/INST]address          $D8            INSRT
Flag: Insert Mode (Any Number Greater Than 0 Is the Number of Inserts)

When the INST key is pressed, the screen editor shifts the line to the
right, allocates another physical line to the logical line if
necessary (and possible), updates the screen line length in 213 ($D5),
and adjusts the screen line link table at 217 ($D9).  This location is
used to keep track of the number of spaces that has been opened up in
this way.

Until the spaces that have been opened up are filled, the editor acts
as if in quote mode (see location 212 ($D4), the quote mode flag).
This means that cursor control characters that are normally
nonprinting will leave a printed equivalent on the screen when
entered, instead of having their normal effect on cursor movement,
etc.  The only difference between insert and quote mode is that the
DELETE key will leave a printed equivalent in insert mode, while the
INST key will insert spaces as normal."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B113?[/INST]address         $B113
Check If .A Register Holds Alphabetic ASCII Character

This is part of the check for a valid variable name (it must start
with an alphabetic character)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B39E?[/INST]address         $B39E          POS
Perform POS

The POS command calls the Kernal PLOT routine (58634, $E50A) to get
the position of the cursor on the logical line.  What it really does
is an equivalent of PEEK(211).  Remember, since we are dealing with a
logical line, this number can be over 39.  The statement 'THIS
SENTENCE IS LONGER THAN ONE PHYSICAL LINE';POS(X) will return a value
of 48 for the POS(X)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E38B?[/INST]address              $E38B
Error Message Handler

This routine to print error messages is pointed to by the vector at
768 ($300).  Using the .X register as an index, it either prints an
error message from the table at 41363 ($A193) or the READY prompt, and
continues through the vector at 770 ($302) to the main BASIC loop."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E447?[/INST]address              $E447
Table of Vectors to Important BASIC Routines

This table contains the vectors which point to the addresses of some
important BASIC routines.  The contents of this table are moved to the
RAM table at 768 ($300)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A857?[/INST]address         $A857          CONT
Perform CONT

The CONT statement is performed by moving the saved pointers back to
the current statement and current text character pointers.  If the
saved pointers cannot be retrieved, the CAN'T CONTINUE error statement
is printed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AAA0?[/INST]address         $AAA0          PRINT
Perform PRINT

The PRINT routine has many segments, which are required for the
various options which can be added to it:  TAB, SPC, comman,
semicolon, variables, PI, ST, TI, and TI$.  Eventually, all output is
converted to strings, and the Kernal CHROUT routine is called to print
each character."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E4E0?[/INST]address              $E4E0
Pause after Finding a File on Cassette

This routine is a patch to the routine which finds a file on cassette.
After the file is found, the message FILETITLE FOUND appears on the
screen.  On the original versions of the Kernal, the user would then
have to hit the Commodore key to continue the load.  On the newer
versions, this patch causes a slight pause after the tape file is
round, during which time a keypress is looked for.  If a key is
pressed, the loading process continues immediately.  If it is not, the
load continues by itself after the end of the pause."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E264?[/INST]address              $E264          COS
Perform COS

COS is executed by adding PI/2 to the contents of FAC1 and dropping
through to SIN."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E50A?[/INST]address              $E50A          PLOT
Read/Set Location of the Cursor

The jump table entry for this documented Kernal is at 65520 ($FFF0).

The routine allows the user to read or set the position of the cursor.
If the carry flag is set with the SEC instruction before calling this
subroutine, cursor column (X position) will be returned in the .X
register, and the cursor row (Y position) will be returned in the .Y
register.  If the carry flag is cleared with a CLC instruction before
entering this routine, and the .Y and .X registers are loaded with the
desired row and column positions respectively, this routine will set
the cursor position accordingly.

The current read routine loads .X and .Y from locations 214 ($D6) and
211 ($D3) respectively.  The cursor set routine stores .X and .Y in
these locations, and calls the routine that sets the screen pointers
at 58732 ($E56C).

The user can access this routine from BASIC by loading the .X, .Y, and
.P register values desired to the save area starting at 780 ($30C)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A96B?[/INST]address         $A96B          LINGET
Convert an ASCII Decimal Number to a Two-Byte Binary Line Nmumber

This subroutine is used by several statements to read a decimal
number, convert it to a two-byte integer line number (in low-byte,
high-byte format), and check that it is in the correct range of
0-63999."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A8D2?[/INST]address         $A8D2          RETURN
Perform RETURN

The RETURN statement finds the saved GOSUB data on the stack, and uses
it to restore the pointers to the current line and current character.
This will cause execution to continue where it left off when GOSUB was
executed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E3A2?[/INST]address              $E3A2          INITAT
Text of the CHRGET Routine Which Runs at 115 ($73)

The text of the CHRGET routine is stored here, and moved to Page 0 by
the BASIC initialization routine.  When creating a wedge in CHRGET, it
is possible to execute all or part of this code in place of the RAM
version."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B248?[/INST]address         $B248          FCERR
Print ILLEGAL QUANTITY Error Message"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B1A5?[/INST]address         $B1A5          N32768
The Constant -32768 in Five-Byte Floating Point Format

This constant is used for range checking in the conversion of a
floating point number to a signed integer (the minimum inter value is
-32768)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D6?[/INST]address           $D6            TBLX
Current Cursor Physical Line Number

This location contains the current physical screen line position of
the cursor (0-24).  It can be used in a fashion to move the cursor
vertically, by POKEing the target screen line (1-25) minus 1 here,
followed by a PRINT command.  For example,

POKE 214,9:PRINT:PRINT 'WE'RE ON LINE ELEVEN'

prints the message on line 11.  The first PRINT statement allows the
system to update the other screen editor variables so that they will
also show the new line.  The cursor can also be set or read using the
Kernal PLOT routine (58634, $E50A) as explained in the entry from
locations 780-783 ($30C-$30F)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F7-$F8?[/INST]address       $F7-$F8        RIBUF
Pointer: RS-232 Input Buffer

When device number 2 (the RS-232 channel) is opened, two buffers of
256 bytes each are created at the top of memory.  This location points
to the address of the one which is used to store characters as they
are received.  A BASIC program should always OPEN device 2 before
assigning any variables to avoid the consequences of overwriting
variables which were previously located at the top of memory, as BASIC
executes a CLR after opening this device."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F92C?[/INST]address             $F92C
Read Tape Data (IRQ)

This is the IRQ handler routine that is used for reading data from the
cassette.  At the end of the read, the IRQ vector is restored to the
normal IRQ routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FD10?[/INST]address              $FD10
Text for Autostart Cartridge Check

The characters stored here must be the fifth through the ninth
characters in the cartridge in order for it to be started on power-up.
These characters are the PETASCII values for CBM, each with the high
bit set (+128), and the characters '80'."
"[INST]In the context of the C64, What is the purpose of the memory location at address $100-$13E?[/INST]address       $100-$13E      BAD
Tape Input Error Log

Each tape block is saved twice consecutively, in order to minimize
loss of data from transmission errors.  These 62 bytes serve as
indices of which bytes in the tape block were not received corectly
during the first transmission, so that corrections might be made on
the second pass."
"[INST]In the context of the C64, What is the purpose of the memory location at address $2D-$2E?[/INST]address         $2D-$2E        VARTAB
Pointer to the Start of the BASIC Variable Storage Area

This location points to the address which marks the end of the BASIC
program text area, and the beginning of the variable storage area.
All nonarray variables are stored here, as are string descriptors (for
the address of the area where the actual text of strings is stored,
see location 51 ($33)).

Seven bytes of memory are allocated for each variable.  The first two
bytes are used for the variable name, which consists of the ASCII
value of the first two letters of the variable name.  If the variable
name is a single letter, the second byte will contain a zero.

The seventh bit of one or both of these bytes can be set (which would
add 128 to the ASCII value of the letter).  This indicates the
variable type.  If neither byte has the seventh bit set, the variable
is the regular floating point type.  If only the first byte has its
seventh bit set, the variable is a string.  If only the second byte
has its seventh bit set, the variable is a defined function (FN).  If
both bytes have the seventh bit set, the variable is an integer.

The use of the other five bytes depends on the type of variable.  A
floating point variable will use the five bytes to store the value of
the variable in floating point format.  An integer will have its value
stored in the third and fourth bytes, high byte first, and the other
three will be unused.

A string variable will use the third byte for its length, and the
fourth and fifth bytes for a pointer to the address of the string
text, leaving the last two bytes unused.  Note that the acrual string
text that is pointed to is located either in the part of the BASIC
program where the string is first assigned a value, or in the string
text storage area pointed to by location 51 ($33).

A function definition will use the third and fourth bytes for a
pointer to the address in the BASIC program text where the function
definition starts.  It uses the fifth and sixth bytes for a pointer to
the dependent variable (the X of FN A(X)).  The final byte is not
used.

Knowing something about how variables are created can help your BASIC
programming.  For example, you can see that nonarray integer variables
take up no less space than floating point variables, and since most
BASIC commands convert the integers to floating point, they do not
offer a speed advantage either, and in many cases will actually slow
the program down.  As will be seen below, however, integer arrays can
save a considerable amount of space.

Variables are stored in the order in which they are created.
Likewise, when BASIC goes looking for a variable, it starts its search
at the beginning of this area.  If commonly used variables are defined
at the end of the program, and are thus at the back of this area, it
will take longer to find them.  It may help program execution speed to
define the variables that will be used most frequently right at the
beginning of the program.

Also, remember that once created, variables do not go away during
program execution.  Even if they are never used again, they still take
up space in the variable storage area, and they slow down the routine
that is used to search for variables that are referenced.

Another point to consider about the order in which to define variables
is that arrays are created in a separate area of memory which starts
at the end of the nonarray variable area.  Therefore, every time a
nonarray variable is created, all of the arrays must be moved seven
bytes higher in memory in order to make room for the new variable.
Therefore, it may help performance to avoid defining nonarray
variables after defining arrays.

This pointer will be reset to one byte past the end of the BASIC
program text whenever you execute the statements CLR, NEW, RUN, or
LOAD.  Adding or modifying a BASIC statement will have the same
effect, because the higher numbered BASIC statements have to be moved
up into memory to make room for the new statements, and can therefore
overwrite the variable storage area.  This means that if you wish to
check the value of a variable after stopping a program, you can only
do so before modifying the program.

The exception to the above is when the LOAD command is issued from a
program.  The purpose of not resetting this pointer in such a case is
to allow the chaining of programs by having one program load and then
run the next (that is also why a LOAD issued from a program causes a
RUN from the beginning of the program).  This allows the second
program to share variables with the first.  There are problems with
this, however.  Some string variable descriptors and function
definitions have their pointers set to areas within the program text.
When this text is replaced by a load, these pointers are no longer
valid, which will lead to errors if the FN or string value is
referenced.  And if the second program text area is larger than that
of the first, the second program will overwrite some of the first
program's variables, and their values will be lost.

The ability to chain short programs is a holdover from the days of the
8K PET, for which this BASIC was written, but with the vastly
increased memory of the 64, program chaining should not be necessary.

You should also note that SAVE uses this pointer as the address of the
byte after the last byte to SAVE."
"[INST]In the context of the C64, What is the purpose of the memory location at address $39-$3A?[/INST]address         $39-$3A        CURLIN
Current BASIC Line Number

This location contains the line number of the BASIC statement which is
currently being executed, in LSB/MSB format.  A value of 255 ($FF) in
location 58 ($3A), which translates to a line number of 65280 or above
(well over the 63999 limit for a program line), means that BASIC is
currently in immediate mode, rather than RUN mode.

BASIC keywords that are illegal in direct mode check 58 ($3A) to
determine whether or not this is the current mode.

When in RUN mode, this location is updated as each new BASIC line is
fetched for execution.  Therefore, a TRACE function could be added by
diverting the vector at 776 ($308), which points to the routine that
executes the next token, to a user-written routine which prints the
line number indicated by this location before jumping to the token
execution routine.  (LISTing the line itself would be somewhat harder,
because LIST uses many Page 0 locations that would have to be
preserved and restored afterwards.)

This line number is used by BREAK and error messages to show where
program execution stopped.  The value here is copied to 59 ($3B) by
STOP, END, and the stop-key BREAK, and copied back by CONT."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FFFA?[/INST]address              $FFFA
Non-Maskable Interrupt Hardware Vector

This vector points to the main NMI routine at 65091 ($FE43)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $14-$15?[/INST]address         $14-$15        LINNUM
Integer Line Number Value

The target line number for GOTO, LIST, ON, and GOSUB is stored here in
low- byte, high-byte integer format, as is the number of a BASIC line
that is to be added or replaced.

LIST saves the highest line number to list (or 65535 ($FFFF) if
program is to be listed to the end) at this location.

GOTO tests the target line number to see if it is greater than the
line number currently being executed.  If it is greater, GOTO starts
its search for the target line at the current line number.  If it is
not greater, GOTO must search for the target line from the first line
of the program.  It is interesting to note that the test is of the
most significant byte only.  Therefore, INT(TARGETLINE/256) must be
greater than INT(CURRENTLINE/256) in order for the search to start
with the current line, instead of at the beginning of the program.

PEEK, POKE, WAIT, and SYS use this location as a pointer to the
address which is the subject of the command.

22            $16            TEMPPT
Pointer to the Next Available Space in the Temporary String Stack

This location points to the next available slot in the temporary
string descriptor stack located at 25-33 ($19-$21).  Since that stack
has room for three descriptors of three bytes each, this location will
point to 25 ($19) if the stack is empty, to 28 ($1C) if there is one
entry, to 31 ($1F) if there are two entries, and to 34 ($22) if the
stack is full.

If BASIC needs to add an entry to the temporary string descriptor
stack, and this location holds a 34, indicating that the stack is
full, the FORMULA TOO COMPLEX error message is issued.  Otherwise, the
entry is added, and three is added to this pointer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC0C?[/INST]address              $DC0C          CIASDR
Serial Data Port

The CIA chip has an on-chip serial port, which allows you to send or
receive a byte of data one bit at a time, with the most significant
bit (Bit 7) being transferred first.  Control Register A at 56334
($DC0E) allows you to choose input or output modes.  In input mode, a
bit of data is read from the SP line (pin 5 of the User Port) whenever
a signal on the CNT line (pin 4) appears to let you know that it is
time for a read.  After eight bits are received this way, the data is
placed in the Serial Port Register, and an interrupt is generated to
let you know that the register should be read.

In output mode, you write data to the Serial Port Register, and it is
sent out over the SP line (pin 5 of the User Port), using Timer A for
the baud rate generator.  Whenever a byte of data is written to this
register, transmission will start as long as Timer A is running and in
continuous mode.  Data is sent at half the Timer A rage, and an output
will appear on the CNT line (pin 4 of the User Port) whenever a bit is
sent.  After all eight bits have been sent, an interrupt is generated
to indicate that it is time to load the next byte to send into the
Serial Register.

The Serial Data Register is not used by the 64, which does all of its
serial I/O through the regular data ports."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D411?[/INST]address              $D411          PWHI3
Voice 3 Pulse Waveform Width (high nybble)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B853?[/INST]address         $B853          FSUBT
BASIC's Subtraction Operation

This routine subtracts the contents of FAC2 from FAC1 by complementing
its sign and adding."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B97E?[/INST]address         $B97E          OVERR
Print Overflow Error Message"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC00-$DC0F?[/INST]address        $DC00-$DC0F
Complex Interface Adapter (CIA) #1 Registers

Locations 56320-56335 ($DC00-$DC0F) are used to communicate with the
Complex Interface Adapter chip #1 (CIA #1).  This chip is a successor
to the earlier VIA and PIA devices used on the VIC-20 and PET.  This
chip functions the same way as the VIA and PIA:  It allows the 6510
microprocessor to communicate with peripheral input and output
devices.  The specific devices that CIA #1 reads data from and sends
data to are the joystick controllers, the paddle fire buttons, and the
keyboard.

In addition to its two data ports, CIA #1 has two timers, each of
which can count an interval from a millionth of a second to a
fifteenth of a second.  Or the timers can be hooked together to count
much longer intervals.  CIA #1 has an interrupt line which is
connected to the 6510 IRQ line.  These two timers can be used to
generate interrupts at specified intervals (such as the 1/60 second
interrupt used for keyboard scanning, or the more complexly timed
interrupts that drive the tape read and write routines).  As you will
see below, the CIA chip has a host of other features to aid in
Input/Output functions."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD0A?[/INST]address              $DD0A          TO2MIN
Time of Day Clock Minutes

Bits 0-3:  Second digit of Time of Day minutes (BCD)
Bits 4-6:  First digit of Time of Day minutes (BCD)
Bit 7:  Unused"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E12A?[/INST]address              $E12A          SYS
Perform SYS

Before executing the machine language subroutine (JSR) at the address
indicated, the .A, .X, .Y, and .P registers are loaded from the
storage area at 780-783 ($30C-$30F).  After the return from subroutine
(RTS), the new values of those registers are stored back at 780-783
($30C-$30F)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E0F9?[/INST]address              $E0F9
Call Kernal I/O Routines

This section is used when BASIC wants to call the Kernal I/O routines
CHROUT, CHRIN, CHKOUT, CHKIN, and GETIN.  It handles any errors that
result from the call, and creates a 512-byte buffer space at the top
of BASIC and executes a CLR if the RS-232 device is opened."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD09?[/INST]address              $DD09          TO2SEC
Time of Day Clock Seconds

Bits 0-3:  Second digit of Time of Day seconds (BCD)
Bits 4-6:  First digit of Time of Day seconds (BCD)
Bit 7:  Unused"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B983?[/INST]address         $B983          MULSHF
SHIFT Routine"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC00-$DC01?[/INST]address      ($DC00-$DC01)
CIA #1 Data Ports A and B

These registers are where the actual communication with outside
devices takes place.  Bits of data written to these registers can be
sent to external devices, while bits of data that those devices send
can be read here.

The keyboard is so necessary to the computer's operation that you may
have a hard time thinking of it as a peripheral device.  Nonetheless,
it cannot be directly read by the 6510 microprocessor.  Instead, the
keys are connected in a matrix of eight rows by eight columns to CIA
#1 Ports A and B.  The layout of this matrix is shown below.

WRITE TO PORT A               READ PORT B (56321, $DC01)
56320/$DC00
         Bit 7   Bit 6   Bit 5   Bit 4   Bit 3   Bit 2   Bit 1   Bit 0

Bit 7    STOP    Q       C=      SPACE   2       CTRL    <-      1

Bit 6    /       ^       =       RSHIFT  HOME    ;       *       LIRA

Bit 5    ,       @       :       .       -       L       P       +

Bit 4    N       O       K       M       0       J       I       9

Bit 3    V       U       H       B       8       G       Y       7

Bit 2    X       T       F       C       6       D       R       5

Bit 1    LSHIFT  E       S       Z       4       A       W       3

Bit 0    CRSR DN F5      F3      F1      F7      CRSR RT RETURN  DELETE

As you can see, there are two keys which do not appear in the matrix.
The SHIFT LOCK key is not read as a separate key, but rather is a
mechanical device which holds the left SHIFT key switch in a closed
position.  The RESTORE key is not read like the other keys either.  It
is directly connected to the NMI interrupt line of the 6510
microprocessor, and causes an NMI interrupt to occur whenever it is
pressed (not just when it is pressed with the STOP key).

In order to read the individual keys in the matrix, you must first set
Port A for all outputs (255, $FF), and Port B for all inputs (0),
using the Data Direction Registers.  Note that this is the default
condition.  Next, you must write a 0 in the bit of Data Port A that
corresponds to the column that you wish to read, and a 1 to the bits
that correspond to columns you wish to ignore.  You will then be able
to read Data Port B to see which keys in that column are being pushed.

A 0 in any bit position signifies that the key in the corresponding
row of the selected column is being pressed, while a 1 indicates that
the key is not being pressed.  A value of 255 ($FF) means that no keys
in that column are being pressed.

Fortunately for us all, an interrupt routine causes the keyboard to be
read, and the results are made available to the Operating System
automatically every 1/60 second.  And even when the normal interrupt
routine cannot be used, you can use the Kernal SCNKEY routine at 65439
($FF9F) to read the keyboard.

These same data ports are also used to read the joystick controllers.
Although common sense might lead you to believe that you could read
the joystick that is plugged into the port marked Controller Port 1
from Data Port A, and the second joystick from Data Port B, there is
nothing common about the Commodore 64.  Controller Port 1 is read from
Data Port B, and Controller Port 2 is read from CIA #1 Data Port A.

Joysticks consist of five switches, one each for up, down, right, and
left directions, and another for the fire button.  The switches are
read like the key switches--if the switch is pressed, the
corresponding bit will read 0, and if it is not pressed, the bit will
be set to 1.  From BASIC, you can PEEK the ports and use the AND and
NOT operators to mask the unused bits and inverse the logic for easier
comprehension.  For example, to read the joystick in Controller Port
1, you could use the statement:

S1=NOT PEEK(56321)AND15

The meaning of the possible numbers returned are:

 0 = none pressed
 1 = up
 2 = down
 4 = left
 5 = up left
 6 = down left
 8 = right
 9 = up right
10 = down right

The same technique can be used for joystick 2, by substituting 56320
as the number to PEEK.  By the way, the 3 and 7 aren't listed because
they represent impossible combinations like up-down.

To read the fire buttons, you can PEEK the appropriate port and use
the AND operator to mask all but bit 4:

T1=(PEEK(56321)AND16)/16

The above will return a 0 if the button is pressed, and a 1 if it is
not.  Substitute location 56320 as the location to PEEK for Trigger
Button 2.

Since CIA #1 Data Port B is used for reading the keyboard as well as
joystick 1, some confusion can result.  The routine that checks the
keyboard has no way of telling whether a particular bit was set to 0
by a keypress or one of the joystick switches.  For example, if you
plug the joystick into Controller Port 1 and push the stick to the
right, the routine will interpret this as the 2 key being pressed,
because both set the same bit to 0.  Likewise, when you read the
joystick, it will register as being pushed to the right if the 2 key
is being pressed.

The problem of mistaking the keyboard for the joystick can be solved
by turning off the keyscan momentarily when reading the stick with a
POKE 56333, 127:POKE 56320,255, and restoring it after the read with a
POKE 56333,129.  Sometimes you can use the simpler solution of
clearing the keyboard buffer after reading the joystick, with a POKE
198,0.

The problem of mistaking the joystick for a keypress is much more
difficult--there is no real way to turn off the joystick.  Many
commercially available games just use Controller Port 2 to avoid the
conflict.  So, if you can't beat them, sit back and press your
joystick to the left in order to slow down a program listing (the
keyscan routine thinks that it is the CTRL key).

As if all of the above were not enough, Port A is also used to control
which set of paddles is read by the SID chip, and to read the paddle
fire buttons.  Since there are two paddles per joystick Controller
Port, and only two SID registers for reading paddle positions, there
has to be a method for switching the paddle read from joystick Port 1
to joystick Port 2.

When Bit 7 of Port A is set to 1 and Bit 6 is cleared to 0, the SID
registers will read the paddles on Port 1.  When Bit 7 is set to 0 and
Bit 6 is set to 1, the paddles on Port 2 are read by the SID chip
registers.  Note that this also conflicts with the keyscan routine,
which is constantly writing different values to CIA #1 Data Port A in
order to select the keyboard column to read (most of the time, the
value for the last column is written to this port, which coincides
with the selection of paddles on joystick Port 1).  Therefore, in
order to get an accurate reading, you must turn off the keyscan IRQ
and select which joystick port you want to read.  See POTX at 54297
($D419), which is the SID register where the paddles are read, for the
exact technique.

Although the SID chip is used to read the paddle settings, the fire
buttons are read at CIA #1 Data Ports A and B.  The fire buttons for
the paddles plugged into Controller Port 1 are read at Data Port B
(56321, $DC01), while those for the paddles plugged into Controller
Port 2 are read from Data Port A (56320, $DC00).  The fire buttons are
read at Bit 2 and Bit 3 of each port (the same as the joystick left
and joystick right switches), and as usual, the bit will read 0 if the
corresponding button is pushed, and 1 if it is not.

Although only two of the rout paddle values can be read at any one
time, you can always read all four paddle buttons.  See the game
paddle input description at 54297 ($D419) for the BASIC statements
used to read these buttons.

Finally, Data Port B can also be used as an output by either Timer A
or B.  It is possible to set a mode in which the timers do not cause
an interrupt when they run down (see the descriptions of Control
Registers A and B at 56334-5 ($DC0E-F)).  Instead, they cause the
output on Bit 6 or 7 of Data Port B to change.  Timer A can be set
either to pulse the output of Bit 6 for one machine cycle, or to
toggle that bit from 1 to 0 or 0 to 1.  Timer B can use Bit 7 of this
register for the same purpose."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D412?[/INST]address              $D412          VCREG3
Voice 3 Control Register

Bit 0:  Gate Bit:  1=Start attack/decay/sustain, 0=Start release
Bit 1:  Sync Bit:  1=Synchronize oscillator with Oscillator 2 frequency
Bit 2:  Ring Modulation:  1=Ring modulate Oscillators 3 and 2
Bit 3:  Test Bit:  1=Disable Oscillator 3
Bit 4:  Select triangle waveform
Bit 5:  Select sawtooth waveform
Bit 6:  Select pulse waveform
Bit 7:  Select noise waveform"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B867?[/INST]address         $B867          FADD
Add FAC1 to a Number in Memory

This routine is used to add the contents of the Floating Point
Accumulator (FAC1) to a number in memory, by moving that number into
FAC2, and falling through to the next routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC0D?[/INST]address              $DC0D          CIAICR
Interrupt Control Register

Bit 0:  Read / did Timer A count down to 0?  (1=yes)
        Write/ enable or disable Timer A interrupt (1=enable, 0=disable)
Bit 1:  Read / did Timer B count down to 0?  (1=yes)
        Write/ enable or disable Timer B interrupt (1=enable, 0=disable)
Bit 2:  Read / did Time of Day Clock reach the alarm time?  (1=yes)
        Write/ enable or disable TOD clock alarm interrupt (1=enable,
        0=disable)
Bit 3:  Read / did the serial shift register finish a byte? (1=yes)
        Write/ enable or disable serial shift register interrupt (1=enable,
        0=disable)
Bit 4:  Read / was a signal sent on the flag line?  (1=yes)
        Write/ enable or disable FLAG line interrupt (1=enable, 0=disable)
Bit 5:  Not used
Bit 6:  Not used
Bit 7:  Read / did any CIA #1 source cause an interrupt?  (1=yes)
        Write/ set or clear bits of this register (1=bits written with 1 will
        be set, 0=bits written with 1 will be cleared)

This register is used to control the five interrupt sources on the
6526 CIA chip.  These sources are Timer A, Timer B, the Time of Day
Clock, the Serial Register, and the FLAG line.  Timers A and B cause
an interrupt when they count down to 0.  The Time of Day Clock
generates an interrupt when it reaches the ALARM time.  The Serial
Shift Register interrupts when it compiles eight bits of input or
output.  An external signal pulling the CIA hardware line called FLAG
low will also cause an interrupt (on CIA #1, this FLAG line is
connected to the Cassette Read line of the Cassette Port).

Even if the condition for a particular interrupt is satisfied, the
interrupt must still be enabled for an IRQ actually to occur.  This is
done by writing to the Interrupt Control Register.  What happens when
you write to this register depends on the way that you set Bit 7.  If
you set it to 0, any other bit that was written to with a 1 will be
cleared, and the corresponding interrupt will be disabled.  If you set
Bit 7 to 1, any bit written to with a 1 will be set, and the
corresponding interrupt will be enabled.  In either case, the
interrupt enable flags for those bits written to with a 0 will not be
affected.

For example, in order to disable all interrupts from BASIC, you could
POKE 56333, 127.  This sets Bit 7 to 0, which clears all of the other
bits, since they are all written with 1's.  Don't try this from BASIC
immediate mode, as it will turn off Timer A which causes the IRQ for
reading the keyboard, so that it will in effect turn off the keyboard.

To turn on the Timer A interrupt, a program could POKE 56333,129.  Bit
7 is set to 1 and so is Bit 0, so the interrupt which corresponds to
Bit 0 (Timer A) is enabled.

When you read this register, you can tell if any of the conditions for
a CIA Interrupt were satisfied because the corresponding bit will be
set to a 1.  For example, if Timer A counts down to 0, Bit 0 of this
register will be set to 1.  If, in addition, the mask bit that
corresponds to that interrupt source is set to 1, and an interrupt
occurs, Bit 7 will also be set.  This allows a multi-interrupt system
to read one bit and see if the source of a particular interrupt was
CIA #1.  You should note, however, that reading this register clears
it, so you should preserve its contents in RAM if you want to test
more than one bit."
"[INST]In the context of the C64, What is the purpose of the memory location at address $13?[/INST]address            $13            CHANNL
Current I/O Channel (CMD Logical File) Number

Whenever BASIC inputs or outputs data, it looks here to determine
which I/O device is currently active for the purpose of prompting or
output control.  It uses location 184 ($B8) for purposes of deciding
what device actually to put input from or output to.

When the default input device (number 0, the keyboard) or output
device (number 3, the display screen) is used, the value here will be
a zero, and the format of prompting and output will be the standard
screen output format.

When another device is used, the logical file number (CMD channel
number) will be placed here.  This lets the system now that it may
have to make some subtle changes in the way it performs the I/O
operation.  For example, if TAB is used with the PRINT command, cursor
right characters are used if the device PRINTed to is the screen.
Otherwise, spaces are output when the number here is other than zero
(the assumption being that you can't tab a printer like you can the
screen).

Likewise, the ? prompt for INPUT is suppressed if the file number here
is nonzero, as is the EXTRA IGNORED message, and input of a carriage
return by itself is ignored, rather than being treated as a null
string ('').  Therefore, by OPENing the screen as a device, and
issuing the CMD statement, you can force the suppression of the ?
prompt, and the other effects above.

CMD places the new output file number here, and calls the Kernal to
open the device for output, leaving it LISTENing for output (such as
the READY prompt, which is diverted to the new device).

Many routines reset this location and UNLISTEN the device, defeating
the CMD and once again sending the output to the screen.  If an error
message has to be displayed, for example, this location will be reset
and the message will be displayed on the screen.  GET, GET#, INPUT,
INPUT#, and PRINT# all will reset this location after the I/O is
completed, effectively redirecting output back to the screen.  PRINT
and LIST are the only I/O operations that will not undo the CMD.

This location can also be used to fool BASIC into thinking that data
it is reading from the tape is actually being entered into the
keyboard in immediate mode.

For a look at a technique that uses a different approach to accomplish
the same thing for disk or tape users, see location 512 ($200), the
keyboard buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address 65530-65535 ($FFFA-$FFFF)?[/INST]address      65530-65535 ($FFFA-$FFFF)
6510 Hardware Vectors

The last six locations in memory are reserved by the 6510 processor
chip for three fixed vectors.  These vectors let the chip know at what
address to start executing machine language program code when an NMI
interrupt occurs, when the computer is turned on, or when an IRQ
interrupt or BRK occurs."
"[INST]In the context of the C64, What is the purpose of the memory location at address $37-$38?[/INST]address         $37-$38        MEMSIZ
Pointer to the Highest Address Used by BASIC

The power-on/reset routine tests each byte of RAM until it comes to
the BASIC ROM, and sets this pointer to the adress of the highest byte
of consecutive RAM found (40959, $9FFF).

There are two circumstances under which this pointer may be changed
after power-up to reflect an address lower than the actual top of
consecutive RAM:

1.  Users may wish to lower this pointer themselves, in order to set
aside an area of free RAM that will not be disturbed by BASIC.  For
example, to set aside a 1K area at the top of BASIC, start your
program with the line:

POKE 56,PEEK(56)-4:CLR

The CLR is necessary to insure that the string text will start below
your safe area.

You may wish to store machine language programs, sprites, or alternate
character sets in such an area.  For the latter two applications,
however, keep in mind the 16K addressing range limitation of the
VIC-II chip.  If you do not assign the VIC-II to a bank other than the
default memory bank of 0-16383 ($0-$3FFF), you must lower the top of
memory below 16383 ($3FFF) if you wish your sprite or character data
area to be within its addressing range.

2.  Then the RS-232 device (number 2) is opened, this pointer and the
pointer to the end of user RAM at 643 are lowered by 512 bytes in
order to create two 256-byte buffers, one for input and the other for
output.

Since the contents of these buffers will overwrite any variables at
the top of memory, a CLR command is issued at the time device 2 is
opened.  Therefore, the RS-232 device should be opened before defining
any variables, and before setting aside a safe area for machine
language programs or other uses, as described above.

5"
"[INST]In the context of the C64, What is the purpose of the memory location at address $2B-$2C?[/INST]address         $2B-$2C        TXTTAB
Pointer to the Start of BASIC Program Text

This two-byte pointer lets BASIC know where program text is stored.
Ordinarily, such text is located beginning at 2049 ($801).  Using this
pointer, it is possible to change the program text area.  Typical
reasons for doing this include:

1.  Conforming the memory configuration to that of other Commodore
computers.  On 32K PET and CBM computers, for example, screen memory
starts at 32768 ($8000), and BASIC text begins at 1025 ($401).  You
can emulate this configuration with the 64 with the following short
program:

10 POKE 55,0:POKE 56,128: CLR: REM LOWER TOP OF MEMORY TO 32768
20 POKE 56576,PEEK(56576) AND 253: REM ENABLE BANK 2
30 POKE 53272,4: REM TEXT DISPLAY MEMORY NOW STARTS AT 32768
40 POKE 648,128:REM OPERATING SYSTEM PRINTS TO SCREEN AT 32768 (128*256)
50 POKE 44,4:POKE 1024,0: REM MOVE START OF BASIC TO 1025 (4*256+1)
60 POKE 792,193: REM DISABLE RESTORE KEY
70 PRINT CHR$(147);'NOW CONFIGURED LIKE PET':NEW
80 REM ALSO SEE ENTRIES FOR LOCATION 55, 56576, AND 648

Such reconfiguring can be helpful in transferring programs from the 64
to the PET, or vice versa.  Since the 64 automatically relocates BASIC
program text, it can load and list PET programs even though the
program file indicates a loading addresss that is different from the
64 start of BASIC.  The PET does not have this automatic relocation
feature, however, and it loads all BASIC programs at the two-byte
address indicated at the beginning of the disk or tape file.

So if the PET loads a 64 program at its normal starting address of
2049 ($801), it will not recognize its presence because it expects a
BASIC program to start at 1025 ($401).  Therefore, if you want to let
a PET and 64 share a program, you must either reconfigure the 64 to
start BASIC where the PET does, or reconfigure the PET to start BASIC
where the 64 does (with a POKE 41,8:POKE 2048,0).

2.  Raising the lowest location used for BASIC text in order to create
a safe area in low memory.  For example, if you wish to use the
high-resolution graphics mode, you may want to put the start of screen
memory at 8192 ($2000).  The high-resolution moe requires 8K of
memory, and you cannot use the lowest 8K for this purpose because it
is already being used for the zero-page assignments.

Since BASIC program text normally starts at 2048 ($801), this means
that you only have 6k for program text before your program runs over
into screen memory.  One way around this is by moving the start of
basic to 16385 ($4001) by typing in direct entry mode:

POKE 44,64: POKE 64*256,0:NEW

Other uses might include setting aside a storage area for sprite shape
data, or user-defined character sets.

3.  Keeping two or more programs in memory simultaneously.  By
changing this pointer, you can keep more than one BASIC program in
memory at one time, and switch back and forth betwenn them.  Examples
of this application can be found in COMPUTE!'s First Book of PET/CBM,
pages 66 and 163.

This technique has a number of offshoots that are perhaps of more
practical use.

a) You can store two programs in memory simultaneously for the purpose
of appending one to the other.  This technique requires that the line
numbers of the two programs do not overlap.  (See Programming the
PET/CBM by Raeto Collin West, pages 41-42, for a discussion of this
technique).

b) You can have two programs in memory at once and use the concept in
(2) above to allow an easier way to create a safe area in low memory.
The first program is just onw line that sets the start of BASIC
pointer to the address of the second program which is located higher
in memory, and then runs that second program.

4. Since this address is used as the address of the first byte to
SAVE, you can save any section of memory by changing this pointer to
indicate the starting address, and the pointer 45-46 ($2D-$2D) to
indicate the address of the byte after the last byte that you wish to
save."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FD15?[/INST]address              $FD15          RESTOR
Restore RAM Vectors for Default I/O Routines

This documented Kernal routine can be entered through the jump table
at 65418 ($FF8A).

It sets the values for the 16 RAM vectors to the interrupt and
important Kernal I/O routines in the table that starts at 788 ($314)
to the standard values held in the ROM table at 64816 ($FD30)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $13F-$1FF?[/INST]address       $13F-$1FF

This area is exclusively for the microprocessor stack.  Some BASIC
commands, such as FOR-NEXT loops require many stack entries at a time.
Therefore, BASIC frequently checks the stack before pushing entries
on, and returns an OUT OF MEMORY error if an operation would result in
less than 62 bytes of available stack memory.

Each FOR statement causes 18 bytes to be pushed onto the stack, which
come off in the following order:

First comes a one-byte constant of 129 ($81).  Next is a two-byte
pointer to the address of the subject variable (the X of FOR X=1 to
10).  This is followed by the five-byte floating point representation
of the TO value.  Finally comes the two-byte line number of the line
to which the program returns after a NEXT, and the two-byte address of
the next character to read in that line after the FOR statement.

Each GOSUB call places five bytes on the stack.  The first byte to
come off is a one-byte constant of 141 ($8D).  The next two bytes
contain the line number of the statement to which the program will
RETURN after the subroutine ends.  And the final two bytes are a
pointer to the address of the BASIC program text for that statement in
which the program RETURNs.

DEF also leaves a five-byte entry on the stack.  It is the same as
that described for GOSUB, except that instead of a constant byte of
141, the first number is a dummy byte, whose value has no
significance."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F9-$FA?[/INST]address       $F9-$FA        ROBUF
Pointer: RS-232 Output Buffer

This location points to the address of the 256-byte output buffer
which is used for transmitting data to RS-232 devices (device number
2)l"
"[INST]In the context of the C64, What is the purpose of the memory location at address $FA60?[/INST]address              $FA60
Receive and Store the Next Character from Cassette

This is the part of the cassette read IRQ routine that actually gets
the next byte of data from the cassette."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D7?[/INST]address           $D7
Temporary Storage Area for ASCII Value of Last Character Printed

The ASCII value of the last character printed to the screen is held
here temporarily."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B194?[/INST]address         $B194          ARYGET
Allocate Space for Array Descriptors

This routine allocates five bytes plus two bytes for every dimension
specified for the array descriptor."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B245?[/INST]address         $B245          BSERR
Print BAD SUBSCRIPT Error Message"
"[INST]In the context of the C64, What is the purpose of the memory location at address $A8F8?[/INST]address         $A8F8          DATA
Perform DATA

DATA uses the next subroutine to find the offset to the next
statement, and adds the offset to the current pointers so that the
next statement will be executed.  If effect, it skips the statement,
much like REM."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E3BA?[/INST]address              $E3BA
Initial RND Seed Value

At power-up time, this five-byte floating point constant is
transferred to 139 ($8B), where it functions as the starting RND seed
number.  Thus, if RND is not initialized with a negative or zero
argument, it will always return the same sequence of numbers."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E518?[/INST]address              $E518
Initialize Screen and Keyboard

This is the original CINT Kernal routine, to which additions were made
in later versions of the Kernal.

After calling the routine at 58784 ($E5A0) to set up default I/O
values, this routine initializes the cursor blink flags, the keyboard
decode vector, the key repeat delay and frequency counters, the
current color code, and maximum keyboard buffer size.  It then falls
through to the next routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A9A5?[/INST]address         $A9A5          LET
Perform LET

The LET command causes variables to be created and initialized, or to
have a new value assigned.  It handles all types of array or nonarray
variables:  strings, floating point, integers, ST, TI, and TI$.  The
routine is composed of several subroutines that evaluate the variable,
evaluate the assigned expression, check that the assigned value is
suitable for a variable of that type, and then assign a value to the
existing variable, or create a new variable."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E268?[/INST]address              $E268          SIN
Perform SIN

This routine evaluates the SIN of the number in FAC1 (which represents
the angle in radians), and leaves the result there."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B018?[/INST]address         $B018          DIM
Perform DIM

This command calls the next routine to create an array for every
variable dimensioned (since a statement can take the form DIM A(12),
B(13), C(14)...).  If the array element is referenced before a DIM
statement (for example, A(3)=4), the array will be dimensioned to 10
(as if DIM A(10) were executed).  Remember, DIMensioning an array to
10 really creates 11 elements (10).  The 0 element should always be
considered in calculating the size to DIMension your array."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E422?[/INST]address              $E422
Print BASIC Start-Up Messages

This routine prints the start-up message '**** COMMODORE 64 BASIC V2
****', calculates the amount of free memory, and prints the BYTES FREE
message."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A8A0?[/INST]address         $A8A0          GOTO
Perform GOTO

This statement scans BASIC for the target line number (the scan starts
with the current line if the target line number is higher, otherwise
it starts with the first line).  When the line is found, the pointers
to the current statement and text character are changed, so that the
target statement will be executed next."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A94B?[/INST]address         $A94B          ONGOTO
Perform ON GOTO or ON GOSUB

ON is performed by converting the argument to an integer, and then
skipping a number between commas each time that the integer is
decremented until the argument reaches 0.  If a GOTO or GOSUB is the
next token, the current number between commas is used to execute one
of those statements.  If the numbers between commas are used up before
the argument reaches 0, the statement has no effect, and the next
statement is executed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E566?[/INST]address              $E566
Home the Cursor

This routine sets PNTR (211, $D3) and TBLX (214, $D6) to 0, and falls
through to the next routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B1AA?[/INST]address         $B1AA
Convert a Floating Point Number to a Signed Integer in .A and .Y Registers

This subroutine calls AYINT, below, which checks to make sure that the
number in the Floating Point Accumulator is between 32767 and -32768,
and converts it to a 16-bit signed integer in 100-101 ($64-$65), high
byte first.  It leaves the high byte of the integer in the
Accumulator, and the low byte in the .Y register.

Although this routine does not appear to be referenced anywhere in
BASIC, the vector at locations 3-4 points to its address.  Presumably,
it is provided for the benefit of the user who wishes to pass
parameters in a USR call, or the like."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B34C?[/INST]address         $B34C          UMULT
Compute the Size of a Multidimensional Array

This routine calculates the size of a multidimensional array by
multiplying the dimensions."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FE34?[/INST]address              $FE34          MEMBOT
Read/Set Bottom of RAM Pointer

This is a documented Kernal routine, which can be entered through the
jump table at location 65436 ($FF9C).

It can be used to either read or set the bottom of RAM pointer.  If
called with the Carry flag set, the address in the pointer willbe
loaded into the .X and .Y registers.  If called with the Carry flag
cleared, the pointer will be changed to the address found in the .X
and .Y registers."
"[INST]In the context of the C64, What is the purpose of the memory location at address $200-$258?[/INST]address      $200-$258      BUF
BASIC Line Editor Input Buffer

When you are in the BASIC immediate mode, and type in a line of
characters, those characters are stored here.  BASIC then scans the
string of characters, converts the text to tokenized BASIC program
format, and either stores it or executes the line, depending on
whether or not it started with a line number.

This same area is also used to store data which is received via the
INPUT and GET commands.  This explains why these commands are illegal
in immediate mode--they must use the same buffer space that is
required by the immediate mode statement itself.

It is interesting to note that this buffer is 89 bytes long.  The
screen editor will allow a maximum of only 80 characters in a program
line, with one extra byte required for a 0 character, marking the end
of the line.  This presumable is a carry over from the VIC, which
allows a line length of up to 88 characters.  The last eight bytes of
this buffer are therefore normally not used, and can be considered
free space for the programmer to use as he or she sees fit.

Location Range: 601-630 ($259-$276)
Tables for File Numbers, Device Numbers, and Secondary Addresses

All three of the tables here have room for ten one-byte entries, each
of which represents an active Input/Output file.  When an I/O file is
opened, its logical file number is put into the table at 601 ($259),
the device number of the I/O device is put into the table at 611
($263), and its secondary address is put into the table at 621 ($26D).

The entry for any particular I/O file will occupy the same position in
each of the three tables.  That is, if logical file number 2 is the
third entry in the file number table, its secondary address will be
the third entry in the secondary address table, and its corresponding
device number will occupy the third spot in the device number table.

Every time a device is OPENed, its information is added as the last
entry in each table, and the value at location 152 ($98) is increased
by one, indicating that there is one more active I/O file.  When a
device is CLOSEd, the value at location 152 is decreased by one, and
all entries that occupy a position in the tables that is higher than
that of the closed device are moved down one position, thus
eliminating the entry for that device.  The Kernal CLALL routine
(62255, $F32F) simply zeros location 152, which has the effect of
emptying these tables."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FD02?[/INST]address              $FD02
Check for an Autostart Cartridge

This routine tests for an autostart cartridge by comparing the
characters at location 32772-6 ($8004-8) to the text below.  The Zero
flag will be set if they match, and cleared if they don't."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F8E2?[/INST]address              $F8E2
Adjust CIA #1 Timer A for Tape Bit Timing"
"[INST]In the context of the C64, What is the purpose of the memory location at address $FF?[/INST]address          $FF            BASZPT
BASIC Temporary Data for Floating Point to ASCII Conversion

This location is used for temporary storage in the process of
converting floating point numbers to ASCII characters.."
"[INST]In the context of the C64, What is the purpose of the memory location at address $3B-$3C?[/INST]address        $3B-$3C        OLDLIN
Previous BASIC Line Number

When program execution ends, the last line number executed is stored
here, and restored to location 57 ($39) by CONT."
"[INST]In the context of the C64, What is the purpose of the memory location at address $2F-$30?[/INST]address          $2F-$30       ARYTAB
Pointer to the Start of the BASIC Array Storage Area

This location points to the address of the end of nonarray variable
storage, and the beginning of array variable storage.  The format for
array storage is as follows:

The first two bytes hold the array name.  The format and high-bit
patterns are the same as for nonarray variables (see 45 ($2D) above),
except that there is no equivalent to the function definition.

Next comes a two-byte offset to the start of the next array, low byte
first.  Then there is a one-byte value for the number of array
dimensions (e.g., 2 for a two-dimensional array like A(x,y)).  That
byte is followed by pairs of bytes which hold the value of each array
dimension+1 (DIMensioning an array always makes space for 0, so A(0)
can be used).

Finally come the values of the variables themselves.  The format for
these values is the same as with nonarray values, but each value only
takes up the space required; that is, floating point variables use
five bytes each, integers two bytes, and string descriptors three
bytes each.

Remember that as with nonarray string, the actual string text is
stored elsewhere, in the area which starts at the location pointed to
in 51-52 ($33- $34)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FFFC?[/INST]address              $FFFC
System Reset (RES) Hardware Vector

This vector points to the power-on routine at 64738 ($FCE2)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B7EB?[/INST]address         $B7EB          GETNUM
Get a 16-Bit Address Parameter and an 8-Bit Parameter (for POKE and WAIT)

This routine gets the next numeric parameter from the current place in
program text.  The routine evaluates it, checks that it is a positive
integer within the range 0-65535, and changes it from floating point
to a two-byte integer in 20-21 ($14-$15).  It checks for and skips a
comma, then gets a one-byte integer parameter in the .X register.  The
routine is used to get the parameters for POKE an WAIT."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC01?[/INST]address              $DC01          CIAPRB
Data Port Register B

Bit 0:  Read keyboard row 0
        Read joystick 1 up direction
Bit 1:  Read keyboard row 1
        Read joystick 1 down direction
Bit 2:  Read keyboard row 2
        Read joystick 1 left direction
        Read paddle 1 fire button
Bit 3:  Read keyboard row 3
        Read joystick 1 right direction
        Read paddle 2 fire button
Bit 4:  Read keyboard row 4
        Read joystick 1 fire button
Bit 5:  Read keyboard row 5
Bit 6:  Read keyboard row 6
        Toggle or pulse data output for Timer A
Bit 7:  Read keyboard row 7
        Toggle or pulse data output for Timer B

Location Range: 56322-56323 ($DC02-$DC03)
CIA #1 Data Direction Registers A and B

These Data Direction Registers control the direction of data flow over
Data Ports A and B.  Each bit controls the direction of the data on
the corresponding bit of the port.  If teh bit of the Direction
Register is set to a 1, the corresponding Data Port bit will be used
for data output.  If the bit is set to a 0, the corresponding Data
Port bit will be used for data input.  For example, Bit 7 of Data
Direction Register A controls Bit 7 of Data Port A, and if that
direction bit is set to 0, Bit 7 of Data Port A will be used for data
input.  If the direction bit is set to 1, however, data Bit 7 on Port
A will be used for data output.

The default setting for Data Direction Register A is 255 (all
outputs), and for Data Direction Register B it is 0 (all inputs).
This corresponds to the setting used when reading the keyboard (the
keyboard column number is written to Data Port A, and the row number
is then read in Data Port B)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B947?[/INST]address         $B947          NEGFAC
Replace FAC1 with Its 2's Complement"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B850?[/INST]address         $B850          FSUB
Subtract FAC1 from a Number in Memory

This routine is used to subtract the Floating Point Accumulator from a
number in memory.  It moves the number in memory into FAC2, and falls
through to the next routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D414?[/INST]address              $D414          SUREL3
Voice 3 Sustain/Release Control Register

Bits 0-3:  Select release cycle duration (0-15)
Bits 4-7:  Select sustain volume level (0-15)

Location Range: 54293-54296 ($D415-$D418)
Filter Controls

In addition to the controls detailed above for each voice, the SID
chip also provides a filtering capability which allows you to
attenuate (make quieter) certain ranges of frequencies.  Any one or
all three voices can be filtered, and there is even a provision for
filtering an external signal that is input through pin 5 of the
monitor jack.

A low-pass filter is available, which suppresses the volume of those
frequency components that are above a designated cutoff level.  The
high-pass filter reduces the volume of frequency components that are
below a certain level.  The band-pass filter reduces the volume of
frequency components on both sides of the chosen frequency, thereby
enhancing that frequency.  Finally, the high-pass and low-pass filters
can be combined to form a notch reject filter, which reduces the
folume of the frequency components nearest the selected frequency.
These various filters can dramatically change the quality of the sound
produced.

The first two registers are used to select the filter cutoff
frequency.  This is the frequency above or below which any sounds will
be made quieter.  The further away from this level any frequency
components are, the more their output volume will be suppresed (high-
and low-pass filters reduce the volume of those components by 12 dB
per octave away from the center frequency, while the band-pass filter
attenuates them by 6 dB per octave).

The cutoff frequency has an 11-bit range (which corresponds to the
numbers 0 to 2047).  This is made up of a high-byte and three low
bits.  Therefore, to compute the frequency represented by the value in
these registers, you must multiply the value in the high byte by 8,
and add the value of the low three bits.  The range of cutoff
freqnencies represented by these 2048 values stretches from 30 Hz to
about 12,000 Hz.  The exact frequency may be calculated with the
formula:

FREQUENCY=(REGISTER VALUE*5.8)+30Hz

An additional element in filtering is the resonance control.  This
allows you to peak the volume of the frequency elements nearest the
cutoff frequency."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E092?[/INST]address              $E092          RADDC
Additive Constant for RND

The five-byte floating point number stored here is added to the seed
as part of the process of obtaining the value for RND."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD07?[/INST]address              $DD07          TI2BHI
Timer B (high byte)

Location Range: 56584-56587 ($DD08-$DD0B)
Time of Day Clock

In addition to the two general purpose timers, the 6526 CIA chip has a
special purpose Time of Day Clock, which keeps time in a format that
humans can understand a little more easily than microseconds.  For
more information about this clock, see the entry for Location Range
56328-56331 ($DC08-$DC0B).  The 64's Operating system does not make
use of these registers."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD08?[/INST]address              $DD08          TO2TEN
Time of Day Clock Tenths of Seconds

Bits 0-3:  Time of Day tenths of second digit (BCD)
Bits 4-7:  Unused"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E097?[/INST]address              $E097          RND
Perform RND

This routine comes up with a random number in one of three ways,
depending on the argument X of RND(X).  If the argument is positive,
the next RND value is obtained by multiplying the seed value in
location 139 ($8B) by one of the constants above, adding the other
constant, and scrambling the resulting bytes.  This produces the next
number in a sequence.  So many numbers can be produced in this way
before the sequence begins to repear that it can be considered random.

If the argument is negative, the argument itself is scrambled, and
made the new seed.  This allows creation of a sequence that can be
duplicated.

If the argument is 0, four bytes of the Floating Point Accumulator are
loaded from the low and high byte of Timer A, and the tenths of second
and second Time of Day Clock registers, all on CIA #1.  This provides
a somewhat random value determined by the setting of those timers at
the moment that the command is executed, which becomes the new seed
value.  The RND(1) command should then be used to generate further
random numbers.

The RND(0) implementation on the 64 has serious problems which make it
unusable for generating a series of random numbers when used by
itself.  First of all, the Time of Day Clock on CIA #1 (see
56328-56331 ($DC08-$DC0B)) does not start running until you write to
the tenth of second register.  The Operating System never starts this
clock, and therefore the two registers used as part of the floating
point RND(0) value always have a value of 0.  Even if the clock was
started, however, these registers keep time in Binary Coded Decimal
(BCD) format, which means that they do not produce a full range of
numbers from 0 to 255.  In addition, the Timer A high register output
ranges only from 0 to 66, which also imits the range of the final
floating point value so that certain numbers are never chosen."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B849?[/INST]address         $B849          FADDH
Add .5 to Contents of Floating Point Accumulator #1"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D413?[/INST]address              $D413          ATDCY3
Voice 3 Attack/Decay Register

Bits 0-3:  Select decay cycle duration (0-15)
Bits 4-7:  Select attack cycle duration (0-15)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC00?[/INST]address              $DC00          CIAPRA
Data Port Register A

Bit 0:  Select to read keyboard column 0
        Read joystick 2 up direction
Bit 1:  Select to read keyboard column 1
        Read joystick 2 down direction
Bit 2:  Select to read keyboard column 2
        Read joystick 2 left direction
        Read paddle 1 fire button
Bit 3:  Select to read keyboard column 3
        Read joystick 2 right direction
        Read paddle 2 fire button
Bit 4:  Select to read keyboard column 4
        Read joystick 2 fire button
Bit 5:  Select to read keyboard column 5
Bit 6:  Select to read keyboard column 6
        Select to read paddles on Port A or B
Bit 7:  Select to read keyboard column 7
        Select to read paddles on Port A or B"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B8FE?[/INST]address         $B8FE          NORMAL
Normalize Floating Point Accumulator #1"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B7AD?[/INST]address         $B7AD          VAL
Perform VAL

The VAL routine obtains the string pointer, and reads the string one
character at a time until an invalid character is found (ASCII
numbers, sign character, a single decimal point, exponent, and spaces
are all valid).  Then the string is changed to floating point.  If no
valid characters are found, a 0 is returned."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FFFE?[/INST]address              $FFFE
Maskable Interrupt Request and Break Hardware Vectors

This vector points to the main IRQ handler routine at 65352 ($FF48)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $31-$32?[/INST]address         $31-$32        STREND
Pointer to End of the BASIC Array Storage Area (+1), and the Start of
Free RAM

This location points to the address of the end of BASIC array storage
space and the start of free RAM.  Since string text starts at the top
of memory and builds downwards, this location can also be thought of
as the last possible address of the string storage area.  Defining new
variables pushes this pointer upward, toward the last string text.

If a string for which space is being allocated would cross over this
boundary into the array storage area, garbage collection is performed,
and if there still is not enough room, an OUT OF MEMORY error occurs.
FRE performs garbage collection, and returns the difference between
the addresses pointed to here and the address of the end of string
text storage pointed to by location 51 ($33)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $3D-$3E?[/INST]address         $3D-$3E        OLDTXT
Pointer to the Address of the Current BASIC Statement

This location contains the address (not the line number) of the text
of the BASIC statement that is being executed.  The value of TXTPTR
(122, $7A), the pointer tot he address of the BASIC text character
currently being scanned, is stored here each time a new BASIC line
begins execution.

END, STOP, and the STOP-key BREAK save the value of TXTPTR here, and
CONT restores this value to TXTPTR.  CONT will not continue if 62
($3E) has been changed to a zero by a LOAD, a modification to the
program text, or by error routines."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F8D0?[/INST]address              $F8D0
Test the STOP Key during Cassette I/O Operations

This subroutine is used to test the STOP key during tape I/O
oeprations, and to stop I/O if it is pressed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FB-$FE?[/INST]address       $FB-$FE        FREEZP
Four Free Bytes of Zero Page for User Programs

These locations were specifically set aside for user-written ML
routines that require zero-page addressing.  While other zero-page
locations can be used on a noninterference basis, it is guaranteed
that BASIC will not alter these locations."
"[INST]In the context of the C64, What is the purpose of the memory location at address $0300-$03FF?[/INST]page 2 and 3

This area is used to store important information for the Operating
System and BASIC.  It contains vectors to certain BASIC routines as
well as Operating System Kernal routines.  Registers for RS-232 serial
I/O are located here.  Buffer space is allocated in this area for tape
I/O, BASIC text input, and the keyboard queue.  In addition, there are
a number of Operating System variables and pointers here which the
programmer can utilize."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FCE2?[/INST]address              $FCE2
Power-On Reset Routine

This is the RESET routine which is pointed to by the 6510 hardware
RESET vector at 65532 ($FFFC).

This routine is automatically executed when the computer is first
turned on.  First, it sets the Interrupt disable flag, sets the stack
pointer, and clears the Decimal mode flag.  Next, it tests for an
autostart cartridge.  If one is found, the routine immediately jumps
through the cartridge cold start vector at 32768 ($8000).  If no
cartridge is found, the Kernal initialization routines IOINIT, RAMTAS,
RESTOR, and CINT are called, the Interrupt disable flag is cleared,
and the BASIC program is entered through the cold start vector at
40960 ($A000)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FE25?[/INST]address              $FE25          MEMTOP
Read/Set Top of RAM Pointer

This is a documented Kernal routine, which can be entered through the
jump table at location 65433 ($FF99).

It can be used to either read or set the top of RAM pointer.  If
called with the Carry flag set, the address in the pointer will be
loaded into the .X and .Y registers.  If called with the Carry flag
cleared, the pointer will be changed to the address found in the .X
and .Y registers."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B37D?[/INST]address         $B37D          FRE
Perform FRE

The FRE function calls the garbage collection routine at 46374 ($B526)
to get rid of unused string text, and calculates the difference
between the bottom of string text and the top of array storage.  It
then drops through to the follow routine, which assumes that the free
memory value is a 16-bit signed integer, and converts it to floating
point accordingly.

Of course, while the free memory space on the PET might have always
been 32767 or less (the maximum value of a signed integer), sich is
definitely not the case on the 64.  Because conversion is from a
signed integer, any memory value over 32767 will be regarded as
negative (the high bit is treated as a sign bit).  Therefore, for
these higher values you must add twice the bit value of the high bit
(65536) in order to come up with the correct value.  The expression
FRE(0)-6556*(FRE(0)<0) will always return the correct amount of free
memory."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B1B2?[/INST]address        $B1B2          INTIDX
Input and Convert a Floating Point Subscript to a Positive Integer

This routine converts a floating point subscript value to an integer,
making sure first that it is positive."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A93B?[/INST]address         $A93B          REM
Perform REM

The REM statement is executed by skipping all program text until the
beginning of the next statement.  It is actually a part of the IF
statement, which continues for a few bytes after the REM part."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E544?[/INST]address              $E544
Initialize the Screen Line Link Table and Clear the Screen

This routine initializes the screen line link table at 217 ($D9),
clears the screen, and clears the Color RAM to the background color.
It falls through to the next routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E3BF?[/INST]address              $E3BF          INIT
Initialize BASIC

This routine is called by the cold start routine to initialize all of
the BASIC zero-page locations which have a fixed value.  This includes
copying the CHRGET routine from the ROM location above, to 115 ($73)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A883?[/INST]address         $A883          GOSUB
Perform GOSUB

This statement pushes the pointers to the current text character and
current line onto the stack, along with a constant 141 ($8D) which
identifies the block as saved GOSUB information to be used by RETURN.
The GOTO is called."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B016?[/INST]address         $B016          DORE1
Perform Comparisons

This routine does the greater than (>), less than (<), and equal (=)
comparisons for foating point numbers and strings.  The result in the
Floating Point Accumulator will be 0 if the comparison is false, and
-1 if it is true."
"[INST]In the context of the C64, What is the purpose of the memory location at address $ABBF?[/INST]address         $ABBF          INPUT
Perform INPUT

The INPUT routine checks to make sure that direct mode is not active,
prints prompts, receives a line of input from the device, and jumps to
the common code in READ that assigns the input to the variables which
were named."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E219?[/INST]address              $E219
Set Parameters for OPEN and CLOSE

This routine is used in common by OPEN and CLOSE for setting the
filename, the logical file, device number, and secondary address, all
of which must be done prior to these operations."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E2EA?[/INST]address              $E2EA          FR4
The Five-Byte Floating Point Representation of the Constant 1/4"
"[INST]In the context of the C64, What is the purpose of the memory location at address $AFA7?[/INST]address         $AFA7          ISFUN
Dispatch and Evaluate a Function

If a BASIC function (like ASC('A')) is part of an expression, this
routine will use the function dispatch table at 42242 ($A502) to set
up the address of th proper function routine, and then branch to that
routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A928?[/INST]address         $A928          IF
Perform IF

IF uses the FRMEVL routine at 44446 ($AD9E) to reduce the expression
which follows to a single term.  If the expression evaluates to 0
(false), the routine falls through to REM.  If it is not 0, GOTO or
the statement following THEN is executed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FE66?[/INST]address              $FE66
BRK, Warm Start Routine

This routine is executed when the STOP/RESTORE combination of
keypresses occurs.  In addition, it is the default target address of
the BRK instruction vector.  This routine calls the Kernal
intialization routines RESTOR, IOINIT, and part of CINT.  It then
exits through the BASIC warm start vector at 40962 ($A002)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D5?[/INST]address          $D5            LNMX
Maximum Length of Physical Screen Line

The line editor uses this location when the end of a line has been
reached to determine whether another physical line can be added to the
current logical line, or if a new logical line must be started."
"[INST]In the context of the C64, What is the purpose of the memory location at address $C5?[/INST]address           $C5            LSTX
Matrix Coordinate of Last Key Pressed, 64=None Pressed

During every normal IRQ interrput this location is set with the value
of the last keypress, to be used in keyboard debouncing.  The
Operating System can check if the current keypress is the same as the
last one, and will not repeat the character if it is.

The value returned here is based on the keyboard matrix values as set
forth in the explanation of location 56320 ($DC00).  The values
returned for each key pressed are shown at the entry for location 203
($CB)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FE07?[/INST]address              $FE07          READST
Read the I/O Status Word

This is a documented Kernal routine, which can be entered through the
jump table at location 65463 ($FFB7).

Whenever an I/O error occurs, a bit of the Status Word is set to
indicate what the problem was.  The routine allows you to read the
status word (it is returned in the Accumulator).  If the device was
the RS-232, its status register is read and cleared to zero.  For the
meanings of the various status codes, see the entry for location 144
($90) or 663 ($297) for the RS-232 device."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FD30?[/INST]address     816         $FD30
Table of RAM Vectors to the Default I/O Routines

This table contains the 16 RAM I/O vectors that are moved to 788-819
($314-$333)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $11?[/INST]address            $11            INPFLG
Flag: Is Data Input to GET, READ or INPUT?

Since the keywords GET, INPUT, and READ perform similar functions,
BASIC executes some of the same instructions for all three.  There are
also many areas of difference, however, and this flag indicates which
of the three keywords is currently being executed, so that BASIC will
know whether or not to execute the instructions which relate to the
areas in which the commands differ (152 ($98)=READ, 64 ($40)=GET,
0=INPUT).

As a result, INPUT will show the ? prompt, will echo characters back
to the screen, and will wait for a whole line of text ended by a
carriage return.  GET gives no prompt and accepts one character
without waiting.  The colon character and the comma are valid data for
GET, but are treated as delimiters between data by INPUT and READ.

As each command has its own error messages, this flag is used to
determine the appropriate message to issue in case of an error."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B77C?[/INST]address         $B77C          LEN
Perform LEN

The LEN function is performed by obtaining the string length from the
descriptor and converting it to a floating point number."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD00?[/INST]address              $DD00          CI2PRA
Data Port Register A

Bits 0-1:  Select the 16K VIC-II chip memory bank (11=bank 0, 00=bank 3)
Bit 2:  RS-232 data output (Sout)/Pin M of User Port
Bit 3:  Serial bus ATN signal output
Bit 4:  Serial bus clock pulse output
Bit 5:  Serial bus data output
Bit 6:  Serial bus clock pulse input
Bit 7:  Serial bus data input"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC0B?[/INST]address              $DC0B          TODHRS
Time of Day Clock Hours

Bits 0-3:  Second digit of Time of Day hours (BCD)
Bit 4:  First digit of Time of Day hours (BCD)
Bits 5-6:  Unused
Bit 7:  AM/PM Flag (1=PM, 0=AM)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B487?[/INST]address         $B487          STRLIT
Scan and Set Up Pointers to a String in Memory

This routine calculates the length of the string, and calls the
routine that allocates space in memory.  It then saves the string, or
creates a pointer to its location in the BASIC text input buffer at
512 ($200)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B8A7?[/INST]address         $B8A7          FADD4
Make the Result Negative If a Borrow Was Done"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E156?[/INST]address              $E156          SAVE
Perform SAVE

This routine sets the range of addresses to be saved from the start of
BASIC program text and end of BASIC program text pointers at 43 ($2B)
and 45 ($2D), and calls the Kernal SAVE routine.  This means that any
area of memory can be saved by altering these two pointers to point to
the starting and ending address of the desired area, and then changing
them back."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E165?[/INST]address              $E165          VERIFY
Perform VERIFY

This routine sets the load/verify flag at 10 ($A), and falls through
to the LOAD routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B86A?[/INST]address         $B86A          FADDT
Perform BASIC's Addition Operation

This routine adds the contents of FAC1 and FAC2 and stores the results
in FAC1."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC0A?[/INST]address              $DC0A          TODMIN
Time of Day Clock Minutes

Bits 0-3:  Second digit of Time of Day minutes (BCD)
Bits 4-6:  First digit of Time of Day minutes (BCD)
Bit 7:  Unused"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B465?[/INST]address         $B465          STRD
Perform STR$

STR$ first checks to make sure that the parameter is a number, and
then calls the routines that convert floating point to ASCII and crate
the pointers to a string constant."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B761?[/INST]address         $B761          PREAM
Pull String Function Parameters from Stack for LEFT$, RIGHT$, and MID$

This routine is used to obtain the first two parameters for all three
of these commands."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD00-$DD0F?[/INST]address        $DD00-$DD0F
Complex Interface Adapter (CIA) #2 Registers

Locations 56576-56591 ($DD00-$DD0F) are used to address the Complex
Interface Adapter chip #2 (CIA #2).  Since the chip itself is
identical to CIA #1, which is addressed at 56320 ($DC00), the
discussion here will be limited to the use which the 64 makes of this
particular chip.  For more general information on the chip registers,
please see the corresponding entries for CIA #1.

One of the significant differences between CIA chips #1 and #1 is the
use to which Data Ports A and B are put.  The peripheral input and
output devices that CIA #2 controls are those on the Serial Bus (such
as the 1541 Disk Drive and 1525 printer), the RS-232 device (which is
used for telecommunications), and the User Port, an eight-bit parallel
port that can be turned to whatever purpose the user desires.  In
addition, Data Port A has the important task of selecting the 16K bank
ofmemory that will be used by the VIC-II chip for graphics.

Another significant difference between CIA chips #1 and #2 is that the
interrupt line of CIA #1 is wired to the 6510 IRQ line, while that of
CIA #2 is wired to the NMI line.  This means that interrupts from this
chip cannot be masked by setting the Interrupt disable flag (SEI).
They can be disabled from CIA's Mask Register, though.  Be sure to use
the NMI vector when setting up routines to be driven by interrupts
generated by this chip.

Location Range: 56576-56577 ($DD00-$DD01)
CIA #2 Data Ports A and B

These registers are where the communication with the Serial Bus,
RS-232 device, and User Port take place.  The Serial Bus is like the
IEEE bus which is used by the PET, in that it allows more than one
device to be connected to the port at a time, in a daisychain
arrangement.  Since each byte of data is sent one bit at a time,
however, the Serial Bus is at least eight times slower than the IEEE.
It is presently used to control the 1541 Disk Drive and 1525 printer,
and other devices (such as printer interface for Centronics- type
parallel pritners and stringy floppy wafer tape storage units) can be
placed on this bus.

Data Port A is used for communication with the Serial Bus.  Bits 5 and
7 are used for Serial Bus Data Output and Input, respectively, and
Bits 4 and 6 are used for the Serial Bus Clock Pulse Output and Input.
Bit 3 of Data Port A is used to send the ATN signal on the Serial Bus.

The 64 has built-in software to handle RS-232 communications through a
modem or other device plugged in the RS-232/User Port.  The RS-232
device uses Bit 2 of Data Port A for data output (it is the only line
from Port A that is connected to the RS-232/User Port jack).  It also
makes heavy use of Port B, using Bit 7 for the Data Set Ready (DSR)
signal, Bit 6 for the Clear to Send (CTS), Bit 4 for the Carrier
Detect (DCD), Bit 3 for the Ring Indicator (RI), Bit 2 for Data
Terminal Ready (DTR), Bit 1 for Request to Send (RTS), and Bit 0 for
data input.  See locations 659-660 ($293-$294) for more details on the
RS-232 device.

All of the data lines which the RS-232 device uses are also available
to the user as part of the User Port.  All of the Port B data lines,
and Bit 2 of Port A, are brought out to the User Port connector on the
back of the 64.  These data bits are utilized in the normal way:  The
port connections are made to TTL-level input or output devices, and
the direction of data is determined by the Data Direction Registers.

In addition, the User Port has pins connected to the two CIA Serial
Ports (whose eight-bit shift registers are well-suited for
serial-to-parallel and parallel-to-serial conversion),and the two CNT
lines which aid in the operation of the Serial Ports.  The CNT lines
can also be used in conjunction with the CIA Timers, and allow them to
be used as frequency counters, event counters, interval timers, etc.
The advanced features of the CIA chip make almost any type of
interfacing application possible, and in the near future we will
probably see many interesting applications for the User Port on the
64.  A pin description of tthe User Port connector is provided below:

User         RS-232
Port  CIA    DB-25
Pin   Line   Pin     Description

1                    Ground
2                    +5 Volts (100 milliamps maximum)
3                    RESET (grounding this pin causes a cold start)
4     CNT1           CIA #1 Serial Port and Timer Counter
5     SP1            CIA #1 Serial Data Port
6     CNT2           CIA #2 Serial Port and Timer Counter
7     SP2            CIA #2 Serial Data Port
8     PC2            CIA #2 handshaking line
9                    Connected to the ATN line of the Serial Bus
10                   9 Volts AC (+ phase, 50 milliamps maximum)
11                   9 volts AC (- phase, 50 milliamps maximum)
12                   Ground
A            1       Ground
B     FLAG2          CIA #2 handshaking line
C     PB0    3       Port B Bit 0--RS-232 Received Data (SIN)
D     PB1    4       Port B Bit 1--RS-232 Request to Send (RTS)
E     PB2    20      Port B Bit 2--RS-232 Data Terminal Ready (DTR)
F     PB3    22      Port B Bit 3--RS-232 Ring Indicator (RI)
H     PB4    8       Port B Bit 4--RS-232 Carrier Detect (DCD)
J     PB5            Port B Bit 5
K     PB6    5       Port B Bit 6--RS-232 Clear to Send (CTS)
L     PB7    6       Port B Bit 7--RS-232 Data Set Ready (DSR)
M     PA2    2       Port A Bit 2--RS-232 Transmitted Data (Sout)
N            7       Ground

One of the handshaking lines on the above chart, PC2, was not covered
in the discussion of CIA #1, because that line of CIA #1 is not
connected to anything.  The CIA #2 PC line is accessible from the User
Port, however.  This line will go low for one cycle following a read
or write of Port B on CIA #2.  This signal lets external devices know
when data has been read or written.

Bits 0 and 1 of CIA #2 Port A have an extremely important function.
As mentioned in the section on the VIC-II chip (53248, $D000), the
video chip can address only 16K of memory at a time, and all graphics
data must be stored in that 16K block in order to be displayed.
Within this area, sprite graphics data may be placed in any of 256
groups of 64 bytes each.  Character data can be stored in any of eight
2K blocks.  Text screen memory may be in any of 16 1K areas, and
bitmap screen memory may be in either of two 8K sections.

When you turn the power on, the VIC-II uses the bottom 16K of memory
for graphics.  Unfortunately, this block of memory is also used
extensively for other important purposes.  Though some means of
eliminating these conflicts are discussed above, in many situations
you will want to change from the default 16K bank at the low end of
memory.

Bits 0 and 1 select the current 16K bank for video memory from the
four possible choices using the following bit patterns:

00 (bit value of 0) Bank 3 (49152-65535, $C000-$FFFF)
01 (bit value of 1) Bank 2 (32768-49151, $8000-$BFFF)
10 (bit value of 2) Bank 1 (16384-32767, $4000-$7FFF)
11 (bit value of 3) Bank 0 (0-16383, $0-$3FFF)

The technique for making this change from BASIC is discussed below.
But before we go ahead and start changing banks, let's briefly review
the contents of these areas, and the considerations for using them for
graphics.

Block 0.  This is normally used for system variables and BASIC program
text.  Locations 1024-2047 ($400-$7FF) are reserved for the default
position of screen memory.

There is an addition limitation on memory usage of this block, as the
VIC-II sees the character generator ROM at 4096-8191 ($1000-$1FFF),
making this portion of memory unavailable for other graphics data.
Generally, there is little free space here for graphics display data.
Locations 679-767 ($2A7- $2FF) are unused, and could hold one sprite
shape (number 11) or data for 11 characters.  The area from 820-1023
($334-$3FF), which includes the cassette I/O buffer, is available for
graphics memory, and is large enough to hold three sprite shapes
(numbers 13, 14, and 15), or data for 25 characters (numbers 103-127).
But getting enough memory for bitmap graphics requires that you either
reserve memory after the end of BASIC text by lowering the end of
BASIC pointer at 56 ($38), or raise the start of BASIC pointer at 44
($2C).  See the entries for these pointers for more details.

Block 1.  Block 1 is normally used for BASIC program storage.  When
using this bank, the VIC-II does not have access to the character
generator ROM.  Providing that you lower the top of memory so that
BASIC programs do not interfere, this area is wide open for sprite
shapes, character graphics, and bitmap graphics.

The drawbacks to useing this bank are the unavailability of the
character ROM and the limitation on BASIC program space (as little as
14K).  The absence of the character ROM is a relatively minor
nuisance, because you can always switch in the ROM and copy any or all
of the characters to RAM (see the entries for location 1 and the
alternate entry for 53248 ($D000), the Character ROM, for details).
This block may be a good alternate choice to avoid potential conflicts
with other applications that use higher memory.

Block 2.  The third block (Block 2) consists of 8K of RAM, half of
which is seen by the VIC-II chip as character ROM, and the 8K BASIC
interpreter ROM.  The BASIC ROM area is available for graphics.  This
is possible because of the 64's special addressing.  The VIC-II chip
reads only from RAM, and thus sees the RAM underneath the BASIC ROM,
even if the 6510 has ROM switched in.  The 6510, on the other hand,
always writes to RAM, even when dealing with memory it reads as ROM.
Whatever is written to the RAM underlying the BASIC ROM is displayed
normally by the VIC-II chip.  This opens up an extra 8K are for
sprites and character data under the BASIC ROM.

You should keep in mind that while you can write to this area, you
cannot read it from BASIC.  This may not be a serious problem when it
comes to character sets and sprite data, but it's more of a drawback
if you want to use this RAM for screen memory.

For example, the Operating System has to read the text screen to move
the cursor properly, and if it reads the ROM value instead of the RAM
screen data, it gets hopelessly confused, making it impossible to type
in any commands.

Likewise, you would not be able to read the high-resolution screen if
it were placed here, without some machine language trickery.  With
locations 36863-40959 ousted by the character ROM, only 4K of true RAM
remains for use as screen memory, not enough for a complete
high-resolution screen.  Therefore, this block is not recommended for
use in bitmap mode if your program needs to check the screen.
Otherwise, this is a good place for graphics memory, particularly if
you need to emulate the screen configuration of the PET.

Block 3.  Normally Block 3 contains 4K of RAM that is completely
unused by the system, 4K if I/O registers, and the 8K Operating System
Kernal ROM.  It is very convenient to use when you need a lot of
memory space for both graphics and a BASIC program.  Although the
character ROM is not available, it can be copied to RAM.  The area
under the Kernal ROM can be used as explained above.  One possible
conflict that you should be aware of is that the current version of
the DOS support program is written to reside at 52224 ($CC00).  It
would be safest to avoid using 52224-53247 for graphics if you plan to
use DOS support.

Changing banks.  Once you have selected a bank of 16K to use, the
procedure for making the change from BASIC is as follows:

1.  Set the Data Direction Register if necessary.  In order to use
Bits 0 and 1 of Port A to change banks, these bits must be set as
outputs in Data Direction Register A.  Since this is the default
condition on powering-up, this step normally will not be needed.

2.  Select a bank.  Banks 0-3 can be chosen by entering the following
lines:

POKE 56578,PEEK(56578) OR 3: REM SET FOR OUTPUT IF NOT ALREADY
POKE 56576,(PEEK(56576) AND 252) OR (3-BANK): REM BANK IS BANK #, MUST
  BE 0-3

3.  Set the VIC-II register for character memory.  As explained at the
entry for location 53272 ($D018), the formula for this is:

POKE 53272,(PEEK(53272) AND 240) OR TK: REM TK IS 2 KBYTE OFFSET FROM
  BEGINNING OF BLOCK

4.  Set the VIC-II register for display memory.  As explained at the
entry for location 53272 ($D018), the formula for this is:

POKE 53272,(PEEK(53272) AND 15) OR K*16: REM K IS KBYTE OFFSET FROM
  BEGINNING OF BLOCK

Since steps 3 and 4 operate on the same register, you could combine
these steps and just POKE 53272,(16*K+TK).

5.  Set the Operating System pointer for display memory at 648 ($288).
Even though you have just told the VIC-II chip where to display memory
for the screen, the Operating System does not yet know where to write
its text characters.  Let it know with this statement:

POKE 648,AD/256: REM AD IS THE ACTUAL ADDRESS OF SCREEN MEMORY

After you make this change, you must watch out for the STOP/RESTORE
key combination.  The BRK initialization changes the screen display
default to location 1024 in Bank 0, but not the Operating System
pointer at 648 ($288).  As a result, what you are typing will not be
displayed on the screen.  The computer will lock up until you turn the
power off and back on again.  The simplest way to avoid this problem
is to disable the RESTORE key entirely (see the entries for 792 ($318)
and 808 ($328) for more information).

Below is a sample program which switches to Bank 3.  It includes a
machine language transfer routine to move the ROM character set to
RAM, and a short interrupt routine to correct the RESTORE key problem.
After the switch is made, a loop isused to POKE characters into the
new screen memory area.  Next, the character data is slowly erased, to
show that the character set is now in RAM.  Then, a loop is used to
read the locations of the character set, and write to the same
locations.  This demonstrates that the 6510 reads the Kernal ROM when
you PEEK those locations, but POKEs to the RAM which is being
displayed.  Finally, the machine language move is used again to show
how quickly the set is restored.

20 FOR I=1 TO 33:READ A:POKE 49152+I,A:NEXT: REM SET UP ML ROUTINE
30 GOSUB 200: REM ML COPY OF ROM CHARACTER SET TO RAM
40 POKE 56576,PEEK(56576) AND 252: REM STEP 1, ENABLE BANK 3
50 POKE 53272,44: REM STEPS 2-3, POINT VIC-II TO SCREEN AND CHARACTER MEMORY
60 REM SCREEN OFFSET IS 2*16, CHARACTER OFFSET IS 12
70 POKE 648,200: REM STEP 4, POINT OS TO SCREEN AT 51200 (200*256)
80 PRINT CHR$(147): REM CLEAR SCREEN
90 FOR I=53236 TO 53245:READ A:POKE I,A:NEXT: REM NEW INTERRUPT ROUTINE
100 POKE 53246,PEEK(792):POKE 53247,PEK(793): REM SAVE OLD NMI VECTOR
110 POKE 792,244:POKE 793,207: REM ROUTE THE INTERRUPT THROUGH THE NEW ROUTINE
120 FOR I=0 TO 255:POKE 51400+I,I:POKE 55496+I,1:NEXT
125 REM POKE CHARACTERS TO SCREEN
130 FOR J=1 TO 8:FOR I=61439+J TO I+2048 STEP 8
140 POKE I,0:NEXT I,J: REM ERASE CHARACTER SET
150 FOR I=61440 TO I+2048:POKE I,PEEK(I):NEXT: REM POKE ROM TO RAM
160 GOSUB 200:END: REM RESTORE CHARACTER SET
200 POKE 56334,PEEK(56334) AND 254: REM DISABLE INTERRUPTS
210 POKE 1,PEEK(1) AND 251:REM SWITCH CHARACTER ROM INTO 6510 MEMORY
220 SYS 49152: REM COPY ROM CHARACTER SET TO RAM AT 61440
230 POKE 1,PEEK(1) OR 4: REM SWITCH CHARACTER ROM OUT OF 6510 MEMORY
240 POKE 56334,PEEK(56334)OR 1: REM ENABLE INTERRUPTS
250 RETURN
300 REM DATA FOR ML PROGRAM TO COPY CHARACTER SET TO RAM
310 DATA169,0,133,251,133,253,169,208,133,252,169,240,133,254,162,16
320 DATA160,0,177,251,145,253,136,208,249,230,252,230,254,202,208,240,96
330 REM NEXT IS ML PROGRAM TO MAKE THE RESTORE KEY RESET OS POINTER TO SCREEN
340 DATA 72,169,4,141,136,02,104,108,254,207

See also the sample program showing how to configure your 64 like a
PET at location 43 ($2B)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $12?[/INST]address           $12            TANSGN
Flag: Sign of the Result of the TAN or SIN Function

This location is used to determine whether the sign of the value
returned by the functions SIN or TAN is positive or negative.

Additionally, the string and numeric comparison routines use this
location to indicate the outcome of the comparison.  For a comparison
of variable A to variable B, the value here will be 1 if A is greater
than B, 2 if A equals B, and 4 if a is less than B.  If more than one
comparison operator was used to compare the two variables (e.g., >= or
<=), the value here will be a combination of the above values."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FD1A?[/INST]address              $FD1A          VECTOR
Set the RAM Vector Table from the Table Pointed to by .X and .Y

This documented Kernal routine can be entered through the jump table
at 65421 ($FF8D).

It is used to read or change the values for the 16 RAM vectors to the
interrupt and important Kernal I/O routines in the table that starts
at 788 ($314).  If the Carry flag is set when the routine is called,
the current value of the 16 vectors will be stored at a table whose
address is pointed to by the values in the .X and .Y registers.  If
the Carry flag is cleared, the RAM vectors will be loaded from the
table whose address is pointed to by the .X and .Y registers.  Since
this routine can change the vectors for the IRQ and NMI interrupts,
you might expect that the Interrupt disable flag would be set at its
beginning.  Such is not the case, however, and therefore it would be
wise to execute an SEI before calling it and a CLI afterwards (as the
power-on RESET routine does) just to be safe.

64"
"[INST]In the context of the C64, What is the purpose of the memory location at address $C1-$C2?[/INST]address       $C1-$C2        STAL
I/O Start Address

This location points to the beginning address of the area in RAM which
is currently being LOADed or SAVEd.  For tape I/O, it will point to
the cassette buffer, and the rest of the data is LOADed or SAVEd
directly to or from RAM.  This location points to the beginning
address of the area of RAM to be used for the blocks of data that come
after the initial header."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FE00?[/INST]address              $FE00          SETLFS
Set Logical File Number, Device Number, and Secondary Address

This is a documented Kernal routine, which can be entered through the
jump table at location 65466 ($FFBA).

It stores the value in the Accumulator in the location which holds the
current logical file number, the value in the .X register is put in
the location that holds the current device number, and the value in
the .Y register is stored in the location that holds the current
secondary address.  If no secondary address is used, the .Y register
should be set to 255 ($FF).  It is necessary to set the values of the
current file number, device number, and secondary address before you
OPEN a file, or LOAD or SAVE."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FE43?[/INST]address              $FE43
NMI Interrupt Entry Point

This routine is the NMI interrupt handler entry, which is pointed to
by the hardware NMI vector at 65530 ($FFFA).

Any time an NMI interrupt occurs, the Interrupt disable flag will be
set, and the routine will jump through the RAM vector at 792 ($318),
which ordinarily points to the continuation of this routine.  The
standard handler first checks to see if the NMI was caused by the
RS-232 device.  If not, the RESTORE key is assumed.  The routine
checks for a cartridge, and if one is found it exits through the
cartridge warm start vector at 32770 ($8002).  If not, the STOP key is
checked, and if it is being pressed, the BRK routine is executed.  If
the RS-232 device was the cause of the NMI, the cartridge and STOP key
checks are bypassed, and the routine skips to the end, where it checks
whether it is time to send or receive a data bit via the RS-232
device."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D4?[/INST]address          $D4            QTSW
Flag: Editor in Quote Mode? 0=No

A nonzero value in this location indicates that the editor is in quote
mode.  Quote mode is toggled every time that you type in a quotation
mark on a given line--the first quote mark turns it on, the second
turns it off, the third turns it back on, etc.

If the editor is in this mode when a cursor control character or other
nonprinting character is entered, a printed equivalent will appear on
the screen instead of the cursor movement or other control operation
taking place.  Instead, that action is deferred until the string is
sent to the string by a PRINT statement, at which time the cursor
movement or other control operation will take place.

The exception to this rule is the DELETE key, which will function
normally within quote mode.  The only way to print a character which
is equivalent to the DELETE key is by entering insert mode (see
loctaion 216 ($D8)).  Quote mode may be exited by printing a closing
quote, or by hitting the RETURN or SHIFT-RETURN keys.

Sometimes, it would be handy to be able to escape from quote mode or
insert mode without skipping to a new line.  The machine language
program below hooks into the keyscan interrupt routine, and allows you
to escape quote mode by changing this flag to 0 when you press the f1
key:

10 FOR I=850 TO I+41:READ A:POKE I,A:NEXT
20 PRINTCHR$(147)'PRESS F1 KEY TO ESCAPE QUOTE MODE'
30 PRINT'TO RESTART AFTER RESTORE ONLY, SYS 850':SYS850:NEW
40 DATA  173 , 143 , 2 , 141 , 46 , 3 , 173 , 144 , 2 , 141
50 DATA 47 , 3 , 120 , 169 , 107 , 141 , 143 , 2 , 169 , 3
60 DATA 141 , 144 , 2 , 88 , 96 , 165 , 203 , 201 , 4 , 208
70 DATA 8 , 169 , 0 , 133 , 212 , 133 , 216 , 133 , 199 , 108 , 46 , 3"
"[INST]In the context of the C64, What is the purpose of the memory location at address $A906?[/INST]address        $A906          DATAN
Search Program Text for the End of the Current BASIC Statement

This routine starts at the current byte of program text and searches
until it finds a zero character (line delimiter) or a colon character
that is not in quotes (statement delimiter)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E2E5?[/INST]address              $E2E5          TWOPI
The Five-Byte Floating Point Representation of the Constant 2*PI"
"[INST]In the context of the C64, What is the purpose of the memory location at address $AF2B?[/INST]address         $AF2B          ISVAR
Get the Value of a Variable"
"[INST]In the context of the C64, What is the purpose of the memory location at address $ABA5?[/INST]address        $ABA5          INPUTN
Perform INPUT#

This routine opens an input channel with the Kernal CHKIN routine,
calls INPUT, and then closes the channel with a CHKOUT routine (62032,
$F250).  Extra data is discarded without an EXTRA IGNORED message, and
a FILE DATA ERROR message is issued when the data type is not suitable
for the type of variable used."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E20E?[/INST]address              $E20E
Check for Comma

This subroutine checks for a comma, moves the text pointer past it if
found, and returns an error if it is not found."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AFE6?[/INST]address         $AFE6          OROP
Perform OR

The OR routine sets the .Y register as a flag, and falls through to
the AND routine, which also performs OR."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E2B4?[/INST]address              $E2B4          TAN
Perform TAN

This routine evaluates the tangent of the number in FAC1 (which
represents the angle in radians) by dividing its sine by its cosine.

Location Range: 58080-58125 ($E2E0-$E30D)
Table of Constants for Evaluation of SIN, COS, and TAN"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E200?[/INST]address              $E200
Skip Comma and Get Integer in .X

This subroutine is used to skip the comma between parameters and get
the following integer value in the .X register."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AC06?[/INST]address         $AC06          READ
Perform READ

This routine includes the READ command and common code for GET and
INPUT.  The READ command locates the next piece of DATA, reads the
text, and converts it to the appropriate type of data to be assigned
to a numeric or string variable."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E56C?[/INST]address              $E56C
Set Pointer to Current Screen Line

This routine sets the pointer PNT (209, $D1) to the address of the
first byte of the current logical line.  In figuring this address, it
takes into account the status of the screen line link table, which can
indicate that two physical lines should be joined as one logical line."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B1D1?[/INST]address         $B1D1          ISARY
Find Array Element or Create New Array in RAM

This routine searches for an array.  If it is found, the subscript
value is checked to see if it is valid, and pointers to the array and
element of the array are set.  If it is not found, the array is
created, and the pointers set."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FE18?[/INST]address              $FE18          SETMSG
Set the Message Control Flag

This documented Kernal routine can be entered through its jump table
vector at 65424 ($FF90).

The routine controls the printing of error messages and control
messages by the Kernal.  It Bit 6 is seto to 1 (bit value of 64),
Kernal control messages can be printed.  These messages include
SEARCHING FOR, LOADING, and the like.  If Bit 6 is cleared to 0, these
messages will not be printed (BASIC will clear this bit when a program
is running so that the messages do not appear when I/O is performed
from a program).  Setting Bit 6 will not suppress the PRESS PLAY ON
TAPE or PRESS PLAY & RECORD messages, however.

If Bit 7 is set to 1 (bit value of 128), Kernal error messages can be
printed.  If Bit 7 is set to 0, those error messages (for example, I/O
ERROR #nn) will be suppressed.  Note that BASIC has its own set of
error messages (such as FILE NOT FOUND ERROR) which it uses in
preference to the Kernal's message."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BF?[/INST]address           $BF            MYCH
Tape Input Byte Buffer

This is used by the tape routines as a work area in which incoming
characters area assembled."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D1-$D2?[/INST]address       $D1-$D2        PNT
Pointer to the Address of the Current Screen Line

This location points to the address in screen RAM of the first column
of the logical line upon which the cursor is currently positioned."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FE72?[/INST]address              $FE72
NMI RS-232 Handler

This is the part of the NMI handler that checks if it is time to
receive or send a bit on the RS-232 channel, and takes the appropriate
action if it is indeed the time."
"[INST]In the context of the C64, What is the purpose of the memory location at address $100-$1FF?[/INST]address       $100-$1FF
Microprocessor Stack Area

Locations 256-511 are reserved for the 6510 microprocessor hardware
stack.  The organization of this temporary storage area has often been
compared to that of a push-down stack of trays at a cafeteria.  The
first number placed on the stack goes to the bottom, and subsequent
entries are placed on top of it.  Then you pull a number off the
stack, you come up with the last number that was pushed on (such a
stack is called a Last In, First Out, or LIFO stack).

The stack is controlled by one of the microprocessor registers called
the Stack Pointer, which keeps track of the last stack location used.
The first number placed on the stack goes to location 511 ($1FF), and
subsequent entries are built downward toward 256 ($100).  If more than
256 numbers are pushed onto the stack, the Stack Pointer will start
counting from 0 again, and an overflow error will result.  Likewise,
if you try to pull more items off the stack than have been pushed on,
an underflow error will result.  Most often, such errors will cause
the system to go haywire, and nothing will operate until you turn the
power off and on again.

The stack is used by the system to keep track of the return addresses
of machine language subroutines and interrupt calls and to save the
contents of internal registers.  The stack can also be used by the
programmer for temporary storage.  BASIC and the Kernal make heavy use
of the stack.

Microsoft BASIC uses part of the stack for a temporary work area.
Therefore, the stack may be broken down into the following subregions:"
"[INST]In the context of the C64, What is the purpose of the memory location at address $35-$36?[/INST]address         $35-$36        FRESPC
Temporary Pointer for Strings

This is used as a temporary pointer to the most current string added
by the routines which build strings or move them in memory."
"[INST]In the context of the C64, What is the purpose of the memory location at address $10?[/INST]address            $10            SUBFLG
Flag: Subscript Reference to an Array or User-Defined Function Call (FN)

This flag is used by the PTRGET routine which finds or creates a
variable, at the time it checks whether the name of a variable is
valid.  If an opening parenthesis is found, this flag is set to
indicate that the variable in question is either an array variable or
a user-defined function.

You should note that it is perfectly legal for a user-defined function
(FN) to have the same name as a floating point variable.  Moreover, it
is also legal to redefine a function.  Using a FN name in an already
defined function results in the new definition of the function."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B4F4?[/INST]address         $B4F4          GETSPA
Allocate Space in Memory for String

The amount of space needed for a string is passed to this routine, and
the routine checks if there is that amount of space available in free
memory.  If not, it does a garbage collection and tries again."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC08?[/INST]address              $DC08          TODTEN
Time of Day Clock Tenths of Seconds

Bits 0-3:  Time of Day tenths of second digit (BCD)
Bits 4-7:  Unused"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC0E?[/INST]address              $DC0E          CIACRA
Control Register A

Bit 0:  Start Timer A (1=start, 0=stop)
Bit 1:  Select Timer A output on Port B (1=Timer A output appears on Bit 6 of
        Port B)
Bit 2:  Port B output mode (1=toggle Bit 6, 0=pulse Bit 6 for one cycle)
Bit 3:  Timer A run mode (1=one-shot, 0=continuous)
Bit 4:  Force latched value to be loaded to Timer A counter (1=force load
        strobe)
Bit 5:  Timer A input mode (1=count microprocessor cycles, 0=count signals on
        CNT line at pin 4 of User Port)
Bit 6:  Serial Port (56332, $DC0C) mode (1=output, 0=input)
Bit 7:  Time of Day Clock frequency (1=50 Hz required on TOD pin, 0=60 Hz)

Bits 0-3.  This nybble controls Timer A.  Bit 0 is set to 1 to start
the timer counting down, and set to 0 to stop it.  Bit 3 sets the
timer for one-shot or continuous mode.

In one-shot mode, the timer counts down to 0, sets the counter value
back to the latch value, and then sets Bit 0 back to 0 to stop the
timer.  In continuous mode, it reloads the latch value and starts all
over again.

Bits 1 and 2 allow you to send a signal on Bit 6 of Data Port B when
the timer counts.  Setting Bit 1 to 1 forces this output (which
overrides the Data Direction Register B Bit 6, and the normal Data
Port B value).  Bit 2 allows you to choose the form this output to Bit
6 of Data Port B will take.  Setting Bit 2 to a value of 1 will cause
Bit 6 to toggle to the opposite value when the timer runs down (a
value of 1 will change to 0, and a value of 0 will change to 1).
Setting Bit 2 to a value of 0 will cause a single pulse of a one
machine-cycle duration (about a millionth of a second) to occur.

Bit 4.  This bit is used to load the Timer A counter with the value
that was previously written to the Timer Low and High Byte Registers.
Writing a 1 to this bit will force the load (although there is no data
stored here, and the bit has no significance on a read).

Bit 5.  Bit 5 is used to control just what it is Timer A is counting.
If this bit is set to 1, it counts the microprocessor machine cycles
(which occur at the rate of 1,022,730 cycles per second).  If the bit
is set to 0, the timer counts pulses on the CNT line, which is
connected to pin 4 of the User Port.  This allows you to use the CIA
as a frequency counter or an event counter, or to measure pulse width
or delay times of external signals.

Bit 6.  Whether the Serial Port Register is currently inputting or
outputting data (see the entry for that register at 56332 ($DC0C) for
more information) is controlled by this bit.

Bit 7.  This bit allows you to select from software whether the Time
of Day Clock will use a 50 Hz or 60 Hz signal on the TOD pin in order
to keep accurate time (the 64 uses a 60 Hz signal on that pin)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B78B?[/INST]address         $B78B          ASC
Perform ASC

This routine gets the first character of the string in the .Y register
(if it's not a null string).  Then it calls the part of POS that
converts a one- byte integer in .Y to a floating point number."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC02?[/INST]address              $DC02          CIDDRA
Data Direction Register A

Bit 0:  Select Bit 0 of Data Port A for input or output (0=input, 1=output)
Bit 1:  Select Bit 1 of Data Port A for input or output (0=input, 1=output)
Bit 2:  Select Bit 2 of Data Port A for input or output (0=input, 1=output)
Bit 3:  Select Bit 3 of Data Port A for input or output (0=input, 1=output)
Bit 4:  Select Bit 4 of Data Port A for input or output (0=input, 1=output)
Bit 5:  Select Bit 5 of Data Port A for input or output (0=input, 1=output)
Bit 6:  Select Bit 6 of Data Port A for input or output (0=input, 1=output)
Bit 7:  Select Bit 7 of Data Port A for input or output (0=input, 1=output)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC03?[/INST]address              $DC03          CIDDRB
Data Direction Register B

Bit 0:  Select Bit 0 of Data Port B for input or output (0=input, 1=output)
Bit 1:  Select Bit 1 of Data Port B for input or output (0=input, 1=output)
Bit 2:  Select Bit 2 of Data Port B for input or output (0=input, 1=output)
Bit 3:  Select Bit 3 of Data Port B for input or output (0=input, 1=output)
Bit 4:  Select Bit 4 of Data Port B for input or output (0=input, 1=output)
Bit 5:  Select Bit 5 of Data Port B for input or output (0=input, 1=output)
Bit 6:  Select Bit 6 of Data Port B for input or output (0=input, 1=output)
Bit 7:  Select Bit 7 of Data Port B for input or output (0=input, 1=output)

Location Range: 56324-56327 ($DC04-$DC07)
Timers A and B Low and High Bytes

These four timer registers (two for each timer) have different
functions depending on whether you are reading from them or writing to
them.  When you read from these registers, you get the present value
of the Timer Counter (which counts down from its initial value to 0).
When you write data to these registers, it is stored in the Timer
Latch, and from there it can be used to load the Timer Counter using
the Force Load bit of Control Register A or B (see 56334-5 ($DC0E-F)
below).

These interval timers can hold a 16-bit number from 0 to 65535, in
normal 6510 low-byte, high-byte format (VALUE=LOW BYTE+256*HIGH BYTE).
Once the Timer Counter is set to an initial value, and the timer is
started, the timer will count down one number every microprocessor
clock cycle.  Since the clock speed of the 64 (using the American NTSC
television standard) is 1,022,730 cycles per second, every count takes
approximately a millionth of a second.  The formula for calculating
the amount of time it will take for the timer to count down from its
latch value to 0 is:

TIME=LATCH VALUE/CLOCK SPEED

where LATCH VALUE is the value written to the low and high timer
registers (LATCH VALUE=TIMER LOW+256*TIMER HIGH), and CLOCK SPEED is
1,022,370 cycles per second for American (NTSC) standard television
monitors, or 985,250 for European (PAL) monitors.

When Timer Counter A or B gets to 0, it will set Bit 0 or 1 in the
Interrupt Control Register at 56333 ($DC0D).  If the timer interrupt
has been enabled (see 56333 ($DC0D)), an IRQ will take place, and the
high bit of the Interrupt Control Register will be set to 1.
Alternately, if the Port B output bit is set, the timer will write
data to Bit 6 or 7 of Port B.  After the timer gets to 0, it will
reload the Timer Latch Value, and either stop or count down again,
depending on whether it is in one-shot or continuous mode (determined
by Bit 3 of the Control Register).

Although usually a timer will be used to count the microprocessor
cycles, Timer A can count either the microprocessor clock cycles or
external pulses on the CTN line, which is connected to pin 4 of the
User Port.

Timer B is even more versatile.  In addition to these two sources,
Timer B can count the number of times that Timer A goes to 0.  By
setting Timer A to count the microprocessor clock, and setting Timer B
to count the number of times that Timer A zeros, you effectively link
the two timers into one 32-bit timer that can count up to 70 minutes
with accuracy within 1/15 second.

In the 64, CIA #1 Timer A is used to generate the interrupt which
drives the routine for reading the keyboard and updating the software
clock.  Both Timers A and B are also used for the timing of the
routines that read and write tape data.  Normally, Timer A is set for
continuous operation, and latched with a value of 149 in the low byte
and 66 in the high byte, for a total Latch Value of 17045.  This means
that it is set to count to 0 every 17045/1022730 seconds, or
approximately 1/60 second.

For tape reads and writes, the tape routines take over the IRQ
vectors.  Even though the tape write routines use the on-chip I/O port
at location 1 for the actual data output to the cassette, reading and
writing to the cassette uses both CIA #1 Timer A and Timer B for
timing the I/O routines."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC0F?[/INST]address              $DC0F          CIACRB
Control Register B

Bit 0:  Start Timer B (1=start, 0=stop)
Bit 1:  Select Timer B output on Port B (1=Timer B output appears on
        Bit 7 of Port B)
Bit 2:  Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one
        cycle)
Bit 3:  Timer B run mode (1=one-shot, 0=continuous)
Bit 4:  Force latched value to be loaded to Timer B counter (1=force
        load strobe)
Bits 5-6:  Timer B input mode
           00 = Timer B counts microprocessor cycles
           01 = Count signals on CNT line at pin 4 of User Port
           10 = Count each time that Timer A counts down to 0
           11 = Count Timer A 0's when CNT pulses are also present
Bit 7:  Select Time of Day write (0=writing to TOD registers sets
        alarm, 1=writing to TOD registers sets clock)

Bits 0-3.  This nybble performs the same functions for Timer B that
Bits 0-3 of Control Register A perform for Timer A, except that Timer
B output on Data Port B appears at Bit 7, and not Bit 6.

Bits 5 and 6.  These two bits are used to select what Timer B counts.
If both bits are set to 0, Timer B counts the microprocessor machine
cycles (which occur at the rate of 1,022,730 cycles per second).  If
Bit 6 is set to 0 and Bit 5 is set to 1, Timer B counts pulses on the
CNT line, which is connected to pin 4 of the User Port.  If Bit 6 is
set to 1 and Bit 5 is set to 0, Timer B counts Timer A underflow
pulses, which is to say that it counts the number of times that Timer
A counts down to 0.  This is used to link the two numbers into one
32-bit timer that can count up to 70 minutes with accuracy to within
1/15 second.  Finally, if both bits are set to 1, Timer B counts the
number of times that Timer A counts down to 0 and there is a signal on
the CNT line (pin 4 of the User Port).

Bit 7.  Bit 7 controls what happens when you write to the Time of Day
registers.  If this bit is set to 1, writing to the TOD registers sets
the ALARM time.  If this bit is cleared to 0, writing to the TOD
registers sets the TOD clock.

Location Range: 56336-56575 ($DC10-$DCFF)
CIA #1 Register Images

Since the CIA chip requires only enough addressing lines to handle 16
registers, none of the higher bits are decoded when addressing the
256-byte area that has been assigned to it.  The result is that every
16-byte area in this 256-byte block is a mirror of every other.  Even
so, for the sake of clarity in your programs it is advisable to use
the base address of the chip, and not use the higher addresses to
communicate with the chip."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B79B?[/INST]address         $B79B          GETBYTC
Input a Parameter Whose Value Is Between 0 and 255

This routine reads numeric ASCII program text, converts it to an
integer, checks that it is in the range 0-255, and stores it in the .X
register.  This routine can be useful for reading parameters from a
USR statement or new commands."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B526?[/INST]address         $B526          GARBAG
String Garbage Collection

Whenever a string is changed in any way, the revised version of the
text is added to the bottom of the string text area, leaving the old
version higher up in memory, wasting space.

In order to reclaim that space, the descriptor for every string whose
text is in the string text area (rather than in the program text area)
must be searched to find the valid text that is highest in memory.  If
that string is not as high as it could be, it is moved up to replace
any string that is no longer valid.  Then all of the string
descriptors must be searched again to find the next highest string and
move it up.  This continues until every string that is un use has been
covered.  After all have been moved up, the pointer to the bottom of
string text at 51-52 ($33-$34) is changed to show the new bottom
location.

If there are more than a few strings whose text is in the string text
storage area, rather than in the body of the program, scanning every
string as many times as there are strings can take an awful lot of
time.  The computer may seem as if it had died (the STOP key is not
even checked during the procedure).

The collection will take about as long whether there is any spare
space or not; the full collection will be done even if it is done
immediately after the last collection.  Although the increased memory
capacity of the 64 helps to forestall the need for garbage collection,
a large program with many string arrays may still experience lengthy
collection delays."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC09?[/INST]address              $DC09          TODSEC
Time of Day Clock Seconds

Bits 0-3:  Second digit of Time of Day seconds (BCD)
Bits 4-6:  First digit of Time of Day seconds (BCD)
Bit 7:  Unused"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F?[/INST]address            $F             GARBFL
Flag for LIST, Garbage Collection, and Program Tokenization

The LIST routine uses this byte as a flag to let it know when it has
come to a character string in quotes.  It will then print the string,
rather than search it for BASIC keyword tokens.

The garbage collection routine uses this location as a flag to
indicate that garbage collection has already been tried before adding
a new string.  If there is still not enough memory, an OUT OF MEMORY
message will result.

This location is also used as a work byte for the process of
converting a line of text in the BASIC input buffer (512, $200) into a
linked program line of BASIC keyword tokens."
"[INST]In the context of the C64, What is the purpose of the memory location at address $33-$34?[/INST]address        $33-$34        FREETOP
Pointer to the Bottom of the String Text Storage Area

This pointer marks the current end of the string text area, and the
top of free RAM (strings are built from the top of memory downward).
Additional string texts are added, to the area below the address
pointed to here.  After they are added, this pointer is lowered to
point below the newly added string text.  The garbage collection
routine (which is also called by FRE) readjusts this pointer upward.

While the power-on/reset routines set this pointer to the top of RAM,
the CLR command sets this pointer to the end of BASIC memory, as
indicated in location 55 ($37).  This allows the user to set aside an
area of BASIC memory that will not be disturbed by the program, as
detailed at location 55 ($37)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $100-$10A?[/INST]address       $100-$10A
Work Area for Floating Point to String Conversions

Used in the conversion of numbers to the equivalent ASCII digits, and
in scanning strings."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D3?[/INST]address          $D3            PNTR
Cursor Column on Current Line

The number contained here is the cursor column position within the
logical line pointed to by 209 ($D1).  Since a logical line can
contain up to two physical lines, this value may be from 0 to 79 (the
number here is the value returned by the POS function)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FEC2?[/INST]address              $FEC2
RS-232 Baud Rate Tables for U.S. Television Standard (NTSC)

This table contains the ten prescaler values for the ten standard baud
rates implemented by the RS-232 Control Register at 659 ($293).  The
table starts with the two values needed for the lowest baud rate (50
baud) and finishes with the entries for the highest baud rate, 2400
baud.  The RS-232 routines are handled by NMI interrupts which are
caused by the timers on CIA #2.  Since the RS-232 device could both
receive and send a bit in a single cycle, the time between interrupts
should be a little less than half of the clock frequency divided by
the baud rate.  The exact formula used is:

((CLOCK/BAUD)/2)-100

where CLOCK is the processor clock speed and BAUD is the baud rate.
The clock frequency for machines using the U.S. television standard
(NTSC) is 1,022,730 cycles per second, while the frequency for the
European (PAL) standard is 985,250 cycles per second.  For this
reason, separate baud rate tables were added for European machines at
58604 ($E4EC)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E21?[/INST]address              $E21           SETTMO
Set Time-Out Flag for IEEE Bus

This documented Kernal routine can be entered fromthe jump table at
65442 ($FFA2).

The routine sets the time-out flag for the IEEE bus.  When timeouts
are enabled, the Commodore will wait for a device for 64 milliseconds,
and if it does not receive a response to its signal it will issue a
time-out error.  Loading the Accumulator with a value less than 128
and calling this routine will enable time-outs, while using a value
over 128 will disable time-outs.

This routine is for use only with the Commodore IEEE add-on card,
which at the time of this writing was not yet available."
"[INST]In the context of the C64, What is the purpose of the memory location at address $C0?[/INST]address           $C0            CAS1
Tape Motor Interlock

This location is maintained by the IRQ interrupt routine that scans
the keyboard.  Whenever a button is pressed on the recorder, this
location is checked.  If it contains a 0, the motor is turned on by
setting Bit 5 of location 1 to 0.  When the button is let up, the tape
motor is turned off, and this location is set to 0.

Since the interrupt routine is executed 60 times per second, you will
not be able to keep the motor bit set to keep the motor on if no
buttons are pushed.  Likewise, if you try to turn the motor off when a
button is pressed and this location is set to 0, the interrupt routine
will turn it back on.

To control the motor via software, you must set this location to a
nonzero value after one of the buttons on the recorder has been
pressed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B1BF?[/INST]address         $B1BF          AYINT
Convert a Floating Point Number to a Signed Integer

This subroutine first checks to make sure that the number in the
Floating Point Accumulator is between 32767 and -32768.  If it is not,
an ILLEGAL QUANTITY error results.  If it is, the routine converts it
to a 16-bit signed integer with the high byte in location 100 ($64),
and the low byte in location 101 ($65)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E5A0?[/INST]address              $E5A0
Set Default I/O Devices and Set Default Values for VIC-II Chip
Registers

This routine sets the keyboard and screen as the current input and
output devices.  It then writes the default values found in the table
at 60601 ($ECB9) to the VIC-II chip."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E206?[/INST]address              $E206
Fetch Current Character and Check for End of Line

This subroutine gets the current character, and if it is 0 (end of
line), it pulls its own return address off the stack and returns.
This terminates both its own execution and that of the subroutine
which called it."
"[INST]In the context of the C64, What is the purpose of the memory location at address $ACFC?[/INST]address         $ACFC          EXIGNT
ASCII Text for Input Error Messages

The text stored here is ?EXTRA IGNORED and ?REDO FROM START, each
followed by a carriage return and a zero byte."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AFE9?[/INST]address         $AFE9          ANDOP
Perform AND

The AND routine changes the parameters to two-byte integer values, and
performs the appropriate logical operation (AND or OR).  A result of 0
signifies false, while a result of -1 signifies true."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E2E0?[/INST]address              $E2E0          PI2
The Five-Byte Floating Point Representation of the Constant PI/2"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E4DA?[/INST]address              $E4DA
Clear Color RAM to the Color in Background Color Register 0

This routine is a patch added to the more recent versions of the
Kernal.  It is called by the routine which clears a screen line
(59903, $E9FF), and it places the color value in Background Color
Register 0 (53281, $D021) into the current byte of Color RAM pointed
to by USER (243, $F3).

In the original version of the Kernal, the routine that cleared a
screen line set the corresponding Color RAM to a value of 1, which
gives text characters a white foreground color.  This was changed when
the white color was found to sometimes cause light flashes during
screen scrolling.  It was that white foreground color, however, that
enabled the user to POKE the screen code for a character into screen
RAM, and make that character appear on the screen in a color that
contrasted the blue background.  This change to the Operating System
causes colors POKEd to screen RAM to be the same color as the
background, and thus they are invisible.

This is a fairly serious problem, because the technique of POKEing
characters to screen RAM has long been a staple of Commodore graphics
programming.  Fortunately, the problem has an easy colution.  Since
the Color RAM will be set to whatevere color is in Background Color
Register 0, what you have to do to initialize Color RAM to the color
you desire is change the background color to the desired foreground
color, clear the screen, and then change the background color back
again:

C=PEEK(53281):POKE 53281,HUE:PRINT CHR$(147):POKE 53281,C"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E30E?[/INST]address              $E30E          ATN
Perform ATN

The arc tangent of the number in FAC1 (which represents the angle in
radians) is evaluated using the 12-term series of operations from the
constant table which follows.  The answer is left in FAC1."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AF08?[/INST]address         $AF08          SNERR
Print Syntax Error Message"
"[INST]In the context of the C64, What is the purpose of the memory location at address $AE83?[/INST]address         $AE83          EVAL
Convert a Single Numeric Term from ASCII Text to a Floating Point
Number

This routine reduces a single arithmetic term which is part of an
expression from ASCII text to its floating point equivalent.

If the term is a constant, the routine sets the data type flag to
number, sets the text pointer to the first ASCII numeric character,
and jumps to the routine which converts the ASCII string to a floating
point number.

If the term is a variable, the variable value is retrieved.  If it is
the PI character, the value of PI is moved into the Floating Point
Accumulator.

This routine is vectored through RAM at 778 ($30A)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E1BE?[/INST]address              $E1BE          OPEN
Perform OPEN

The BASIC OPEN statement calls the Kernal OPEN routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B3E1?[/INST]address         $B3E1          GETFNM
Check DEF and FN Syntax

This routine checks to make sure that FN follow SEG, and that the
dependent variable has a valid floating point variable name.  It calls
the routine to find or create a variable to get the pointer to its
address."
"[INST]In the context of the C64, What is the purpose of the memory location at address $283-284?[/INST]address       $283-284       MEMSIZ
Pointer: O.S. End of Memory

When the power is first turned on, or a cold start RESET is performed,
the Kernal routine RAMTAS (64848, $FD50) performs a nondestructive
test of RAM from 1024 ($400) up, stopping when the test fails,
indicating the presence of ROM.  This will normally occur at 40960
($A000), the location of the BASIC ROM.  The top of user RAM pointer
is then set to point to that first ROM location.

After BASIC has been started, the system will alter this location only
when an RS-232 channel (device number 2) is OPENed or CLOSEd.  As 512
bytes of memory are required for the RS-232 transmission and reception
buffers, this pointer, as well as the end of BASIC pointer at 55
($37), is lowered to create room for those buffers when the device is
opened.  CLOSing the device resets these pointers.

The Kernal routine MEMTOP (65061, $FE25) may be used to read or set
this pointer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $C7?[/INST]address          $C7            RVS
Flag: Print Reverse Characters? 0=No

When the [CTRL][RVS-ON] characters are printer (CHR$(18)), this flag
is set to 18 ($12), and the print routines will add 128 ($80) to the
screen code of each character which is printed, so that the caracter
will appear on the screen with its colors reversed.

POKEing this location directly with a nonzero number will achieve the
same results.  You should remember, however, that the contents of this
location are returned to 0 not only upon entry of a [CTRL][RVS-OFF]
character (CHR$(146)), but also at every carriage return.  When this
happens, characters printed thereafter appear with the normal
comination of colors."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FDF9?[/INST]address              $FDF9          SETNAM
Set Filename Parameters

This is a documented Kernal routine, which can be entered through the
jump table at location 65469 ($FFBD).

It puts the value in the Accumulator into the location which stores
the number of characters in the filename, and sets the pointer to the
address of the ASCII text of the filename from the .X and .Y
registers.  This sets up the filename for the OPEN, LOAD, or SAVE
routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FF5B?[/INST]address              $FF5B          CINT
Initialize Screen Editor and VIC-II Chip

This is a documented Kernal routine whose entry in the jump table is
located at 65409 ($FF81).

The start of the routine appears to be a patch that was added to later
versions of the Kernal.  It first calls the old routine at 58648
($E518).  This initializes the VIC-II chip to the default values, sets
the keyboard as the input device and the screen as the output device,
initializes the cursor flash variables, builds the screen line link
table, clears the screen, and homes the cursor.  The new code then
checks the VIC Interrupt register to see if the conditions for a
Raster Compare IRQ have been fulfilled.  Since the Raster Register was
initialized to 311, that can only occur when using a PAL system (NTSC
screens do not have that many scan lines).  The PAL/NTSC register at
678 ($2A6) is set on the basis of the outcome of this test.  The CIA
#1 Timer A is then set to cause an IRQ interrupt every sixtieth of a
second, using the prescaler figures for a PAL or NTSC system, as
appropriate."
"[INST]In the context of the C64, What is the purpose of the memory location at address $CE?[/INST]address           $CE            GDBLN
Character Under Cursor

The cursor is formed by printing the inverse of the character that
occupies the cursor position.  If that characters is the letter A, for
example, the flashing cursor merely alternates between printing an A
and a reverse-A.  This location keeps track of the normal screen code
of the character that is located at the cursor position, so that it
may be restored when the cursor moves on."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B?[/INST]address           $B             COUNT
Index into the Text Input Buffer/Number of Array Subscripts

The routines that convert the text in the input buffer at 512 ($200)
into lines of executable program tokes, and the routines that link
these program lines together, use this location as an index into the
input buffer area.  When the job of converting text to tokens is
finished, the value in this location is equal to the length of the
tokenized line.

The routines which build an array or locate an element in an array use
this location to calculate the number of DIMensions called for and the
amount of storage required for a newly created array, or the number of
subscripts specified when referencing an array element."
"[INST]In the context of the C64, What is the purpose of the memory location at address $47-$48?[/INST]address         $47-$48        VARPNT
Pointer to the Current BASIC Variable Value

This location points to the address of the descriptor of the current
BASIC variable (see location 45 ($2D) for the format of a variable
descriptor).  Specifically, it points to the byte just after the
two-character variable name.

During a FN call, this location does not point to the dependent
variable (the A of FN A), so that a real variable of the same name
will not have its value changed by the call."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D41A?[/INST]address              $D41A          POTY
Read Game Paddle 2 (or 4) Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC05?[/INST]address              $DC05          TIMAHI
Timer A (high byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B67A?[/INST]address         $B67A          MOVINS
Move a String in Memory

This is the routine which is used to move a string to the bottom of
the string text area for the above routine.  It is generally used as a
utility routine to move strings."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B737?[/INST]address         $B737          MIDD
Perform MID$

MID$ manipulates its parameters so that the tail end of LEFT$ can be
used to create a temporary string descriptor for a new string.  This
new string contains the number of characters from the position in the
middle of the string that is specified in the command."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD02?[/INST]address              $DD02          C2DDRA
Data Direction Register A

Bit 0:  Select Bit 0 of data Port A for input or output (0=input, 1=output)
Bit 1:  Select Bit 1 of data Port A for input or output (0=input, 1=output)
Bit 2:  Select Bit 2 of data Port A for input or output (0=input, 1=output)
Bit 3:  Select Bit 3 of data Port A for input or output (0=input, 1=output)
Bit 4:  Select Bit 4 of data Port A for input or output (0=input, 1=output)
Bit 5:  Select Bit 5 of data Port A for input or output (0=input, 1=output)
Bit 6:  Select Bit 6 of data Port A for input or output (0=input, 1=output)
Bit 7:  Select Bit 7 of data Port A for input or output (0=input, 1=output)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B72C?[/INST]address         $B72C          RIGHTD
Perform RIGHT$

RIGHT$ manipulates its parameters so that the tail end of LEFT$ can be
used to create a temporary string descriptor for a new string.  This
new string contains the number of characters from the right side of
the string that is specified in the command."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD01?[/INST]address              $DD01          CI2PRB
Data Port B

Bit 0:  RS-232 data input (SIN)/ Pin C of User Port
Bit 1:  RS-232 request to send (RTS)/ Pin D of User Port
Bit 2:  RS-232 data terminal ready (DTR)/ Pin E of User Port
Bit 3:  RS-232 ring indicator (RI)/ Pin F of User Port
Bit 4:  RS-232 carrier detect (DCD)/ Pin H of User Port
Bit 5:  Pin J of User Port
Bit 6:  RS-232 clear to send (CTS)/ Pin K of User Port
        Toggle or pulse data output for Timer A
Bit 7:  RS-232 data set ready (DSR)/ Pin L of User Port
        Toggle or pulse data output for Timer B

Location Range: 56578-56579 ($DD02-$DD03)
CIA #2 Data Direction Registers A and B

These Data Direction registers control the direction of data flow over
Data Ports A and B.  For more details on the operation of these
registers, see the entry for the CIA #1 Data Direction Registers at
56322 ($DC02).

The default setting for Data Direction Register A is 63 (all bits
except 6 and 7 are outputs), and for Data Direction Register B the
default setting is 0 (all inputs).  Bits 1 and 2 of Port B are changed
to output when the RS-232 device is opened."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC04?[/INST]address              $DC04          TIMALO
Timer A (low byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B63D?[/INST]address         $B63D          CAT
Concatenate Two Strings

This routine is used to add the text of one string onto the end of
another (A$+B$).  Error checking is done to see if the length of the
combined string is within range, the allocation routine is called to
allocate space, and the new string is built at the bottom of the
string text area."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D419?[/INST]address              $D419          POTX
Read Game Paddle 1 (or 3) Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $49-$4A?[/INST]address         $49-$4A        FORPNT
Temporary Pointer to the Index Variable Used by FOR

The address of the BASIC variable which is the subject of a FOR/NEXT
loop is first stored here, but is then pushed onto the stack.  That
leaves this location free to be used as a work area by such statements
as INPUT, GET, READ, LIST, WAIT, CLOSE, LOAD, SAVE, RETURN, and GOSUB.

For a description of the stack entries made by FOR, see location 256
($100)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $C?[/INST]address            $C             DIMFLG
Flags for the Routines That Locate or Build an Array

This location is used as a flag by the routines that build an array or
reference an existing array.  It is used to determine whether a
variable is in an array, whether the array has already been
DIMensioned, and whether a new array should assume the default
dimensions."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FF48?[/INST]address              $FF48
Main IRQ/BRK Interrupt Entry Point

The 6510 hardware IRQ/BRK vector at 65534 ($FFFE) points to this
address.

Anytime the BRK instruction is encountered or an IRQ interrupt occurs,
this routine will be executed.  The routine first saves the .A, .X,
and .Y registers on the stack, and then tests the BRK bit of the
status register (.P) to see if a BRK was executed.  If it was, the
routine exits through the RAM BRK vector at 790 ($316), where it will
usually be directed to the BRK routine at 65126 ($FE66).  If not, the
routine exits through the RAM IRQ vector at 788 ($314), where it will
usually be directed to the handler that scans the keyboard at 59953
($EA31).

If you plan to change either of these vectors to your own routine,
remember to pull the stored register values off the stack before
finishing.

Location Range: 65371-65407 ($FF5B-$FF7F)
Patches Added to Later Kernal Versions

This area contains additional code not found in the original version
of the Kernal.  It is used to test whether a European (PAL) or U.S.
(NTSC) standard monitor is used, and to compensate so that the
sixtieth of a second interrupt will be accurately timed on either
system."
"[INST]In the context of the C64, What is the purpose of the memory location at address $CD?[/INST]address          $CD            BLNCT
Timer: Countdown to Blink Cursor

The interrupt routine that blinks the cursor uses this location to
tell when it's time for a blink.  First the number 20 is put here, and
every jiffy (1/60 second) the value here is decreased by one, until it
reaches zero.  Then the cursor is blinked, the number 20 is put back
here, and the cycle starts all over again.  Thus, under normal
circumstances, the cursor blinks three times per second."
"[INST]In the context of the C64, What is the purpose of the memory location at address $C6?[/INST]address           $C6            NDX
Number of Characters in Keyboard Buffer (Queue)

The value here indicates the number of charracters waiting in the
keyboard buffer at 631 ($277).  The maximum number of characters in
the keyboard buffer at any one time is determined by the value in
location 649 ($289), which defaults to 10.

If INPUT or GET is executed while there are already characters in the
buffer, those characters will be read as part of the data stream.  You
can prevent this by POKEing a 0 to this location before those
operations, which will always cause any character in the buffer to be
ignored.  This technique can be handy when using the joystick in
Controller Port #1, which sometimes causes fake keypresses to be
registered, placing unwanted characters in the keyboard buffer.

Not only is this location handy for taking unwanted characters out of
the keyboard buffer, but it can also be used to put desired characters
into the buffer, and thus to program the keyboard buffer.  This
technique (dynamic keyboard) allows you to simulate keyboard input in
direct mode from a program.

The dynamic keyboard technique is an extremely useful one, as it
enables you to add, delete, or modify program lines while the program
is running.  The basic scheme is to POKE the PETASCII character values
that you wish to be printed (including cursor control characters and
carriage returns) into the buffer.  Then, when an END statement is
executed, the characters in the buffer will be printed, and entered by
the carriage return.

This technique can help with the problem of trying to use data
separation and terminator characters with INPUT statements.  If you
try to INPUT a string that has a comma or colon, the INPUT will read
only up to that character and issue an EXTRA IGNORED error message.
You can avoid this by entering the input string in quotes, but this
places on the user the burder of remembering the quote marks.  One
solution is to use the statements:

POKE 198,3:POKE 631,34: POKE 632,34: POKE 633,20

before the input.  This will force two quote marks and a delete into
the buffer.  The first quote mark allows the comma or colon to be
INPUT, the second is used to get the editor out of quote mode, and the
delete removes that second quote.

For more specific information and programming examples, see the
description of location 631 ($277), the keyboard buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FDA3?[/INST]address              $FDA3          IOINIT
Initialize CIA I/O Devices

This documented Kernal routine, which can be entered through the jump
table at 65412 ($FF84), intializes the Complex Interface Adapter (CIA)
devices, and turns the volume of the SID chip off.  As part of this
initialization, it sets CIA #1 Timer A to cause an IRQ interrupt every
sixtieth of a second."
"[INST]In the context of the C64, What is the purpose of the memory location at address $281-282?[/INST]address       $281-282       MEMSTR
Pointer: O.S. Start of Memory

When the power is first turned on, or a cold start RESET is performed,
the Kernal routine RAMTAS (64848, $FD50) sets this location to point
to address 2048 ($800).  This indicates that this is the starting
address of user RAM.  BASIC uses this location to set its own start of
memory pointer at location 43 ($2B), and thereafter uses only its own
pointer.

The Kernal routine MEMBOT (65076, $FE34) may be used to read or set
this pointer, or these locations may be directly PEEKed or POKEd from
BASIC."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B3F4?[/INST]address         $B3F4          FNDOER
Perform FN

The FN evaluation is done by evaluating the FN argument (for example,
FN(A+B*C/D)) and then getting the rest of the expression from the text
of the function definition statement.  The function variable
descriptor area is used as a work area, and the dependent variable is
not disturbed (so that if the definition used FN(X), the value of X
will not be changed by the function call)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AD9E?[/INST]address         $AD9E          FRMEVAL
Evaluate Expression

This is the beginning point of a very powerful group of subroutines
which are used extensively by BASIC.

The main purpose of these routines is to read in the ASCII text of
BASIC expressions, separate the operators and terms of the expression,
check them for errors, combine the individual terms by performing the
indicated operations, and obtain a single value which the BASIC
program can use.

This can be a very complex task, and expressions an be of the string
or numeric type, and can contain any type of variable, as well as
constants.

At the end, the flag which shows whether the resulting value is string
or numeric at 13 ($D) is set, and if the value is numeric, the flag at
14 ($E) is set as well, to show if it is an integer or floating point
numer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E168?[/INST]address              $E168          LOAD
Perform LOAD

This routine sets the load address to the start of BASIC (from pointer
at 43 ($2B)), and calls the Kerneal LOAD routine.  If the load is
successful, it relinks the BASIC program so that the links agree with
the address to which it is loaded, and it resets the end of BASIC
pointer to reflect the new end of program text.  If the LOAD was done
while a program was running, the pointers are reset so that the
program starts executing all over again from the beginning.  A CLR is
not performed, so that the variables build so far are retained, and
their values are still accessible.  The pointer to the variable area
is not changed, but if the new program is longer than the one that
loaded it, the variable table will be partially overwritten.  This
will cause errors when the overwritten variables are referenced.
Likewise, strings whose text was referenced at its location within the
original program listing will be incorrect.

Since a LOAD from a program causes the program execution to continue
at the first line, when loading a machine language routine or data
file with a nonrelocating load (for example, LOAD'FILE',8,1) from a
program, you should read a flag and GOTO the line after the LOAD if
you don't want the program to keep rerunning indefinitely:

10 IF FLAG=1 THEN GOTO 30
20 FLAG=1:LOAD'FILE',8,1
30 REM PROGRAM CONTINUES HERE"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E2EF?[/INST]address              $E2EF          SINCON
Table of Constants for Evaluation of SIN, COS, and TAN

This table starts with a counter byte of 5, indicating that there are
six entries in the table.  This is followed by the six floating point
constants of five bytes each."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AEFF?[/INST]address         $AEFF          CHKCOM
Check for and Skip Comma

This syntax checking device is the same in substance as the two
checking routines above.  It is used when the next character should be
a comma.  If it is not, a SYNTAX ERROR retults.  If it is, the
character is skipped and the next character is read.  Any character
can be checked for and skipped this way by loading the character into
the Accumulator and entering this routine from SYNCHR at 44799
($AEFF)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E4B7?[/INST]address              $E4B7
35 Unused Bytes (all have the value of 170 ($AA)

Locaiton Range: 58586-65535 ($E4DA-$FFFF)
Kernal I/O Routines

After the conclusion of BASIC comes the part of this ROM which can be
considered the Kernal proper.  This part contains all of the vectored
routines found in the jump table starting at 65409 ($FF81)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AB4D?[/INST]address         $AB4D          DOAGIN
Error Message Formatting Routines for GET, INPUT, and READ"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E1C7?[/INST]address              $E1C7          CLOSE
Perform CLOSE

The BASIC CLOSE statement calls the Kernal CLOSE routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AD1E?[/INST]address        $AD1E          NEXT
Perform NEXT

NEXT is executed by finding the appropriate FOR data on the stack,
adding the STEP value to the FOR variable, and comparing the result to
the TO value.  If the loop is done, the stack entries for that FOR
command are removed from the stack.  If the loop hasn't reached its
limit, the pointers to the current statement and text character are
updated from the FOR stack entry, which causes execution to continue
with the statement after the FOR statement."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AEF7?[/INST]address         $AEF7          CHKCLS
Check for and Skip Closing Parentheses"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E33E?[/INST]address              $E33E          ATNCON
Table of Constants for ATN Evaluation

The table begins with a count byte of 11, which is followed by 12
constants in five-byte floating point representation."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FC6A?[/INST]address              $FC6A
Write Data fo Cassette--Part 1 (IRQ)

This IRQ handler routine is the other part of the write data to
cassette routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $CF?[/INST]address           $CF            BLNON
Flag: Was Last Curson Blink on or off?

This location keeps track of whether, during the current cursor blink,
the character under the cursor was reversed, or was restored to
normal.  This location will contain a 0 if the character is reversed,
and a 1 if the character is restored to its nonreversed status."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FED6?[/INST]address              $FED6
RS-232 Receive the Next Bit (NMI)

The NMI handler calls this subroutine to input the next bit on the
RS-232 bus.  It then calls the next subroutine to reload the timer
that causes the interrupts."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FD50?[/INST]address              $FD50          RAMTAS
Perform RAM Test and Set Pointers to the Top and Bottom of RAM

This documented Kernal routine, which can be entered through location
65415 ($FF87) of the jump table, performs a number of initialization
tasks.

First, it clears Pages 0, 2, and 3 of memory to zeros.  Next, it sets
the tape buffer pointer to address 828 ($33C), and performs a
nondestructive test of RAM from 1024 ($400) up.  When it reaches a
non-RAM address (presumably the BASIC ROM at 40960 ($A000)), that
address is placed in the top of memory pointer at 643-4 ($283-4).  The
bottom of memory pointer at 641-2 ($281-2) is set to point to address
2048 ($800), which is the beginning of BASIC program text.  Finally,
the pointer to screen memory at 648 ($288) is set to 4, which lets the
Operating System know that screen memory starts at 1024 ($400)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $C8?[/INST]address          $C8            INDX
Pointer: End of Logical Line for Input

This pointer indicates the column number of the last nonblank
character on the logical line that is to be input.  Since a logical
line can be up to 80 characters long, this number can range from 0-79."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E?[/INST]address            $E             INTFLG
Flat: Type of Numeric Data (Integer or Floating Point)

If data which BASIC is using is determined to be numeric, it is
further classified here as either a floating point number or as an
integer.  A 128 ($80) in this location identifies the number as an
integer, and a 0 indicates a floating point number."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BA59?[/INST]address         $BA59          MLTPLY
Multiply a Byte Subroutine

This subroutine is used to repetitively add a mantissa byte of FAC2 to
FAC1 the number of times specified in the .A register."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD03?[/INST]address              $DD03          C2DDRB
Data Direction Register B

Bit 0:  Select Bit 0 of data Port B for input or output (0=input, 1=output)
Bit 1:  Select Bit 1 of data Port B for input or output (0=input, 1=output)
Bit 2:  Select Bit 2 of data Port B for input or output (0=input, 1=output)
Bit 3:  Select Bit 3 of data Port B for input or output (0=input, 1=output)
Bit 4:  Select Bit 4 of data Port B for input or output (0=input, 1=output)
Bit 5:  Select Bit 5 of data Port B for input or output (0=input, 1=output)
Bit 6:  Select Bit 6 of data Port B for input or output (0=input, 1=output)
Bit 7:  Select Bit 7 of data Port B for input or output (0=input, 1=output)

Location Range: 56580-56583 ($DD04-$DD07)
Timer A and B Low and High Bytes

These four timer registers are used to control Timers A and B.  For
details on the operation of these timers, see the entry for Location
Range 56324-56327 ($DC04-$DC07).

The 64 Operating System uses the CIA #2 Timers A and B mostly for
timing RS-232 send and receive operations.  Serial Bus timing uses CIA
#1 Timer B."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B6EC?[/INST]address         $B6EC          CHRD
Perform CHR$

The CHR$ routine creates a descriptor on the temporary string stack
for the one-byte string whose value is specified in the command, and
sets a pointer to that string."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B5BD?[/INST]address         $B5BD
Check for Most Eligible String to Collect

This part of the garbage collection routine checks to see if the
current string is the highest in memory."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC06?[/INST]address              $DC06          TIMBLO
Timer B (low byte)"
"[INST]In the context of the C64, Give explanations about the kernal[/INST]As with the section on the BASIC ROM, this section is not meant to be
a complete explanation of the Kernal ROM, but rather a guidepost for
further exploration.  Where the exact instructions the Kernal ROM
routines use are important to your programming, it will be necessary
for you to obtain a disassembly listing of those routines and look at
the code itself.

Keep in mind that there is 8K of RAM underlying the Kernal ROM that
can be used by turning off interrupts and switching out the Kernal ROM
temporarily.  Even without switching out the Kernal ROM, this RAM may
be read by the VIC-II chip if it is banked to use the top 16K of
memory, and may be used for graphics data.  The Kernal and BASIC ROMs
may be copied to RAM, and the RAM versions modified to change existing
features or add new ones.

There are some differences between the version of the Kernal found on
the first few Commodore 64s and those found on the majority of newer
models.  Those differences are discussed in the entries for the
sections on later Kernal additions (patches) at 58541-58623
($E4AD-$E4FF) an 65371-67407 ($FF5B-$FF7F).

The most obvious change causes the Color RAM at 55296 ($D800) to be
initialized to the background color when the screen is cleared on
newer models, instead of white as on the original models.  Other
changes allow the new Kernal software to be used by either U.S. or
European 64s.  Keep in mind that the Kernal is always subject to
change, and that the following discussion, while accurate at the time
written (mid-1983), may not pertain to later models.  If future
changes are like past ones, however, they are likely to be minor ones.
The first place to look for these changes would be in the patch
sections identified above."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD0F?[/INST]address              $DD0F          CI2CRB
Control Register B

Bit 0:  Start Timer B (1=start, 0=stop)
Bit 1:  Select Timer B output on Port B (1=Timer B output appears on
        Bit 7 of Port B)
Bit 2:  Port B output mode (1=toggle Bit 7, 0=pulse Bit 7 for one
        cycle)
Bit 3:  Timer B run mode (1=one shot, 0=continuous)
Bit 4:  Force latched value to be loaded to Timer B counter (1=force
        load strobe)
Bits 5-6:  Timer B input mode
           00 = Timer B counts microprocessor cycles
           01 = Count signals on CNT line at pin 4 of User Port
           10 = Count each time that Timer A counts down to 0
           11 = Count Timer A 0's when CNT pulses are also present
Bit 7:  Select Time of Day write (0=writing to TOD registers sets
           alarm, 1=writing to ROD registers sets clock)

Location Range: 56592-56831 ($DD10-$DDFF)
CIA #2 Register Images

Since the CIA chip requires only enough addressing lines to handle 16
registers, none of the higher bits are decoded when addressing the
256-byte area that has been assigned to it.  The result is that every
16-byte area in this 256-byte block is a mirror of every other.  For
the sake of clarity in your programs, it is advisable not to use these
addresses.

Location Range: 56832-57087 ($DE00-$DEFF)
Reserved for I/O Expansion

This range of locations is not used directly by the 64's internal
hardware.  It is, however, accessible via pin 7 of the Expansion Port.
It can be used to control cartridges which are connected to this port.
For example, the CP/M module uses this space to control which
microprocessor is in control of the system.  The Z-80 microprocessor
is turned on and off by writing to 56832 ($DE00).

Another cartridge which uses this space is Simon's BASIC.  This 16K
cartridge is addressed at memory locations 32768-49151 ($8000-$BFFF),
which means that it overlaps the regular BASIC ROM at 40960-49151
($A000-$BFFF).  But since it contains additions to BASIC, it must use
the BASIC ROM as well.  This problem is solved by copying the
cartridge at 32768-40959 ($8000-$9FFF) to RAM, and turning the
cartridge on and off by writing to or reading from location 56832
($DE00).

Location Range: 57088-57343 ($DF00-$DFFF)
CIA #2 Register Images

This range of locations is not used directly by the 64's internal
hardward, but is accessible via pin 10 of the Expansion Port.  One
possible use for this I/O memory that Commodore has mentioned is an
inexpensive parallel disk drive (which presumable would be much faster
than the current serial model).

Alternate 53248-57343 ($D000-$DFFF)
Character Generator ROM

The character generator ROM supplies the data which is to form the
shapes of the text and graphics characters that are displayed on the
screen.  Each character requires eight bytes of shape data, and these
eight-byte sequences are arranged in order in which the characters
appear in the screen code chart (see Appendix G).  For example, the
first eight bytes of data in the ROM hold the shape information for
the commercial at sign (@), the next eight hold the shape of the
letter A, etc.  In all, there are 4096 bytes, representing shape data
for two complete character sets of 256 characters each--1K each for
uppercase/graphics, reverse uppercase/reverse graphics, lowercase/
uppercase, and reverse lowercase/reverse uppercase.

The shape of each character is formed by an 8 by 8 matrix of screen
dots.  Whether any of the 64 dots is lit up or not is determined by
the bit patterns of the character data.  Each byte of the Character
ROM holds a number from 0 to 255.  This number can be represented by
eight binary digits of 0 or 1.  The leftmost bit of these eight is
known as Bit 7, while the rightmost bit is called Bit 0.  Each of
these binary digits has a bit value that is two times greater than the
last.  The values of a bit set to 1 in each of the bit places are:

Bit    0    1     2    3    4    5    6    7
Value  1    2     4    8   16   32   64  128

A byte whose value is 255 has every bit set to 1
(128+64+32+16+8+4+2+1=255), while a byte whose value is 0 is made up
of all zero bits.  Numbers in between are made up of combinations of
bits set to 1 and bits set to 0.  If you think of every bit that holds
0 as a dot on the screen which is the color of the screen background,
and every bit that holds a 1 as a dot whose color is that of the
appropriate nybble in Color RAM, you can begin to get an idea of how
the byte values relate to the shape of the character.  For example, if
you PEEK at the first eight bytes of the character ROM (the technique
is explained in the entry for location 1), you will see the numbers
60, 102, 110, 110, 96, 98, 60, 0.  Breaking these data bytes down into
their bit values gives us a picture that looks like the following:

00111100   0 +   0 +  32 +  16 +   8 +   4 +   0 +   0 =  60
01100110   0 +  64 +  32 +   0 +   0 +   4 +   2 +   0 = 101
01101110   0 +  64 +  32 +   0 +   8 +   4 +   2 +   0 = 110
01101110   0 +  64 +  32 +   0 +   8 +   4 +   2 +   0 = 110
01100000   0 +  64 +  32 +   0 +   0 +   0 +   0 +   0 =  96
01100010   0 +  64 +  32 +   0 +   0 +   0 +   2 +   0 =  98
00111100   0 +   0 +  32 +  16 +   8 +   4 +   0 +   0 =  60
00000000   0 +   0 +   0 +   0 +   0 +   0 +   0 +   0 =   0

If you look closely, you will recognize the shape of the commercial at
sign (@) as it's displayed on your screen.  The first byte of data is
60, and you can see that Bits 5, 4, 3, and 2 are set to 1.  The chart
above shows that the bit values for these bits are 32, 16, 8, and 4.
Adding these together, you get 32+16+8+4=60.  This should give you an
idea of how the byte value corresponds to the patterns of lit dots.
For an even more graphic display, type in the following program, which
shows the shape of any of the 512 characters in the ROM, along with
the number value of each byte of the shape.

10 DIM B%(7),T%(7):FOR I=0 TO 7:T%(I)=2^I:NEXT
20 POKE 53281,2:PRINT CHR$(147):POKE 53281,1:POKE 53280,0:POKE 646,11
30 POKE 214,20:PRINT:INPUT' CHARACTER NUMBER (0-511)';C$
40 C=VAL(C$):GOSUB 80:FOR I=0 TO 7
50 POKE 214,6+I:PRINT:PRINT TAB(23);B%(I);CHR$(20);'   '
60 FOR J=7 TO 0 STEP-1:POKE 1319+(7-J)+I*40,32-128*((B%(I)ANDT%(J))=T%(J))
70 NEXT J,I:POKE 214,20:PRINT:PRINT TAB(27)'    ':GOTO 30
80 POKE 56333,127:POKE 1,51:FOR I=0 TO 7
90 B%(I)=PEEK(53248+C*8+I):NEXT:POKE 1,55:POKE 56333,129:RETURN

If you have read about the VIC-II video chip, you know that it can
address only 16K of memory at a time, and that all display data such
as screen memory, character shape data, and sprite shape data must be
stored within that 16K block.

Since it would be very inconvenient for the VIC-II chip to be able to
access the character data only at the 16K block which includes
adresses 53248-57343 ($D000-$DFFF), the 64 uses an addressing trick
that makes the VIC-II chip see an image of the Character ROM at
4096-8191 ($1000-$1FFF) and at 36864-40959 ($9000-$9FFF).  It is not
available in the other two blocks.  To generate characters in these
blocks, you must supply your own user-defined character set, or copy
the ROM data to RAM.  A machine language routine for doing this is
included in a sample program at the entry for 56576 ($DD00).

As indicated above, you are by no means limited to useing the
character data furnished by the ROM.  The availability of user-defined
characters greatly extends the graphics power of the 64.  It allows
you to create special text characters, like math or chemistry symbols
and foreign language alphabets.  You can also develop special graphics
characters as a substitute for plotting points in bitmap graphics.
You can achieve the same resolution using a custom character as in
high-resolution bitmap mode, but with less memory. Once you have
defined the character, it is much faster to print it to the screen
than in would be to plot out all of the individual points.

To employ user-defined characters, you must first pick a spot to put
the shape data.  This requires choosing a bank of 16K for video chip
memory (see the entry under Bits 0-1 of 56576 ($DD00) for the
considerations involved), and setting the pointer to the 2K area of
character memory in 53272 ($D018).  It is then up to you to supply the
shape data for the characters.  You can use part of the ROM character
set by reading the ROM and transferring the data to your character
shape area (see the entry for location 1 for a method of reading the
ROM).

Your original characters may be created by darkening squares on an 8
by 8 grid, converting all darkened squares to their bit values, and
then adding the bit values for each of the eight bytes.  Or, you may
use one of the many character graphics editor programs that are
available commercially to generate the data interactively by drawing
on the screen.

One graphics mode, multicolor text mode, almost requires that you
define your own character set in order to use it effectively.
Multicolor mode is enabled by Bit 4 of location 53270 ($D016).
Instead of using each bit to control whether an individual dot will be
foreground color (1) or background color (0), that mode breaks down
each byte of shape data in four bit-pairs.  These bit pairs control
whether a dot will be the color in Background Color Register #0 (00),
the color in Background Color Register #1 (01), the color in
Background Color Register #2 (10), or the color in the appropriate
nybble of Color RAM (11).  Since each pair of bits controls one dot,
each character is only four dots across.  To make up for this, each
dot is twice as wide as a normal high-resolution dot."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B606?[/INST]address         $B606
Collect a String

This part of the garbage collection routine moves the string to high
memory and updates the descriptor to point to its new location."
"[INST]In the context of the C64, What is the purpose of the memory location at address $DC07?[/INST]address              $DC07          TIMBHI
Timer B (high byte)

Location Range: 56328-56331 ($DC08-$DC0B)
Time of Day Clock (TOD)

In addition to the two general-purpose timers, the 6526 CIA chip has a
special-purpose Time of Day Clock, which keeps time in a format that
humans can understand a little more easily than microseconds.

This Time of Day Clock even has an alarm, which can cause an interrupt
at a specific time.  It is organized in four registers, one each for
hours, minutes, seconds, and tenths of seconds.  Each register reads
out in Binary Coded Decimal (BCD) format, for easier conversion to
ASCII digits.  A BCD byte is divided into two nybbles, each of which
represents a single digit in base 10.  Even though a four-bit nybble
can hold a number from 0 to 15, only the base 10 digits of 0-9 are
used.  Therefore, 10 0'clock would be represented by a byte in the
hours register with the nybbles 0001 and 0000, which stand for the
digits 1 and 0.  The binary value of this byte would be 16 (16 times
the high nybble plus the low nybble).  Each of the other registers
operates in the same manner.  In addition, Bit 7 of the hours register
is used as an AM/PM flag.  If that bit is set to 1, it indicates PM,
and if it is set to 0, the time is AM.

The Time of Day Clock Registers can be used for two purposes,
depending on whether you are reading them or writing to them.  If you
are reading them, you will always be reading the time.  There is a
latching feature associated with reading the hours register in order
to solve the problem of the time changing while you are reading the
registers.  For example, if you were reading the hours register just
as the time was changing from 10:59 to 11:00, it is possible that you
would read the 10 in the hours register, and by the time you read the
minutes register it would have changed from 59 to 00.  Therefore, you
would read 10:00 instead of either 10:59 or 11:00.

To prevent this kind of mistake, the Time of Day Clock Registers stop
updating as soon as you read the hours register, and do not start
again until you read the tenths of seconds register.  Of course, the
clock continues to keep time internally even though it does not update
the registers.  If you want to read only minutes, or seconds or tenths
of seconds, there is no problem, and no latching will occur.  But
anytime you read hours, you must follow it by reading tenths of
seconds, even if you don't care about them, or else the registers will
not continue to update.

Writing to these registers either sets the time or the alarm,
depending on the setting of Bit 7 of Control Register B (56335,
$DC0F).  If that bit is set to 1, writing to the Time of Day registers
sets the alarm.  If the bit is set to 0, writing to the Time of Day
registers sets the Time of Day clock.  In either case, as with reading
the registers, there is a latch function.  This function stops the
clock from updating when you write to the hours register.  The clock
will not start again until you write to the tenths of seconds
registers.

The only apparent use of the Time of Day Clock by the 64's Operating
System is in the BASIC RND statement.  There, the seconds and tenths
of seconds registers are read and their values used as part of the
seed value for the RND(0) command.

Nonetheless, this clock can be an invaluable resource for the 64 user.
It will keep time more accurately than the software clock maintained
at locations 60-162 ($A0-$A2) by the Timer A interrupt routine.  And
unlike that software clock, the Time of Day Clock will not be
disturbed when I/O operations disrupt the Timer A IRQ, or when the IRQ
vector is diverted elsewhere.  Not even a cold start RESET will
disrupt the time.  For game timers, just set the time for 00:00:00:0
and it will keep track of elapsed time in hours, minutes, seconds and
tenths of seconds format.

The following digital clock program, written in BASIC, will
demonstrate the use of these timers:

10 PRINT CHR$(147):GOSUB 200
20 H=PEEK(56331):POKE 1238,(H AND 16)/16+48:POKE 1239,(H AND 15)+48
30 M=PEEK(56330):POKE 1241,(M AND 240)/16+48:POKE 1242,(M AND 15)+48
40 S=PEEK(56329):POKE 1244,(S AND 240)/16+48:POKE 1245,(S AND 15)+48
50 T=PEEK(56328)AND15:POKE 1247,T+48:GOTO 20
200 INPUT'WHAT IS THE HOUR';H$:IF H$='' THEN 200
210 H=0:IF LEN(H$)>1 THEN H=16
220 HH=VAL(RIGHT$(H$,1)):H=H+HH:POKE56331,H
230 INPUT 'WHAT IS THE MINUTE';M$:IF M$=''THEN 200
240 M=0:IF LEN(M$)>1 THEN M=16*VAL(LEFT$(M$,1))
250 MM=VAL(RIGHT$(M$,1)):M=M+MM:POKE56330,M
260 INPUT 'WHAT IS THE SECOND';S$:IF S$=''THEN 200
270 S=0:IF LEN(S$)>1 THEN S=16*VAL(LEFT$(S$,1))
280 SS=VAL(RIGHT$(S$,1)):S=S+SS:POKE56329,S:POKE56328,0
290 POKE 53281,1:PRINT CHR$(147):POKE 53281,6
300 POKE 1240,58:POKE 1243,58:POKE 1246,58:GOTO 20"
"[INST]In the context of the C64, What is the purpose of the memory location at address $DD04?[/INST]address              $DD04          TI2ALO
Timer A (low byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $B700?[/INST]address         $B700          LEFTD
Perform LEFT$

LEFT$ creates a temporary string descriptor for a new string which
contains the number of characters from the left side of the string
that is specified in the command."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BA8C?[/INST]address         $BA8C          CONUPK
Move a Floating Point Number from Memory into FAC2

This subroutine loads FAC2 from the four-byte number (three mantissa
and one sign) pointed to by the .A and .Y registers."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D?[/INST]address            $D             VALTYP
Flag: Type of Data (String or Numeric)

This flag is used internally to indicate whether data being operated
upon is string or numeric.  A value of 255 ($FF) in this location
indicates string data, while a 0 indicates numeric data.  This
determination is made every time a variable is located or created."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FD9B?[/INST]address              $FD9B
Table of IRQ Vectors

This table holds the vectors to the four IRQ routines which the system
uses.  The first points to Part 1 of the cassette write routine at
64618 ($FC6A), the second to Part 2 of the cassette write routine at
64461 ($FBCD), the third to the standard scan keyboard IRQ at 59953
($EA31), and the last to the cassette read routine at 63788 ($F92C)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $C9-$CA?[/INST]address       $C9-$CA        LXSP
Cursor X,Y Position at Start of Input

These locations keep track of the logical line that the cursor is on,
and its column position on that logical line (in line, column format).

Each logical line may contain one or two 40-column physical lines.
Thus there may be as many as 25 logical lines, or as few as 13 at any
one time.  Therefore, the logical line number might be anywhere from
1-25.  Depending on the length of the logical line, the cursor column
may be from 1-40 or 1-80.

For a more detailed exaplanation of logical lines, see the description
of the screen line link talbe, 217 ($D9)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D0?[/INST]address          $D0            CRSW
Flag: Input from Keyboard or Screen

This flag is used by the Kernal CHRIN (61783, $F157) routine to
indicate whether input is available from the screen (3), or whether a
new line should be obtained from the keyboard (0)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $FF1A?[/INST]address              $FF1A
Load the Timer with Prescaler Values from the Baud Rate Lookup Table"
"[INST]In the context of the C64, What is the purpose of the memory location at address $FC93?[/INST]address              $FC93
Restores the Default IRQ Routine

At the end of the tape I/O operations, this subroutine is used to turn
the screen back on and stop the cassette motor.  It then resets the
CIA #1 Timer A to generate an interrupt every sixtieth of a second,
and restores the IRQ vector to point to the normal interrupt routine
that updates the software clock and scans the keyboard."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AEFA?[/INST]address         $AEFA          CHKOPN
Check for and Skip Opening Parentheses"
"[INST]In the context of the C64, What is the purpose of the memory location at address $E37B?[/INST]address              $E37B
Warm Start BASIC

This is the entry point into BASIC from the BRK routine at 65126
($FE66), which is executed when the STOP and RESTORE keys are both
pressed.  It first executes the Kernal CLRCHN routine which closes all
files.  It then sets the default devices, resets the stack and BASIC
program pointers, and jumps through the vector at 768 ($300) to the
next routine to print the READY prompt and enter the main BASIC loop."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E1D4?[/INST]address              $E1D4
Set Parameters for LOAD, VERIFY, and SAVE

This routine is used in common by LOAD, SAVE, and VERIFY for setting
the filename, the logical file, device number, and secondary address,
all of which must be done prior to these operations."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AD8A?[/INST]address         $AD8A          FRMNUM
Evaluate a Numeric Expression and/or Check for Data Type Mismatch

This routine can be called from different entry points to check the
current data against the desired data type (string or numeric) to see
if they match.  If they don't, a TYPE MISMATCH error will result."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AB7B?[/INST]address         $AB7B          GET
Perform GET and GET#

The GET routine first makes sure that the program is not in direct
mode.  It opens an input channel using the Kernal CHKIN routine
(61966, $F20E) if a number sign was added to make GET#.  Then it calls
the common I/O routines in READ to get a single character, and causes
the input channel to be closed if one was opened."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EA31?[/INST]address              $EA31
IRQ Interrupt Entry

This is the entry point to the standard IRQ interrupt handler.  Timer
A of CIA #1 is set at power-on to cause an IRQ interrupt to occur
every 1/60 second.  When the interrupt occurs, program flow is
transferred here via the CINV vector at 788 ($314).  This routine
updates the software clock at 160-162 ($A0-$A2), handles the cursor
flash, and maintains the tape interlock which keeps the cassette motor
on if a button is pushed and the interlock flag is on.  Finally, it
calls the keyboard scan routine, which checks the keyboard and puts
any character it finds into the keyboard buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $33C-$3FB?[/INST]address     $33C-$3FB      TBUFFER
Cassette I/O Buffer

This 192-byte buffer area is used to temporarily hold data that is
read from or written to the tape device (device number 1).

When not being used for tape I/O, the cassette buffer has long been a
favorite place for Commodore programmers to place short machine
language routines (although the 64 has 4K of unused RAM above the
BASIC ROM at 49152 ($C000) that would probably better serve the
purpose).

Of more practical interest to the 64 programmer is the possible use of
this area for VIC-II chip graphics memory (for example, sprite shape
data or text character dot data).  If the VIC-II chip is banked to the
lowest 16K of memory (as is the default selection), there is very
little memory space which can be used for such things as sprite shape
data without conflict.  If the tape is not in use, locations 832-895
($340-$37F) can be used as sprite data block number 13, and locations
896-959 ($380-$3BF) can be used as sprite data block number 14.

The types of tape blocks that can be stored here are program header
blocks, data header blocks, and data storage blocks.

The first byte of any kind of block (which is stored at location 828
($33C)) identifies the block type.  Header blocks follow this
identifier byte with the two-byte starting RAM address of the tape
data, the two-byte ending RAM address, and the filename, padded with
blanks so that the total length of the name portion equals 187 bytes.
Data storage blocks have 191 bytes of data following the identifier
byte.  The meanings of the various identifier blocks are as follows:

A value of 1 signifies that the block is the header for a relocatable
program file, while a value of 3 indicates that the block is the
header for a nonrelocatable program file.

A relocatable file is created when a program is SAVEd with a secondary
address of 0 (or any even number), while a nonrelocatable program file
is created if the secondary SAVE address is 1 (or any odd number).
The difference between the two types of files is that a nonrelocatable
program will always load at the address specified in the header.  A
relocatable program will load at the current start of BASIC address
unless the LOAD statement uses a secondary address of 1, in which case
it will also be loaded at the addrss specified in the header.

You should note that a program file uses the cassette buffer only to
store the header block.  Actual program data is transferred directly
to or from RAM, without first being buffered.

An identifier value of 4 means that the block is a data file header.
Such a header block is stored in the cassette buffer whenever a BASIC
program OPENs a tape data file for reading or writing.  Subsequent
data blocks start with an identifier byte of 2.  These blocks contain
the actual data byte written by the PRINT #1 command, and read by the
GET #1 and INPUT #1 commands.  Unlike the body of a program file,
these blocks are temporarily stored in the cassette byffer when being
written or read.

An identifier byte of 5 indicates that this block is the logical end
of the tape.  This signals the Kernal not to search past this point,
even if there are additional tape blocks physically present on the
tape.

1020-1023     $3FC-$3FF
Unused

Four more free bytes."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A080-$A09D?[/INST]address  $A080-$A09D    OPTAB
Operator Dispatch Vector Table

This table contains two-byte vectors, each of which points to an
address which is one byte before the address of one of the routines
that perform a BASIC math operation.

For the reasoning behind the one-byte offset to the true address, see
the entry for location 40972 ($A00C).  In addition, each entry has a
one-byte number which indicates the degree of precedence that
operation takes.  Operations with a higher degree of precedence are
performed before operations of a lower degree (for example, in the
expression A=3+4*6, the 4*6 operation is performed first, and 3 is
added to the total).  The order in which they are performed is:

1.  Expressions in parentheses
2.  Exponentation (raising to a power, using the up-arrow symbol)
3.  Negation of an expression (-5, -A)
4.  Multiplication and division
5.  Addition and subtraction
6.  Relation tests (=, <>, <, >, <=, >= all have the same precedence)
7.  NOT (logical operation)
8.  AND (logical operation)
9.  OR (logical operation)

The substance of this table, which can be used to locate the addresses
of the math routines, is given below.  Note that less that, equal, and
greater than operators all use the same routines, though they have
different token numbers."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EBC2?[/INST]address              $EBC2
SHIFTed Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the shifted keyboard,
one for each key which is struck while the SHIFT key is pressed.  The
table is in keycode order (see the keycode table in Appendix H for the
correspondence of keycode to key).  A 65th byte with the value of 255
($FF) marks the end of the table (this corresponds to a keypress value
of 64, no key pressed)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E9E0?[/INST]address              $E9E0
Set Temporary Color Pointer for Scrolling

This subrouting sets up a pointer in 17-175 ($AE-$AF) to the Color RAM
address that corresponds to the temporary screen line address in
172-173 ($AC-$AD)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $306-$307?[/INST]address      $306-$307      IQPLOP
Vector to the Routine That Lists BASIC Program Token as ASCII Text

This vector points to the address of the QPLOP routine at 42778
($A71A)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F250?[/INST]address              $F250          CHKOUT
Designate a Logical File As the Current Output Channel

This is a documented Kernal routine which can be entered from the jump
table at 65481 ($FFC9).

The routine jumps through a RAM vector at 800 ($320).  If you wish to
output data to any device other than the screen, this routine must be
called after OPENing the device, and before you output a data byte
with the CHROUT routine.  When called, the routine will designate the
logical file whose file number is in the .X register as the current
file, its device as the current device, and its secondary address as
the current secondary address.  If the device on the channel uses the
serial bus, and therefore requires a LISTEN command and possibly a
secondary address, this information will be sent on the bus."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F0BD?[/INST]address              $F0BD
Kernal Control Messages

The ASCII text of the Kernal I/O control messages is stored here.  The
last byte of every message has Bit 7 set to 1 (ASCII value + 128).
The messages are:

I/O ERROR
SEARCHING
FOR
PRESS PLAY ON TAPE
PRESS RECORD & PLAY ON TAPE
LOADING
SAVING
VERIFYING
FOUND
OK"
"[INST]In the context of the C64, What is the purpose of the memory location at address $29C?[/INST]address          $29C           RIDBS
RS-232: Index to Start of Receive Buffer

This index points to the starting byte within the 256-byte RS-232
receive buffer, and is used to remove data from that buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $28D?[/INST]address           $28D           SHFLAG
Flag: SHIFT/CTRL/Logo Keypress

This flag signals which of the SHIFT, CTRL, or Commodore logo keys are
currently being pressed, if any.

A value of 1 signifies that one of the SHIFT keys is being pressed, a
2 shows that the Commodore logo key is down, and 4 means that the CTRL
key is being pressed.  If more than one key is held down, these values
will be added; for example, a 3 indicates that SHIFT and logo are both
held down.

The value here is used by the Operating System when determining how to
convert a keypress into a PETASCII character.  There are four
different tables used to translate one of the 64 keys on the keyboard
matrix into a PETASCII character, and the combination of special SHIFT
keys determines which of these tables will be used (see the entry for
location 245 ($F5) for more details on the keyboard tables).

Pressing the SHIFT and Commodore logo keys at the same time will
toggle the character set that is presently being used between the
uppercase/graphics set, and the lowercase/uppercase set (provided that
the flag at 657 ($291) has not been set to disable this switch).

This changes the appearance of all of the characters on the screen at
once.  It has nothing whatever to do with the keyboard shift tables,
however, and should not be confused with the printing of SHIFTed
characters, which affects only one character at a time.  Rather, it is
the result of the value of the character dot data table base address
in 53272 ($D018) being changed.  The came result may be obtained by
POKEing that address directly."
"[INST]In the context of the C64, What is the purpose of the memory location at address $62-$65?[/INST]address        $62-$65        FACHO
Floating Point Accumulator #1: Mantissa

The most significant digit can be assumed to be a 1 (remember that the
range of the mantissa is from 1 to 1.99999...) when a floating point
number is stored to a variable.  The first bit is used for the sign of
the number, and the other 31 bits of the four-byte mantissa hold the
other significant digits.

The first two bytes (98-99, $62-$63) of this location will hold the
signed integer result of a floating point to integer conversion, in
high-byte, low- byte order."
"[INST]In the context of the C64, What is the purpose of the memory location at address $9D?[/INST]address           $9D            MSGFLG
Flag: Kernal Message Control

This flag is set by the Kernal routine SETMSG (65048, $FE18), and it
controls whether or not Kernal error messages or control messages will
be displayed.

A value of 192 ($C0) here means that both Kernal error and control
messages will be displayed.  This will never normally occur when using
BASIC, which prefers its own plain text error messages over the
Kernal's perfunctory I/O ERROR (number).  The Kernal error messages
might be used, however, when you are SAVEing or LOADing with a machine
language monitor.

A 128 ($80) means that control messages only will be displayed.  Such
will be the case when you are in the BASIC direct or immediate mode.
These messages include SEARCHING, SAVING, FOUND, etc.

A value of 64 means that Kernal error messages only are on.  A 0 here
suppresses the display of all Kernal messages.  This is the value
placed here when BASIC enters the program or RUN mode."
"[INST]In the context of the C64, What is the purpose of the memory location at address $8B-$8F?[/INST]address       $8B-$8F        RNDX
RND Function Seed Value

This location holds the five-byte floating point value returned by the
RND function.  It is initially set to a seed value copied from ROM
(the five bytes are 128, 79, 199, 82, 88--$80, $4F, $C7, $52, $58).

When the function RND(X) is called, the numeric value of X does not
affect the number returned, but its sign does.  If X is equal to 0,
RND generates a seed value from chip-level hardware timers.  If X is a
positive number, RND(X) will return the next number in an arithmetic
sequence.  This sequence continues for such a long time without
repeating itself, and gives such an even distribution of numbers, that
it can be considered random.  If X is negative, the seed value is
changed to a number that corresponds to a scrambled floating point
representation of the number X itself.

Given a particular seed value, the same pseudorandom series of numbers
will always be returned.  This can be handy for debugging purposes,
but not where you wish to have truly random numbers.

The traditional Commodore method of selecting a random seed is by
using the expression RND(-TI), mostly because RND(0) didn't function
correctly on early PETs.  While the RND(0) form doesn't really work
right on the 64 either (see location 57495 ($E097)), the expression
RND(-RND(0)) may produce a more random seed value.

Location Range: 144-255 ($90-$FF)
Kernal Work Storage Area

This is the zero-page storage area for the Kernal.  The user should
take into account what effect changing a location here will have on
the operation of the Kernal functions before making any such changes.

At power-on, this range of locations is first filled with zeros, and
then initialized from values stored in ROM as needed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D023?[/INST]address              $D023          BGCOL2
Background Color 2

This register sets the color for the 10 bit-pair of multicolor
character graphics, and the background color for characters habing
screen codes 128-191 in extended background color text mode.  The
default color value is 2 (red)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D000-$D02E?[/INST]address   $D000-$D02E
VIC-II Chip Registers

The Video Interface Controller (VIC-II chip) is a specially designed
processor that is in charge of the 64's video display.  It is this
chip which makes possible the 64's wide range of graphics
capabilities.

The VIC-II chip's ability to address memory is independent of the 6510
microprocessor.  It can address only 16K at a time, and any of the
four blocks of 16K can be chosen for video memory.  The system default
is for it to use the first 16K.

All of the video display memory, character dot data, and sprite shapes
must be stored within the chosen 16K block.  Locations 53248-53294
($D000-$D02E) are registers which allow the user to communicate with
the VIC-II chip.  Although for the most part they can be written to
and read like ordinary memory locations, their contents directly
control the video display.  Since many of these locations work in
close conjunction with others, a general overview of some of the
different graphics systems on the 64 is in order.

The most familiar type of graphics display is the ordinary text that
appears when you turn the machine on.  The area of RAM which is
displayed on the screen is determined by the Video Matrix Base Address
Nybble of the VIC-II Memory Control Register (53272, $D018).  The
address of the dot-data which is used to assign a shape to each text
character based on an 8 by 8 matrix of lit or unlit dots is determined
by the other half of the Memory Control Register at 53272 ($D018).
More information on how the data is used to represent the character
shapes may be found at the alternate entry for 49152 ($C000), the
Character Generator ROM.

Text character graphics may employ one of the two sets of text and
graphics characters in the Character Generator ROM, or the user may
substitute a completely different set of graphics or text characters
in RAM.

Normally, the text graphics screen uses a background color which is
common to all text characters, and that value is stored in Background
Color Register 0 (53281, $D021).  The color of the frame around the
screen is determined by the Border Color Register at 53280 ($D020).

The color of each character is determined by one nybble of the Color
RAM which starts at 55296 ($D800).  There are, however, two variations
which alter this scheme somewhat.

The first is called multicolor text mode, and is set by Bit 4 of 53270
($D016).  Instead of each bit selecting either the foreground or the
background color for each dot in the character, bit-pairs are used to
select one of four colors for each double-width dot.  This results in
the horizontal resolution being cut to four dots across per character,
but allows two extra colors to be introduced from Background Color
Registers 1 and 2 (53282-53283, $D022-$D023).

The other text mode is called Extended Background Color Mode.  In this
mode, the foreground color is always selected by the Color RAM.  The
background color depends on the actual screen code of the character.
In this mode, only the first 64 character shapes are available, but
each can have one of four different background colors.

The background color for each character is determined by its screen
code as follows:

1.  If the screen code is from 0-63 (this includes the normal
alphanumerics), the value in Background Color Register 0 (53281,
$D021) will determine the background color, as is usual.

2.  Characters with codes 64-255 will have the same shape as the
corresponding character in the group with codes 0-63.

3.  For characters with codes 64-127 (SHIFTed characters), the
background colors are deterined by the value in Background Color
Register 1 (53282, $D022).

4.  The value in Background Color Register 2 (53283, $D023) is used
for characters with codes 128-191 (reversed alphanumerics).

5.  For characters with codes 192-255, the value in Background Color
Register 3 (53284, $D024) is used to determine the background color.


In place of the normal text mode, a bitmap graphics mode is also
abailable by setting Bit 5 of location 53265 ($D011).  In this mode,
each bit of data determines whether one dot on the screen will be set
to either the background color or foreground color.  Within an 8 by 8
dot area, the foreground and background colors may be individually
selected.

The bitmap area is 320 dots wide and 200 dots high.  The area which
contains the graphics data, the bitmap, is determined by the Character
Dot Data Base Address in the lower nybble of the VIC-II Memory Control
Register (53272, $D018).  The Video Matrix Base Address in the upper
nybble, which normally determines which area of memory will be
displayed, instead determines where the color memory for each 8 by 8
ground of dots will be located.

The Color RAM is not used for high-resolution bitmap graphics.  But
multicolor mode is also available for bitmap graphics, and it uses the
Color RAM to determine the foreground color of each dot.

As with multicolor text mode, the horizontal resolution is but in half
(to 160 dots across), so that in addition to the foreground and
background colors, each dot can be one of two other colors as well.
This mode gets the value for the two extra colors from the two nybbles
of each byte of bitmap color memory, the location of which is
determined by the Video Matrix Base Address.

Multicolor text mode offers four colors, three of which will be common
to all characters, and one of which can be selected individually.
Multicolor bitmap mode offers a choice of four colors, three of which
can be individually selected within an 8 by 8 dot area.

The 64 also contains an entirely separate graphics system, whose
character shapes, colors, and positions are derived and displayed
without any reference to the Video Matrix and Character Dot-Data
addresses.  Best of all, these characters may be moved quickly and
easily to any position on the screen, greatly facilitating games and
animated graphics of all types.  This system is known as sprite
graphics.

Sprite graphics takes its name from the graphics characters it
displays, each of which is called a sprite.  There are eight sprites,
known as Sprites 0-7.  Each sprite character is 24 dots wide by 21
dots high.  This is about eight times as large as a regular text
character, which is only 8 dots wide by 8 dots high.

A sprite takes its shape from 63 bytes of data in one of the 256 data
blocks, each 64 bytes long, that can fit into the 16K space which the
VIC-II chip can address.  The block currently assigned to any given
sprite is determined by the Sprite Data Pointers, which are located at
the last eight bytes of the screen memory area (the default locations
are 2040-2047, $7F8-$7FF).

The first Sprite Data Pointer determines the data block used for the
shape of Sprite 0, the second for the shape of Sprite 1, etc.  The
number in the pointer times 64 equals the address of the first byte of
the data block within the VIC-II addressing range.

For example, using the default values for VIC-II addressing area and
screen memory, a value of 11 in location 2040 ($7F8) would mean that
the shape of Sprite0 is determined by the data in the 63-byte block
starting at location 704 (11*64).  It should be noted that it is
possible for more than one sprite to take its shape data from the same
block, so that only 64 bytes of data are required to create eight
sprites, each having the same shape.

The dot patterns of each sprite correspond to the bit patterns of the
sprite shape data.  Each byte of shape data in memory consists of a
number from 0 to 255.  This number can be represented by eight binary
digits of 0 or 1.

Each binary digit has a bit value that is two times greater than the
last.  If the digit in the zero bit place is a 1, it has a value of 1
(we count bit places from 0 to 7).  A 1 in the first bit place has a
value of 2, the second bit has a value of 4, the third has a value of
8, the fourth has a vlue of 16, the fifth a value of 32, the sixth a
value of 64, and the seventh a value of 128.

By making all of the possible combinations of 0's and 1's in all eight
bit places, and adding the bit values of every bit place that contains
a 1, we can represent every number from 0 to 255 as a series of 1's
and 0's.

If you think of every 0 as a dot having the same color as the
background, and every 1 as a dot which is the color of the sprite, you
can see how a series of bytes could be used to represent the sprite
shape.

Since each line of the sprite is 24 dots wide, it takes 3 bytes of
memory (24 bits) per line to portray its shape.  Let's take a look at
a couple of sample sprite lines.

00000000 01111110 00000000 = 0, 126, 0

As you can see, the first and last bytes are all 0's, so nothing will
be displayed there.  The middle byte has six 1's, so it will be
displayed as a line six dots long.  By adding the values of these dix
bits (64+32+16+8+4+2), we get a byte value of 126.  Let's try another
line.

00011111 11111111 11111000 = 21, 255, 248

The first byte has five bits set to 1, having values of 16, 8, 4, 2,
and 1, for a total of 31.  The second byte has all bits set to 1, so
it has the maximum value of 255.  The third byte also has five bits
set to 1, having values of 128, 64, 32, 16, and 8, for a total of 248.
The result is that this line of sprite data will display a line that
is 18 dots long.

We can put these two kinds of lines together to show how a large cross
might be drawn using bytes of sprite data."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BDC0?[/INST]address         $BDC0          INPRT
Print IN Followed by a Line Number"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D01D?[/INST]address              $D01D          XXPAND
Sprite Horizontal Expansion Register

Bit 0:  Expand Sprite 0 horizontally (1=double-width sprite, 0=normal
        width)
Bit 1:  Expand Sprite 1 horizontally (1=double-width sprite, 0=normal
        width)
Bit 2:  Expand Sprite 2 horizontally (1=double-width sprite, 0=normal
        width)
Bit 3:  Expand Sprite 3 horizontally (1=double-width sprite, 0=normal
        width)
Bit 4:  Expand Sprite 4 horizontally (1=double-width sprite, 0=normal
        width)
Bit 5:  Expand Sprite 5 horizontally (1=double-width sprite, 0=normal
        width)
Bit 6:  Expand Sprite 6 horizontally (1=double-width sprite, 0=normal
        width)
Bit 7:  Expand Sprite 7 horizontally (1=double-width sprite, 0=normal
        width)

This register can be used to double the width of any sprite.  Setting
any bit of this register to 1 will cause each dot of the corresponding
sprite shape to be displayed twice as wide as normal, so that without
changing its horizontal resolution, the sprite takes up twice as much
space.  The horizontal expansion feature can be used alone, or in
combination with the vertical expansion register at 53271 ($D017).

Location Range: 53278-53279 ($D01E-$D01F)
Sprite Collision Detection Registers

While Bit 2 of the VIC IRQ Register at 53273 ($D019) is set to 1
anytime two sprites overlap, and Bit 1 is set to 1, when a sprite
shape is touching the foreground text or bit-graphics display, these
registers specify which sprites were involved in the collision.  Every
bit that is set to 1 indicates that the corresponding sprite was
involved in the collision.  Reading these registers clears them so
that they can detect the next collision.  Therefore, if you plan to
make multiple tests on the values stored here, it may be necessary to
copy it to a RAM variable for further reference.

Note that while these registers tell you what sprites were involved in
a collision, they do not necessarily tell you what objects have
collided with each other.  It is quite possible to have three sprites
lined up in a row, where Sprite A is on the left, Sprite B is in the
middle, touching Sprite A, and Sprite C is on the right, touching
Sprite B but not touching Sprite A.  The Sprite-Sprite Collision
register would show that all three are involved.  The only way to make
absolutely certain which collided with which is to check the position
of each sprite, and calculate for each sprite display line if a sprite
of that size would touch either of the others.  As you can imagine,
this is no easy task.

There are a few simple rules concerning what does or does not cause a
collision.  Though the sprite character consists of 504 dots in a 24
by 21 matrix, does which represent data bits that are equal to 0 (or
multicolor bit- pairs equal to 00), and therefore always displayed in
the background color, do not count when it comes to collision.

A collision can occur only if a dot which represents a sprite shape
data bit of 1 touches another dot of nonzero graphics data.  Consider
the case of two invisible sprites.  The first sprite is enabled, its
color set to contrast the background, and it is positioned on the
screen, but its shape data bytes are all 0.  This sprite can never be
involved in a collision, because it displays no nonzero data.  The
second sprite is enabled, positioned on the screen, and its shape
pointer set for a data read that is filled with bytes having a value
of 255.  Even if that sprite's color is set to the same value as the
background color, making the sprite invisible, it can still be
involved in collisions.  The only exception to this rule is the 01
bit-pair of multicolor graphics data.  This bit-pair is considered
part of the background, and the dot it displays can never be involved
in a collision.

The other rule to remember about collisions is that they can occur in
areas that are covered by the screen border.  Collision between
sprites can occur when the sprites are offscreen, and collisions
between sprites and foreground display data can occur when that data
is in an area that is covered by the border due to the reduction of
the display to 38 columns or 24 rows."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D40F?[/INST]address              $D40F          FREHI3
Voice 3 Frequency Control (high byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D00B?[/INST]address              $D00B          SP5Y
Sprite 5 Vertical Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D009?[/INST]address         $D009          SP4Y
Sprite 4 Vertical Position

53258         $D00A          SP5X
Sprite 5 Horizontal Position"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D410?[/INST]address              $D410          PWLO3
Voice 3 Pulse Waveform Width (low byte)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BDCD?[/INST]address         $BDCD          LINPRT
Output a Number in ASCII Decimal Digits

This routine is used to output the line number for the routine above.
It converts thenumber whose high byte is in .A and whose low byte is
in .X to a floating point number.  It also calls the routine below,
which converts the floating point number to an ASCII string."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D01E?[/INST]address              $D01E          SPSPCL
Sprite to Sprite Collision Register

Bit 0:  Did Sprite 0 collide with another sprite?  (1=yes)
Bit 1:  Did Sprite 1 collide with another sprite?  (1=yes)
Bit 2:  Did Sprite 2 collide with another sprite?  (1=yes)
Bit 3:  Did Sprite 3 collide with another sprite?  (1=yes)
Bit 4:  Did Sprite 4 collide with another sprite?  (1=yes)
Bit 5:  Did Sprite 5 collide with another sprite?  (1=yes)
Bit 6:  Did Sprite 6 collide with another sprite?  (1=yes)
Bit 7:  Did Sprite 7 collide with another sprite?  (1=yes)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D024?[/INST]address              $D024          BGCOL3
Background Color 3

This register sets the background color for characters having screen
codes between 192 and 255 in extended background color text mode.  The
default color value is 3 (cyan)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $73-$8A?[/INST]address       $73-$8A        CHRGET
Subroutine: Get Next BASIC Text Character

This is actually a machine language subroutine, which at the time of a
BASIC cold start (such as when the power is turned on) is copied from
MOVCHG (58274, $E3A2) in the ROM to this zero page location.

CHRGET is a crucial routine which BASIC uses to read text characters,
such as the text of the BASIC program which is being interpreted.  It
is placed on zero page to make the routine run faster.  Since it keeps
track of the address of the character being read within the routine
itself, the routine must be in RAM in order to update that pointer.
The pointer to the address of the byte currently being read is really
the operand of a LDA instruction.  When entered from CHRGET, the
routine increments the pointer by modifying the operand at TXTPTR
(122, $7A), thus allowing the next character to be read.

Entry at CHRGOT (121, $79) allows the current character to be read
again.  The CHRGET routine skips spaces, sets the various flags or the
status register (.P) to indicate whether the character read was a
digit, statement terminator, or other type of character, and returns
with the retrieved character in the Accumulator (.A).

Since CHRGET is used to read every BASIC statement before it is
executed, and since it is in RAM, and therefore changeable, it makes a
handy place to intercept BASIC to add new features and commands (and
in the older PET line, it was the only way to add such features).
Diversion of the CHRGET routine for this purpose is generally referred
to as a wedge.

Since a wedge can greatly slow down execution speed, mose of the time
it is set up so that it performs its preprocessing functions only when
in direct or immediate mode.  The most well-known example of such a
wedge is the 'Universal DOS Support' program that allows easier
communication with the disk drive command channel.

As this is such a central routine, a disassembly listing is given
below to provide a better understanding of how it works.

115 $73   CHRGET  INC TXTPTR   ; increment low byte of TXTPTR
117 $75           BNE CHRGOT   ; if low byte isn't 0, skip next
119 $77           INC TXTPTR+1 ; increment high byte of TXTPTR
121 $79   CHRGOT  LDA          ; load byte from where TXTPTR points
                               ; entry here does not update TXTPTR,
                               ; allowing you to readl the old byte again
122 $7A   TXTPTR  $0207        ; pointer is really the LDA operand
                               ; TXTPTR+1 points to 512-580 ($200-$250)
                               ; when reading from the input buffer
                               ; in direct mode
124 $7C   POINTB  CMP #$3A     ; carry flag set if > ASCII numeral 9
126 $7E           BCS EXIT     ; character is not a numeral--exit
128 $80           CMP #$20     ; if it is an ASCI space...
130 $82           BEQ CHRGET   ; ignore it and get next character
132 $84           SEC          ; prepare to subtract
133 $85           SBC #$30     ; ASCII 0-9 are between 48-57 ($30-$39)
135 $87           SEC          ; prepare to subtract again
136 $88           SBC #$D0     ; if < ASCII 0 (57, $39) then carry is set
138 $8A   EXIT    RTS          ; carry is clear only for numeral on return

The Accumulator (.A register) holds the character that was read on
exit from the routine.  Status register (.P) bits which can be tested
for on exit are:

  Carry Clear if the character was an ASCII digit 0-9.
  Carry Set, otherwise.
  Zero Set only if the character was a statement terminator 0 or an
ASCII colon, 58 ($3A).
  Zero Clear, otherwise.


One wedge insertion technique is to change CHRGET's INC $7A to a JMP
WEDGE, have your wedge update TXTPTR itself, and then JSR CHRGOT.
Another is to change the CMP #$3A at location 124 ($7C), which I have
labeled POINTB, to a JMP WEDGE, do your wedge processing, and then
exit through the ROM version of POINTB, which is located at 48283
($E3AB).  For more detailed information about wedges, see Programming
the PET/CBM, Raeto Collin West, pages 365-68.

While the wedge is a good, quick technique for adding new commands, a
much more elegant method exists for accomplishing this task on the
VIC-20 and 64 withouth slowing BASIC down to the extent that the wedge
does.  See the entries for the BASIC RAM vector area at 768-779
($300-$30B) for more details."
"[INST]In the context of the C64, What is the purpose of the memory location at address $9C?[/INST]address           $9C            DPSW
Flag: Tape Byte Received

This location is used as a flag to indicate whether a complete byte of
tape data has been received, or whether it has only been partially
received."
"[INST]In the context of the C64, What is the purpose of the memory location at address $61?[/INST]address            $61            FACEXP
Floating Point Accumulator #1: Exponent

This exponent represents the closest power of two to the number, with
129 added to take care of the sign problem for negative exponents.  An
exponent of 128 is used for the value 0; an exponent of 129 represents
2 to the 0 power, or 1; an exponent of 130 represents 2 to the first
power, or 2; 131 is 2 squared, or 4; 132 is 2 cubed, or 8; and so on."
"[INST]In the context of the C64, What is the purpose of the memory location at address $28E?[/INST]address           $28E           LSTSHF
Last Pattern of SHIFT/CTRL/Logo Keypress

This location is used in combination with the one above to debounce
the special SHIFT keys.  This will keep the SHIFT/logo combination
from changing character sets back and forth during a single pressing
of both keys.

655-656       $28F-$290      KEYLOG
Vector to Keyboard Table Setup Routine

This location points to the address of the Operating System routine
which actually determines which keyboard matrix lookup table will be
used.

The routine looks at the value of the SHIFT flag at 653 ($28D), and
based on what value it finds there, stores the address of the correct
table to use at location 245 ($F5).

The interrupt driven keyboard-scanning routine jumps through this RAM
vector to get to the table setup routine.  Therefore, it is possible
to alter the address contained in this vector, and direct the keyscan
routine to your own routine, which can check the keypress and SHIFT
combination, and act before a character is printed.

Since this routine comes after the keypress, but before it is printed,
this is a very good place to have your preprocessor routine check for
a particular keypress.  An excellent example of such a program is the
'VICword' program by Mark Niggemann, COMPUTE!'s Second Book of VIC.
This program adds a machine language routine that checks if the SHIFT
or Commodore logo key is pressed while not in quote mode.  If it finds
one of these keypresses, it substitutes an entire BASIC keyword for
the letter (A-Z) of the key that was pressed.  An adaptation of that
program for the 64 appears below.

100 IF PEEK(PEEK(56)*256)<>120THENPOKE56,PEEK(56)-1:CLR
110 HI=PEEK(56):BASE=HI*256
120 PRINTCHR$(147)'READING DATA'
130 FOR AD=0 TO 211:READ BY
140 POKE BASE+AD,BY:NEXT AD
150 :
200 REM RELOCATION ADJUSTMENTS
210 POKE BASE+26,HI:POKE BASE+81,HI
220 POKE BASE+123,HI:POKE BASE+133,HI
230 :
240 PRINT CHR$(147) TAB(15)'***64WORD***':PRINT
250 PRINT'TO TOGGLE THE PROGRAM ON/OFF:':PRINT:PRINT:PRINT 'SYS';BASE;
260 PRINT CHR$(145);CHR$(145);
270 DATA 120,173,143,2,201,32
280 DATA 208,12,169,220,141,143
290 DATA 2,169,72,141,144,2
300 DATA 88,96,169,32,141,143
310 DATA 2,169,0,141,144,2
320 DATA 88,96,165,212,208,117
330 DATA 173,141,2,201,3,176
340 DATA 110,201,0,240,106,169
350 DATA 194,133,245,169,235,133
360 DATA 246,165,215,201,193,144
370 DATA 95,201,219,176,91,56
380 DATA 233,193,174,141,2,224
390 DATA 2,208,3,24,105,26
400 DATA 170,189,159,0,162,0
410 DATA 134,198,170,160,158,132
420 DATA 34,160,160,132,35,160
430 DATA 0,10,240,16,202,16
440 DATA 12,230,34,208,2,230
450 DATA 35,177,34,16,246,48
460 DATA 241,200,177,34,48,17
470 DATA 8,142,211,0,230,198
480 DATA 166,198,157,119,2,174
490 DATA 211,0,40,208,234,230
500 DATA 198,166,198,41,127,157
510 DATA 199,2,230,198,169,20
520 DATA 141,119,2,76,72,235
530 DATA 76,224,234
550 REM TOKENS FOR SHIFT KEY
570 DATA 153,175,199,135,161,129
580 DATA 141,164,133,137,134,147
590 DATA 202,181,159,151,163,201
600 DATA 196,139,192,149,150,155
610 DATA 191,138
630 REM TOKENS FOR COMMODORE KEY
650 DATA 152,165,198,131,128,130
660 DATA 142,169,132,145,140,148
670 DATA 195,187,160,194,166,200
680 DATA 197,167,186,157,165,184
690 DATA 190,158,0"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F12B?[/INST]address              $F12B
Print Kernal Error Message if in Direct Mode

This routine first checks location 157 ($9D) to see if the messages
are enabled.  If they are, it prints the message indexed by the .Y
register."
"[INST]In the context of the C64, What is the purpose of the memory location at address $29D?[/INST]address          $29D           RODBS
RS-232: Index to Start of Transmit Buffer

This index points to the starting byte within the 256-byte RS-232
transmit buffer, and is used to remove data from that buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $308-$309?[/INST]address      $308-$309      IGONE
Vector to the Routine That Executes the Next BASIC Program Token

This vector points to the address of the GONE routine at 42980 ($A7E4)
that executes the next program token."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F291?[/INST]address              $F291          CLOSE
Close a Logical I/O File

CLOSE is a documented Kernal routine which can be entered via the jump
table at 65475 ($FFC3).

The routine jumps through a RAM vector at 796 ($31C).  It is used to
close a logical file after all I/O operations involving that file have
been completed.  This is accomplished by loading the Accumulator with
the logical file number of the file to be closed, and calling this
routine.

Closing an RS-232 file will de-allocate space at the top of memory for
the receiving and trasmit buffers.  Closing a cassette file that was
opened for writing will force the last block to be written to
cassette, even if it is not a full 192 bytes.  Closing a serial bus
device will send an UNLISTEN command on the bus.  Remember, it is
necessary to properly CLOSE a cassette or disk data file in order to
retrieve the file later.

For all types of files, CLOSE removes the file's entry from the tables
of logical files, device, and secondary address at 601, 611, and 621
($259, $263, $26D), and moves all higher entries in the table down one
space."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E9F0?[/INST]address              $E9F0
Set Pointer to Screen Address of Start of Line

This subroutine puts the address of the first byte of the screen line
designated by the .X register into locations 209-210 ($D1-$D2)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A09E-$A19D?[/INST]address  $A09E-$A19D    RESLST
List of Keywords

This table contains a complete list of the reserved BASIC keywords
(those combinations of ASCII text characters that cause BASIC to do
something).  The ASCII text characters of these words are stored in
token number order.  Bit #7 of the last letter of each word is set to
indicate the end of the word (the last letter has 128 added to its
true ASCII value).

When the BASIC program text is stored, this list of words is used to
reduce any keywords to a single-byte value called a token.  The
command PRINT, for example, is not stored in a program as five ASCII
bytes, but rather as the single token 153 ($99).

When the BASIC program is listed, this table is used to convert these
tokens back to ASCII text.  The entries in this table consist of the
following:

1.  The statements found in STMDSP at 40972 ($A00C), in the token
number order indicated (token numbers 128-162).

2.  Some miscellaneous keywords which never begin a BASIC statement:

Token #    Keyword
162 $A3    TAB(
164 $A4    TO
165 $A5    FN
166 $A6    SPC(
167 $A7    THEN
168 $A8    NOT
169 $A9    STEP

3.  The math operators found in OPTAB at 41088 ($A080), in the token
number order indicated (token numbers 170-179).

4.  The functions found in FUNDSP at 41042 ($A052), in the token
number order indicated (token numbers 182-202).

5.  The word GO (token number 203 ($CB)).  This word was added to the
table to make the statement GO TO legal, to afford some compatibility
with the very first PET BASIC, which allowed spaces within keywords.

41374-41767   $A19E-$A327    ERRTAB
ASCII Text of BASIC Error Messages

This table contains the ASCII text of all of the BASIC error messages.
As in the keyword table, Bit 7 of the last letter of each message is
set to indicate the end of the message.  Although we've all seen some
of them at one time or another, it's somewhat daunting to see the
whole list at once.  The possible errors you can make include:

 1.  TOO MANY FILES
 2.  FILE OPEN
 3.  FILE NOT OPEN
 4.  FILE NOT FOUND
 5.  DEVICE NOT PRESENT
 6.  NOT INPUT FILE
 7.  NOT OUTPUT FILE
 8.  MISSING FILENAME
 9.  ILLEGAL DEVICE NUMBER
10.  NEXT WITHOUT FOR
11.  SYNTAX
12.  RETURN WITHOUT GOSUB
13.  OUT OF DATA
14.  ILLEGAL QUANTITY
15.  OVERFLOW
16.  OUT OF MEMORY
17.  UNDEF'D STATEMENT
18.  BAD SUBSCRIPT
19.  REDIM'D ARRAY
20.  DIVISION BY ZERO
21.  ILLEGAL DIRECT
22.  TYPE MISMATCH
23.  STRING TOO LONG
24.  FILE DATA
25.  FORMULA TOO COMPLEX
26.  CAN'T CONTINUE
27.  UNDEF'D FUNCTION
28.  VERIFY
29.  LOAD

Message number 30, BREAK, is located in the Miscellaneous Messages
table below.

41768-41828   $A328-$A364
Error Message Vector Table

This table contains the two-byte address of the first letter of each
of the 30 error messages.

41829-41865   $A365-$A389
Miscellaneous Messages

The text of some of the other messages that BASIC can give you is
stored here.  This text includes cursor movement characters, and each
message ends with a 0 character.  The messages are:

1) Carriage return, OK, carriage return
2) Space, space, ERROR
3) Space, IN, space
4) Carriage return, linefeed, READY., carraige return, linefeed
5) Carriage return, linefeed, BREAK"
"[INST]In the context of the C64, What is the purpose of the memory location at address $EC03?[/INST]address              $EC03
Commodore Logo Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the logo keyboard, one
for each key which is struck while the Commodore logo key is pressed.
The table is in keycode order (see the keycode table in Appendix H for
the correspondence of keycode to key).  A 65th byte with the value of
255 ($FF) marks the end of the table (this corresponds to a keypress
value of 64, no key pressed)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EA87?[/INST]address              $EA87          SCNKEY
Read the Keyboard

This subroutine is called by the IRQ interrupt handler above to read
the keyboard device which is connected to CIA #1 (see entry for 56320
($DC00) for details on how to read the keyboard).

It is the Kernal routine SCNKEY which can be entered from the jump
table at 65439 ($FF9F).  This routine returns the keycode of the key
currently being pressed in 203 ($CB), sets the shift/control flag if
appropriate, and jumps through the vector at 655 ($28F) to the routine
that sets up the proper table to translate the keycode to PETASCII.
It concludes with the next routine, which places the PETASCII value of
the character in the keyboard buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $400-$7FF?[/INST]address     $400-$7FF      VICSCN
Video Screen Memory Area

This is the default location of the video screen memory area, which
contains the video matrix and the sprite data pointers.  Keep in mind,
however, that the video screen memory area can be relocated to start
on any even 1K boundary.  Its location at any given moment is
getermined by the VIC-II chip memory control register at 53272
($D018), and the VIC-II memory bank select bits on CIA #2 Data Port A
(56576, $DD00)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EC5E?[/INST]address              $EC5E
Set Flag to Enable or Disable Switching Character Sets

This subroutine is also used to check for special characters to print.
In this case, it checks for the characters that enable or disable the
SHIFT/logo combination from toggling the character set currently in
use (CHR$(8) and CHR$(9)).  If one of these is to be printed, the flag
at 657 ($291) is changed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A052-$A07F?[/INST]address   $A052-$A07F    FUNDSP
                             TABLE
Function Dispatch Vector Table

This table contains two-byte vectors, each of which points to the
address of one of the routines that performs a BASIC function.

A function is distinguished by a following argument, in parentheses.
The expression in the parentheses is first evaluated by the routines
which begin at 44446 ($AD9E).  Then this table is used to find the
address of the function that corresponds to the token number of the
function to be executed.

The substance of this table, which can be used for locating the
addresses of these routines, is reproduced below.  Note that the
address for the USR function is 784 ($310), which is the address of
the JMP instruction which precedes the user-supplied vector."
"[INST]In the context of the C64, What is the purpose of the memory location at address $334-$33B?[/INST]address       $334-$33B
Unused

Eight free bytes for user vectors or other data."
"[INST]In the context of the C64, What is the purpose of the memory location at address $Eb48?[/INST]address              $Eb48
Set Up the Proper Keyboard Decode Table

This routine is pointed to by the vector at 655 ($28F).  Its function
is to read the shift/control flag at 653 ($28D), and set the value of
the decode table pointer at 245 ($F5) accordingly.

First it checks if the SHIFT/Commodore logo combination was pressed,
and if the toggle enable at 657 (291) will allow a change, the
character set will be changed to lowercase/uppercase or
uppercase/graphics by changing the VIC Memory Control Register at
53272 ($D018), and no character will be printed.

Next it sets the decode table pointer.  There are 64 keys, and each
can have four different PETASCII values, depending on whether the key
is pressed by itself, or in combination with the SHIFT, CTRL, or
Commodore logo keys.  Therefore, there are four tables of 64 entries
each to translate the keycode to PETASCII:  the standard table, the
SHIFT table, the Commodore logo table, and the CONTROL table.  The
routine will set up the pointer for the appropriate table, depending
on whether the SHIFT, CTRL, or logo key was pressed.  The CTRL key
takes precedence, so that if another of these keys is pressed along
with the CTRL key, the CONTROL table is used."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A579?[/INST]address         $A579          CRUNCH
Tokenize Line in Input Buffer

When a line of program text has been input into the BASIC text buffer
at 512 ($200), this routine goes through the line and changes any
keywords or their abbreviations, which do not appear in quotes, into
their corresponding token.  This command is vectored through RAM at
772 ($304), so it can be diverted in order to add new commands."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EF7E?[/INST]address              $EF7E
Setup to Receive a New Byte from RS-232

61"
"[INST]In the context of the C64, What is the purpose of the memory location at address $29F-$2A0?[/INST]address       $29F-$2A0      IRQTMP
SAve Area for IRQ Vector During Cassette I/O

The routines that read and write tape data are driven by an IRQ
interrupt.  In order to hook one of these routines into the interrupt,
the RAM IRQ vector at 788-789 ($314-$315) must be changed to point to
the address at which it starts.  Before that change is made, the old
IRQ vector address is saved at these locations, so that after the tape
I/O is finished, the interrupt that is used for scanning the keyboard,
checking the stop key, and updating the clock can be restored.

You will note that all of the above functions will be suspended during
tape I/O."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F0A4?[/INST]address              $F0A4
Stop CIA #2 RS-232 NMIs for Serial/Cassette Routines

This subroutine turns off the NMIs that drive the RS-232 routines
before any I/O is done using the serial bus or cassette device.  Such
interrupts could throw off the timing of those I/O routines, and
interfere with the transmission of data."
"[INST]In the context of the C64, What is the purpose of the memory location at address $B0-$B1?[/INST]address       $B0-$B1        CMP0
Tape Timing

Location 176 ($B0) is used to determine the value of the adjustable
timing constant at 146 ($92).  Location 199 is also used in the timing
of tape reads.

178-179       $B2-$B3        TAPE1
Pointer: Start of Tape Buffer

On power-on, this pointer is set to the address of the cassette buffer
(828, $33C).  This pointer must contain an address greater than or
equal to 512 ($200), or an ILLEGAL DEVICE NUMBER error will be sent
when tape I/O is tried."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F20E?[/INST]address              $F20E          CHKIN
Designate a Logical File As the Current Input Channel

This is a documented Kernal routine which can be entered from the jump
table at 65478 ($FFC6).

The routine jumps through a RAM vector at 798 ($31E).  If you wish to
get data from any device other than the keyboard, this routine must be
called after OPENing the device, before you can get a data byte with
the CHRIN or GETIN routine.  When called, the routine will designate
the logical file whose file number is in the .X register as the
current file, its device as the current device, and its secondary
address as the current secondary address.  If the device on the
channel is a serial device, which requires a TALK command and
sometimes a secondary address, this routine will send them over the
serial bus."
"[INST]In the context of the C64, What is the purpose of the memory location at address $30C?[/INST]address          $30C           SAREG
Storage Area for .A Register (Accumulator)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F875?[/INST]address              $F875
Common Code for Reading a Data Block from Tape and Writing a Block to Tape

This routine sets the actual reading or writing of a block of data.
It sets CIA #1 Timer B to call the IRQ which drives the actual reading
or writing routine, saves the old IRQ vector, and sets the new IRQ
vector to the read or write routine.  It also blanks the screen so
that the video chip's memory addressing (which normally takes away
some of the 6510 microprocessor's addressing time) will not interfere
with the timing of the routines."
"[INST]In the context of the C64, What is the purpose of the memory location at address $90?[/INST]address           $90            STATUS
Kernal I/O Status Word (ST)

The Kernal routines which open I/O channels or perform input/output
functions check and update this location.  The value here is almost
always the same as that returned to BASIC by use of the reserved
variable ST.  Note that BASIC syntax will not allow an assignment such
as ST=4.  A table of status codes for cassette and serial devices
follows below:

Cassette:
Bit 2 (Bit Value of 4) = Short Block
Bit 3 (Bit Value of 8) = Long Block
Bit 4 (Bit Value of 16) = Unrecoverable error (Read), mismatch
Bit 5 (Bit Value of 32) = Checksum error
Bit 6 (Bit Value of 64) = End of file

Serial Devices:
Bit 0 (Bit Value of 1) = Time out (Write)
Bit 1 (Bit Value of 2) = Time out (Read)
Bit 6 (Bit Value of 64) = EOI (End or Identify)
Bit 7 (Bit Value of 128) = Device not present

Probably the most useful bit to test is Bit 6 (end of file).  When
using the GET statement to read in individual bytes from a file, the
statement IF ST AND 64 will be true if you have got to the end of the
file.

For status codes for the RS-232 device, see the entry for location 663
($297)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $9E?[/INST]address           $9E            PTR1
Tape Pass 1 Error Log Index

This location is used in setting up an error log of bytes in which
transmission parity errors occur the first time that the block is
received (each tape block is sent twice to minimize data loss from
transmission error)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $31A-$31B?[/INST]address      $31A-$31B      IOPEN
Vector to Kernal OPEN Routine (Currently at 62282 ($F34A))"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D020?[/INST]address              $D020          EXTCOL
Border Color Register

The color value here determines the color of the border or frame
around the central display area.  The entire screen is set to this
color when the blanking feature of Bit 4 of 53265 ($D011) is enabled.
The default color value is 14 (light blue)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BDB3?[/INST]address         $BDB3          NO999

This table of three floating point constants holds the values
99,999,999.5, 999,999,999.5 and 1,000,000,000.  These values are used
in converting strings to floating point numbers."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D000-$DFFF?[/INST]address  $D000-$DFFF

This 4K block of memory is used for several key functions.  Normally,
the 6510 microprocessor addresses the two Complex Interface Adapter
(CIA) Input/Output chips here, along with the VIC-II video controller
chip, the Sound Interface Device (SID) music synthesizer, and the
Color RAM.

Alternatively, the 6510 can address the character ROM here (though
normally only the VIC-II chip has access to it).  Finally, there is
also 4K of RAM here, although to use it may require banking it in only
when necessary, as the I/O devices are needed for such niceties as
reading he keyboard, and updating the screen display.

It will appear from the map of the I/O devices below that many of the
locations are not accounted for.  That is beause these devices tie up
more addressing space than they actually use.  Each of them uses only
a few addresses, mostly on the bit level.

The missing addresses either consist of images of the hardware
registers, or cannot be addressed in this configuration.  In addition,
some address space is left open for the use of future hardware devices
which might be plugged into the expansion port, like the CP/M card.

As mentioned above, memory usage by these I/O devices is to intensive
that to work with them often requires that you turn individual bits on
and off.  Here is a quick reminder of how to manipulate bits.

The bit values for each bit are:

Bit 0 = 1
Bit 1 = 2
Bit 2 = 4
Bit 3 = 8
Bit 4 = 16
Bit 5 = 32
Bit 6 = 64
Bit 7 = 128

To set a bit to 1 from BASIC, POKE address, PEEK(address) OR Bitvalue.
To reset a bit to 0 from BASIC, POKE address, PEEK(address) AND
255-Bitvalue."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D026?[/INST]address              $D026          SPMC1
Sprite Multicolor Register 1

This register sets the color that is displayed by the 11 bit-pair in
multicolor sprite graphics.  The default color value is 0 (black).

Location Range: 53287-53294 ($D027-$D02E)
Sprite Color Registers

These registers are used to set the color to be displayed by bits of
hi-res sprite data having a value of 1, and by bit-pairs of multicolor
sprite data having a value of 10.  The color of each sprite is
determined by its own individual color register."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BBFC?[/INST]address         $BBFC          MOVFA
Move a Floating Point Number from FAC2 to FAC1"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BBC7?[/INST]address         $BBC7          MOV2F
Move a Floating Point Number from FAC1 to Memory

This routine is used to move a number from the Floating Point
Accumulator (FAC1) to memory at either 92-96 ($5C-$60) or 87-91
($57-$5B), depending on the entry point to the routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $C000-$CFFF?[/INST]address   $C000-$CFFF
4K Free RAM

Locations 49152 to 53247 ($C000 to $CFFF) are free RAM.  Since this
area is not contiguous with the BASIC program text RAM area, it is not
available for BASIC program or variable storage (it is not counted in
the FRE(0) total).

This area is fully available for any other use, however, sudh as
storing machine language subroutines for use with BASIC, alternate I/O
drivers for parallel or IEEE devices, character graphics or sprite
data, etc.

This large free area is such a tempting spot for system additions that
many such applications may be competing for the same RAM space.  For
example, the Universal Wedge DOS Support program that adds easy access
to the disk communications channel is usually loaded at 52224 ($CC00).
Programs that use that part of RAM will therefore overwrite the DOS
support program, with the result that they may not run correctly, or
even at all.  Likewise, Simon's BASIC, the extended language which
Commodore has released on cartridge, uses several locations in this
range.  Be aware of this potential problem when you buy hardware
additions that use this spot to hook into the system."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D025?[/INST]address              $D025          SPMC0
Sprite Multicolor Register 0

This register sets the color that is displayed by the 01 bit-pair in
multicolor sprite graphics.  The default color value is 4 (purple)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D01F?[/INST]address              $D01F          SPBGCL
Sprite to Foreground Collision Register

Bit 0:  Did Sprite 0 collide with the foreground display?  (1=yes)
Bit 1:  Did Sprite 1 collide with the foreground display?  (1=yes)
Bit 2:  Did Sprite 2 collide with the foreground display?  (1=yes)
Bit 3:  Did Sprite 3 collide with the foreground display?  (1=yes)
Bit 4:  Did Sprite 4 collide with the foreground display?  (1=yes)
Bit 5:  Did Sprite 5 collide with the foreground display?  (1=yes)
Bit 6:  Did Sprite 6 collide with the foreground display?  (1=yes)
Bit 7:  Did Sprite 7 collide with the foreground display?  (1=yes)

Location Range: 53280-53294 ($D020-$D02E)
VIC-II Color Register

Although these color registers are used for various purposes, all of
them have one thing in common.  Like the Color RAM Nybbles, only the
lower four bits are connected.  Therefore, when reading these
registers, you must mask out the upper four bits (that is,
BORDERCOLOR=PEEK(53280)AND15) in order to get a true reading."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BD7E?[/INST]address         $BD7E          FINLOG
Add Signed Integer to FAC1

This routine is used to add an ASCII digit that has been converted to
a signed integer to FAC1."
"[INST]In the context of the C64, What is the purpose of the memory location at address $9F?[/INST]address           $9F            PTR2
Tape Pass 2 Error Log Correction Index

This location is used in correcting bytes of tape data which were
transmitted incorrectly on the first pass."
"[INST]In the context of the C64, What is the purpose of the memory location at address $$31C-$31D ?[/INST]address       $31C-$31D      ICLOSE
Vector to Kernal CLOSE Routine (Currently at 62097 ($F291))"
"[INST]In the context of the C64, What is the purpose of the memory location at address $91?[/INST]address          $91            STKEY
Flag: Was STOP Key Pressed?

This location is updated every 1/60 second during the execution of the
IRQ routine that reads the keyboard and updates the jiffy clock.

The value of the last row of the keyboard matrix is placed here.  That
row contains the STOP key, and although this location is used
primarily to detect when that key has been pressed, it can also detect
when any of the other keys in that row of the matrix have been
pressed.

In reading the keyboard matrix, a bit set to 1 means that no key has
been pressed, while a bit reset to 0 indicates that a key is pressed.
Therefore, the following values indicate the keystrokes detailed
below:

255 $FF  = no key pressed
254 $FE  = 1 key pressed
253 $FD  = (left arrow) key pressed
251 $FB  = CTRL key pressed
247 $F7  = 2 key pressed
239 $EF  = space bar pressed
223 $DF  = Commodore logo key pressed
191 $BF  = Q key pressed
127 $7F  = STOP key pressed

VIC owners will notice that the 64's keyboard matrix is very different
from the VIC's.  One of the advantages of this difference is that you
can test for the STOP key by following a read of this location with a
BPL instruction, which will cause a branch to occur anytime that the
STOP key is pressed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F864?[/INST]address              $F864
Start Writing a Block of Data to the Cassette

This subroutine tests the cassette switch and initializes various
flags for writing a block of data to cassette."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F1CA?[/INST]address              $F1CA          CHROUT
Output a Byte

This is a documented Kernal routine whose jump table entry point is at
65490 ($FFD2).  The routine jumps through a RAM vector at 806 ($326).
It is probably one of the best known and most used Kernal routines,
because it sends the character in the Accumulator to the current
output device.  Unless a device has been OPENed and designated as the
current output channel using the CHKOUT routine, the character is
printed to the screen, which is the default output device.  If the
cassette is the current device, outputting a byte will only add it to
the buffer.  No actual transmission of data will occur until the
192-byte buffer is full."
"[INST]In the context of the C64, What is the purpose of the memory location at address $AE-$AF?[/INST]address       $AE-$AF        EAL
Pointer to Ending Address of Load (End of Program)

This location is set by the Kernal routine SAVE to point to the ending
address for SAVE, LOAD, or VERIFY."
"[INST]In the context of the C64, What is the purpose of the memory location at address $30A-$30B?[/INST]address      $30A-$30B      IEVAL
Vector to the Routine That Evaluates a Single-Term Arithmetic
Expression

This vector points to the address of the EVAL routinea t 44678 ($AE86)
which, among other things, is used to evaluate BASIC functions such as
INT and ABS.

Location Range: 780-783 ($30C-$30F)
Register Storage Area

The BASIC SYS command uses this area to store 6510 internal
registers--the Accumulator (.A), the .X and .Y index registers, and
the status register, .P.

Before every SYS command, each of the registers is loaded with the
value found in the corresponding storage address.  After the ML
program finished executing, and returns to BASIC with an RTS
instruction, the new value of each register is stored in the
appropriate storage address.  This is only true of SYS, not of the
similar USR command.

This feature allows you to place the necessary preentry values into
the registers from BASIC before you SYS to a Kernal or BASIC ML
routine.  It also enables you to examine the resulting effect of the
routine on the registers, and to preserve the condition of the
registers on exit for subsequent SYS calls.

An extremely practical application comes immediately to mind.
Although the 64's BASIC 2 has many commands for formatting printed
characters on the monitor screen (for example, TAB, SPC, PRINT A$,B),
there is none to adjust the vertical cursor position.

There is a Kernal routine, PLOT (58634, $E50A), which will allow you
to position the cursor anywhere on the screen.  In order to use it,
you must first clear the carry flag (set it to 0), and then place the
desired horizontal column number in the .Y register and the vertical
row number in the .X register before entering the routine with a SYS
65520.  Using the register storage area, we can print the work HELLO
at row 10, column 5 with the following BASIC line:

POKE 781,10:POKE 782,5:POKE 783,0:SYS 65520:PRINT 'HELLO'

You can also use these locations to help you take advantage of Kernal
routines that return information in the register.  For example, the
SCREEN routine (58629,$E505) returns the number of screen rows int he
.Y register, and the number of columns in the .X register.  Using this
routine, a BASIC program could be written to run on machines with
different screen formats (for example, the 64 and the VIC-20).  Just
PEEK(781) after a SYS 65517 to see how many screen columns the
computer display has."
"[INST]In the context of the C64, What is the purpose of the memory location at address $29E?[/INST]address         $29E           RODBE
RS-232: Index to End of Transmit Buffer

This index points to the ending byte within the 256-byte RS-232
transmit buffer, and is used to add data to that buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F086?[/INST]address              $F086
GETIN for the RS-232 Device

The Kernal GETIN routine calls this subroutine to remove the next byte
of data from the RS-232 receive buffer and return it in the
Accumulator.  The routine checks for the Receive Buffer Empty Error.
It is also called by the Kernal CHRIN routine, which essentially does
the same thing as GETIN for the RS-232 device."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EF90?[/INST]address     328         $EF90
Test If Start Bit Received from RS-232"
"[INST]In the context of the C64, What is the purpose of the memory location at address $A560?[/INST]address         $A560          INLIN
Input a Line to Buffer from Keyboard

This subroutine calls the Kernal CHRIN routine (61783, $F157) to
obtain a line of input from the current input device (usually the
keyboard).  It stores the characters in the BASIC text input buffer at
512 ($200) until a carriage return or 89 characters have been
received.  The keyboard device will never return more than 80
characters before a carriage return, but other devices can output a
longer line.  An error will occur if the line goes over 80 characters."
"[INST]In the context of the C64, What is the purpose of the memory location at address $332-$333[/INST]address       $332-$333      ISAVE
Vector: Kernal SAVE Routine (Currently at 62941 ($F5DD))"
"[INST]In the context of the C64, What is the purpose of the memory location at address $EAE0?[/INST]address              $EAE0
Decode the Keystroke and Place its ASCII Value in the Keyboard Buffer

This is the continuation of the IRQ keyscan routine.  It decodes the
keycode with the proper PETASCII table, and compares it with the last
keystroke.  If if is the same, it checks to see if it is okay to
repeat the character without waiting for the key to be let up.  If the
character should be printed, it is moved to the end of the keyboard
buffer at 631 ($277)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EC44?[/INST]address              $EC44
Set Lowercase/Uppercase or Uppercase/Graphics Character Set

The part of the Kernal CHROUT routine that outputs to the screen uses
this subroutine to check for the special nonprinting characters that
switch the character set (CHR$(14) and CHR$(142)).  If one of these is
the character to be printed, this routine makes the switch by setting
the location 53272 ($D018) accordingly."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A00C-$A051?[/INST]address   $A00C-$A051    STMDSP
Statement Dispatch Vector Table

This table contains two-byte vectors, each of which points to an
address which is one byte before the address of one of the routines
that perform a BASIC statement.

The statements are in token number order.  When it comes time to
execute a statement, the NEWSTT routine at 42926 ($A7AE) places this
address-1 on the stack and jumps to the CHRGET routine.  The RTS
instruction at the end of that routine causes the statement address to
be pulled off the stack, incremented, and placed in the Program
Counter, just as if it were the actual return address."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A7E4?[/INST]address         $A7E4          GONE
Read and Execute the Next Statement

This is the routine which gets the next token and executes the
statement.  It is vectored through RAM at 776 ($308) to allow the
addition and execution of new statement tokens.

Since a statement must always start with a token or an implied LET
statement, this routine checks to see if the first character is a
valid token.  If it is, the address is placed on the stack, so that a
call to CHRGET will return to the address of the code that executes
the statement (see the table of statement tokens at 40972 ($A00C)).

An invalid token will cause a SYNTAX ERROR.  A character whose ASCII
value is less that 128 will cause LET to be executed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A000 to $BFFF?[/INST]Locations 40960 to 49152 ($A000 to $BFFF) are used by the BASIC ROM
when it is selected (which is the default condition).  BASIC is the
64's main program, which is always run if there is no autostart
cartridge inserted at power-up time.  When the 64 tells you READY,
that's BASIC talking.

The BASIC interpreter that comes with the 64 is, aside from being
located in a different memory space, almost identical to the Microsoft
BASIC interpreter found on the VIC-20.  Both of these interpreters are
slightly modified versions of PET BASIC 2.0, also known as PET BASIC
3.0 or Upgrade BASIC, because it was an upgraded version of the BASIC
found on the original PET.

This is a somewhat mixed blessing, because while PET BASIC was, in its
day, quote an advanced language for use with an eight-bit
microprocessor, it lacks several of the features (such as error
trapping) which are now standard on most home computers.  And, of
course, it makes no provision whatever for easy use of the many
graphics and sound capabilities made available by the new dedicated
video and sound support chips.

On the other hand, its faithfulness to the original Commodore BASIC
allows a large body of software to be translated for the 64 with
little change (in most cases, the PET Emulator program from Commodore
will allow you to run PET programs with no changes).  Programming aids
and tricks developed for the PET and VIC will, for the most part,
carry over quite nicely to the 64.  Although there is no official
source code listing of the ROM available from Commodore, this version
of BASIC has been around long enough that it has been thoroughly
disassembled, dissected, and documented by PET users.

The labels used here correspond to those used by Jim Butterfield in
his PET memory maps, which are well-known among PET BASIC users.  They
should, therefore, provide some assistance in locating equivalent
routines on the two machines.  A good description of the workings of
PET BASIC can be found in Programming the PET/CBM by Raeto West.

It is beyond the scope of this book to detail the inner workings of
each routine in the BASIC interpreter.  However, the following summary
of routines and their functions should aid the user who is interested
in calling BASIC routines from his or her own program, or in modifying
the BASIC.

Please keep in mind that the entry and exit points listed for routines
that perform a particular function are to be used as guideposts, and
not absolutes.  In fact, BASIC enters many of these routines from
slightly different places to accomplish different tasks.  Some
subroutines are called by so many commands that it is hard to say
which they belong to.  You will even find that some whole commands are
part of other commands.  Where it is important for you to know the
details of a particular routine, you will need to obtain a disassembly
of that section and look at the machine language program itself.

It should be noted that when BASIC is not neede,d it can be switched
out and the RAM underneath can be accessed by the VIC-II chip and used
for screen graphics.  See location 56576 ($DD00) for more information."
"[INST]In the context of the C64, What is the purpose of the memory location at address $ECE7?[/INST]address              $ECE7
Text for Keyboard Buffer When SHIFT/RUN is Pressed

When the SHIFT and RUN keys are pressed, the ASCII text stored here is
forced into the keyboard buffer.  That text is LOAD, carriage return,
RUN, carriage return."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EA1C?[/INST]address              $EA1C
Store to Screen

This routine stores the character in the .A register to the screen
address pointed to by 209 ($D1), and stores the color in the .X
register to the address pointed to by 243 ($F3)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $0400-$07E7?[/INST]address     $400-$7E7
Video Matrix: 25 Lines by 40 Columns

The video matrix is where thext screen characters are stored in RAM.
Normally, the VIC-II chip will treat each byte of memory here as a
screen display code and will display the text character that
corresponds to that byte of code.  The first byte of memory here will
be displayed in the top-left corner of the screen, and subsequent
bytes will be displayed in the columns to the right and the rows below
that character.

It is possible to make text or graphics characters appear on the
screen by POKEing their screen codes directly into this area of RAM.
For example, the letter A has a screen code value of 1.  Therefore,
POKE 1024,1 should make the letter A appear in the top-left corner of
the screen.

However, you should be aware that the most current version of the
Operating System initializes the color RAM which is used for the
foreground color of text characters to the same value as the
background color every time that the screen is cleared.  The result is
that although the POKE will put a blue A on the screen, you won't be
able to see it because it is the same color blue as the background.
This can be remedied by POKEing a different value into color RAM
(which starts at 55296 ($D800)).

A POKE 1024,1:POKE 1024+54272,1 will put a white A in the upper-left
corner of the screen.  The loop

FOR I=0 TO 255:POKE 1024+I,I:POKE 1024+54272+I,1:NEXT

will display all of the characters in white at the top of the screen.
Another solution to the color RAM problem is to fool the Operating
System into initializing the color RAM for you.  If you change the
background color to the desired foreground color before you clear the
screen, color RAM will be set to that color.  Then, all you have to do
is change the background color back to what it was.  This example will
show how it's done:

10 POKE 53281,2:REM BACKGROUND IS RED
20 PRINT CHR$(147):REM CLEAR SCREEN
30 POKE 53281,1:REM BACKGROUND IS WHITE
40 POKE 1024,1:REM RED 'A' APPEARS IN TOP LEFT CORNER"
"[INST]In the context of the C64, What is the purpose of the memory location at address $EE85?[/INST]address              $EE85
Set the Serial Clock Line Low (Active)

This subroutine clears the serial bus clock pulse output bit (Bit 4 of
CIA #2 Data Port A at 56576 ($DD00))."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F6FB?[/INST]address              $F6FB
Set Kernal I/O Error Messages

This subroutine is used to handle I/O errors from Kernal I?O routines.
It calls CLRCHN to restore default I/O devices.  If Bit 6 of the flag
at 157 ($9D) is set, it prints I/O ERROR followed by the error number,
and then sets the Carry flag to indicate an error, with the error
number in the Accumulator.  The Kernal error messages are not used by
BASIC, but may be used by machine language monitors and other
applications."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EF97?[/INST]address              $EF97
Put a Byte of Received Data into RS-232 Receive Buffer

This routine checks for a Receive Buffer Overrun, stores the byte just
received in the RS-232 receive buffer, and checks for Parity Error,
Framing Error, or Break Detected Error.  It then sets up to receive
the next byte.

614"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BD?[/INST]address          $BD            ROPRTY
RS-232 Output Parity/Cassette Temporary Storage

This location is used by the RS-232 routines as an output parity work
byte, and by the tape as temporary storage for the current character
being read or sent."
"[INST]In the context of the C64, What is the purpose of the memory location at address $2A3?[/INST]address           $2A3
Save Area for CIA #1 Interrupt Control Register During Cassette Read"
"[INST]In the context of the C64, What is the purpose of the memory location at address $302-$303?[/INST]address      $302-$303      IMAIN
Vector to the Main BASIC Program Loop

This vector points to the address of the main BASIC program loop at
42115 ($A483).  This is the routine that is operating when you are in
the direct mode (READY).  It executes statements, or stores them as
program lines."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F30F?[/INST]address              $F30F
Find the File in the Logical File Table

This subroutine is used by many Kernal routines to find the position
of the logical file in the logical file table at 601 ($259)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $95?[/INST]address           $95            BSOUR
Buffered Character for Serial Bus

This is the character waiting to be sent.  A 255 ($FF) indicates that
no character is waiting for serial output."
"[INST]In the context of the C64, What is the purpose of the memory location at address $330-$331?[/INST]address       $330-$331      ILOAD
Vector to Kernal LOAD Routine (Currently at 62622 ($F49E))"
"[INST]In the context of the C64, What is the purpose of the memory location at address $9B?[/INST]address           $9B            PRTY
Tape Character Parity

This location is used to help detect when bits of information have
been lost during transmission of tape data."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A?[/INST]address            $A             VERCK
Flag: LOAD or VERIFY

BASIC uses one Kernal routine to perform either the LOAD or VERIFY
function, depending on whether the Accumulator (.A) is set to 0 or 1
upon entry to the routine.  BASIC sets the value of VERCK to 0 for a
LOAD, or 1 for a VERIFY.  Its contents are passed to the Kernal LOAD
routine, which in turn stores it in location 147 ($93)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BCCC?[/INST]address         $BCCC          INT
Perform INT

This routine removes the fractional part of a floating point number by
calling the routine above to change it to an integer, and then
changing the integer back to floating point format."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BDDD?[/INST]address         $BDDD          FOUT
Convert Contents of FAC1 to ASCII String

This routine converts a floating point number to a string of ASCII
digits, and sets a pointer to the string in .A and .Y."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D01B?[/INST]address              $D01B          SPBGPR
Sprite to Foreground Display Priority Register

Bit 0:  Select display priority of Sprite 0 to foreground (0=sprite
        appears in front of foreground)
Bit 1:  Select display priority of Sprite 1 to foreground (0=sprite
        appears in front of foreground)
Bit 2:  Select display priority of Sprite 2 to foreground (0=sprite
        appears in front of foreground)
Bit 3:  Select display priority of Sprite 3 to foreground (0=sprite
        appears in front of foreground)
Bit 4:  Select display priority of Sprite 4 to foreground (0=sprite
        appears in front of foreground)
Bit 5:  Select display priority of Sprite 5 to foreground (0=sprite
        appears in front of foreground)
Bit 6:  Select display priority of Sprite 6 to foreground (0=sprite
        appears in front of foreground)
Bit 7:  Select display priority of Sprite 7 to foreground (0=sprite
        appears in front of foreground)

If a sprite is positioned to appear at a spot on the screen that is
already occupied by text or bitmap graphics, a conflict arises.  The
contents of this register determines which one will be displayed in
such a situation.  If the bit that corresponds to a particular sprite
is set to 0, the sprite will be displayed in front of the foreground
graphics data.  If that bit is set to 1, the foreground data will be
displayed in front of the sprite.  The default value that this
register is set to at power-on is 0, so all sprites start out with
priority over foreground graphics.

Note that for the purpose of priority, the 01 bit-pair of multicolor
graphics modes is considered to display a background color, and
therefore will be shown behind sprite graphics even if the foreground
graphics data takes priority.  Also, between the sprites themselves
there is a fixed priority.  Each sprite has priority over all
higher-number sprites, so that Sprite 0 is displayed in front of all
the others.

The use of priority can aid in creating three-dimensional effects, by
allowing some objects on the screen to pass in front of or behind
other objects."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D029?[/INST]address              $D029          SP2COL
Sprite 2 Color Register (the default color value is 3, cyan)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BF7B?[/INST]address         $BF7B          FPWRT
Performs Exponentation (Power Calculation Called for by UPARROW)

This routine raises the value in FAC2 to the power in FAC1 and leaves
the result in FAC1."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D01A?[/INST]address              $D01A          SP3COL
Sprite 3 Color Register (the default color value is 4, purple)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BFB4?[/INST]address         $BFB4          NEGOP
Perform NOT and >

This negates the Floating Point Accumulator by exclusive ORing the
sign byte with a constant of 255 ($FF).  Zero is left unchanged.  The
results of this command follow rom the formula NOT X=-(X+1).
Therefore, if you NOT a tatement that is true (-1), you get 0 (false)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BF11?[/INST]address         $BF11          FHALF
The Constant Value 1/2 in Five-Byte Floating Point Notation

This constant is used for rounding and SQR."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D01C?[/INST]address              $D01C          SPMC
Sprite Multicolor Registers

Bit 0:  Select multicolor mode for Sprite 0 (1=multicolor, 0=hi-res)
Bit 1:  Select multicolor mode for Sprite 1 (1=multicolor, 0=hi-res)
Bit 2:  Select multicolor mode for Sprite 2 (1=multicolor, 0=hi-res)
Bit 3:  Select multicolor mode for Sprite 3 (1=multicolor, 0=hi-res)
Bit 4:  Select multicolor mode for Sprite 4 (1=multicolor, 0=hi-res)
Bit 5:  Select multicolor mode for Sprite 5 (1=multicolor, 0=hi-res)
Bit 6:  Select multicolor mode for Sprite 6 (1=multicolor, 0=hi-res)
Bit 7:  Select multicolor mode for Sprite 7 (1=multicolor, 0=hi-res)

Sprite multicolor mode is very similar to text and bitmap multicolor
modes (see Bit 4 of 53270, $D016).  Normally, the color of each dot of
the sprite is controlled by a single bit of sprite shape data.  When
thi mode is enabled for a sprite, by setting the corresponding bit of
this register to 1, the bits of sprite shape data are grouped together
in pairs, with each pair of bits controlling a double-wide dot of the
sprite display.  By sacrificing some of the horizontal resolution (the
sprite, although the same size, is now only 12 dots wide), you gain
the use of two additional colors.  The four possible combinations of
these bit-pairs display dot colors from the following sources:

00 Background Color Register 0 (transparent)
01 Sprite Multicolor Register 0 (53285, $D025)
10 Sprite Color Registers (53287-94, $D027-E)
11 Sprite Multicolor Register 1 (53286, $D026)

Like multicolor text characters, multicolor sprites all share two
color registers.  While each sprite can display three foreground
colors, only one of these colors in unique to that sprite.  The number
of unique colors may be increated by combining more than one sprite
into a single character."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BCF3?[/INST]address         $BCF3          FIN
Convert an ASCII String to a Floating Point Number FAC1

This routine is called by VAL to evaluate and convert an ASCII string
to a floating point number."
"[INST]In the context of the C64, What is the purpose of the memory location at address $9?[/INST]address             $9             TRMPOS
Column position of the Cursor before the Last TAB or SPC

TRMPOS is used by TAB and SPC.  The cursor column position prior to
the TAB or SPC is moved here from 211 ($D3), and is used to calculate
where the cursor ends up after one of these functions is invoked.
Note that the value contained here shows the position of the cursor on
a logical line.  Since one logical line can be up to two physical
lines long, the value stored here can range from 0 to 79."
"[INST]In the context of the C64, What is the purpose of the memory location at address $9A?[/INST]address           $9A            DFLTO
Default Output (CMD) Device (Set to 3 for the Screen)

The default value of this location is 3, which designates the screen
as the current output device.  That value can be changed by the Kernal
routine CHKOUT (62032, $F250), which uses this location to store the
device number of the device whose file it defines as an output
channel.

BASIC calls CHKOUT whenever the command PRINT# or CMD is executed, but
clears the channel after the PRINT# operation has been completed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $94?[/INST]address          $94            C3PO
Flag: Serial Bus--Output Character Was Buffered

This location is used by the serial output routines to indicate that a
character has been placed in the output buffer and is waiting to be
sent."
"[INST]In the context of the C64, What is the purpose of the memory location at address $32E-$32F?[/INST]address       $32E-$32F      USRCMD
Vector to User-Defined Command (Currently Points to BRK at 65126
($FE66))

This appears to be a holdover from PET days, when the built-in machine
language monitor would JuMP through the USRCMD vector when it
encountered a command that it did not understand, allowing the user to
add new commands to the monitor.

Although this vector is initialized to point to the routine called by
STOP/ RESTORE and the BRK interrupt, and is updated by the Kernal
VECTOR routine (64794, $FD1A), it does not seem to have the function
of aiding in the addition of new commands."
"[INST]In the context of the C64, What is the purpose of the memory location at address $304-$305?[/INST]address      $304-$305      ICRNCH
Vector to the Routine That Crunches the ASCII Text of Keywords into
Tokens

This vector points to the address of the CRUNCH routine at 42364
($A57C)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F31F?[/INST]address              $F31F
Set Current Logical File, Current Device, and Current Seconday Address

This subroutine is used to update the Kernal variables at 184-186
($B8-$BA) which holds the current logical file number, current device
number, and current secondary address number."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BE?[/INST]address           $BE            FSBLK
Cassette Read/Write Block Count

Used by the tape routines to count the number of copies of a data
block remaining to be read or written."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EFE1?[/INST]address     09         $EFE1
CHKOUT for the RS-232 device

The Kernal CHKOUT routine calls this subroutine to define the RS-232
device's logical file as an output channel.  Before this can be done,
the logical file must first be OPENed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $2A4?[/INST]address           $2A4
Save Area for CIA #1 Control Register A During Cassette Read"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F72C?[/INST]address              $F72C
Get Next Tape File Header from Cassette

This routine reads in tape blocks until it finds a file header block.
It then prints out the FOUND message along with the first 16
characters of the filename."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EE13?[/INST]address              $EE13          ACPTR
Receive a Byte of Data from a Device on the Serial Bus

This is a documented Kernal routine whose entry point in the jump
table is 65445 ($FFA5).  When called, it will get a byte of data from
the current TALKer on the serial bus and store it in the Accumulator.
In order to receive the data, the device must have previously been
sent a command to TALK and a secondary address if it needs one."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EA24?[/INST]address              $EA24
Synchronize Color RAM Pointer to Screen Line Pointer

This subroutine sets the pointer at 243 ($F3) to the address of the
beginning of the line of Color RAM which corresponds to the current
line of screen RAM (whose pointer is at 209 ($D1))."
"[INST]In the context of the C64, What is the purpose of the memory location at address $7F8-$7FF?[/INST]address     $7F8-$7FF
Sprite Shape Data Pointers

The last eight bytes of the video matrix (whether it is here at the
default location, or has been relocated elsewhere) are used as
pointers to the data blocks used to define the sprite shapes.

Each sprite is 3 bytes wide (24 bits) by 21 lines high.  It therefore
requires 63 bytes for its shape definition, but it actually uses 64
bytes in order to arrive at an even 256 shape blocks in the 16K area
of RAM which the VIC-II chip addresses.

Each pointer holds the current data block being used to define the
shape of one sprite.  The block numver used to define the shape of
Sprite 0 is held in location 2040 ($7F8), the Sprite 1 shape block is
designated by location 2041 ($7F9), etc.  The value in the pointer
times 64 equals the starting location of the sprite shape data table.
For example, a value of 11 in location 2040 indicates that the shape
data for Sprite 0 starts at address 704 (11*64), and continues for 63
more bytes to 767.

For additional information on sprite graphics, see the entries for
individual VIC-II chip sprite graphics locations, and the summary at
the beginning of the VIC-II chip section, at 53248 ($D000)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A000-$A001?[/INST]address  $A000-$A001
Cold Start Vector

This vector points to the address of the routine used to initialize
BASIC.  After the Operating System finishes its power-on activities,
it enters the BASIC program through this vector.  The most visible
effect of the BASIC initialization routine is that the screen is
cleared, and the words:

     **** COMMODORE 64 BASIC V2 ****

are printed along with the BYTES FREE message.  For details of the
steps taken during the initialization of BASIC, see the entry for
58260 ($E394), the current cold start entry point."
"[INST]In the context of the C64, What is the purpose of the memory location at address $ECF0?[/INST]address              $ECF0
Low Byte Table of Screen Line Addresses

This table holds the low byte of the screen address for lines 0-24.
The high byte is derived from combining a value from the screen line
link table at 217 ($D9) with the pointer to screen memory at 648
($288)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A81D?[/INST]address         $A81D          RESTOR
Perform RESTORE

The RESTORE command simply resetes the DATA pointer at 65-66 ($41-$42)
from the start of BASIC pointer at 43-44 ($2B-$2V)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E87C?[/INST]address              $E87C
Move Cursor to Next Line

This subroutine moves the cursor down to the next line if possible, or
scrolls the screen if the cursor is on the last line."
"[INST]In the context of the C64, What is the purpose of the memory location at address $1000-$1FFF?[/INST]address     $1000-$1FFF
Character ROM Image for VIC-II Chip When Using Memory Bank 0 (Default)

Though the VIC-II chip shares memory with the 6510 processor chip, it
does not always see that memory in exactly the same way as the main
microprocessor.

Although the 6510 accesses RAM at these locations, when the VIC-II is
banked to use the first 16K of RAM (which is the default condition),
it sees the character ROM here (the 6510 cannot access this ROM unless
it is switched into its memory at 49152 ($C000)).  This solves the
riddle of how the VIC-II chip can use the character ROM at 49152
($C000) for character shape data and RAM at 1024 ($400), when it can
only address memory within a 16K range.  It also means that the RAM at
4096-8191 cannot be used for screen display memory or user-defined
character dot data, and sprite data blocks 64-127 are not accessible.

You can verify this by turning on bitmap graphics with the screen
memory set to display addresses from 0 to 8192.  You will see that the
bottom portion of the screen shows all of the text character shapes
stored in the ROM.  For more information on the format of text
character data storage, see the description of the Character ROM at
49152 ($C000)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EA13?[/INST]address              $EA13
Set Cursor Blink Timing and Color Memory Address for Print to Screen

This subroutine sets the cursor blink countdown and sets the pointer
to Color RAM.  It then falls through to the next routine."
"[INST]In the context of the C64, What is the purpose of the memory location at address $ECB9?[/INST]address              $ECB9
Video Chip Register Default Table

This table contains the default values that are stored in the 47
VIC-II chip registers.  It is interesting to note that this table
appears to be incomplete.  While Sprite Color Registers 0-6 are
initialized to values of 1-7, Sprite Color Register 7 is initialized
to 76--the ASCII value of the letter L which begins on the next table."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A004-$A00B?[/INST]address  $A004-$A00B
ASCII Text characters CBMBASIC

The ASCII characters for the letters CBMBASIC are located here.
Possibly an identifier, this text is not referenced elsewhere in the
program."
"[INST]In the context of the C64, What is the purpose of the memory location at address $29B?[/INST]address          $29B           RIDBE
RS-232: Index to End of Receive Buffer

This index points to the ending byte within the 256-byte RS-232
receive buffer, and is used to add data to that buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F333?[/INST]address              $F333          CLRCHN
Restore Current Input and Output Devices to the Default Devices

This is a documented Kernal Routine which can be entered at location
65484 ($FFCC) in the jump table.

The routine jumps through a RAM vector at 802 ($322).  It sets the
current input device to the keyboard, and the current output device to
the screen.  Also, if the current input device was formerly a serial
device, the routine sends it an UNTALK command on the serial bus, and
if a serial device was formerly the current output device, the routine
sends it an UNLISTEN command."
"[INST]In the context of the C64, What is the purpose of the memory location at address $300-$301?[/INST]address       $300-$301      IERROR
Vector to the Print BASIC Error Message Routine

This vector points to the address of the ERROR routine at 58251
($E38B)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $2A2?[/INST]address           $2A2
Indicator of CIA #1 Control Register B Activity During Cassette I/O"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F04D?[/INST]address              $F04D
CHKIN for the RS-232 Device

The Kernal CHKIN routine calls this subroutine to define the RS-232
device's logical file as an input channel.  A prerequisite for this is
that the logical file first be OPENed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $98?[/INST]address           $98            LDTND
Number of Open I/O Files/Index to the End of File Tables

The number of currently open I/O files is stored here.  The maximum
number that can be open at one time is ten.  The number stored here is
used as the index to the end of the tables that hold the file numbers,
device numbers, and secondary address numbers (see locations 601-631
($259-$277) for more information about these tables).

CLOSE decreases this number and removes entries from the tables
referred to above, while OPEN increases it and adds the appropriate
information to the end of the tables.  The Kernal routine CLALL closes
all files by setting this number to 0, which effectively empties the
table."
"[INST]In the context of the C64, What is the purpose of the memory location at address $92?[/INST]address           $92            SVXT
Timing Constant for Tape Reads

This location is used as an adjustable timing constant for tape reads,
which can be changed to allow for the slight speed variation between
tapes."
"[INST]In the context of the C64, What is the purpose of the memory location at address $70?[/INST]address           $70            FACOV
Low Order Mantissa Byte of Floating Point Accumulator #1 (For
Rounding)

If the mantissa of the floating point number has more significant
figures than can be held in four bytes, the least significant figures
are placed here.  They are used to extend the accuracy of intermediate
mathematical operations and to round to the final figure."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D406?[/INST]address              $D406          SUREL1
Voice 1 Sustain/Release Control Register

Bits 0-3:  Select release cycle duration (0-15)
Bits 4-7:  Select sustain volume level (0-15)

Bits 4-7 select the volume level at which the note is sustained.
Following the decay cycle, the volume of the output of voice 1 will
remain at the selected sustain level as long as the gate bit of the
Control Register is set to 1.  The sustain values range from 0, which
chooses no volume, to 15, which sets the output of voice 1 equal to
the peak volume achieved during the attack cycle.

Bits 0-3 determine the length of the release cycle.  This phase, in
which the volume fades from the sustain level to near zero volume,
begins when the gate bit of the Control Register is set to 0 (while
leaving the waveform setting that was previously chosen).  The
duration of this decline in volume corresponds to the number (0-15)
selected in the same way as for the decay value:

0 = 6 milliseconds           8 = 300 milliseconds
1 = 24 milliseconds          9 = 750 milliseconds
2 = 48 milliseconds         10 = 1.5 seconds
3 = 72 milliseconds         11 = 2.4 seconds
4 = 114 milliseconds        12 = 3 seconds
5 = 168 milliseconds        13 = 9 seconds
6 = 204 milliseconds        14 = 15 seconds
7 = 240 milliseconds        15 = 24 seconds

Location Range: 54279-54292 ($D407-$D414)
Voice 2 and Voice 3 Controls

The various control registers for these two voices correspond almost
exactly to those of voice 1.  The one exception is that the sync and
ring-modulation bits of voice 2 operate on Oscillators 1 and 2, while
the same bits of the Control Register for voice 3 uses Oscillators 2
and 3."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BFED?[/INST]address         $BFED          EXP
Perform EXP

This routine calculates the natural logarithm e (2.718281828...)
raised to the power in FAC1.  The result is left in FAC1.

This routine is split between the BASIC ROM wich ends at 49151 ($BFFF)
and the Kernal ROM which begins at 57344 ($E000).  Therefore, a JMP
$E000 instruction is tacked on to the end, which makes the BASIC
routines in the 64 Kernal ROM three bytes higher in memory than the
corresponding VIC-20 routines."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D028?[/INST]address              $D028          SP1COL
Sprite 1 Color Register (the default color value is 2, red)"
"[INST]In the context of the C64, What is the purpose of the memory location at address 53274 ($D01A)?[/INST]address     3274         $D01A          IRQMASK
IRQ Mask Register

Bit 0:  Enable Raster Compare IRQ (1=interrupt enabled)
Bit 1:  Enable IRQ to occure when sprite collides with display of
  normal
        graphics data (1=interrupt enabled)
Bit 2:  Enable IRQ to occur when two sprites collide (1=interrupt
  enabled)
Bit 3:  Enable light pen to trigger an IRQ (1=interrupt enabled)
Bits 4-7:  Not used

This register is used to enable an IRQ request to occur when one of
the VIC-II chip interrupt conditions is met.  In order to understand
what that means, and how these interrupts can extend the range of
options available to a programmer, you must first understand what an
interrupt is.

An interrupt is a signal given to the microprocessor (the brains of
the computer) that tells it to stop executing its machine language
program (for example, BASIC), and to work on another program for a
short time, perhaps only a fraction of a second.  After finishing the
interrupt program, the computer goes back to executing the main
program, just as if there had never been a detour.

Bit 0.  This bit enables the Raster Compare IRQ.  The conditions for
this IRQ are met when the raster scan reaches the video line indicated
by the value written to the Raster Register at 53266 ($D012) and Bit 7
of 53265 ($D011).  Again, an explanation of the terminology is in
order.

In the normal TV display, a beam of electrons (raster) scans the
screen, starting in the top-left corner, and moving in a straight line
to the right, lighting up appropriate parts of the screen line on the
way.  When it comes to the right edge, the beam moves down a line, and
starts again from the left.  There are 262 such line that are scanned
by the 64 display, 200 of which form the visible screen area.  This
scan updates the complete screen display 60 times every second.

The VIC-II chip keeps track of which line is being scanned, and stores
the scan number in the Raster Register at 53266 and 53265 ($D012 and
$D011).  The Raster Register has two functions.  When read, it tells
what line is presently being scanned.  But when written to, it
designates a particular scan line as the place where a raster
interrupt will occur.

At the exact moment that the raster beam line number equals the number
written to the register, Bit 0 of the status register will be set to
1, showing that the conditions for a Raster Compare Interrupt have
been fulfulled.  If the raster interrupt is enabled then,
simultaneously, the interrupt program will be executed.  This allows
the user to reset any of the VIC-II registers at any point in the
display, and thus change character sets, background color, or graphics
mode for only a part of the screen display.

The interrupt routine will first check if the desired condition is the
source of the interrupt (see above entry) and then make the changes to
the screen display.  Once you have written this interrupt routine, you
must take the following steps to install it.

1.  Set the interrupt disable flag in the status register with an SEI
instruction.  This will disable all interrupts and prevent th system
from crashing while you are changing the interrupt vectors.

2.  Enable the raster interrupt.  This is done by setting Bit 0 of the
VIC- II chip interrupt enable register at location 53274 ($D01A) to 1.

3.  Indicate the scan line on which you want the interrupt to occur by
writing to the raster registers.  Don't forget that this is a nine-bit
value, and you must set both the low byte (in location 53266 ($D012))
and the high bit (in the register at 53265 ($D011)) in order to insure
that the interrupt will start at the scan line you want it to, and not
256 lines earlier or later.

4.  Let the computer know where the machine language routine that you
want the interrupt to execute starts.  This is done by placing the
address in the interrupt vector at locations 788-789 ($314-$315).
This address is split into two parts, a low byte and a high byte, with
the low byte stored at 788.

To calculate the two values for a given address AD, you may use the
formula HIBYTE=INT(AD/156) and LOWBYTE=AD-(HIBYTE*256).  The value
LOWBYTE would go into location 788, and the value HIBYTE would go into
location 789.

5.  Reenable interrupts with a CLI instruction, which clears the
interrupt disable flag on the status register.

When the computer is first turned on, the interrupt vector is set to
point to the normal hardware timer interrupt routine, the one that
advances the jiffy clock and reads the keyboard.  Since this interrupt
routine uses the same vector as the raster interrupt routine, it is
best to turn off the hardware timer interrupt by putting a value of
127 in location 56333 ($DC0D).

If you want the keyboard and jiffy clock to function normally while
your interrupt is enabled, you must preserve the contents of locations
788 and 789 before you change them to point to your new routine.  Then
you must have your interrupt routine jump to the old interrupt routine
exactly once per screen refresh (every 1/60 second).

Another thing that you should keep in mind is that at least two raster
interrupts are required if you want to change only a part of the
screen.  Not only must the interrupt routine change the display, but
it must also set up another raster interrput that will change it back.

The sample program below uses a raster-scan interrupt to divide the
display into three sections.  The first 80 scan lines are in
high-resolution bitmap mode, the next 40 are regular text, and the
last 80 are in multicolor bitmap mode.  The screen will split this way
as soon as a SYS to the routine that turns on the interrupt occurs.
The display will stay split even after the program ends.  Only if you
hit the STOP and RESTORE keys together will the display return to
normal.

The interrupt uses a table of values that are POKEd into four key
locations during each of the three interrupts, as well as values to
determine at what scan lines the interrupt will occur.  The locations
affected are Control Register 1 (53265, $D011), Control Register 2
(53270, $D016), the Memory Control Register (53272, $D018), and
Background Color 0 (53281, $D021).  The data for the interrupt routine
is contained in lines 49152-49276.  Each of these line numbers
corresponds to the locations where the first data byte in the
statement is POKEd into memory.

If you look at lines 49264-49276 of the BASIC program, you will see
REMark statements that explain which VIC-II registers are affected by
the DATA statements in each line.  The number in these DATA
startements appear in the reverse order in which they are put into the
VIC register.  For example, line 49273 holds the data that will go
into Control Register 2.  The last number, 8, is the one that will be
placed into Control Register 2 while the top part of the screen is
displayed.  The first number, 24, is placed into Control Register 2
during the bottom part of the screen display, and changes that portion
of the display to multicolor mode.

The only tricky part in determining which data byte affects which
interrupt comes in line 49264, which holds the data that determines
the scan line at which each interrupt will occur.  Each DATA statement
entry reflects the scan line at which the next interrupt will occur.
The first item in line 49264 is 49.  Even though this is the entry for
the third interrupt, the next to be generates is the first interrupt,
which occurs at the top of the screen.  Likewise, the last data item
of 129 is used during the first interrupt to start the next interrupt
at scan line 129.

Try experimenting with these values to see what results you come up
with.  For example, if you change the number 170 to 210, you will
increase the text area by five lines (40 scan lines).

By changing the values in the data tables, you can alter the effect of
each interrupt.  Change the 20 in line 49276 to 22, and you will get
lowercase text in the middle of the screen.  Change the first 8 in
line 49273 to 24, and you'll get multicolor text in the center window.
Each of these table items may be used exactly like you would use the
corresponding register, in order to change background color, to obtain
text or bitmap graphics, regular or multicolor modes, screen blanking
or extended background color mode.

It is even possible to change the table values during a program, by
POKEing the new value into the memory location where those table
values are stored.  In that way, you can, for example, change the
background color of any of the screen parts while the program is
running.

5 FOR I=0 TO 7:BI(I)=2^I:NEXT
10 FOR I=49152 TO 49278:READ A:POKE I,A:NEXT:SYS12*4096
20 PRINT CHR$(147):FOR I=0 TO 8:PRINT:NEXT
30 PRINT'THE TOP AREA IS HIGH-RES BIT MAP MODE'
40 PRINT:PRINT'THE MIDDLE AREA IS ORDINARY TEXT '
50 PRINT:PRINT'THE BOTTOM AREA IS MULTI-COLOR BIT MAP'
60 FORG=1384 TO 1423:POKE G,6:NEXT
70 FORG=1024 TO 1383:POKEG,114:POKE G+640,234:NEXT
80 A$='':FOR I=1 TO 128:A$=A$+'@':NEXT:FOR I=32 TO 63 STEP 2
90 POKE 648,I:PRINT CHR$(19)CHR$(153);A$;A$;A$;A$:NEXT:POKE 648,4
100 BASE=2*4096:BK=49267
110 H=40:C=0:FORX=0TO319:GOSUB150:NEXT
120 H=160:C=0:FORX=0TO319STEP2:GOSUB150:NEXT:C=40
125 FORX=1TO319STEP2:GOSUB150:NEXT
130 C=80:FOR X=0 TO 319 STEP2:W=0:GOSUB150:W=1:GOSUB150:NEXT
140 GOTO 140
150 Y=INT(H+20*SIN(X/10+C)):BY=BASE+40*(Y AND 248)+(Y AND 7)+(X AND 504)
160 POKE BY,PEEK(BY) OR (BI(ABS(7-(XAND7)-W))):RETURN
49152 DATA 120, 169, 127, 141, 13, 220
49158 DATA 169, 1, 141, 26, 208, 169
49164 DATA 3, 133, 251, 173, 112, 192
49170 DATA 141, 18, 208, 169, 24, 141
49176 DATA 17, 208, 173, 20, 3, 141
49182 DATA 110, 192, 173, 21, 3, 141
49188 DATA 111, 192, 169, 50, 141, 20
49194 DATA 3, 169, 192, 141, 21, 3
49200 DATA 88, 96, 173, 25, 208, 141
49206 DATA 25, 208, 41, 1, 240, 43
49212 DATA 190, 251, 16, 4, 169, 2
49218 DATA 133, 251, 166, 251, 189, 115
49224 DATA 192, 141, 33, 208, 189, 118
49230 DATA 192, 141, 17, 208, 189, 121
49236 DATA 192, 141, 22, 208, 189, 124
49242 DATA 192, 141, 24, 208, 189, 112
49248 DATA 192, 141, 18, 208, 138, 240
49254 DATA 6, 104, 168, 104, 170, 104
49260 DATA 64, 76, 49, 234
49264 DATA 49, 170, 129 :REM SCAN LINES
49267 DATA 0, 6, 0:REM BACKGROUND COLOR
49270 DATA 59, 27,59:REM CONTROL REG. 1
49273 DATA 24, 8, 8:REM CONTROL REG. 2
49276 DATA 24, 20, 24:REM MEMORY CONTROLRUN

Besides enabling the creation of mixed graphics-modes screens, the
Raster Compare Interrupt is also useful for creating scrolling zones,
so that some parts of the screen can be fine-scrolled while the rest
remains stationary.

Bit 1 enables the light pen interrupt.  This interrupt can occur when
the light of the raster beam strikes the light-sensitive device in the
pen's tip, causing it to close the fire button switch on joystick
Controller Port #1.

The light pen interrupt affords a method of signaling to a program
that the pen is being held to the screen, and that its position can be
read.  Some light pens provide a push-button switch which grounds one
of the other lines on the joystick port.  This switch can be pressed
by the user as an additional signal that the pen is properly
positioned.  Its location can then be read in the light pen position
registers (53267-8, $D013-4).

Bit 2 enables the sprite-foreground collision interrupt.  This
interrupt can occur if one of the srpte character's dots is touching
one of the dots from the foreground display of either text character
or bitmap graphics.

Bit 3 enables the sprite-sprite collision interrupt, which can occur
if one of the sprite character's dots is touching one of the dots of
another sprite character.

These two interrupts are useful for games, where such collisions often
require that some action be taken immediately.  Once the interrupt
signals that a collision has occurred, the interrupt routine can check
the Sprite- Foreground Collision Register at 53279 ($D01F), or the
Sprite-Sprite Collision Register at 53278 ($D01E), to see which sprite
or sprites are involved in the collision.  See the entry for those
locations for more details on collisions."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BF3A?[/INST]address         $BF3A          FDCEND
Table of Constants for TI$ Conversion

This table contains the floating point representation of the powers of
-60 multiplied by 1 or 10.  These constants are used for converting
TI$ to ASCII."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D015?[/INST]address              $D015          SPENA
Sprite Enable Register

Bit 0:  Enable Sprite 0 (1=sprite is on, 0=sprite is off)
Bit 1:  Enable Sprite 1 (1=sprite is on, 0=sprite is off)
Bit 2:  Enable Sprite 2 (1=sprite is on, 0=sprite is off)
Bit 3:  Enable Sprite 3 (1=sprite is on, 0=sprite is off)
Bit 4:  Enable Sprite 4 (1=sprite is on, 0=sprite is off)
Bit 5:  Enable Sprite 5 (1=sprite is on, 0=sprite is off)
Bit 6:  Enable Sprite 6 (1=sprite is on, 0=sprite is off)
Bit 7:  Enable Sprite 7 (1=sprite is on, 0=sprite is off)

In order for any sprite to be displayed, the corresponding bit in this
register must be set to 1 (the default for this location is 0).  Of
course, just setting this bit along will not guarantee that a sprite
will be shown on the screen.  The Sprite Data Pointer must indicate a
data area that holds some values other than 0.  The Sprite Color
Register must also contain a value other than that of the background
color.  In addition, the Sprite Horizontal and Vertical Position
Registers must be set for positions that lie within the visible screen
range in order for a sprite to appear on screen."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D016?[/INST]address              $D016          SCROLX
Horizontal Fine Scrolling and Control Register

Bits 0-2:  Fine scroll display horizontally by X dot positions (0-7)
Bit 3:  Select a 38-column or 40-column text display (1=40 columns,
  0=38 columns)
Bit 4:  Enable multicolor text or multicolor bitmap mode (1=multicolor on,
  0=multicolor off)
Bit 5:  Video chip reset (0=normal operations, 1=video completely off)
Bits 6-7:  Unused

This is one of the two important multifunction control registers on
the VIC-II chip.  On power-up, it is set to a default value of 8,
which means that the VIC chip Reset line is set for a normal display,
Multicolor Mode is disabled, a 40-column text display is selected, and
no horizontal fine-scroll offset is used.

Bits 0-2.  The first three bits of this chip control vertical fine
scrolling of the screen display.  This feature allows you to smoothly
move the entire text display back and forth, enabling the display area
to act as a window, scrolling over a larger text or character graphics
display.

Since each text character is eight dots wide, moving each character
over one whole character position (known as coarse scrolling) is a
relatively big jump, and the motion looks jerky.  By placing a number
from 1 to 7 into these three bits, you can move the whole screen
display from one to seven dot spaces to the right.

Stepping through values 1 to 7 allows you to smoothly make the
transition from having a character appear at one screen column to
having it appear at the next one over.  To demonstrate this, type in
the following program, LIST, and RUN it.

10 FOR I=1 TO 50:FOR J=0 TO 7
20 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I
30 FOR I=1 TO 50:FOR J=7 TO 0 STEP-1
40 POKE 53270,(PEEK(53270)AND248) OR J:NEXT J,I

As you can see, after the display has moved over seven dots, it starts
over at its original position.  In order to continue with the scroll,
you must do a coarse scroll every time the value of the scroll bits
goes from 7 to 0, or from 0 to 7.  This is accomplished by moving each
byte of display data on each line over one position, overwriting the
last character, and introducing a new byte of data on the opposite end
of the screen line to replace it.

Obviously, only a machine language program can move all of these bytes
quickly enough to maintain the effect of smooth motion.  The following
BASIC program, however, will give you an idea of what the combination
of fine and coarse scrolling looks like.

10 POKE 53281,0:PRINT CHR$(5);CHR$(147):FOR I=1 TO 5:PRINT CHR$(17):NEXT
20 FOR I=1 TO 30
30 PRINT TAB(I-1)'{UP}{10 SPACES}{UP}'
40 WAIT53265,128:POKE53270,PEEK(53270)AND248:PRINTTAB(I)'AWAY WE GO'
50 FOR J=1 TO 7
60 POKE 53270,(PEEK(53270)AND248)+J
70 FORK=1TO30-I
80 NEXT K,J,I:RUN

Changing the value of the three horizontal scroll bits will affect the
entire screen display.  If you wish to scroll only a portion of the
screen, you will have to use raster interrupts (see 53274 ($D01A)
below) to establish a scroll zone, change the value of these scroll
bits only when that zone is being displayed, and change it back to 0
afterward.

Bit 3.  Bit 3 of this register allows you to cover up the first and
last columns of the screen display with the border.  Since the viewers
cannot see the characters there, they will not be able to see you
insert a new character on the end of the line when you do coarse
scrolling (see explanation of Bits 0-2 above).

Setting this bit to 1 enables the normal 40-column display, while
resetting it to 0 changes the display to 38 columns.  This is a purely
cosmetic aid, and it is not necessary to change the screen to the
smaller size to use the scrolling feature.

Bit 4.  This bit selects multicolor graphics.  The effect of setting
this bit to 1 depends on whether or not the bitmap graphics mode is
also enabled.

If you are not in bitmap mode, and you select multicolor text
character mode by setting this bit to 1, characters with a color
nybble whose value is less than 8 are displyed normally.  There will
be one background color and one foreground color.  But each dot of a
character with a color nybble whose value is over 7 can have any one
of four different colors.

The two colors in the Background Control Registers 1 and 2 (53282-3,
$D022-3) are available in addition to the colors supplied by the Color
RAM.  The price of these extra colors is a reduction in horizontal
resolution.  Instead of each bit controlling one dot, in multicolor
mode a pair of bits control the color of a larger dot.  A pattern of
11 will light it with the color from the lower three bits of color
RAM.  Patterns of 01 and 10 will select the colors from Background
Color Registers 1 and 2, respectively, for the double-width dot.

You can see the effect that setting this bit has by typing in the
following BASIC command line:

POKE 53270,PEEK(53280)OR16:PRINT CHR$(149)'THIS IS MULTICOLOR MODE'

It is obvious from this example that the normal set of text characters
was not made to be used in multicolor mode.  In order to take
advantage of this mode, you will need to design custom four-color
characters.  For more information, see the alternate entry for 53248
($D000), the Character Generator ROM.

If the multicolor and bitmap enable bits are both set to 1, the result
is a multicolor bitmap mode.  As in multicolor text mode, pairs of
graphics data bits are used to set each dot in a 4 by 8 matrix to one
of four colors.  This results in a reduction of the horizontal
resolution to 160 double-wide dots across.  But while text multicolor
mode allows only one of the four colors to be set individually for
each 4 by 8 dot area, bitmap multicolor mode allows up to three
different colors to be individually selected in each 4 by 8 dot area.
The source of the dot color for each bit-pair combination is shown
below:

00 Background Color Register 0 (53281, $D021)
01 Upper four bits of Video Matrix
10 Lower four bits of Video Matrix
11 Color RAM nybble (area starts at 55296 ($D800))

The fact that bit-pairs are used in this mode changes the strategy for
plotting somewhat.  In order to find the byte BY in which the desired
bit-pair resides, you must multiply the horizontal position X, which
has a value of 0- 159, by 2, and then use the same formula as for
hi-res bitmap mode.

Given that the horizontal position (0-159) of the dot is stored in the
variable X, its vertical position is in the variable Y, and the base
address of the bitmap area ia in the variable BASE, you can find the
desired byte with the formula:

BY=BASE+(Y AND 248)*40+(Y AND 7)+(2*X AND 504)

Setting the desired bit-pair will depend on what color you chose.
First, you must set up an array of bit masks.

CA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64

To turn on the desired dot, select a color CO from 0 to 3
(representing the color selected by the corresponding bit pattern) and
execute the following statement:

BI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR (CO*CA(BI))

The following program will demonstrate this technique:

10 CA(0)=1:CA(1)=4:CA(2)=16:CA(3)=64:REM ARRAY FOR BIT PAIRS
20 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
30 POKE53265,PEEK(53265)OR32:POKE53270,PEEK(53270)OR16:REM MULTI-COLOR BIT MAP
40 A$='':FOR I=1 TO 37:A$=A$+'C':NEXT:PRINT CHR$(19);
50 FOR I=1 TO 27:PRINT A$;:NEXT:POKE 2023,PEEK(2022): REM SET COLOR MAP
60 A$='':FOR I=1 TO 128:A$=A$+'@':NEXT:FOR I=32 TO 63 STEP 2
70 POKE648,I:PRINTCHR$(19);A$;A$;A$;A$:NEXT:POKE648,4:REM CLR HI-RES SCREEN
80 FOR CO=1TO3:FOR Y=0TO199STEP.5:REM FROM THE TOP OF THE SCREEN TO THE BOTTOM
90 X=INT(10*CO+15*SIN(CO*45+Y/10)): REM SINE WAVE SHAPE
100 BY=BASE+40*(Y AND 248)+(Y AND 7)+(X*2 AND 504): REM FIND HI-RES BYTE
110 BI=(NOT X AND 3):POKE BY,PEEK(BY) AND (NOT 3*CA(BI)) OR(CO*CA(BI))
120 NEXT Y,CO
130 GOTO 130: REM LET IT STAY ON SCREEN

Bit 5:  Bit 5 controls the VIC-II chip Reset line.  Setting this bit
to 1 will completely stop the video chip from operating.  On older
64s, the screen will go black.  It should always be set to 0 to insure
normal operation of the chip.

Bits 6 and 7.  These bits are not used.

53271         $D017          YXPAND
Sprite Vertical Expansion Register

Bit 0:  Expand Sprite 0 vertically (1=double height, 0=normal height)
Bit 1:  Expand Sprite 1 vertically (1=double height, 0=normal height)
Bit 2:  Expand Sprite 2 vertically (1=double height, 0=normal height)
Bit 3:  Expand Sprite 3 vertically (1=double height, 0=normal height)
Bit 4:  Expand Sprite 4 vertically (1=double height, 0=normal height)
Bit 5:  Expand Sprite 5 vertically (1=double height, 0=normal height)
Bit 6:  Expand Sprite 6 vertically (1=double height, 0=normal height)
Bit 7:  Expand Sprite 7 vertically (1=double height, 0=normal height)

This register can be used to double the height of any sprite.  When
the bit in this register that corresponds to a particular sprite is
set to 1, each dot of the 24 by 21 sprite dot matrix will become two
raster scan lines high instead of one."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D018?[/INST]address              $D018          VMCSB
VIC-II Chip Memory Control Register

Bit 0:  Unused
Bits 1-3:  Text character dot-data base address within VIC-II address
  space
Bits 4-7:  Video matrix base address within VIC-II address space

This register affects virtually all graphics operations.  It
determines the vase address of two very important data areas, the
Video Matrix, and the Character Dot-Data area.

Bits 1-3.  These bits are used to set the location of the Character
Dot-Data area.  This area is where the data is stored (for more
information on character shape data, see the alternate entry for
location 53248 ($D000), the Character Generator ROM).

Bits 1-3 can represent any even number from 0 to 14.  That numer
stands for the even 1K offset of the character data area from the
beginning of VIC-II memory.  For example, if these bits are all set to
0, it means that the character memory occupies the first 2K of VIC-II
memory.  If they equal 2, the data area starts 2*1K (2*1024) or 2048
bytes from the beginning of VIC memory.

The default value of this nybble is 4.  This sets the address of the
Character Dot-Data area to 4096 ($1000), which is the starting address
of where the VIC-II chip addresses the Character ROM.  The normal
character set which contains uppercase and graphics occupies the first
2K of that ROM.  The alternate character set which contains both
upper- and lowercase letters use the second 2K.  Therefore, to shift
to the alternate character set, you must change the value of this
nybble to 6, with a POKE 53272,PEEK(53272)OR2.  To change it back,
POKE 53272,PEEK(53272)AND253.

In bitmap mode, the lower nybble controls the location of the bitmap
screen data.  Since this data area can start only at an offset of 0 or
8K from the beginning of VIC-II memory, only Bit 3 of the Memory
Control Register is significant in bitmap mode.  If Bit 3 holds a 0,
the offset is 0, and if it holds a 1, the offset is 8192 (8K).

Bits 4-7.  This nybble determines the starting address of the Video
Matrix area.  This is the 1024-byte area of memory which contains the
screen codes for the text characters that are displayed on the screen.
In addition, the last eight bytes of this area are used as pointers
which designate which 64- byte block of VIC-II memory will be used as
shape data for each sprite.

These four bits can represent numbers from 0 to 15.  These numbers
stand for the offset (in 1K increments) from the beginning of VIC-II
memory to the Video Matrix.

For example, the default bit pattern is 0001.  This indicates that the
Video Matrix is offset by 1K from the beginning of VIC-II memory, the
normal starting place for screen memory.  Remember, though, the bit
value of this number will be 16 times what the bit pattern indicates,
because we are dealing with Bits 4-7.  Therefore, the 0001 in the
upper nybble has a value of 16.

Using this register, we can move the start of screen memory to any 1K
boundary within the 16K VIC-II memory area.  Just changing this
register, however, is not enough if you want to use the BASIC line
editor.  The editor looks to location 648 ($288) to determine where to
print screen characters.

If you just change the location of the Video Matrix without changing
the value in 648, BASIC will continue to print characters in the
memory area starting at 1024, even though that area is no longer being
displayed.  The result is that you will not be able to see anything
that you type in on the keyboard.  To fix this, you must POKE 648 with
the page number of the starting address of screen memory (page
number=location/256).  Remember, the actual starting address of screen
memory depends not only on the offset from the beginning of VIC-II
memory in the register, but also on which bank of 16K is used for
VIC-II memory.

For example, if the screen area starts 1024 bytes from the beginning
of VIC- II memory, and the video chip is using Bank 2 (32768-49151),
the actual starting address of screen memory is 32768+1024=33792
($8400).  For examples of how to change the video memory area, and of
how to relocate the screen, see the entro for 56576 ($DD00).

53273         $D019          VICIRQ
VIC Interrupt Flag Register

Bit 0:  Flag:  Is the Raster Compare a possible source of an IRQ?
        (1=yes)
Bit 1:  Flag:  Is a collision between a sprite and the normal graphics
        display a possible source of an IRQ?  (1=yes)
Bit 2:  Flag:  Is a collision between two sprites a possible source of
        an IRQ?  (1=yes)
Bit 3:  Flag:  Is the light pen trigger a possible source of an IRQ?
        (1=yes)
Bits 4-6:  Not used
Bit 7:  Flag:  Is there any VIC-II chip IRQ source which could cause
        an IRQ?  (1=yes)

The VIC-II chip is capable of generating a maskable request (IRQ) when
certain conditions relating to the video display are fulfilled.
Briefly, the conditions that can cause a VIC-II chip IRQ are:

1.  The line number of the current screen line being scanned by the
raster is the same as the line number value written to the Raster
Register (53266, $D012).

2.  A sprite is positioned at the same location where normal graphics
data are being displayed.

3.  Two sprites are positioned so that they are touching.

4.  The light sensor on the light pen has been struck by the raster
beam, causing the fire button switch on joystick Control Port #1 to
close (pressing the joystick fire button can have the same effect).

When one of these conditions is met, the corresponding bit in this
status register is set to 1 and latched.  That means that as long as
the corresponding enable bit in the VIC IRQ Mask register is set to 1,
and IRQ requested will be generated, and any subsequent fulfillment of
the same condition will be ignored until the latch is cleared.

This allows you to preserve multiple interrupt requests if more than
one of the interrupt conditions is met at a time.  In order to keep an
IRQ source from generating another request after it has been serviced,
and to enable subsequent interrupt conditions to be detected, the
interrupt service routine must write a 1 to the corresponding bit.
This will clear the latch for that bit.  The default value written to
this register is 15, which clears all interrupts.

There is only 1 IRQ vector that points to the address of the routine
that will be executed when an IRQ interrupt occurs.  The same routine
will therefore be executed regardless of the source of the interrupt.
This status register provides a method for that routine to check what
the source of the IRQ was, so that the routine can take appropriate
action.  First, the routine can check Bit 7.  Anytime that any of the
other bits in the status register is set to 1, Bit 7 will also be set.
Therefore, if that bit holds a 1, you know that the VIC-II chip
requested an IRQ (the two CIA chips which are the other sources of IRQ
interrupts can be checked in a similar manner).  Once it has been
determined that the VIC chip is responsible for the IRQ, the
individual bits can be tested to see which of the IRQ conditions have
been met.

For more information, and a sample VIC IRQ program, see the following
entry.

5"
"[INST]In the context of the C64, What is the purpose of the memory location at address $BF1C?[/INST]address         $BF1C          FOUTBL
Powers of Minus Ten Constants Table

This table contains the powers of -10 expressed as four-byte floating
point numbers (that is, -1; +10; -100; +1000; -10,000; +100,000;
-1,000,000; +10,000,000; and -100,000,000)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $BFBF?[/INST]address         $BFBF          EXPCON
Table of Constants for EXP and LOG in Five-Byte Floating Point Format

These tables are used to calculate 2 to the N power."
"[INST]In the context of the C64, What is the purpose of the memory location at address $D027?[/INST]address              $D027          SP0COL
Sprite 0 Color Register (the default color value is 1, white)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $D405?[/INST]address              $D405          ATDCY1
Voice 1 Attack/Decay Register

Bits 0-3:  Select decay cycle duration (0-15)
Bits 4-7:  Select attack cycle duration (0-15)

Bits 4-7 control the duration of the attack cycle.  This is the period
of time over which the volume will rise from 0 to its peak amplitude.
There are 16 durations which may be selected.  The way in which the
number placed here corresponds to the elapsed time of this cycle is as
follows:

0 = 2 milliseconds           8 = 100 milliseconds
1 = 8 milliseconds           9 = 250 milliseconds
2 = 16 milliseconds         10 = 500 milliseconds
3 = 24 milliseconds         11 = 800 milliseconds
4 = 38 milliseconds         12 = 1 second
5 = 56 milliseconds         13 = 3 seconds
6 = 68 milliseconds         14 = 5 seconds
7 = 80 milliseconds         15 = 8 seconds

Bits 0-3 control the length of the decay phase, in which the volume of
the note declines from the peak reached in the attack phase to the
sustain level.  The number selected corresponds to the length of this
phase as shown below:

0 = 6 milliseconds           8 = 300 milliseconds
1 = 24 milliseconds          9 = 750 milliseconds
2 = 48 milliseconds         10 = 1.5 seconds
3 = 72 milliseconds         11 = 2.4 seconds
4 = 114 milliseconds        12 = 3 seconds
5 = 168 milliseconds        13 = 9 seconds
6 = 204 milliseconds        14 = 15 seconds
7 = 240 milliseconds        15 = 24 seconds

Since the two functions share one register, you must multiply the
attack value by 16 and add it to the decay value in order to come up
with the number to be placed in the register:

REGISTER VALUE=(ATTACK*16)+DECAY"
"[INST]In the context of the C64, What is the purpose of the memory location at address $71-$72?[/INST]address       $71-$72        FBUFPT
Series Evaluation Pointer

This location points to the address of a temporary table of values
built in the free RAM area for the evaluation of formulas.  It is also
used for such various purposes as a TI$ work area, string setup
pointer, and work space for the evaluation of the size of an array.

Although this is labeled a pointer to the tape buffer in the
Programmer's Reference Guide, disassembly of the BASIC ROM reveals no
reference to this location for that purpose (see 178 ($B2) for pointer
to tape buffer)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $93?[/INST]address           $93            VERCK
Flag for Load Routine: 0=LOAD, 1=VERIFY

The same Kernal routine can perform either a LOAD or VERIFY, depending
on the value stored in the Accumulator (.A) on entry to the routine.
This location is used to determine which operation to perform."
"[INST]In the context of the C64, What is the purpose of the memory location at address $99?[/INST]address           $99            DFLTN
Default Input Device (Set to 0 for Keyboard)

The default value of this location is 0, which designates the keyboard
as the current input device.  That value can be changed by the Kernal
routine CHKIN (61966, $F20E), which uses this location to store the
device number of the device whose file it defines as an input channel.

BASIC calls CHKIN whenever the command INPUT# or GET# is executed, but
clears the channel after the input operation has been completed."
"[INST]In the context of the C64, What is the purpose of the memory location at address $2A1?[/INST]address          $2A1           ENABL
RS-232 Interrupts Enabled

This location holds the active NMI interrupt flag byte from CIA #2
Interrupt Control Register (56589, $DD0D).  The bit values for this
flag are as follows:

Bit 4: 1 (bit value of 16) = System is Waiting for Receiver Edge
Bit 1: 1 (bit value of 2)  = System is Receiving Data
Bit 0: 1 (bit value of 1)  = System is Transmitting Data"
"[INST]In the context of the C64, What is the purpose of the memory location at address $F014?[/INST]address              $F014
CHROUT for the RS-232 Device

The Kernal CHROUT routine calls this subroutine to output a character
to the RS-232 device.  After the logical file has been OPENed and set
for output using CHKOUT, the CHROUT routine is used to actually send a
byte of data."
"[INST]In the context of the C64, What is the purpose of the memory location at address $F32F?[/INST]address              $F32F          CLALL
Close All Logical I/O Files

CLALL is a documented Kernal routine whose entry point in the jump
table is 65511 ($FFE7).

The routine jumps through a RAM vector at 812 ($32C).  It closes all
open files, by resetting the index into open files at 152 ($98) to
zero.  It then falls through to the next routine, which restores the
default I/O devices."
"[INST]In the context of the C64, What is the purpose of the memory location at address $2A7-$2FF?[/INST]address       $2A7-$2FF
Unused

The programmer may use this area for machine language subroutines, or
for graphics data storage.

If the VIC-II ship is using the bottom 16K for graphics and memory
(the default setting when the system is turned on), this is one of the
few free areas available for storing sprite or character data.
Locaitons 704-767 could be used for sprite data block number 11,
without interfering with BASIC program text or variables.

Location Range: 768-779 ($300-$30B)
BASIC Indirect Vector Table

Several important BASIC routines are vectored through RAM.  This means
that the first instruction executed by the routine is an indirect jump
to a location pointed to by one of the vectors in this table.

On power up, the system sets these vectors to point to the next
instruction past the original JuMP instruction.  The routine then
continues with that instruction as if the jump never took place.  For
example, the BASIC error message routine starts at 42039 ($A437) with
the instruction JMP ($300).  The indirect vector at 768 ($300) points
to 42042 ($A43A), which is the instruction immediately following JMP
($300).

Although this may seem like a fancy way of accomplishing nothing,
using these indirect vectors serves two important purposes.  First, it
allows you to use these important BASIC routines without knowing their
addresses in the BASIC ROM.

For example, the routine to LIST the ASCII text of the single-byte
BASIC program token that is currently in the Accumulator (.A) is
located at one address in the VIC, and another in the 64.  On future
Commodore computers it may be found at still another location.  Yet as
long as the routine is vectored in RAM at 774 ($306), the statement
QP=PEEK(774)+256*PEEK(775) would find the address of that routine on
any of the machines.  Thus, entering such routines through RAM vectors
rather than a direct jump into the ROMs helps to keep your programs
compatible with different machines.

The other important effect of having these vectors in RAM is that you
can alter them.  In that way, you can redirect these important BASIC
routines to execute your own preprocessing routines first.

If you wanted to add commands to BASIC, for example, how would you go
about it?  First, you would need to change the BASIC routines that
convert ASCII program text to tokenized program format, so that when a
line of program text was entered, the new keyword would be stored as a
token.

Next, you would need to change the routine that executes tokens, so
that when the interpreter comes to your new keyword token, it will
take the proper action.

You would also have to change the routine that converts tokens back to
ASCII text, so that your program would LIST the token out correctly.
And you might want to alter the routine that prints error messages, to
add new messages for your keyword.

As you will see, vectors to all of these routines can be found in the
following indirect vector table.  Changing these vectors is a much
more elegant and efficient solution than the old wedge technique
discussed at location 115 ($73)"
"[INST]In the context of the C64, What is the purpose of the memory location at address $299-$29A?[/INST]address       $299-$29A      BAUDOF
Time Required to Send a Bit

This location holds the prescaler value used by CIA #2 timers A and B.

These timers cause an NMI interrupt to drive the RS-232 receive and
transmit routines CLOCK/PRESCALER times per second each, where CLOCK
is the system 02 frequency of 1,022,730 Hz (985,250 if you are using
the European PAL television standard rather than the American NTSC
standard), and PRESCALER is the value stored at 56580-1 ($DD04-5) and
56582-3 ($DD06-7), in low-byte, high-byte order.  You can use the
following formula to figure the correct prescaler value for a
particular RS-232 baud rate:

PRESCALER=((CLOCK/BAUDRATE)/2)-100

The American (NTSC standard) prescaler values for the standard RS-232
baud rates which the control register at 659 ($293) makes available
are stored in a table at 65218 ($FEC2), starting with the two-byte
value used for 50 baud.  The European (PAL standard) version of that
table is located at 58604 ($E4EC).

Location Range: 667-670 ($29B-$29E)
Byte Indices to the Beginning and End of Receive and Transmit Buffers

The two 256-byte First In, First Out (FIFO) buffers for RS-232 data
reception and transmission are dynamic wraparound buffers.  This means
that the starting point and the ending point of the buffer can change
over time, and either point can be anywhere withing the buffer.  If,
for example, the starting point is at byte 100, the buffer will fill
towards byte 255, at which point it will wrap around to byte 0 again.
To maintain this system, the following four locations are used as
indices to the starting and the ending point of each buffer."
"[INST]In the context of the C64, What is the purpose of the memory location at address $EC78?[/INST]address              $EC78
Control Keyboard Matrix Decode Table

This table contains the 64 PETASCII values for the Control keyboard,
one for each key which is struck while the CTRL key is pressed.  The
table is in keycode order (see the keycode table in Appendix H for the
correspondence of keycode to key).  A 65th byte with the value of 255
($FF) marks the end of the table (this corresponds to a keypress value
of 64, no key pressed).

The only keys generally struck in combination with the CTRL key are
the ones that change the colors on the top row of the keyboard, but
this doesn't necessarily mean that the other CTRL key combinations
don't do anything.  On the contrary, looking at the values in this
table, you can see that any of the first 32 values in the PETASCII
table can be produced by some combination of the CTRL key and another
key.  CTRL-@ produces a CHR$(0).  CTRL-A through CTRL-Z produce
CHR$(1) through CHR$(26).  Ctrl-: is the same as CHR$(27), CTRL-Lira
(that's the slashed-L British pound sign) produces CHR$(28), CTRL-;
equals CHR$(29), CTRL-up arrow produces CHR$(30), and CTRL-= produces
CHR$(31).

Any of these combinations produce the same effect as the CHR$(X)
statement.  For examble, CTRL-; moves the cursor over to the right,
CTRL-N switches to lowercase, CTRL-R turns on reverse video, and
CTRL-E changes the printing to white."
"[INST]In the context of the C64, What is the purpose of the memory location at address $A002-$A003?[/INST]address  $A002-$A003
Warm Start Vector

The warm start vector points to the address of the routines used to
reset BASIC after the STOP/RESTORE key combination is pressed.  This
is the same address to which the BRK instruction is vectored.  When
BASIC is entered through this vector, the program in memory is not
disturbed.  For more information, see the entry for 58235 ($E37B), the
current warm start entry point."
"[INST]In the context of the C64, What is the purpose of the memory location at address $800-$9FFF?[/INST]address    $800-$9FFF
BASIC Program Text

This is the area where the actual BASIC program text is stored.  The
text of a BASIC program consists of linked lines of program tokens.
Each line contains the following:

1.  A two-byte pointer to the address of the next program line (in
standard low-byte, high-byte order).  After the last program line, a
link pointer consisting of two zeros marks the end of the program.

2.  A two-byte line number (also in low-byte, high-byte order).

3.  The program commands.  Each keyword is stored as a one-byte
character whose value is equal to or greater than 128.  Print, for
example, is stored as the number 151.  Other elements of the BASIC
command, such as the variable names, string literals ('HELLO'), and
numbers, are stored using their ASCII equivalents.

4.  A 0 character, which acts as a line terminator.  In order for
BASIC to work correctly, the first character of the BASIC text area
must be 0.

A quick review of the BASIC pointers starting at 43 ($2B) reveals that
the layout of the BASIC program area (going from lower memory
addresses to higher) is as follows:

BASIC Program Text
Non-Array Variables and String Descriptors
Array Variables
Free Area (Reported by FRE(0))
String Text Area (Strings build from top of memory down into free area)
BASIC ROM

It is interesting to note that the NEW command does not zero out the
text area but rather replaces the first link address in the BASIC
program with two zeros, indicating the end of the program.  Therefore,
you can recover a program from a NEW by replacing the first link
adress, finding the address of the two zeros that actually mark the
end of the program, and setting the pointers at 45, 47, and 49 (which
all point to the end of a BASIC program before the program is RUN) to
the byte following these zeros."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E9FF?[/INST]address              $E9FF
Clear Screen Line

This subroutine writes space characters to an entire line of screen
memory, and clears the corresponding line of color memory to color in
Background Color Register 0 (53281, $D021)."
"[INST]In the context of the C64, What is the purpose of the memory location at address $E716?[/INST]address              $E716
Output to the Screen

This is the main entry point for the part of CHROUT that handles
output to the screen device.  It takes an ASCII character number, and
tests if the character is printable.  If it is, it prints it (taking
into consideration the reverse flag, if any inserts are left, etc.).
If it is a nonprinting character, the routine performs the appropriate
cursor movement, color change, screen clearing, or whatever else might
be indicated."
"[INST]In the context of the C64, What is the importance of delaying the reading of the POT register in the C64 and C128 when using a mouse driver, and how can it be ensured?[/INST]SID Register Cautions

In  the  C64 & C128,  the  SID  POT  lines  are connected to both
joystick  ports.  A 4066 analog switch is used  to switch the POT
lines  between  the  two  ports based on one of the keyboard scan
lines.  This  means that the normal keyscan interrupt temporarily
affects the values returned in the POT registers.  Therefore,  in
order  to  perform  reliable  conversions,  the POT lines must be
connected  to  the mouse for a period >1.6 millisecond before the
value in the POT register is valid.

The best way to insure this is to wedge the mouse driver software
into the IRQ handler prior  to the polled keyscan.  This more-or-
less assures that the keyscan lines have been sufficiently stable
before the POT register is read by the mouse drivers."
"[INST]In the context of the C64, What is the BASIC program code for a 1351 mouse driver on a Commodore 64?[/INST]BASIC PROGRAM FOR 1351 MOUSE AND C64


start tok64 data64.prg
 100 GOSUB 140:GOSUB 330
 110 V=13*4096:POKE V+21,1:POKE V+39,1:POKEV+0,100:POKE V+1,100:\
     POKE V+16,0
 120 POKE 2040,56:SYS 12*4096+256
 130 END
 140 FOR X=0 TO 129:READ A$:GOSUB 430:POKE 49408+X,Y:NEXT X:RETURN
 150 DATA AD,15,03,C9,C1,F0,19,08
 160 DATA 78,AD,14,03,8D,00,C0,AD
 170 DATA 15,03,8D,01,C0,A9,21,8D
 180 DATA 14,03,A9,C1,8D,15,03,28
 190 DATA 60,D8,AD,19,D4,AC,02,C0
 200 DATA 20,58,C1,8C,02,C0,18,6D
 210 DATA 00,D0,8D,00,D0,8A,69,00
 220 DATA 29,01,4D,10,D0,8D,10,D0
 230 DATA AD,1A,D4,AC,03,C0,20,58
 240 DATA C1,8C,03,C0,38,49,FF,6D
 250 DATA 01,D0,8D,01,D0,6C,00,C0
 260 DATA 8C,05,C0,8D,04,C0,A2,00
 270 DATA 38,ED,05,C0,29,7F,C9,40
 280 DATA B0,07,4A,F0,12,AC,04,C0
 290 DATA 60,09,C0,C9,FF,F0,08,38
 300 DATA 6A,A2,FF,AC,04,C0,60,A9
 310 DATA 00,60
 320 REM ------------------------
 330 FOR X=0 TO 63:READ A$:GOSUB 430:POKE 3584+X,Y:NEXT X:RETURN
 340 DATA F8,00,00,90,00,00,B8,00
 350 DATA 00,DC,00,00,8E,00,00,07
 360 DATA 00,00,02,00,00,00,00,00
 370 DATA 00,00,00,00,00,00,00,00
 380 DATA 00,00,00,00,00,00,00,00
 390 DATA 00,00,00,00,00,00,00,00
 400 DATA 00,00,00,00,00,00,00,00
 410 DATA 00,00,00,00,00,00,00,00
 420 REM ------------------------
 430 Y=1:Y1=0
 440 IF LEFT$(A$,1)<>MID$('0123456789abcdef',Y,1) THEN Y=Y+1:\
     GOTO 440
 450 Y1=(Y-1)*16:Y=1
 460 IF RIGHT$(A$,1)<>MID$('0123456789abcdef',Y,1) THEN Y=Y+1:\
     GOTO 460
 470 Y=Y1+Y-1:RETURN"
"[INST]In the context of the C64, What is the operational mode of a mouse that tracks movement internally and transmits position data to the SID POTX and POTY registers every 512 microseconds without requiring software intervention?[/INST]Proportional Mode

In proportional mode the mouse operates as follows:
1) Mouse  movement  is  tracked internally within the mouse.  The
   position of the mouse MOD 64  is  transmitted to the SID  POTX
   and  POTY  registers  every  512  microsecond  and requires no
   software intervention.
   The  POTX  register  is  used  to read X position of the mouse
   and the POTY register is used to read Y position of the mouse.
   The register contents are as follows:

                    +-------------------------------+
   Bit Position     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
                    +---+---+---+---+---+---+---+---+
   POT Register     | X | P5| P4| P3| P2| P1| P0| N |
                    +-------------------------------+
   where:
        X ......... is a don't care bit.
        P5-P0 ..... is the mouse position MOD 64.
        N ......... is a special (noise) bit (keep reading...).

2) The  left  mouse  button  is  mapped to what would be the fire
   button on a joystick.
3) The  right  mouse  button  is  mapped to what would be that UP
   direction on a joystick.

Software Interface

1) Because  the  left and right buttons appear as joystick lines,
   reading  them  from  software is a simple exercise in polling.
   Note that as with a joystick,  the buttons will interfere with
   the  keyboard  map,  and  software  should make some effort to
   distinguish between point short in the keyboard matrix  (i.e.,
   a  key  being  depressed),  and  a  whole  row or column being
   grounded (i.e., a joystick type of signal).
2) The  position information is not difficult to handle.  Ideally
   is  should be installed as part of the 60 Hz interrupt routine
   (preferably  at  the  beginning  --  see  the  section  on SID
   Register Cautions).
   This strategy is as follows:
   1) Read the mouse position MOD 64.
   2) Determine  if  the mouse has moved by comparing the current
      position with a saved copy of the previous position.
   3) If  the mouse has moved,  then modify your pointer position
      appropriately.
      You  should  note,  that even if the mouse is still,  it is
      possible for the POT register  to oscillate between $80 and
      $7F.  This  would result in the mouse position as jittering
      between two points.

In  order  to  ascertain  whether  the mouse has moved the software
should read the low order bit of the POT register.

All of this can be seen in the supplied mouse driver code."
"[INST]In the context of the C64, How does the mouse operate in joystick mode?[/INST]In joystick mode the mouse operates as follows:
1) If the mouse is moved, then the appropriate joystick lines are
   activated for a period of 20 ms. Thus moving the mouse is like
   pushing the joystick in the appropriate direction.
2) The  left  mouse  button  is  mapped to what would be the fire
   button on a joystick.
3) The  right  mouse button is mapped into the SID POTX register.
   If  the  button  is depressed  then the SID POTX register will
   contain a number <$80. If the button is not depressed then SID
   POTX will contain a number >=$80.
4) See the section on SID Register Cautions.

Software Interface

For  most  applications,  the  interface for joystick mode should
be  just  as  any joystick driver, and the right button should be
ignored."
"[INST]In the context of the C64, What are the features and modes of operation of the Commodore 1351 Mouse(TM)?[/INST]The  Commodore  1351  Mouse(TM)  is a controller designed for use
with  the  Commodore 64(R)  or  Commodore 128(TM)  computers.  It
features two buttons on the top, and a ball on the underside that
is rolled upon a flat surface to manipulate onscreen activity.

The  mouse  has  two  modes  of  operation  --  joystick mode and
proportional mode.

In  joystick  mode,  the  mouse  emulates  a  joystick and can be
used  with all joystick-compatible  software.  In this mode,  the
left  button  is  the fire button and the right button is usually
ignored.

In   proportional  mode,  the  mouse  uses  a  new  technique  to
communicate   mouse   movement  to  the  controlling  application
software.  That requires  the software to know the mouse is there
and  how to read it.  For example,  the GEOS(TM) operating system
can  use  many  different  input  drivers.  One  of  them  is the
Commodore  Mouse  driver,  which  can  be  used  with the 1351 in
proportional mode.

The  1351  provides a proportional mode  so that applications can
have a fast,  responsive pointer that moves easily on the screen.
Joystick mode acts as a fallback for those for those applications
that don't have installable device drivers. You can therefore use
the mouse as a joystick for older software, and take advantage of
the   benefits   provided   by   proportional   mode  with  newer
applications.

The mouse automatically powers up in proportional mode. To choose
joystick mode,  plug  the  mouse into either joystick port on the
side  of  the  computer  and  hold  down the right button  as the
computer is powered up."
"[INST]In the context of the C64, What are the steps to clean a computer mouse?[/INST]Mouse Cleaning

Since the ball of your mouse roll freely to accurately manipulate
the cursor  (or whatever) on the screen,  it's important that the
ball remains free of dirt or debris.  This is easily accomplished
by sliding out the plastic piece holding the ball in place.


Remove  the  ball  and  wipe  it off with a soft cloth, such as a
handkerchief.


To remove any dirt or dust  from the ball area,  just blow gently
into the opening.  Around the top of the opening, there are three
metal rollers. To clean these, take cotton-tipped swab, moistened
with head cleaning fluid or alcohol, and gently clean the surface
of each roller.  Replace the ball inside the controller  and snap
the plastic piece back on."
"[INST]In the context of the C64, What are the features and operating modes of the Commodore 1351 mouse for use with the C64/C128 product line?[/INST]The  Commodore 1351 mouse  for use with the C64/C128 product line
is a small two-button device  which is connected to either of the
joystick ports on the C64/C128.

The mouse supports two distinct operating modes:
1) Joystick mode.
2) Proportional mode.

Proportional  mode  is  usable  with  the  C64  or the C128,  and
requires  a  special  machine  language  driver  to yield optimum
performance.

Mode selection is determined when the mouse is powered up. If the
user  depresses the right mouse button when the device is powered
up, then the mouse will be in joystick mode.

If  the  user  does  not  depress the right mouse button when the
device is powered up, then the mouse will default to proportional
mode.

Joystick  mode allows you to utilize the mouse as a joystick when
using software which does not support proportional mode."
"[INST]In the context of the C64, What are some important tips for the proper care and use of a computer mouse?[/INST]Mouse Tips

Proper care and use of your mouse requires common sense.

Use your mouse on a clean, smooth surface.

Make  sure  you  have  adequate  desktop space to manipulate your
mouse, so you don't have to constantly pick up and reposition it.

Don't  hold  the mouse by its cord,  or let the body of the mouse
hang off the table."
"[INST]In the context of the C64, What is the assembly code for a Commodore 128 mouse driver for BASIC 7.0 applications?[/INST];
;       C128 MOUSE DRIVER FOR BASIC 7.0 APPLICATIONS
;
IIRQ    = $0314
VIC     = $D000         ; VIC REGISTERS
SID     = $D400         ; SID REGISTERS
POTX    = SID+$19
POTY    = SID+$1A
;
ACTIVE  = $117E         ; IF ZERO, THEN MOVE SPRITE
;
XPOS    = VIC+$00       ; LOW ORDER X POSITION
YPOS    = VIC+$01       ; Y POSITION
XPOSMSB = VIC+$10       ; BIT 0 IS HIGH ORDER X POSITION
;
        *=$18F0
IIRQ2   *=*+2
OPOTX   *=*+1
OPOTY   *=*+1
NEWVALUE        *=*+1
OLDVALUE        *=*+1
;
        * = $1800
;
INSTALL LDA IIRQ+1
        CMP #>MIRQ
        BEQ L90
        PHP
        SEI
        LDA IIRQ
        STA IIRQ2
        LDA IIRQ+1
        STA IIRQ2+1

        LDA #<MIRQ
        STA IIRQ
        LDA #>MIRQ
        STA IIRQ+1
;
        PLP
L90     RTS
;
MIRQ    CLD             ; JUST IN CASE.....
        LDA ACTIVE      ; IF    BASIC IS MOVING SPRITE
        BNE L90         ;       LET BASIC HAVE IT ( WHY NOT ? )
        LDA POTX        ; GET DELTA VALUES FOR X
        LDY OPOTX
        JSR MOVCHK
        STY OPOTX
;
        CLC             ; MODIFY LOW ORDER X POSITION
        ADC XPOS
        STA XPOS
        TXA
        ADC #$00
        AND #%00000001
        EOR XPOSMSB
        STA XPOSMSB
;
        LDA POTY        ; GET DELTA VALUE FOR Y
        LDY OPOTY
        JSR MOVCHK
        STY OPOTY
;
        SEC             ; MODIFY Y POSITION ( DECREASE Y FOR
                        ;                     INCRESE IN POT )
        EOR #$FF
        ADC YPOS
        STA YPOS
;
        JMP (IIRQ2)     ; CONTINUE W/ IRQ OPERATION
;
; MOVCHK
;       ENTRY   Y    = OLD VALUE OF POT REGISTER
;               A    = CURRENT VALUE OF POT REGISTER
;       EXIT    Y    = VALUE TO USE FOR OLD VALUE
;               X, A = DELTA VALUE FOR POSITION
;
MOVCHK  STY OLDVALUE    ; SAVE OLD &  NEW VALUES
        STA NEWVALUE
        LDX #0          ; PRELOAD X W/ 0
;
        SEC             ; A <=  MOD64( NEW-OLD )
        SBC OLDVALUE
        AND #%01111111
        CMP #%01000000  ; IF      > 0
        BCS L50
        LSR A           ;         A <= A/2
        BEQ L80         ;         IF      <> 0
        LDY NEWVALUE    ;                 Y <= NEWVALUE
        RTS             ;                 RETURN
;
L50     ORA #%11000000  ; ELSE    OR IN HIGH ORDER BITS
        CMP #$FF        ;         IF      <> -1
        BEQ L80
        SEC             ;                 A <= A/2
        ROR A
        LDX #$FF        ;                 X <= -1
        LDY NEWVALUE    ;                 Y <= NEWVALUE
        RTS             ;                 RETURN
;
L80     LDA #0          ; A <= 0
        RTS             ; RETURN W/ Y = OLD VALUE
;"
"[INST]In the context of the C64, What is the assembly language code for a Commodore 64 mouse driver?[/INST]MACHINE LANGUAGE PROGRAMS FOR 1351 MOUSE AND C64
;       C64 MOUSE DRIVER FOR BASIC 2.0 APPLICATIONS
;
IIRQ    = $0314
VIC     = $D000         ; VIC REGISTERS
SID     = $D400         ; SID REGISTERS
POTX    = SID+$19
POTY    = SID+$1A
;
XPOS    = VIC+$00       ; LOW ORDER X POSITION
YPOS    = VIC+$01       ; Y POSITION
XPOSMSB = VIC+$10       ; BIT 0 IS HIGH ORDER X POSITION
;
        *=$C000
IIRQ2   *=*+2
OPOTX   *=*+1
OPOTY   *=*+1
NEWVALUE        *=*+1
OLDVALUE        *=*+1
;
        * = $C100
;
INSTALL LDA IIRQ+1
        CMP #>MIRQ
        BEQ L90
        PHP
        SEI
        LDA IIRQ
        STA IIRQ2
        LDA IIRQ+1
        STA IIRQ2+1

        LDA #<MIRQ
        STA IIRQ
        LDA #>MIRQ
        STA IIRQ+1
;
        PLP
L90     RTS
;
MIRQ    CLD             ; JUST IN CASE.....
        LDA POTX        ; GET DELTA VALUES FOR X
        LDY OPOTX
        JSR MOVCHK
        STY OPOTX
;
        CLC             ; MODIFY LOW ORDER X POSITION
        ADC XPOS
        STA XPOS
        TXA
        ADC #$00
        AND #%00000001
        EOR XPOSMSB
        STA XPOSMSB
;
        LDA POTY        ; GET DELTA VALUE FOR Y
        LDY OPOTY
        JSR MOVCHK
        STY OPOTY
;
        SEC             ; MODIFY Y POSITION ( DECREASE Y FOR
                        ;                     INCREASE IN POT )
        EOR #$FF
        ADC YPOS
        STA YPOS
;
        JMP (IIRQ2)     ; CONTINUE W/ IRQ OPERATION
;
; MOVCHK
;       ENTRY   Y    = OLD VALUE OF POT REGISTER
;               A    = CURRENT VALUE OF POT REGISTER
;       EXIT    Y    = VALUE TO USE FOR OLD VALUE
;               X, A = DELTA VALUE FOR POSITION
;
MOVCHK  STY OLDVALUE    ; SAVE OLD &  NEW VALUES
        STA NEWVALUE
        LDX #0          ; PRELOAD X W/ 0
;
        SEC             ; A <=  MOD64( NEW-OLD )
        SBC OLDVALUE
        AND #%01111111
        CMP #%01000000  ; IF      > 0
        BCS L50
        LSR A           ;         A <= A/2
        BEQ L80         ;         IF      <> 0
        LDY NEWVALUE    ;                 Y <= NEWVALUE
        RTS             ;                 RETURN
;
L50     ORA #%11000000  ; ELSE    OR IN HIGH ORDER BITS
        CMP #$FF        ;         IF      <> -1
        BEQ L80
        SEC             ;                 A <= A/2
        ROR A
        LDX #$FF        ;                 X <= -1
        LDY NEWVALUE    ;                 Y <= NEWVALUE
        RTS             ;                 RETURN
;
L80     LDA #0          ; A <= 0
        RTS             ; RETURN W/ Y = OLD VALUE
;"
"[INST]In the context of the C64, What is a humorous way to brag about the amount of RAM in a computer to an Apple user?[/INST]RAM Expansion
Wanna show off to that overinflated 48K Apple user next door. Try this on 'im.
sys 54295 ;BASIC4.0
Of course you know there can't possibly be that much, but how's he gonna know. Stay sharp though - he may know his Apple ROMs with equal impunity."
"[INST]In the context of the C64, What is the purpose and usage of the SYS command in Commodore BASIC, and how can it be used to report the current line number or convert hexadecimal to decimal?[/INST]Instant BASIC Monitor
You can execute this SYS directly, but it won't mean much. However, put on the end of some line in your program and itwill report what line that is. It's part of the error message routine - the part that reports the line number after a run is interrupted. For example: ?syntax error in 6010.
Immediately upon entering direct mode, the operating sys tem deposits an FF into the high order byte of the Current Line Number word, thus rendering that information mean ingless. During program execution, the current line being executed is copied here. Try this:
100 print 'line 100' 110 print 'some line ' : sys 53112:?
120sys53112
130 goto 100

For C64 it's SYS 48585 and the VIC 20 is 56777. As you can see, if the program is renumbered, the message in line 100 will need updating. The ROM call, however, is universal. You can skip the 'in' display by adding 7 to the address.
Taking this one baby step further, this routine could be used as a primitive hex to decimal converter. For example:
poke 55, 10: poke 54, 7: sys 53119
. . .would print the decimal equivalent of $0A07. (C64/ VIC20: use 58 and 57 for the POKE addresses, with the above SYS address + 7) This is ok when you can convert the low order and high order to decimal in your head. When numbers get like CF7D it's a little tougher. Perhaps some one with BASIC 4.0 (built-in MLM) will investigate a more sophisticated approach to the same end. (Dave Hook, you there? You did that once long ago, did you not?)"
"[INST]In the context of the C64, What are some creative ways to deter software pirates and protect your program from being cracked?[/INST]Pirate Peeves
Want to drive program pirates crazy. You must admit, if a burglar really wants in, he'll get in no matter how much protection you have. Program pirates are no different. The idea is to make them work for it. As they remove one lock, you check for it later in the program and throw them a couple of knuckle balls. Here's a couple of knuckle balls:
poke 175, 3
. . .switches the input device from the keyboard to the screen. ForVIC20/C64 use poke 153,3. Of course the pirate will remove this rather unsophisticated excuse for protec tion. So, you check for it. Then execute:
sys 57441
This turns off the keyboard completely except for carriage returns. It has no VIC20/C64 equivalent. The point is, if you make it appear as though the more they unprotect your software, the more foul it behaves, pretty soon they'll be replacing the protection they removed just so they can use it. The Transactor will be devoting an entire issue to soft ware protection and piracy in August 1984. Watch for it."
"[INST]In the context of the C64, What are some important considerations and guidelines for formatting and using a Commodore hard disk drive?[/INST]Hard Disk Formatting
If you have any plans to install a Commodore hard disk drive, chances are the first command you send to it will be a New or HEADER operation. Disk users will know that this formating procedure is necessary to prepare the unit for all future operations. But once you get it started, you might as well find something else to do for a while like learn to play piano or re-build the engine in your car. A Header opera tion on the hard disk can take as long as 1 hour 45 minutes because the ID you select is recorded on every sector header.
You need only do this once unless you wish to change the ID. A Header without the ID merely clears the BAM (Block Allocation Map) and the directory - the rest of the disk is left untouched. If you do decide a re-format is necessary, just remember it will take a while.
Two other hard disk notes: The unit should never be moved while the cylinder is spinning. It takes a minute or so for the cylinder to come to a complete stop after power-down. When moving it, keep the unit level - don't set it on end or its side. Hard disks should be kept on a good solid surface during operation. Even small vibrations can cause undue wear on the disk bearings. Avoid sheifs, tables with long legs or spots that may get bumped by passers-by.
Lastly, Commodore hard disks don't have a drive 0 and drive 1 - only drive 0. Some software packages assume you have a dual floppy and will attempt to access drive 1. Even BASIC tries to read drive 1 when you give a Catalog or Directory command with no drive specified. If you're experi encing any trouble, just slip in a ',D0' or '0:'."
"[INST]In the context of the C64, What are some handy methods and user-defined functions for working with inverse trigonometric functions and trigonometric functions in degrees?[/INST]INVERSE TRIGNOMETRIC FUNCTIONS
Here are a couple of handy methods of obtaining are sine and arc
cosine (remember, the result will be in radians).
ASNX = ATN (X/SQR(1-Xf2)
ACSX = ATN (SQR(1-Xf2)/X)
For those of you who are used to working in degrees, here are some
handy user defined functions:
DEFFNS(V) = SIN(V/(18O/tf))
DEFFNC(V) = COS(V/(180/rf))
DEFFNT(V) = TAN(V/(18O/rf))
These are three user defined functions which when called with
arguments and degrees will give the appropriate results. In these
examples V can be any variable but if all three are defined in
the same programme, you must use three different dummy variables.
EXAMPLE: PRINT FNS(3O)
Result of this will be .5. Notice that the argument for FNS, or
FN anything for that matter, can be either a variable or numeric
constant. Also, after a programme containing these definitions
has been run, these functions may be called using FN in the direct
mode, that is, from the keyboard directly without being in a
programme."
"[INST]In the context of the C64, What is the price and availability of the second cassette unit for the PET computer?[/INST]SECOND CASSETTE UNIT
The second cassette unit with lead and plug ready to go straight
onto the second cassette port on the rear of the PET, will be
available from the beginning of June at a cost $130.00 plus P.S.T."
"[INST]In the context of the C64, How can you use a bell built into your computer to alert you when a long disk operation is finished?[/INST]Disk De-Activity Indicator
If you're disk unit gets into some long operation, like the one mentioned above, you might not notice that it's finished until the next time you browse by. If you have a bell built into your computer, here is one way to make it useful:
print ds$ : poke 231, 100 : print '|
The POKE increases the chime time of the bell, and the 3 reverse G's invoke it 3 times. If you're within ear-shot, this should be enough to get your attention. Or you can put the bell in an endless loop that stops when you hit a key. Only one problem with this though - if you happen to step out or something, that insidious chiming is enough to drive some one bonkers if left exposed to it for too long. You might come home to find your new hard disk is now a chopping block in the kitchen!"
"[INST]In the context of the C64, How does the processor handle interrupts, including break or software interrupts, and what are the implications for user-modified code and I/O chip setup?[/INST]INTERRUPT STRUCTURE
Interrupts (including Break or Software Interrupts) are handled
by software polling.
When the processor recognizes an interrupt it vectors through
FFFE, FFFF in ROM to a routine that first inspects the processor
hardware (IRQ line low).
If it was caused by a Break instruction, a Jump Indirect is
executed through locations 02IB, C. If by a hardware interrupt then
a Jump Indirect is taken through locations 0219, A.
These locations being in RAM may be user-modified to point to
extra user code ahead of normal interrupt processing.
Note, however that the IRQ pointer is used by the cassette
routines and should be restored to standard values before the cassette
Save or Load functions are called.
Various sections of the I/O chips can be set up to cause inter
rupts through the IRQ line.
Example: POKE 59470,2 enables a negative edge on the
user port CAL line to cause an interrupt.
However, have your code set up to handle it when it happens!
Also note that each pass through the regular interrupt code
increments the time register."
"[INST]In the context of the C64, What are some advanced Commodore 64 hardware tips and modifications for service technicians and enthusiasts?[/INST]Some More C64 Hardware Tips
Tony Lamartina of Chicago has another, but it's more suited to service technicians or those with access to necessary equipment.
1. Remove metal cover from video RF area.
2. Connect scope lead between ground and pin 1 of IC31. 3. Adjust R27 for 1.5 volt DC level.
4. Connect scope lead between ground and pin 4 of DIN
plug.
5. Adjust R25 for midposition
6. Connect decade box between pin 4 of DIN plug and
right side of C78
7. Adjust resistance of decade box for 0.8 to 1 volt of
signal level on scope
8. Connect resistor of value determined by decade box
across pin 1 and pin 4 of DIN plug
9. Fine adjust R25 for best display of colour monitor.
Tony also suggests the following be checked on early re leases of the 64:
1. Loose RF box covers. Tighten the metal tabs and re-in stall.
2. Check for a missing heat sink on VR2-7805 voltage regulator. Install suitable heat sink.
3. If the unit displays 'sparkling' (interference across the CRT screen, random in nature) connect a 330 picoF capacitor from pin 20 (ground) to pin 30 (address 6) of the 6567 (VIC II) video chip. Make this connection outside the RF shielded box."
"[INST]In the context of the C64, What is the trick to merge two lines of BASIC code into one line on a Commodore PET/CBM or 80-column machine, and how can it be achieved using a POKE command?[/INST]Text In Drag
Back when there was only 40 Column PET/CBMs, The Transactor discussed a method of attaching the code from one line of BASIC onto the end of the line above it. For example, the following two lines need not be on two sepa rate lines:
100 for j = 1 to 10 110 next
The two lines would be LISTed on the screen. Then using the space bar to wrap around the top line onto the bottom line, the two lines would become one double line. Naturally it only worked for a range of 80 characters. The top line had to be less than 40 characters long and only the first 40 characters of the line below could be transfered. With the two screen lines linked together, the DELete key would beused to 'drag' the line below up onto the line above, squeezing out the line number plus those extra spaces in the process. Of course you'd have to insert a colon yourself and also delete line 110. Try it! (By the way, this doesn't work on the VIC 20/C64 - the screen editor has been changed and is now too smart for this trick to be pulled off)
When 80 Column machines came along there was no longer any need for a line wrap table in low RAM - all the lines were identical regardless of how much code was entered. So the situation above could still occur, but to add one line to another required re-typing.
(You must know what I'm leading up to. Yes, a POKE this time) By making the operating system 'think' that each line is longer than 80 characters, this same trick can be played on the 80 column screen editor. Slight of hand? No. More accurately, 'right of hand'. Location 213 is the right hand window margin. Normally it contains 79 for 80 column lines (0-79):
poke 213,159
. . .will make the editor think that each screen line is 160 characters long, however, you're still limited to 80 charac ters per program line.
Now, about the only way I could make this work was to start from the beginning of the first line and ' cursor right' all the way over to about column 75. Only then would DELete cooperate and drag the bottom line up. Using cursor left to 'go around the other way' created some other problems.
Once you're done you'll want to restore 213 to a 79. Otherwise you'll get some strangeness occurring. Try POKE 213, 255 and cursor down off the bottom of the screen. Weird, eh? Again, I don't know why. And if you think that's weird, try listing a program that will cause screen scrolling. You won't crash the machine, but you may have to clear the screen before entering any new direct commands. Try experimenting. I'm not sure, but it might even work for 3 screen lines (ie. POKE 213, 239)."
"[INST]In the context of the C64, What is the function of the COLOR CONTROL knob on a <1702 monitor?[/INST]1702 monitor COLOR CONTROL
Turn this knob to the left to pale colors, and to the right to
brighten colors.  The normal setting is at the center, which is the
click-stop position."
"[INST]In the context of the C64, What is the function of the knob on a 1702 monitor and how does it affect the picture?[/INST]1702 monitor BRIGHTNESS CONTROL
Turn this knob to the right to brighten the picture.  The normal
setting is at the center."
"[INST]In the context of the C64, What is the purpose of the TINT CONTROL knob on a 1702 monitor?[/INST]1702 monitor TINT CONTROL
Turn this knob to the left to add more red, and to the right to add
more green color.

The normal setting forthis knob is at the center, which is the click-
stop position.

When you're adjusting the color, concentrate on one or two colors,
such as brown and purple."
"[INST]In the context of the C64, How do you access and use the manual control buttons to adjust the picture on your 1702 monitor?[/INST]You can adjust your 1702 monitor's picture with the seven manual control
buttons located behind the panel beneath the monitor screen.  The
panel opens from the top; just flip open the cover by releasing it at
the top."
"[INST]In the context of the C64, What does the user manual of the Commodore 1702 color monitor instruct the user to do before using the monitor and what warnings does it provide?[/INST]Your new Commodore 1702 color monitor gives you a superior color
picture that enhances your computing experience.  This monitor is
simple to hook up to your computer and is easy to adjust.

Please read this brief manual carefully before you try to use your
monitor.  The manual shows you how to install and use the monitor
correctly.  It also explains how to use the picture control knobs,
which are like the control knobs on a color TV.

Be sure to heed any warnings in this manual, and do NOT remove the
back cover or otherwise attempt to service this monitor.  If you have
problems with your monitor that are not covered in this manual, see
your Commodore dealer or a qualified technician."
"[INST]In the context of the C64, What are the steps to connect a Commodore 1702 monitor to a personal computer?[/INST]CONNECTING THE 1702 MONITOR TO A COMPUTER
The monitor connection cable connects your monitor to a Commodore
personal computer.  Before you connect the cable, turn off the power
to both your personal computer and the monitor.

There are two different cables that you can use to connect the monitor
to your computer.

1. One kind of cable has three jacks that connect to the BACK of the
monitor.

2. The other cable has two jacks that connect to the FRONT of the
monitor.

The kind of cable you'll use depends on your computer.  To find out
which kind of cable you should use, look at the audio/video connector
on your computer (see your computer's user manual if you don't know
where this connector is).

1. If the audio/video connector has EIGHT little holes, use the
three-jack cable.

2. If the connector has FIVE little holes, use the two-jack cable.

To connect a three-jack cable to the rear panel of the monitor, follow
these instructions, which clarify the diagram:

1. Plug the eight PIN DIN connector (the larger end of the cable) into
the audio/video connector port on your computer.  Just push the cable
end in.

2. Plug the RCA pin plugs (the jacks) of the cable into the rear
terminals on the monitor.  The jacks and the terminals are color-
coded:

* the audio output jack (WHITE) plugs into the AUDIO IN terminal
(WHITE) on the monitor
* the luminance output jack (YELLOW) plugs into the LUMA terminal
(YELLOW)
* the chroma output jack (RED) plugs into the CHROMA terminal (RED)

3. Switch the SIGNAL SELECTOR to the REAR position."
"[INST]In the context of the C64, What are the steps to turn on your 1702 monitor and personal computer, and what should you expect to see on the monitor screen?[/INST]TURNING ON YOUR 1702 MONITOR
When you finish connecting your monitor according to the instructions,
follow these simple steps:

1. Turn on the monitor by pushing down the power switch. The POWER
INDICATOR LIGHT on the front of the monitor shows you when the power
is on.  Always turn on the monitor BEFORE you turn on the computer.

Later, when you're ready to turn the power off, just press the power
button again.  The button will pop back up and the power light will go
out.

2. Turn on your personal computer.  You can tell that both the monitor
and the computer are working correctly when the monitor displays a
message like this one, which appears when you're using a Commodore 64:

[ Graphic partially omitted: Black and white front view of monitor
showing characters, screen, and border. ]

 .-------------------------------------------------------.
 |                                                       |
 |   .-----------------------------------------------.   |
 |   |   .---------------------------------------.   |   |
 |   |   |                                       |   |   |
 |   |   | ****COMMODORE 64 BASIC V2****         |   |   |
 |   |   | 64K RAM SYSTEM 38911 BASIC BYTES FREE . . . . . . Character
 |   |   | READY.                                |   |   |
 |   |   | #                               . . . . . . . . . Screen
 |   |   |                                       |   |   |
 |   |   |                                       |   |   |
 |   |   |                                       | . . . . . Border
 |   |   |                                       |   |   |


Different computers display other opening messages.  If you don't know
what message to expect, see your computer's user manual."
"[INST]In the context of the C64, How do you connect a two-jack cable to the front of a 1702 monitor?[/INST]To connect a two-jack cable to the front of the 1702. monitor, follow these
steps:

1. Plug the five PIN DIN connector (the larger end of the cable) into
the audio/video connector port on your computer.  Just push the cable
in.

2. Plug the VIDEO IN and AUDIO IN jacks into the VIDEO INPUT and AUDIO
INPUT terminals on the front of the monitor under the screen.

3. Switch the SIGNAL SELECTOR to the FRONT position. The SIGNAL
SELECTOR is a switch on the REAR PANEL.  After you follow these simple
steps, your 1702is ready for useasa video monitor for your personal
computer."
"[INST]In the context of the C64, What precautions and guidelines should be taken when servicing or repairing a 1702 monitor?[/INST]1702 monitor SERVICE

15. Unplug the set from the wall outlet and refer servicing to
qualified service personnel under the following conditions:

A. When the power cord or plug is damaged or frayed.

B. If liquid has been spilled into the set.

C. If the set has been exposed to rain or water.

D. If the set does not operate normally by following the operating
instructions.  Adjust only those controls that are covered in the
operating instructions, as improper adjustment of other controls may
result in damage and will often require extensive work by a qualified
technician to restore the set to normal operation.

E. If the set has been dropped or the cabinet has been damaged.

F. When the set exhibits a distinct change in performance -- this
indicates a need for servicing.

G. If snapping or popping from the set is continuous or frequent while
the set is operating.  It is normal for some sets to make occasional
snapping or popping sounds, particularly when being turned on or off.


16. Do not attempt to service this set yourself, as opening or
removing covers may expose you to dangerous voltage or other hazards.
Refer all servicing to qualified service personnel.

17. When replacement parts are required, have the service technician
verify in writing that the replacements he uses have the same safety
characteristics as the original parts.  Use of manufacturer's
specified replacements can prevent fire, shock, or other hazards.

18. Upon completion of any service or repairs to the set, please ask
the service technician to perform the safety check described in the
manufacturers' service literature.

19. When a video monitor reaches the end of its useful life, improper
disposal could result in a picture tube implosion.  Ask a qualified
service technician to dispose of the set."
"[INST]In the context of the C64, What are the safety precautions and guidelines for using a 1702 monitor?[/INST]USE 1702 monitor 

. Always turn the set off if it is necessary to leave the room for
more than a short period of time.  Never leave a set on when leaving
the house.  A possible malfunction may result in a fire hazard.

. Caution children about dropping or pushing objects into the set's
cabinet openings.  Some internal parts carry hazardous voltages and
contact can result in a fire or electrical shock.

. Unplug the set from the wall outlet before cleaning the face of
the picture tube.  Use a slightly damp (not wet) cloth.  Do not use an
aerosol directly on the picture tube since it may overspray and cause
electrical shock.

. Never add accessories to a set that has not been designed for this
purpose.  Such additions may result in a shock hazard.

. For added protection of the set during a lightning storm or when
the set is to be left unattended for an extended period of time,
unplug it from the wall outlet.  This will prevent possible shock and
fire hazards due to lightning storms or power line surges.

. Do not bring magnetic devices such as magnets or motors near the
picture tube.  These things have a bad effect on the color purity of
the picture.

. Sometimes you may feel static electricity when you touch the
surface of the picture tube.  However, this is normal for any TV set
and is harmless to the human body."
"[INST]In the context of the C64, What is the function of the knob labeled VERTICAL POSITION CONTROL"" on a 1702 monitor?""[/INST]1702 monitor VERTICAL POSITION CONTROL
Turn this knob to stop vertical rolling of the picture."
"[INST]In the context of the C64, What is the function of the knob on a 1702 monitor?[/INST]1702 monitor VOLUME CONTROL
Turn this knob to the right to increase sound volume and to the left
to decrease volume."
"[INST]In the context of the C64, What are the safety precautions and guidelines for the installation and operation of a <1702 monitor?[/INST]1702 monitor INSTALLATION

1. Your set is equipped with a polarized AC line plug (one blade of
the plug is wider than the other).

This safety feature allows the plug to fit into the power outlet only
one way.  Should you be unable to insert the plug fully into the
outlet, try reversing the plug.  Should it still fail to fit, contact
your electrician.

2. Operate the set only from a power source as indicated on the set or
refer to the user's manual for this information.  If you are not sure
of the type of power supply to your home, consult your dealer or local
power company.

3. Overloaded AC outlets and extension cords are dangerous, and so are
frayed power cords and broken plugs.  They may result in a shock or
fire hazard.  Call your service technician for replacement.

4. Do not allow anything to rest or roll over the power cord, and do
not place the set where power cord is subject to traffic or abuse.
This may result in a shock or fire hazard.

5. Do not use this set near water -- for example, near a bathtub,
washbowl, kitchen sink, or laundry tub, in a wet basement, or near a
swimming pool, etc.

6. Sets are provided with ventilation openings in the cabinet to allow
heat generated during operation to be released.  If these openings are
blocked, heat built up within the set can cause failures which may
result in a fire hazard.  Therefore:

* Never block the bottom ventilation slots by placing it on a bed,
sofa, rug, etc.;
* Never place a set in a 'built-in' enclosure unless proper
ventilation is provided;
* Never cover the openings with cloth or other material;
* Never place the set near or over a radiator or heat register."
"[INST]In the context of the C64, What safety precautions should be taken when installing, using, and servicing a monitor to avoid electrical shock or fire hazards?[/INST]1702 monitor SAFETY PRECAUTIONS

Electrical energy can perform many useful functions.  This unit has
been engineered and manufactured to assure your personal safety.  But
improper use can result in potential electrical shock or fire hazards.
In order not to defeat the safeguards incorporated in this monitor,
observe the following basic rules for its installation, use and
servicing.  And also follow all warnings and instructions marked on
your video monitor."
"[INST]In the context of the C64, What is the function of the horizontal position control knob on a 1702 monitor?[/INST]1702 monitor HORIZONTAL POSITION CONTROL
Turn this knob to the right to move the center of the picture to the
right, and turn it to the left to move the center of the picture to
the left."
"[INST]In the context of the C64, What is the purpose of the CONTRAST CONTROL knob on a 1702 monitor?[/INST]1702 monitor CONTRAST CONTROL
Turn this knob to the right to increase contrast.  The normal setting
is at the center."
