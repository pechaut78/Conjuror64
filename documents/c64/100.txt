  LDA - LOAD THE ACCUMULATOR

    In 6510 assembly language, mnemonics are always three characters. LDA
  represents "load accumulator with...", and what the accumulator should be
  loaded with is decided by the parameter(s) associated with that
  instruction. The assembler knows which token is represented by each
  mnemonic, and when it "assembles" an instruction, it simply puts into
  memory (at whatever address has been specified), the token, and what
  parameters, are given. Some assemblers give error messages, or warnings
  when you try to assemble something that either the assembler, or the 6510
  microprocessor, cannot do.
    If you put a "#" symbol in front of the parameter associated with the
  instruction, this means that you want the register specified in the
  instruction to be loaded with the "value" after the "#". For example:

    LDA #$05  <----[ $=HEX ]

  This instruction will put $05 (decimal 5) into the accumulator register.
  The assembler will put into the specified address for this instruction,
  $A9 (which is the token for this particular instruction, in this mode),
  and it will put $05 into the next location after the location containing
  the instruction ($A9).
    If the parameter to be used by an instruction has "#" before it; i.e.,
  the parameter is a "value," rather than the contents of a memory loca-
  tion, or another register, the instruction is said to be in the
  "immediate" mode. To put this into perspective, let's compare this with
  another mode:
    If you want to put the contents of memory location $102E into the
  accumulator, you're using the "absolute" mode of instruction:

    LDA $102E

  The assembler can distinguish between the two different modes because the
  latter does not have a "#" before the parameter. The 6510 microprocessor
  can distinguish between the immediate mode, and the absolute mode of the
  LDA instruction, because they have slightly different tokens. LDA
  (immediate) has $A9 as its token, and LDA (absolute), has $AD as its
  token.
    The mnemonic representing an instruction usually implies what it does.
  For instance, if we consider another instruction, LDX, what do you think
  this does?
    If you said "load the X register with...", go to the top of the class.
  If you didn't, then don't worry, learning machine language does take
  patience, and cannot be learned in a day.
    The various internal registers can be thought of as special memory
  locations, because they too can hold one byte of information. It is not
  necessary for us to explain the binary numbering system (base 2) since it
  follows the same rules as outlined for hexadecimal and decimal outlined
  previously, but one "bit" is one binary digit and eight bits make up one
  byte! This means that the maximum number that can be contained in a
  byte is the largest number that an eight digit binary number can be. This
  number is 11111111 (binary), which equals $FF (hexadecimal), which equals
  255 (decimal). You have probably wondered why only numbers from zero to
  255 could be put into a memory location. If you try POKE 7680,260 (which
  is a BASIC statement that "says": "Put the number two hundred and sixty,
  into memory location seven thousand, six hundred and eighty", the BASIC
  interpreter knows that only numbers 0 - 255 can be put in a memory
  location, and your Commodore 64 will reply with:

    ?ILLEGAL QUANTITY ERROR

    READY.

  If the limit of one byte is $FF (hex), how is the address parameter in
  the absolute instruction "LDA $102E" expressed in memory? It's expressed
  in two bytes (it won't fit into one, of course). The lower (rightmost)
  two digits of the hexadecimal address form the "low byte" of the address,
  and the upper (leftmost) two digits form the "high byte."
    The 6510 requires any address to be specified with its low byte first,
  and then the high byte. This means that the instruction "LDA $102E" is
  represented in memory by the three consecutive values:

    $AD, $2E, $10

  Now all you need to know is one more instruction and then you can write
  your first program. That instruction is BRK. For a full explanation of
  this I instruction, refer to M.O.S. 6502 Programming Manual. But right
  now, you can think of it as the END instruction in machine language.
    If we write a program with 64MON and put the BRK instruction at the
  end, then when the program is executed, it will return to 64MON when it
  is finished. This might not happen if there is a mistake in your program,
  or the BRK instruction is never reached (just like an END statement in
  BASIC may never get executed). This means that if the Commodore 64 didn't
  have a STOP key, you wouldn't be able to abort your BASIC programs!