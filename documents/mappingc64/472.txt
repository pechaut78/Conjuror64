


address        $DD00-$DD0F
Complex Interface Adapter (CIA) #2 Registers

Locations 56576-56591 ($DD00-$DD0F) are used to address the Complex
Interface Adapter chip #2 (CIA #2).  Since the chip itself is
identical to CIA #1, which is addressed at 56320 ($DC00), the
discussion here will be limited to the use which the 64 makes of this
particular chip.  For more general information on the chip registers,
please see the corresponding entries for CIA #1.

One of the significant differences between CIA chips #1 and #1 is the
use to which Data Ports A and B are put.  The peripheral input and
output devices that CIA #2 controls are those on the Serial Bus (such
as the 1541 Disk Drive and 1525 printer), the RS-232 device (which is
used for telecommunications), and the User Port, an eight-bit parallel
port that can be turned to whatever purpose the user desires.  In
addition, Data Port A has the important task of selecting the 16K bank
ofmemory that will be used by the VIC-II chip for graphics.

Another significant difference between CIA chips #1 and #2 is that the
interrupt line of CIA #1 is wired to the 6510 IRQ line, while that of
CIA #2 is wired to the NMI line.  This means that interrupts from this
chip cannot be masked by setting the Interrupt disable flag (SEI).
They can be disabled from CIA's Mask Register, though.  Be sure to use
the NMI vector when setting up routines to be driven by interrupts
generated by this chip.

Location Range: 56576-56577 ($DD00-$DD01)
CIA #2 Data Ports A and B

These registers are where the communication with the Serial Bus,
RS-232 device, and User Port take place.  The Serial Bus is like the
IEEE bus which is used by the PET, in that it allows more than one
device to be connected to the port at a time, in a daisychain
arrangement.  Since each byte of data is sent one bit at a time,
however, the Serial Bus is at least eight times slower than the IEEE.
It is presently used to control the 1541 Disk Drive and 1525 printer,
and other devices (such as printer interface for Centronics- type
parallel pritners and stringy floppy wafer tape storage units) can be
placed on this bus.

Data Port A is used for communication with the Serial Bus.  Bits 5 and
7 are used for Serial Bus Data Output and Input, respectively, and
Bits 4 and 6 are used for the Serial Bus Clock Pulse Output and Input.
Bit 3 of Data Port A is used to send the ATN signal on the Serial Bus.

The 64 has built-in software to handle RS-232 communications through a
modem or other device plugged in the RS-232/User Port.  The RS-232
device uses Bit 2 of Data Port A for data output (it is the only line
from Port A that is connected to the RS-232/User Port jack).  It also
makes heavy use of Port B, using Bit 7 for the Data Set Ready (DSR)
signal, Bit 6 for the Clear to Send (CTS), Bit 4 for the Carrier
Detect (DCD), Bit 3 for the Ring Indicator (RI), Bit 2 for Data
Terminal Ready (DTR), Bit 1 for Request to Send (RTS), and Bit 0 for
data input.  See locations 659-660 ($293-$294) for more details on the
RS-232 device.

All of the data lines which the RS-232 device uses are also available
to the user as part of the User Port.  All of the Port B data lines,
and Bit 2 of Port A, are brought out to the User Port connector on the
back of the 64.  These data bits are utilized in the normal way:  The
port connections are made to TTL-level input or output devices, and
the direction of data is determined by the Data Direction Registers.

In addition, the User Port has pins connected to the two CIA Serial
Ports (whose eight-bit shift registers are well-suited for
serial-to-parallel and parallel-to-serial conversion),and the two CNT
lines which aid in the operation of the Serial Ports.  The CNT lines
can also be used in conjunction with the CIA Timers, and allow them to
be used as frequency counters, event counters, interval timers, etc.
The advanced features of the CIA chip make almost any type of
interfacing application possible, and in the near future we will
probably see many interesting applications for the User Port on the
64.  A pin description of tthe User Port connector is provided below:

User         RS-232
Port  CIA    DB-25
Pin   Line   Pin     Description

1                    Ground
2                    +5 Volts (100 milliamps maximum)
3                    RESET (grounding this pin causes a cold start)
4     CNT1           CIA #1 Serial Port and Timer Counter
5     SP1            CIA #1 Serial Data Port
6     CNT2           CIA #2 Serial Port and Timer Counter
7     SP2            CIA #2 Serial Data Port
8     PC2            CIA #2 handshaking line
9                    Connected to the ATN line of the Serial Bus
10                   9 Volts AC (+ phase, 50 milliamps maximum)
11                   9 volts AC (- phase, 50 milliamps maximum)
12                   Ground
A            1       Ground
B     FLAG2          CIA #2 handshaking line
C     PB0    3       Port B Bit 0--RS-232 Received Data (SIN)
D     PB1    4       Port B Bit 1--RS-232 Request to Send (RTS)
E     PB2    20      Port B Bit 2--RS-232 Data Terminal Ready (DTR)
F     PB3    22      Port B Bit 3--RS-232 Ring Indicator (RI)
H     PB4    8       Port B Bit 4--RS-232 Carrier Detect (DCD)
J     PB5            Port B Bit 5
K     PB6    5       Port B Bit 6--RS-232 Clear to Send (CTS)
L     PB7    6       Port B Bit 7--RS-232 Data Set Ready (DSR)
M     PA2    2       Port A Bit 2--RS-232 Transmitted Data (Sout)
N            7       Ground

One of the handshaking lines on the above chart, PC2, was not covered
in the discussion of CIA #1, because that line of CIA #1 is not
connected to anything.  The CIA #2 PC line is accessible from the User
Port, however.  This line will go low for one cycle following a read
or write of Port B on CIA #2.  This signal lets external devices know
when data has been read or written.

Bits 0 and 1 of CIA #2 Port A have an extremely important function.
As mentioned in the section on the VIC-II chip (53248, $D000), the
video chip can address only 16K of memory at a time, and all graphics
data must be stored in that 16K block in order to be displayed.
Within this area, sprite graphics data may be placed in any of 256
groups of 64 bytes each.  Character data can be stored in any of eight
2K blocks.  Text screen memory may be in any of 16 1K areas, and
bitmap screen memory may be in either of two 8K sections.

When you turn the power on, the VIC-II uses the bottom 16K of memory
for graphics.  Unfortunately, this block of memory is also used
extensively for other important purposes.  Though some means of
eliminating these conflicts are discussed above, in many situations
you will want to change from the default 16K bank at the low end of
memory.

Bits 0 and 1 select the current 16K bank for video memory from the
four possible choices using the following bit patterns:

00 (bit value of 0) Bank 3 (49152-65535, $C000-$FFFF)
01 (bit value of 1) Bank 2 (32768-49151, $8000-$BFFF)
10 (bit value of 2) Bank 1 (16384-32767, $4000-$7FFF)
11 (bit value of 3) Bank 0 (0-16383, $0-$3FFF)

The technique for making this change from BASIC is discussed below.
But before we go ahead and start changing banks, let's briefly review
the contents of these areas, and the considerations for using them for
graphics.

Block 0.  This is normally used for system variables and BASIC program
text.  Locations 1024-2047 ($400-$7FF) are reserved for the default
position of screen memory.

There is an addition limitation on memory usage of this block, as the
VIC-II sees the character generator ROM at 4096-8191 ($1000-$1FFF),
making this portion of memory unavailable for other graphics data.
Generally, there is little free space here for graphics display data.
Locations 679-767 ($2A7- $2FF) are unused, and could hold one sprite
shape (number 11) or data for 11 characters.  The area from 820-1023
($334-$3FF), which includes the cassette I/O buffer, is available for
graphics memory, and is large enough to hold three sprite shapes
(numbers 13, 14, and 15), or data for 25 characters (numbers 103-127).
But getting enough memory for bitmap graphics requires that you either
reserve memory after the end of BASIC text by lowering the end of
BASIC pointer at 56 ($38), or raise the start of BASIC pointer at 44
($2C).  See the entries for these pointers for more details.

Block 1.  Block 1 is normally used for BASIC program storage.  When
using this bank, the VIC-II does not have access to the character
generator ROM.  Providing that you lower the top of memory so that
BASIC programs do not interfere, this area is wide open for sprite
shapes, character graphics, and bitmap graphics.

The drawbacks to useing this bank are the unavailability of the
character ROM and the limitation on BASIC program space (as little as
14K).  The absence of the character ROM is a relatively minor
nuisance, because you can always switch in the ROM and copy any or all
of the characters to RAM (see the entries for location 1 and the
alternate entry for 53248 ($D000), the Character ROM, for details).
This block may be a good alternate choice to avoid potential conflicts
with other applications that use higher memory.

Block 2.  The third block (Block 2) consists of 8K of RAM, half of
which is seen by the VIC-II chip as character ROM, and the 8K BASIC
interpreter ROM.  The BASIC ROM area is available for graphics.  This
is possible because of the 64's special addressing.  The VIC-II chip
reads only from RAM, and thus sees the RAM underneath the BASIC ROM,
even if the 6510 has ROM switched in.  The 6510, on the other hand,
always writes to RAM, even when dealing with memory it reads as ROM.
Whatever is written to the RAM underlying the BASIC ROM is displayed
normally by the VIC-II chip.  This opens up an extra 8K are for
sprites and character data under the BASIC ROM.

You should keep in mind that while you can write to this area, you
cannot read it from BASIC.  This may not be a serious problem when it
comes to character sets and sprite data, but it's more of a drawback
if you want to use this RAM for screen memory.

For example, the Operating System has to read the text screen to move
the cursor properly, and if it reads the ROM value instead of the RAM
screen data, it gets hopelessly confused, making it impossible to type
in any commands.

Likewise, you would not be able to read the high-resolution screen if
it were placed here, without some machine language trickery.  With
locations 36863-40959 ousted by the character ROM, only 4K of true RAM
remains for use as screen memory, not enough for a complete
high-resolution screen.  Therefore, this block is not recommended for
use in bitmap mode if your program needs to check the screen.
Otherwise, this is a good place for graphics memory, particularly if
you need to emulate the screen configuration of the PET.

Block 3.  Normally Block 3 contains 4K of RAM that is completely
unused by the system, 4K if I/O registers, and the 8K Operating System
Kernal ROM.  It is very convenient to use when you need a lot of
memory space for both graphics and a BASIC program.  Although the
character ROM is not available, it can be copied to RAM.  The area
under the Kernal ROM can be used as explained above.  One possible
conflict that you should be aware of is that the current version of
the DOS support program is written to reside at 52224 ($CC00).  It
would be safest to avoid using 52224-53247 for graphics if you plan to
use DOS support.

Changing banks.  Once you have selected a bank of 16K to use, the
procedure for making the change from BASIC is as follows:

1.  Set the Data Direction Register if necessary.  In order to use
Bits 0 and 1 of Port A to change banks, these bits must be set as
outputs in Data Direction Register A.  Since this is the default
condition on powering-up, this step normally will not be needed.

2.  Select a bank.  Banks 0-3 can be chosen by entering the following
lines:

POKE 56578,PEEK(56578) OR 3: REM SET FOR OUTPUT IF NOT ALREADY
POKE 56576,(PEEK(56576) AND 252) OR (3-BANK): REM BANK IS BANK #, MUST
  BE 0-3

3.  Set the VIC-II register for character memory.  As explained at the
entry for location 53272 ($D018), the formula for this is:

POKE 53272,(PEEK(53272) AND 240) OR TK: REM TK IS 2 KBYTE OFFSET FROM
  BEGINNING OF BLOCK

4.  Set the VIC-II register for display memory.  As explained at the
entry for location 53272 ($D018), the formula for this is:

POKE 53272,(PEEK(53272) AND 15) OR K*16: REM K IS KBYTE OFFSET FROM
  BEGINNING OF BLOCK

Since steps 3 and 4 operate on the same register, you could combine
these steps and just POKE 53272,(16*K+TK).

5.  Set the Operating System pointer for display memory at 648 ($288).
Even though you have just told the VIC-II chip where to display memory
for the screen, the Operating System does not yet know where to write
its text characters.  Let it know with this statement:

POKE 648,AD/256: REM AD IS THE ACTUAL ADDRESS OF SCREEN MEMORY

After you make this change, you must watch out for the STOP/RESTORE
key combination.  The BRK initialization changes the screen display
default to location 1024 in Bank 0, but not the Operating System
pointer at 648 ($288).  As a result, what you are typing will not be
displayed on the screen.  The computer will lock up until you turn the
power off and back on again.  The simplest way to avoid this problem
is to disable the RESTORE key entirely (see the entries for 792 ($318)
and 808 ($328) for more information).

Below is a sample program which switches to Bank 3.  It includes a
machine language transfer routine to move the ROM character set to
RAM, and a short interrupt routine to correct the RESTORE key problem.
After the switch is made, a loop isused to POKE characters into the
new screen memory area.  Next, the character data is slowly erased, to
show that the character set is now in RAM.  Then, a loop is used to
read the locations of the character set, and write to the same
locations.  This demonstrates that the 6510 reads the Kernal ROM when
you PEEK those locations, but POKEs to the RAM which is being
displayed.  Finally, the machine language move is used again to show
how quickly the set is restored.

20 FOR I=1 TO 33:READ A:POKE 49152+I,A:NEXT: REM SET UP ML ROUTINE
30 GOSUB 200: REM ML COPY OF ROM CHARACTER SET TO RAM
40 POKE 56576,PEEK(56576) AND 252: REM STEP 1, ENABLE BANK 3
50 POKE 53272,44: REM STEPS 2-3, POINT VIC-II TO SCREEN AND CHARACTER MEMORY
60 REM SCREEN OFFSET IS 2*16, CHARACTER OFFSET IS 12
70 POKE 648,200: REM STEP 4, POINT OS TO SCREEN AT 51200 (200*256)
80 PRINT CHR$(147): REM CLEAR SCREEN
90 FOR I=53236 TO 53245:READ A:POKE I,A:NEXT: REM NEW INTERRUPT ROUTINE
100 POKE 53246,PEEK(792):POKE 53247,PEK(793): REM SAVE OLD NMI VECTOR
110 POKE 792,244:POKE 793,207: REM ROUTE THE INTERRUPT THROUGH THE NEW ROUTINE
120 FOR I=0 TO 255:POKE 51400+I,I:POKE 55496+I,1:NEXT
125 REM POKE CHARACTERS TO SCREEN
130 FOR J=1 TO 8:FOR I=61439+J TO I+2048 STEP 8
140 POKE I,0:NEXT I,J: REM ERASE CHARACTER SET
150 FOR I=61440 TO I+2048:POKE I,PEEK(I):NEXT: REM POKE ROM TO RAM
160 GOSUB 200:END: REM RESTORE CHARACTER SET
200 POKE 56334,PEEK(56334) AND 254: REM DISABLE INTERRUPTS
210 POKE 1,PEEK(1) AND 251:REM SWITCH CHARACTER ROM INTO 6510 MEMORY
220 SYS 49152: REM COPY ROM CHARACTER SET TO RAM AT 61440
230 POKE 1,PEEK(1) OR 4: REM SWITCH CHARACTER ROM OUT OF 6510 MEMORY
240 POKE 56334,PEEK(56334)OR 1: REM ENABLE INTERRUPTS
250 RETURN
300 REM DATA FOR ML PROGRAM TO COPY CHARACTER SET TO RAM
310 DATA169,0,133,251,133,253,169,208,133,252,169,240,133,254,162,16
320 DATA160,0,177,251,145,253,136,208,249,230,252,230,254,202,208,240,96
330 REM NEXT IS ML PROGRAM TO MAKE THE RESTORE KEY RESET OS POINTER TO SCREEN
340 DATA 72,169,4,141,136,02,104,108,254,207

See also the sample program showing how to configure your 64 like a
PET at location 43 ($2B).