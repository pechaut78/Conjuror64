question,answer
What is the purpose of the OPEN statement in BASIC?,"OUTPUT TO OTHER DEVICES

    It is often necessary to send output to devices other than the screen,
  like a cassette deck, printer, disk drive, or modem. The OPEN statement
  in BASIC creates a 'channel' to talk to one of these devices. Once the
  channel is OPEN, the PRINT# statement will send characters to that
  device.

  EXAMPLE of OPEN and PRINT# Statements:

    100 OPEN 4,4: PRINT# 4, 'WRITING ON PRINTER'
    110 OPEN 3,8,3,'0:DISK-FILE,S,W':PRINT#3,'SEND TO DISK'
    120 OPEN 1,1,1,'TAPE-FILE': PRINT#1,'WRITE ON TAPE'
    130 OPEN 2,2,0,CHR$(10):PRINT#2,'SEND TO MODEM'
    The OPEN statement is somewhat different for each device. The pa-
  rameters in the OPEN statement are shown in the table below for each
  device."
How can I output data to the RS-232 on the Commodore 64?,"SENDING DATA TO AN RS-232 CHANNEL

    When sending data, the output buffer can hold 255 characters before a
  full buffer hold-off occurs. The system will wait in the CHROUT routine
  until transmission is allowed or the <RUN/STOP> and <RESTORE> keys are
  used to recover the system through a WARM START.


  BASIC SYNTAX:

    CMD lfn-acts same as in the BASIC specifications.
    PRINT#lfn,<variable list>


  KERNAL ENTRIES:

    CHKOUT ($FFC9)-See Memory Map for more information on entry and exit
  conditions.
    CHROUT ($FFD2)-See Memory Map for more information on entry conditions.
 
 
  | IMPORTANT NOTES: There is no carriage-return delay built into the     |
  | output channel. This means that a normal RS-232 printer cannot        |
  | correctly print, unless some form of hold-off (asking the Commodore 64|
  | to wait) or internal buffering is implemented by the printer. The     |
  | hold-off can easily be implemented in your program. If a CTS (x-line) |
  | handshake is implemented, the Commodore 64 buffer will fill, and then |
  | hold-off more output until transmission is allowed by the RS-232      |
  | device. X-line handshaking is a handshake routine that uses multi-    |
  | lines for receiving and transmitting data.                            |
  |   The routine CHKOUT handles the x-line handshake, which follows the  |
  | EIA standard (August 1979) for RS-232-C interfaces. The RTS, CTS, and |
  | DCD lines are implemented with the Commodore 64 defined as the Data   |
  | Terminal Device.                                                      |"
What is the purpose of the RTS instruction in the 6502 assembly language?,"RTS                    RTS Return from subroutine                     RTS
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   RTS                 |    60   |    1    |    6     |"
What is the purpose of the JSR 6502 instruction ?,"JSR          JSR Jump to new location saving return address           JSR


  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Absolute      |   JSR Oper            |    20   |    3    |    6     |"
What is the primary function of the input/output port described in the given text?,"THE INPUT/OUTPUT PORT

    This register appears at memory locations 0 (for the DATA DIRECTION
  REGISTER) and 1 (for the actual PORT). It is an 8-bit input/output port.
  On the Commodore 64 this register is used for memory management, to
  allow the chip to control more than 64K of RAM and ROM memory.
    The details of these registers are not given here. They are explained
  as the principles needed to explain them are explained."
What types of filtering are available on the SID chip?,"FILTERING

    The harmonic content of a waveform can be changed by using a filter.
  The SID chip is equipped with three types of filtering. They can be used
  separately or in combination with one another. Let's go back to the
  sample program you've been using to play with a simple example that uses
  a filter. There are several filter controls to set.
    You add line 15 in the program to set the cutoff frequency of the
  filter. The cutoff frequency is the reference point for the filter. You
  SET the high and low frequency cutoff points in registers 21 and 22. To
  turn ON the filter for voice 1, POKE register 23.
    Next change line 30 to show that a high-pass filter will be used (see
  the SID register map).


    The SID chip also has a low-pass filter. As its name implies, this
  filter will pass the frequencies below cutoff and attenuate those above.


    Finally, the chip is equipped with a bandpass filter, which passes a
  narrow band of frequencies around the cutoff, and attenuates all others.


    The high- and low-pass filters can be combined to form a notch reject
  filter which passes frequencies away from the cutoff while attenuating
  at the cutoff frequency.



    Register 24 determines which type filter you want to use. This is in
  addition to register 24's function as the overall volume control. Bit 6
  controls the high-pass filter (0 = off, 1 = on), bit 5 is the bandpass
  filter, and bit 4 is the low-pass filter. The low 3 bits of the cutoff
  frequency are determined by register 21 (Lcf) (Lcf = 0 through 7). While
  the 8 bits of the high cutoff frequency are determined by register 22
  (Hcf) (Hcf = 0 through 255).
    Through careful use of filtering, you can change the harmonic structure
  of any waveform to get just the sound you want. In addition, changing the
  filtering of a sound as it goes through the ADSR phases of its life can
  produce interesting effects."
What is the purpose of the RAMTAS kernal function?,"B.20. Function Name: RAMTAS

    Purpose: Perform RAM test
    Call address: $FF87 (hex) 65415 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: This routine is used to test RAM and set the top and
  bottom of memory pointers accordingly. It also clears locations $0000 to
  $0101 and $0200 to $03FF. It also allocates the cassette buffer, and sets
  the screen base to $0400. Normally, this routine is called as part of the
  initialization process of a Commodore 64 program cartridge.

  EXAMPLE:
    JSR RAMTAS"
"For sprites: What values can the X position take on, and how do you move beyond the range of 0 to 255?","X POSITION VALUES BEYOND 255:

    X positions run from 0 to 255... and then START OVER from 0 to 255. To
  put a sprite beyond X position 255 on the far right side of the screen,
  you must first POKE V+ 16 as shown, THEN POKE a new X valve from 0 to 63,
  which will place the sprite in one of the X positions at the right side
  of the screen. To get back to positions 0-255, POKE V+16,0 and POKE in an
  X value from 0 to 255.

  Y POSITION VALUES:

    Y positions run from 0 to 255, including 0 to 49 off the TOP of the
  viewing area, 50 to 229 IN the,viewing area, and 230 to 255 off the
  BOTTOM of the viewing area."
What is the purpose of the CIOUT routine in a serial communication system?,"B-6. Function Name: CIOUT

    Purpose: Transmit a byte over the serial bus
    Call address: $FFA8 (hex) 65448 (decimal)
    Communication registers: A
    Preparatory routines: LISTEN, [SECOND]
    Error returns: See READST
    Stack requirements: 5
    Registers affected: None

    Description: This routine is used to send information to devices on the
  serial bus. A call to this routine will put a data byte onto the serial
  bus using full serial handshaking. Before this routine is called, the
  LISTEN KERNAL routine must be used to command a device on the serial bus
  to get ready to receive data. (If a device needs a secondary address, it
  must also be sent by using the SECOND KERNAL routine.) The accumulator is
  loaded with a byte to handshake as data on the serial bus. A device must
  be listening or the status word will return a timeout. This routine
  always buffers one character. (The routine holds the previous character
  to be sent back.) So when a call to the KERNAL UNLSN routine is made to
  end the data transmission, the buffered character is sent with an End Or
  Identify (EOI) set. Then the UNLSN command is sent to the device.
  How to Use:

    0) Use the LISTEN KERNAL routine (and the SECOND routine if needed).
    1) Load the accumulator with a byte of data.
    2) Call this routine to send the data byte.

  EXAMPLE:


    LDA #'X       ;SEND AN X TO THE SERIAL BUS
    JSR CIOUT"
What is the purpose of the BANK SELECT bits in the 6526 COMPLEX INTERFACE ADAPTER CHIP #2 (CIA #2) in the Commodore 64?,"VIDEO BANK SELECTION
 OR VBLANK

    The VIC-II chip can access ('see') 16K of memory at a time. Since there
  is 64K of memory in the Commodore 64, you want to be able to have the
  VIC-II chip see all of it. There is a way. There are 4 possible BANKS
  (or sections) of 16K of memory. All that is needed is some means of
  controlling which 16K bank the VIC-II chip looks at. In that way, the
  chip can 'see' the entire 64K of memory. The BANK SELECT bits that allow
  you access to all the different sections of memory are located in the
  6526 COMPLEX INTERFACE ADAPTER CHIP #2 (CIA #2). The POKE and PEEK BASIC
  statements (or their machine language versions) are used to select a
  bank, by controlling bits 0 and 1 of PORT A of CIA#2 (location 56576 (or
  $DD00 HEX)). These 2 bits must be set to outputs by setting bits 0 and 1
  of location 56578 ($DD02,HEX) to change banks. The following example
  shows this:

    POKE 56578,PEEK(56578)OR 3: REM MAKE SURE BITS 0 AND 1 ARE OUTPUTS
    POKE 56576,(PEEK(56576)AND 252)OR A: REM CHANGE BANKS



  This 16K bank concept is part of everything that the VIC-II chip does.
  You should always be aware of which bank the VIC-II chip is pointing at,
  since this will affect where character data patterns come from, where the
  screen is, where sprites come from, etc. When you turn on the power of
  your Commodore 64, bits 0 and 1 of location 56576 are automatically set
  to BANK 0 ($0000-$3FFF) for all display information.

  
  NOTE: The Commodore 64 character set is not available to the VIC-II 
  chip in BANKS 1 and 3. (See character memory section.)"
What is the purpose of the interrupt status register in the Commodore 64?,"INTERRUPT STATUS REGISTER

    The interrupt status register shows the current status of any interrupt
  source. The current status of bit 2 of the interrupt register will be a 1
  when two sprites hit each other. The same is true, in a corresponding 1
  to 1 relationship, for bits 0-3 listed in the chart below. Bit 7 is also
  set with a 1, whenever an interrupt occurs.
    The interrupt status register is located at 53273 ($D019) and is as
  follows:

    LATCH  BIT#             DESCRIPTION

    IRST    0   Set when current raster count = stored raster count
    IMDC    1   Set by SPRITE-DATA collision (1st one only, until reset)
    IMMC    2   Set by SPRITE-SPRITE collision (1st one only, until reset)
     ILP    3   Set by negative transition of light pen (1 per frame)
     IRQ    7   Set by latch set and enabled
 
    Once an interrupt bit has been set, it's 'latched' in and must be
  cleared by writing a 1 to that bit in the interrupt register when you're
  ready to handle it. This allows selective interrupt handling, without
  having to store the other interrupt bits."
What are the three registers used to move a sprite around the screen on a Commodore 64?,"SPRITE POSITIONING

    Once you've made a sprite you want to be able to move it around the
  screen. To do this, your Commodore 64 uses three positioning registers:

    1) SPRITE X POSITION REGISTER
    2) SPRITE Y POSITION REGISTER
    3) MOST SIGNIFICANT BIT X POSITION REGISTER

    Each sprite has an X position register, a Y position register, and a
  bit in the X most significant bit register. This lets you position your
  sprites very accurately. You can place your sprite in 512 possible X
  positions and 256 possible Y positions.
    The X and Y position registers work together, in pairs, as a team. The
  locations of the X and Y registers appear in the memory map as follows:
  First is the X register for sprite 0, then the Y register for sprite 0.
  Next comes the X register for sprite 1, the Y register for sprite 1, and
  so on. After all 16 X and Y registers comes the most significant bit in
  the X position (X MSB) located in its own register."
What is the correct POKE statement to move the screen to a new location?,"The location of screen memory can be changed easily by a POKE to
  control register 53272 ($D018 HEX). However, this register is also used
  to control which character set is used, so be careful to avoid disturbing
  that part of the control register. The UPPER 4 bits control the location
  of screen memory. To move the screen, the following statement should be
  used:
  POKE53272,(PEEK(53272)AND15)OR A
  Where 'A' has one of the following values:
$0000
$0400
$0800
$0C00
$1000
$1400
$1800
$1C00
$2000
$2400
$2400
$2800 
$2800 
$2C00 
$2C00 
$3000 
$3000 
$3400 
$3400 
$3800 
$3800 
$3C00 
$3C00 

* Remember that the BANK ADDRESS of the VIC-II chip must be added in.
* Remember that the BANK ADDRESS of the VIC-II chip must be added in.
You must also tell the KERNAL'S screen editor where the screen is as
follows: POKE 648, page (where page = address/256, e.g., 1024/256= 4,
so POKE 648,4)."
What is the purpose of the INTERRUPT ENABLE REGISTER in the VIC-II chip?,"The INTERRUPT ENABLE REGISTER is located at 53274 ($D01A). It has the
  same format as the interrupt status register. Unless the corresponding
  bit in the interrupt enable register is set to a 1, no interrupt from
  that source will take place. The interrupt status register can still be
  polled for information, but no interrupts will be generated.
    To enable an interrupt request the corresponding interrupt enable bit
  (as shown in the chart above) must be set to a 1.
    This powerful interrupt structure lets you use split screen modes. For
  instance you can have half of the screen bit mapped, half text, more than
  8 sprites at a time, etc. The secret is to use interrupts properly. For
  example, if you want the top half of the screen to be bit mapped and the
  bottom to be text, just set the raster compare register (as explained
  previously) for halfway down the screen. When the interrupt occurs, tell
  the VIC-II chip to get characters from ROM, then set the raster compare
  register to interrupt at the top of the screen. When the interrupt occurs
  at the top of the screen, tell the VIC-II chip to get characters from RAM
  (bit map mode).
  You can also display more than 8 sprites in the same way. Unfortunately BASIC isn't fast enough to do this very well. So if you want to start using display interrupts, you should work in machine language."
What is the purpose of the CINT routine in the Commodore 64 KERNAL?,"B-7. Function Name: CINT

    Purpose: Initialize screen editor & 6567 video chip
    Call address: $FF81 (hex) 65409 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: None
    Stack requirements: 4
    Registers affected: A, X, Y


    Description: This routine sets up the 6567 video controller chip in the
  Commodore 64 for normal operation. The KERNAL screen editor is also
  initialized. This routine should be called by a Commodore 64 program
  cartridge.

  How to Use:

    1) Call this routine.

  EXAMPLE:

    JSR CINT
    JMP RUN       ;BEGIN EXECUTION"
What is the purpose and description of the RDTIM function in  kernal?,"B-21. Function Name: RDTIM

    Purpose: Read system clock
    Call address: $FFDE (hex) 65502 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: This routine is used to read the system clock. The clock's
  resolution is a 60th of a second. Three bytes are returned by the
  routine. The accumulator contains the most significant byte, the X index
  register contains the next most significant byte, and the Y index
  register contains the least significant byte.

  EXAMPLE:

    JSR RDTIM
    STY TIME
    STX TIME+1
    STA TIME+2
    ...
    TIME *=*+3"
What is the recommended memory setting for each sprite in the computer's memory?,"SPRITE COLORS:

    To make sprite 0 WHITE, type: POKE V+39,1 (use COLOR POKE SETTING shown
  in chart, and INDIVIDUAL COLOR CODES shown below):

    0-BLACK     4-PURPLE        8-ORANGE        12-MED. GREY
    1-WHITE     5-GREEN         9-BROWN         13-LT. GREEN
    2-RED       6-BLUE          10-LT. RED      14-LT. BLUE
    3-CYAN      7-YELLOW        11-DARK GREY    15-LT. GREY

  MEMORY LOCATION:

    You must 'reserve' a separate 64-BYTE BLOCK of numbers in the
  computer's memory for each sprite of which 63 BYTES will be used for
  sprite data. The memory settings shown below are recommended for the
  'sprite pointer' settings in the chart above. Each sprite will be unique
  and you'll have to define it as you wish. To make all sprites exactly the
  same, point the sprites you want to look the same to the same register
  for sprites."
What is the purpose of the TYA instruction in the 6502 assembly language?,"TYA                TYA Transfer index Y to accumulator                TYA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TYA                 |    98   |    1    |    2     |"
What does the stack pointer register contain on C64?,"THE STACK POINTER

    This register contains the location of the first empty place on the
  stack. The stack is used for temporary storage by machine language pro-
  grams, and by the computer."
What are the details for the Jump 6502 instruction?,"JMP                     JMP Jump to new location                      JMP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Absolute      |   JMP Oper            |    4C   |    3    |    3     |
  |  Indirect      |   JMP (Oper)          |    6C   |    3    |    5     |"
What is the instruction that performs a return from interrupt in 6502?,"RTI                    RTI Return from interrupt                      RTI

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   RTI                 |    4D   |    1    |    6     |"
How can I get data from an RS-232 channel on a Commodore 64?,"GETTING DATA FROM AN RS-232 CHANNEL

    When getting data from an RS-232 channel, the Commodore 64 receiver
  buffer will hold up to 255 characters before the buffer overflows. This
  is indicated in the RS-232 status word (ST in BASIC, or RSSTAT in machine
  language). If an overflow occurs, then all characters received during a
  full buffer condition, from that point on, are lost. Obviously, it pays
  to keep the buffer as clear as possible.
    If you wish to receive RS-232 data at high speeds (BASIC can only go so
  fast, especially considering garbage collects. This can cause the re-
  ceiver buffer to overflow), you will have to use machine language
  routines to handle this type of data burst.

  BASIC SYNTAX:

    Recommended: GET#lfn, <string variable>
    NOT Recommended: INPUT#lfn <variable list>

  KERNAL ENTRIES:

    CHKIN ($FFC6)-See Memory Map for more information on entry and exit
  conditions.
    GETIN ($FFE4)-See Memory Map for more information on entry and exit
  conditions.
    CHRIN ($FFCF)-See Memory Map for more information on entry and exit
  conditions.

  | NOTES:                                                                |
  |   If the word length is less than 8 bits, all unused bit(s) will be   |
  | assigned a value of zero.                                             |
  |   If a GET# does not find any data in the buffer, the character '' (a |
  | null) is returned.                                                    |
  |   If INPUT# is used, then the system will hang in a waiting condition |
  | until a non-null character and a following carriage return is         |
  | received. Therefore, if the Clear To Send (CTS) or Data Set Ready     |
  | (DSR) line(s) disappear during character INPUT#, the system will hang |
  | in a RESTORE-only state. This is why the INPUT# and CHRIN routines are|
  | NOT recommended.                                                      |
  |   The routine CHKIN handles the x-line handshake which follows the EIA|
  | standard (August 1979) for RS-232-C interfaces. (The Request To Send  |
  | (RTS), CTS, and Received line signal (DCD) lines are implemented with |
  | the Commodore 64 computer defined as the Data Terminal device.)       |"
How does the print function works?,"OUTPUT TO THE TV

    The simplest form of output in BASIC is the PRINT statement. PRINT uses
  the TV screen as the output device, and your eyes are the input device
  because they use the information on the screen.
    When PRINTing on the screen, your main objective is to format the
  information on the screen so it's easy to read. You should try to think
  like a graphic artist, using colors, placement of letters, capital and
  lower case letters, as well as graphics to best communicate the
  information. Remember, no matter how smart your program, you want to be
  able to understand what the results mean to you.
    The PRINT statement uses certain character codes as 'commands' to the
  cursor. The <CRSR> key doesn't actually display anything, it just makes
  the cursor change position. Other commands change colors, clear the
  screen, and insert or delete spaces. The <RETURN> key has a character
  code number (CHR$) of 13. A complete table of these codes is contained in
  Appendix C.
    There are two functions in the BASIC language that work with the PRINT
  statement. TAB positions the,cursor on the given position from the left
  edge of the screen, SPC moves the cursor right a given number of spaces
  from the current position.
    Punctuation marks in the PRINT statement serve to separate and format
  information. The semicolon (;) separates 2 items without any spaces in
  between. If it is the last thing on a line, the cursor remains after the
  last thing PRINTed instead of going down to the next line. It suppresses
  (replaces) the RETURN character that is normally PRINTed at the end of
  the line.
    The comma (,) separates items into columns. The Commodore 64 has 4
  columns of 10 characters each on the screen. When the computer PRINTs a
  comma, it moves the cursor right to the start of the next column. If it
  is past the last column of the line, it moves the cursor down to the next
  line. Like the semicolon, if it is the last item on a line the RETURN is
  suppressed.
    The quote marks ('') separate literal text from variables. The first
  quote mark on the line starts the literal area, and the next quote mark
  ends it. By the way, you don't have to have a final quote mark at the
  end of the line.
    The RETURN code (CHR$ code of 13) makes the cursor go to the next
  logical line on the screen. This is not always the very next line. When
  you type past the end of a line, that line is linked to the next line.
  The computer knows that both lines are really one long line. The links
  are held in the line link table (see the memory map for how this is set
  up).
    A logical line can be 1 or 2 screen lines long, depending on what was
  typed or PRINTed.  The logical line the cursor is on determines where the
  <RETURN> key sends it. The logical line at the top of the screen
  determines if the screen scrolls 1 or 2 lines at a time. There are other
  ways to use the TV as an output device. The chapter on graphics describes
  the commands to create objects that move across the screen. The VIC chip
  section tells how the screen and border colors and sizes are changed. And
  the sound chapter tells how the TV speaker creates music and special
  effects."
What is the Commodore 64's built-in interface for connecting to devices?,"RS-232 INTERFACE DESCRIPTION

  GENERAL OUTLINE

    The Commodore 64 has a built-in RS-232 interface for connection to any
  RS-232 modem, printer, or other device. To connect a device to the
  Commodore 64, all you need is a cable and a little bit of programming.
    RS-232 on the Commodore 64 is set-up in the standard RS-232 format, but
  the voltages are TTL levels (0 to 5V) rather than the normal RS-232 -12
  to 12 volt range. The cable between the Commodore 64 and the RS-232
  device should take care of the necessary voltage conversions. The
  Commodore RS-232 interface cartridge handles this properly.
    The RS-232 interface software can be accessed from BASIC or from the
  KERNAL for machine language programming.
    RS-232 on the BASIC level uses the normal BASIC commands: OPEN, CLOSE,
  CMD, INPUT#, GET#, PRINT#, and the reserved variable ST. INPUT# and GET#
  fetch data from the receiving buffer, while PRINT# and CMD place data
  into the transmitting buffer. The use of these commands (and examples)
  will be described in more detail later in this chapter.
    The RS-232 KERNAL byte and bit level handlers run under the control of
  the 6526 CIA #2 device timers and interrupts. The 6526 chip generates

  NMI (Non-Maskable Interrupt) requests for RS-232 processing. This allows
  background RS-232 processing to take place during BASIC and machine
  language programs. There are built-in hold-offs in the KERNAL, cassette,
  and serial bus routines to prevent the disruption of data storage or
  transmission by the NMIs that are generated by the RS-232 routines.
  During cassette or serial bus activities, data can NOT be received from
  RS-232 devices. But because these hold-offs are only local (assuming
  you're careful about your programming) no interference should result.
    There are two buffers in the Commodore 64 RS-232 interface to help
  prevent the loss of data when transmitting or receiving RS-232 informa-
  tion.
    The Commodore 64 RS-232 KERNAL buffers consist of two first-in/first-
  out (FIFO) buffers, each 256 bytes long, at the top of memory. The
  OPENing of an RS-232 channel automatically allocates 512 bytes of memory
  for these buffers. If there is not enough free space beyond the end of
  your BASIC program no error message will be printed, and the end of your
  program will be destroyed. SO BE CAREFUL!
    These buffers are automatically removed by using the CLOSE command."
What is the purpose and functionality of the MACHINE LANGUAGE MONITOR (64MON) program?,"MACHINE LANGUAGE MONITOR (64MON):

    This program allows you to enter a program in either HEX or SYMBOLIC
  codes, and save the portion of memory the program is in. Advantages of
  this method include easier entry of the machine language routines,
  debugging aids, and a much faster means of saving and loading. The
  drawback to this method is that it generally requires the BASIC program
  to load the machine language routine from tape or disk when it is
  started. (For more details on 64MON see the machine language section.)

  EXAMPLE:

    The following is an example of a BASIC program using a machine language
  routine prepared by 64MON. The routine is stored on tape:

    10 IF FLAG=L THEN 20
    15 FLAG=1:LOAD'MACHINE LANGUAGE ROUTINE NAME',1,1
    20
    .
    .
    REST OF BASIC PROGRAM"
What is the purpose of the SETTMO kernal routine?,"Function  Name: SETTMO

    Purpose: Set IEEE bus card timeout flag
    Call address: $FFA2 (hex) 65442 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: None

  NOTE: This routine is used ONLY with an IEEE add-on card!      
  
    Description: This routine sets the timeout flag for the IEEE bus. When
  the timeout flag is set, the Commodore 64 will wait for a device on the
  IEEE port for 64 milliseconds. If the device does not respond to the
  Commodore 64's Data Address Valid (DAV) signal within that time the
  Commodore 64 will recognize an error condition and leave the handshake
  sequence. When this routine is called when the accumulator contains a 0
  in bit 7, timeouts are enabled. A 1 in bit 7 will disable the timeouts.

NOTE: The Commodore 64 uses the timeout feature to communicate that a 
disk file is not found on an attempt to OPEN a file only with an IEEE card.                                                                 |
  
  How to Use:

  TO SET THE TIMEOUT FLAG
    1) Set bit 7 of the accumulator to 0.
    2) Call this routine.

  TO RESET THE TIMEOUT FLAG
    1) Set bit 7 of the accumulator to 1.
    2) Call this routine.

  EXAMPLE:

    ;DISABLE TIMEOUT
    LDA #0
    JSR SETTMO"
What are the details of the 6502 LDA instruction?,"LDA                  LDA Load accumulator with memory                 LDA


  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   LDA #Oper           |    A9   |    2    |    2     |
  |  Zero Page     |   LDA Oper            |    A5   |    2    |    3     |
  |  Zero Page,X   |   LDA Oper,X          |    B5   |    2    |    4     |
  |  Absolute      |   LDA Oper            |    AD   |    3    |    4     |
  |  Absolute,X    |   LDA Oper,X          |    BD   |    3    |    4*    |
  |  Absolute,Y    |   LDA Oper,Y          |    B9   |    3    |    4*    |
  |  (Indirect,X)  |   LDA (Oper,X)        |    A1   |    2    |    6     |
  |  (Indirect),Y  |   LDA (Oper),Y        |    B1   |    2    |    5*    |
  * Add 1 if page boundary is crossed."
What is the purpose of the SBC instruction in 6502?,"SBC          SBC Subtract memory from accumulator with borrow         SBC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   SBC #Oper           |    E9   |    2    |    2     |
  |  Zero Page     |   SBC Oper            |    E5   |    2    |    3     |
  |  Zero Page,X   |   SBC Oper,X          |    F5   |    2    |    4     |
  |  Absolute      |   SBC Oper            |    ED   |    3    |    4     |
  |  Absolute,X    |   SBC Oper,X          |    FD   |    3    |    4*    |
  |  Absolute,Y    |   SBC Oper,Y          |    F9   |    3    |    4*    |
  |  (Indirect,X)  |   SBC (Oper,X)        |    E1   |    2    |    6     |
  |  (Indirect),Y  |   SBC (Oper),Y        |    F1   |    2    |    5     |
  * Add 1 when page boundary is crossed."
"What is the harmonic structure of a triangular wave, and how does it relate to the fundamental frequency and the harmonic number?","UNDERSTANDING WAVEFORMS

    When a note is played, it consists of a sine wave oscillating at the
  fundamental frequency and the harmonics of that wave.
    The fundamental frequency defines the overall pitch of the note.
  Harmonics are sine waves having frequencies which are integer multiples
  of the fundamental frequency. A sound wave is the fundamental frequency
  and all of the harmonics it takes to make up that sound.

    In musical theory let's say that the fundamental frequency is harmonic
  number 1. The second harmonic has a frequency twice the fundamental
  frequency, the third harmonic is three times the fundamental frequency,
  and so on. The amounts of each harmonic present in a note give it its
  timbre.
    An acoustic instrument, like a guitar or a violin, has a very compli-
  cated harmonic structure. In fact, the harmonic structure may vary as a
   single note is played. You have already played with the waveforms
  available in your Commodore music synthesizer. Now let's talk about how
  the harmonics work with the triangular, sawtooth, and rectangular waves.
    A triangular wave contains only odd harmonics. The amount of each
  harmonic present is proportional to the reciprocal of the square of the
  harmonic number. In other words harmonic number 3 is 1/9 quieter than
  harmonic number 1, because the harmonic 3 squared is 9 (3 X 3) and the
  reciprocal of 9 is 1/9.
    As you can see, there is a similarity in shape of a triangular wave to
  a sine wave oscillating at the fundamental frequency.
    Sawtooth waves contain all the harmonics. The amount of each harmonic
  present is proportional to the reciprocal of the harmonic number. For
  example, harmonic number 2 is 1/2 as loud as harmonic number 1.
    The square wave contains odd harmonics in proportion to the reciprocal
  of the harmonic number. Other rectangular waves have varying harmonic
  content. By changing the pulse width, the timbre of the sound of a
  rectangular wave can be varied tremendously.

    By choosing carefully the waveform used, you can start with a harmonic
  structure that looks somewhat like the sound you want. To refine the
  sound, you can add another aspect of sound quality available on your
  Commodore 64 called filtering, which we'll discuss later in this section."
What is the primary component of the CPU that consists of eight flags?,"THE STATUS REGISTER

    This register consists of eight 'flags' (a flag = something that indi-
  cates whether something has, or has not occurred)."
HWhat is the purpose of the CHROUT routine in the KERNAL?,"B-5. Function Name: CHROUT

    Purpose: Output a character
    Call address: $FFD2 (hex) 65490 (decimal)
    Communication registers: A
    Preparatory routines: (CHKOUT,OPEN)
    Error returns: 0 (See READST)
    Stack requirements: 8+
    Registers affected: A

    Description: This routine outputs a character to an already opened
  channel. Use the KERNAL OPEN and CHKOUT routines to set up the output
  channel before calling this routine, If this call is omitted, data is
  sent to the default output device (number 3, the screen). The data byte
  to be output is loaded into the accumulator, and this routine is called.
  The data is then sent to the specified output device. The channel is left
  open after the call.

 
 NOTE: Care must be taken when using this routine to send data to a    
 specific serial device since data will be sent to all open output     
 channels on the bus. Unless this is desired, all open output channels 
 on the serial bus other than the intended destination channel must be 
 closed by a call to the KERNAL CLRCHN routine.                        

  How to Use:

    0) Use the CHKOUT KERNAL routine if needed, (see description above).
    1) Load the data to be output into the accumulator.
    2) Call this routine.

  EXAMPLE:

    ;DUPLICATE THE BASIC INSTRUCTION CMD 4,'A';
    LDX #4          ;LOGICAL FILE #4
    JSR CHKOUT      ;OPEN CHANNEL OUT
    LDA #'A
    JSR CHROUT      ;SEND CHARACTER"
What is the purpose of the PLOT kernal function?,"B-19. Function Name: PLOT

    Purpose: Set cursor location
    Call address: $FFF0 (hex) 65520 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: A call to this routine with the accumulator carry flag
  set loads the current position of the cursor on the screen (in X,Y
  coordinates) into the Y and X registers. Y is the column number of the
  cursor location (6-39), and X is the row number of the location of the
  cursor (0-24). A call with the carry bit clear moves the cursor to X,Y
  as determined by the Y and X registers.

  How to Use:


  READING CURSOR LOCATION

    1) Set the carry flag.
    2) Call this routine.
    3) Get the X and Y position from the Y and X registers, respectively.


  SETTING CURSOR LOCATION

    1) Clear carry flag.
    2) Set the Y and X registers to the desired cursor location.
    3) Call this routine.


  EXAMPLE:

    ;MOVE THE CURSOR TO ROW 10, COLUMN 5 (5,10)
    LDX #10
    LDY #5
    CLC
    JSR PLOT"
explain the vertical positionning of sprites,"VERTICAL POSITIONING

    Setting up positions in the horizontal direction is a little more
  difficult than vertical positioning, so we'll discuss vertical (Y)
  positioning first.
    There are 200 different dot positions that can be individually pro-
  grammed onto your TV screen in the Y direction. The sprite Y position
  registers can handle numbers up to 255. This means that you have more
  than enough register locations to handle moving a sprite up and down. You
  also want to be able to smoothly move a sprite on and off the screen.
  More than 200 values are needed for this.
    The first on-screen value from the top of the screen, and in the Y
  direction for an unexpanded sprite is 30. For a sprite expanded in the Y
  direction it would be 9. (Since each dot is twice as tall, this makes a
  certain amount of sense, as the initial position is STILL calculated from
  the top left corner of the sprite.)
    The first Y value in which a sprite (expanded or not) is fully on the
  screen (all 21 possible lines displayed) is 50.
    The last Y value in which an unexpanded sprite is fully on the screen
  is 229. The last Y value in which an expanded sprite is fully on the
  screen is 208.
    The first Y value in which a sprite is fully off the screen is 250."
What is the starting location of the VIC-II chip in the Commodore 64's memory?,"GRAPHICS LOCATIONS

    Some general information first. There are 1000 possible locations on
  the Commodore 64 screen. Normally, the screen starts at location 1024
  ($0400 in HEXadecimal notation) and goes to location 2023. Each of
  these locations is 8 bits wide. This means that it can hold any integer
  number from 0 to 255. Connected with screen memory is a group of 1000
  locations called COLOR MEMORY or COLOR RAM. These start at location 55296
  ($D800 in HEX) and go up to 56295. Each of the color RAM locations is 4
  bits wide, which means that it can hold any integer number from 0 to 15.
  Since there are 16 possible colors that the Commodore 64 can use, this
  works out well.
    In addition, there are 256 different characters that can be displayed
  at any time. For normal screen display, each of the 1000 locations in
  screen memory contains a code number which tells the VIC-II chip which
  character to display at that screen location.
    The various graphics modes are selected by the 47 CONTROL registers in
  the VIC-II chip. Many of the graphics functions can be controlled by
  POKEing the correct value into one of the registers. The VIC-II chip is
  located starting at 53248 ($D000 in HEX) through 53294 ($D02E in HEX)."
What are the key characteristics of the ADSR envelope generator in the SID chip?,"SID ENVELOPE GENERATORS

    The four-part ADSR (ATTACK, DECAY, SUSTAIN, RELEASE) envelope generator
  has been proven in electronic music to provide the optimum trade-off
  between flexibility and ease of amplitude control. Appropriate selection
  of envelope parameters allows the simulation of a wide range 2: of
  percussion and sustained instruments. The violin is a good example of a
  sustained instrument. The violinist controls the volume by bowing the
  instrument. Typically, the volume builds slowly, reaches a peak, then
  drops to an intermediate level. The violinist can maintain this level for
  as long as desired, then the volume is allowed to slowly die away.
    Note that the tone can be held at the intermediate SUSTAIN level for
  as long as desired. The tone will not begin to die away until GATE is
  cleared. With minor alterations, this basic envelope can be used for
  brass and woodwinds as well as strings.
    An entirely different form of envelope is produced by percussion in-
  struments such as drums, cymbals and gongs, as well as certain
  keyboards such as pianos and harpsichords. The percussion envelope is
  characterized by a nearly instantaneous attack, immediately followed by
  a decay to zero volume. Percussion instruments cannot be sustained at
  a constant amplitude. For example, the instant a drum is struck, the
  sound reaches full volume and decays rapidly regardless of how it was
  struck.

    Note that the tone immediately begins to decay to zero amplitude after
  the peak is reached, regardless of when GATE is cleared. The amplitude
  envelope of pianos and harpsichords is somewhat more complicated, but can
  be generated quite easily with the ADSR. These instruments reach full
  volume when a key is first struck. The amplitude immediately begins to
  die away slowly as long as the key remains depressed. If the key is
  released before the sound has fully died away, the amplitude will
  immediately drop to zero. 
    Note that the tone decays slowly until GATE is cleared, at which point
  the amplitude drops rapidly to zero.
    The most simple envelope is that of the organ, When a key is pressed,
  the tone immediately reaches full volume and remains there. When the key
  is released, the tone drops immediately to zero volume. 
    The real power of SID lies in the ability to create original sounds
  rather than simulations of acoustic instruments. The ADSR is capable of
  creating envelopes which do not correspond to any 'real' instruments. A
  good example would be the 'backwards' envelope. This envelope is
  characterized by a slow attack and rapid decay which sounds very much
  like an instrument that has been recorded on tape then played backwards.
 
    Many unique sounds can be created by applying the amplitude envelope of
  one instrument to the harmonic structure of another. This produces sounds
  similar to familiar acoustic instruments, yet notably different. In
  general, sound is quite subjective and experimentation with various
  envelope rates and harmonic contents will be necessary in order to
  achieve the desired sound."
Can you suggest colors good for TVs?,"SUGGESTED SCREEN AND CHARACTER COLOR COMBINATIONS

    Color TV sets are limited in their ability to place certain colors next
  to each other on the same line. Certain combinations of screen and char-
  acter colors produce blurred images. This chart shows which color com-
  binations to avoid, and which work especially well together.

 


  PROGRAMMING SPRITES - ANOTHER LOOK

    For those of you having trouble with graphics, this section has been
  designed as a more elementary tutorial approach to sprites."
What are the different graphics display modes supported by the Commodore 64's 6567 Video Interface Chip (VIC-II chip)?,"GRAPHICS OVERVIEW

  All of the graphics abilities of the Commodore 64 come from the 6567
  Video Interface Chip (also known as the VIC-II chip). This chip gives a
  variety of graphics modes, including a 40 column by 25 line text display,
  a 320 by 200 dot high resolution display, and SPRITES, small movable
  objects which make writing games simple. And if this weren't enough,
  many of the graphics modes can be mixed on the same screen. It is
  possible, for example, to define the top half of the screen to be in
  high resolution mode, while the bottom half is in text mode. And SPRITES
  will combine with anything! More on sprites later. First the other
  graphics modes.
   The VIC-II chip has the following graphics display modes:

  A) CHARACTER DISPLAY MODES

     1) Standard Character Mode
            a)ROM characters
            b)RAM programmable characters
     2) Multi-Color Character Mode
            a)ROM characters
            b)RAM programmable characters

     3) Extended Background Color Mode
            a)ROM characters
            b)RAM programmable characters


  B) BIT MAP MODES

     1) Standard Bit Map Mode
     2) Multi-Color Bit Map Mode


  C) SPRITES

     1) Standard Sprites
     2) Multi-Color Sprites"
What is the starting point for calculating the position of a sprite in a 24x21 dot area?,"The position of a sprite is calculated from the TOP LEFT corner of the
  24 dot by 21 dot area that your sprite can be designed in. It does NOT
  matter how many or how few dots you use to make up a sprite. Even if only
  one dot is used as a sprite, and you happen to want it in the middle of
  the screen, you must still calculate the exact positioning by starting at
  the top left corner location."
What is the purpose of the OPEN function in the KERNAL routines?,"B-18. Function Name: OPEN


    Purpose: Open a logical file
    Call address: $FFC0 (hex) 65472 (decimal)
    Communication registers: None
    Preparatory routines: SETLFS, SETNAM
    Error returns: 1,2,4,5,6,240, READST
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine is used to OPEN a logical file. Once the
  logical file is set up, it can be used for input/output operations. Most
  of the I/O KERNAL routines call on this routine to create the logical
  files to operate on. No arguments need to be set up to use this routine,
  but both the SETLFS and SETNAM KERNAL routines must be called before
  using this routine.


  How to Use:

    0) Use the SETLFS routine.
    1) Use the SETNAM routine.
    2) Call this routine."
What is the purpose of the CHRIN  kernal function?,"B-4. Function Name: CHRIN

    Purpose: Get a character from the input channel
    Call address: $FFCF (hex) 65487 (decimal)
    Communication registers: A
    Preparatory routines: (OPEN, CHKIN)
    Error returns: 0 (See READST)
    Stack requirements: 7+
    Registers affected: A, X

    Description: This routine gets a byte of data from a channel already
  set up as the input channel by the KERNAL routine CHKIN. If the CHKIN has
  NOT been used to define another input channel, then all your data is
  expected from the keyboard. The data byte is returned in the accumulator.
  The channel remains open after the call.
    Input from the keyboard is handled in a special way. First, the cursor
  is turned on, and blinks until a carriage return is typed on the
  keyboard. All characters on the line (up to 88 characters) are stored in
  the BASIC input buffer. These characters can be retrieved one at a time
  by calling this routine once for each character. When the carriage return
  is retrieved, the entire line has been processed. The next time this
  routine is called, the whole process begins again, i.e., by flashing the
  cursor.

  How to Use:

  FROM THE KEYBOARD

    1) Retrieve a byte of data by calling this routine.
    2) Store the data byte.
    3) Check if it is the last data byte (is it a CR?)
    4) If not, go to step 1.

  EXAMPLE:

       LDY $#00      ;PREPARE THE Y REGISTER TO STORE THE DATA
   RD  JSR CHRIN
       STA DATA,Y    ;STORE THE YTH DATA BYTE IN THE YTH
                     ;LOCATION IN THE DATA AREA.
       INY
       CMP #CR       ;IS IT A CARRIAGE RETURN?
       BNE RD        ;NO, GET ANOTHER DATA BYTE

  EXAMPLE:

    JSR CHRIN
    STA DATA

  FROM OTHER DEVICES

    0) Use the KERNAL OPEN and CHKIN routines.
    1) Call this routine (using a JSR instruction).
    2) Store the data.

  EXAMPLE:

    JSR CHRIN
    STA DATA"
What is the primary function of the program counter in a C64?,"THE PROGRAM COUNTER

    This contains the address of the current machine language instruction
  being executed. Since the operating system is always 'RUN'ning in the
  Commodore 64 (or, for that matter, any computer), the program counter is
  always changing. It could only be stopped by halting the microprocessor
  in some way."
Explain the sid envelop generator?,"SID: THE ENVELOPE GENERATOR

    The volume of a musical tone changes from the moment you first hear it,
  all the way through until it dies out and you can't hear it anymore. When
  a note is first struck, it rises from zero volume to its peak volume. The
  rate at which this happens is called the ATTACK. Then, it fails from the
  peak to some middle-ranged volume. The rate at which the fall of the note
  occurs is called the DECAY. The mid-ranged volume itself is called the
  SUSTAIN level. And finally, when the note stops playing, it fails from
  the SUSTAIN level to zero volume. The rate at which it fails is called
  the RELEASE. 


    Each of the items mentioned above give certain qualities and restric-
  tions to a note. The bounds are called parameters.
    The parameters ATTACK/DECAY/SUSTAIN/RELEASE and collectively called
  ADSR, can be controlled by your use of another set of locations in the
  sound generator chip. LOAD your first example program again. RUN it again
  and remember how it sounds."
What is the purpose of the SEC instruction in the 6502 microprocessor?,"SEC                        SEC Set carry flag                         SEC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   SEC                 |    38   |    1    |    2     |"
What is the purpose of the LDX 6502 instruction ?,"LDX                   LDX Load index X with memory                    LDX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   LDX #Oper           |    A2   |    2    |    2     |
  |  Zero Page     |   LDX Oper            |    A6   |    2    |    3     |
  |  Zero Page,Y   |   LDX Oper,Y          |    B6   |    2    |    4     |
  |  Absolute      |   LDX Oper            |    AE   |    3    |    4     |
  |  Absolute,Y    |   LDX Oper,Y          |    BE   |    3    |    4*    |
  * Add 1 when page boundary is crossed."
What is the purpose of the STOP kernal function in a computer system?,"Function Name: STOP

    Purpose: Check if <STOP> key is pressed
    Call address: $FFE1 (hex) 65505 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: None
    Stack requirements: None
    Registers affected: A, X

    Description: If the <STOP> key on the keyboard was pressed during a
  UDTIM call, this call returns the Z flag set. In addition, the channels
  will be reset to default values. All other flags remain unchanged. If the
  <STOP> key is not pressed then the accumulator will contain a byte
  representing the lost row of the keyboard scan. The user can also check
  for certain other keys this way.

  How to Use:
    0) UDTIM should be called before this routine.
    1) Call this routine.
    2) Test for the zero flag.

  EXAMPLE:

    JSR UDTIM   ;SCAN FOR STOP
    JSR STOP
    BNE *+5     ;KEY NOT DOWN
    JMP READY   ;=... STOP"
How do I open an RS-232 communication?,"OPENING AN RS-232 CHANNEL

    Only one RS-232 channel should be open at any time; a second OPEN
  statement will cause the buffer pointers to be reset. Any characters in
  either the transmit buffer or the receive buffer will be lost.
    Up to 4 characters can be sent in the filename field. The first two are
  the control and command register characters; the other two are reserved
  for future system options. Baud rate, parity, and other options can be
  selected through this feature.
    No error-checking is done on the control word to detect a non-
  implemented baud rate. Any illegal control word will cause the system
  output to operate at a very slow rate (below 50 baud).

  BASIC SYNTAX:

    OPEN lfn,2,0,'<control register><command register><opt baud low><opt
  baud high>'
    lfn-The logical file number (lfn) then can be any number from 1 through
  255. But be aware of the fact that if you choose a logical file number
  that is greater than 127, then a line feed will follow all carriage
  returns.
               
    <control register>- Is a single byte character (see Figure 6-1, Control
  Register Map) required to specify the baud rates. If the lower 4 bits of
  the baud rate is equal to zero (0), the <opt baud low><opt baud high>
  characters give you a rate based on the following:
    <opt baud low>=<system frequency/rate/2-100-<opt baud high>*256
    <opt baud high>=INT((system frequency/rate/2-100)/256

 
                    
  The formulas above are based on the fact that:

    system frequency = 1.02273E6 NTSC (North American TV standard)
                     = 0.98525E6 PAL (U.K. and most European TV standard)

    <command register>- Is a single byte character (see Figure 6-2, Command
  Register Map) that defines other terminal parameters. This character is
  NOT required.

  KERNAL ENTRY:

    OPEN ($FFC0) (See KERNAL specifications for more information on entry
  conditions and instructions.)


IMPORTANT NOTE: In a BASIC program, the RS-232 OPEN command should be
  | performed before creating any variables or arrays because an automatic|
  | CLR is performed when an RS-232 channel is OPENed (This is due to the |
  | allocation of 512 bytes at the top of memory.) Also remember that your|
  | program will be destroyed if 512 bytes of space are not available at  |
  | the time of the OPEN statement.                                       |"
What are the common methods to add machine language programs to a BASIC program?,"HOW TO ENTER MACHINE LANGUAGE

    There are 3 common methods to add the machine language programs to a
  BASIC program. They are:

  1-DATA STATEMENTS:

    By READing DATA statements, and POKEing the values into memory at the
  start of the program, machine language routines can be added. This is the
  easiest method. No special methods are needed to save the two parts of
  the program, and it is fairly easy to debug. The drawbacks include taking
  up more memory space, and the wait while the program is POKED in.
  Therefore, this method is better for smaller routines.

  EXAMPLE:

  10 RESTORE:FORX=1T09:READA:POKE12*4096+X,A:NEXT
  .
  BASIC PROGRAM
  .
  1000 DATA 161,1,204,204,204,204,204,204,96"
How can I handle the paddles?,"PADDLES

    A paddle is connected to both CIA #1 and the SID chip (MOS 6581 Sound
  Interface Device) through a game port. The paddle value is read via the
  SID registers 54297 ($D419) and 54298 ($D41A). PADDLES ARE NOT RELIABLE
  WHEN READ FROM BASIC ALONE!!!! The best way to use paddles, from BASIC or
  machine code, is to use the following machine language routine... (SYS to
  it from BASIC then PEEK the memory locations used by the subroutine).


                      ; four paddle read routine (can also be used for two)
                      ;
                      ; author - bill hindorff
                      ;
porta=$dc00
ciddra=$dc02
sid=$d400

*=$c100

buffer  *=*+1
pdlx    *=*+2
pdly    *=*+2
btna    *=*+1
btnb    *=*+1

* = $c000

pdlrd   ldx #1        ; for four paddles or two analog joysticks
pdlrd0                ; entry point for one pair (condition x 1st)
        sei
        lda ciddra    ; get current value of ddr
        sta buffer    ; save it away
        lda #$c0
        sta ciddra    ; set port a for input
        lda #$80
pdlrd1
        sta porta     ; address a pair of paddles
        ldy #$80      ; wait a while
pdlrd2
        nop
        dey
        bpl pdlrd2
        lda sid+25    ; get x value
        sta pdlx,x
        lda sid+26
        sta pdly,x    ; get y value
        lda porta     ; time to read paddle fire buttons
        ora #80       ; make it the same as other pair
        sta btna      ; bit 2 is pdl x, bit 3 is pdl y
        lda #$40
        dex           ; all pairs done?
        bpl pdlrd1    ; no
        lda buffer
        sta ciddra    ; restore previous value of ddr
        lda porta+1   ; for 2nd pair -
        sta btnb      ; bit 2 is pdl x, bit 3 is pdl y
        cli
        rts
.end"
WHow can I output to a Commodore printer?,"OUTPUT TO PRINTER

    The printer is an output device similar to the screen. Your main con-
  cern when sending output to the printer is to create a format that is
  easy on the eyes. Your tools here include reversed, double-width, capital
  and lower case letters, as well as dot-programmable graphics.
    The SPC function works for the printer in the same way it works for the
  screen. However, the TAB function does not work correctly on the printer,
  because it calculates the current position on the line based on the
  cursor's position on the screen, not on the paper.
    The OPEN statement for the printer creates the channel for communi-
  cation. It also specifies which character set will be used, either upper
  case with graphics or upper and lower case.

  EXAMPLES of OPEN Statement for Printer:

    OPEN 1,4: REM UPPER CASE/GRAPHICS
    OPEN 1,4,7: REM UPPER AND LOWER CASE

    When working with one character set, individual lines can be PRINTed
  in the opposite character set. When in upper case with graphics, the
  cursor down character (CHR$(17)) switches the characters to the upper
  and lower case set. When in upper and lower case, the cursor up char-
  acter (CHR$(145)) allows upper case and graphics characters to be
  PRINTed.
    Other special functions in the printer are controlled through character
  codes. All these codes are simply PRINTed just like any other character.

  TABLE of Printer Control Character Codes:

  | CHR$ CODE|                         PURPOSE                            |
  |    10    |   Line feed                                                |
  |    13    |   RETURN (automatic line feed on CBM printers)             |
  |    14    |   Begin double-width character mode                        |
  |    15    |   End double-width character mode                          |
  |    18    |   Begin reverse character mode                             |
  |   146    |   End reverse character mode                               |
  |    17    |   Switch to upper/lower case character set                 |
  |   145    |   Switch to upper case/graphics character set              |
  |    16    |   Tab to position in next 2 characters                     |
  |    27    |   Move to specified dot position                           |
  |     8    |   Begin dot-programmable graphic mode                      |
  |    26    |   Repeat graphics data                                     |
    See your Commodore printer's manual for details on using the command
  codes."
What is the register A on 6502 and 6510?,"THE REGISTERS INSIDE THE 6510 MICROPROCESSOR

  THE ACCUMULATOR

    This is THE most important register in the microprocessor. Various ma-
  chine language instructions allow you to copy the contents of a memory
  location into the accumulator, copy the contents of the accumulator into
  a memory location, modify the contents of the accumulator or some other
  register directly, without affecting any memory. And the accumulator is
  the only register that has instructions for performing math."
What are the details for the ORA 6502 instruction?,"ORA                 ORA 'OR' memory with accumulator                  ORA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   ORA #Oper           |    09   |    2    |    2     |
  |  Zero Page     |   ORA Oper            |    05   |    2    |    3     |
  |  Zero Page,X   |   ORA Oper,X          |    15   |    2    |    4     |
  |  Absolute      |   ORA Oper            |    0D   |    3    |    4     |
  |  Absolute,X    |   ORA Oper,X          |    10   |    3    |    4*    |
  |  Absolute,Y    |   ORA Oper,Y          |    19   |    3    |    4*    |
  |  (Indirect,X)  |   ORA (Oper,X)        |    01   |    2    |    6     |
  |  (Indirect),Y  |   ORA (Oper),Y        |    11   |    2    |    5     |
  * Add 1 on page crossing"
What is the purpose of the ROR instruction in 6502?,"ROR          ROR Rotate one bit right (memory or accumulator)         ROR

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Accumulator   |   ROR A               |    6A   |    1    |    2     |
  |  Zero Page     |   ROR Oper            |    66   |    2    |    5     |
  |  Zero Page,X   |   ROR Oper,X          |    76   |    2    |    6     |
  |  Absolute      |   ROR Oper            |    6E   |    3    |    6     |
  |  Absolute,X    |   ROR Oper,X          |    7E   |    3    |    7     |
    Note: ROR instruction is available on MCS650X microprocessors after
          June, 1976."
"What are the acceptable ranges for the X and Y coordinates for unexpanded sprites in the 40 column, 25 row mode?","SPRITE POSITIONING SUMMARY

    Unexpanded sprites are at least partially visible in the 40 column, by
  25 row mode within the following parameters:

1 < X < 343
30 < Y < 249

  In the 38 column mode, the X parameters change to she following:

 8 <= X <= 334

  In the 24 row mode, the Y parameters change to the following:

 34 <= Y <= 245

Expanded sprites are at least partially visible in the 40 column, by 25
  row mode within the following parameters:
  489 >= X <= 343
  9 >= Y <= 249

In the 38 column mode, the X parameters change to the following:
496 >= X <= 334

In the 24 row mode, the Y parameters change to the following:
13 <= Y <= 245"
What are the three program modules that make up the Operating System?,"THE OPERATING SYSTEM (OS)
    The Operating System is contained in the Read Only Memory (ROM) chips
  and is a combination of three separate, but interrelated, program
  modules.

    1) The BASIC Interpreter
    2) The KERNAL
    3) The Screen Editor

    1) The BASIC Interpreter is responsible for analysing BASIC statement
       syntax and for performing the required calculations and/or data
       manipulation. The BASIC Interpreter has a vocabulary of 65
       'keywords' which have special meanings. The upper and lower case
       alphabet and the digits 0-9 are used to make both keywords and
       variable names. Certain punctuation characters and special symbols
       also have meanings for the Interpreter. Table 1-1 lists the special
       characters and their uses.
    2) The KERNAL handles most of the interrupt level processing in the
       system (for details on interrupt level processing, see Chapter 5).
       The KERNAL also does the actual input and output of data.
    3) The Screen Editor controls the output to the video screen (tele-
       vision set) and the editing of BASIC program text. In addition, the
       Screen Editor intercepts keyboard input so that it can decide
       whether the characters put in should be acted upon immediately, or
       passed on to the BASIC Interpreter."
how do I control the screen blanking?,"SCREEN BLANKING

    Bit 4 of the VIC-II control register controls the screen blanking func-
  tion. It is found in the control register at location 53265 ($D011). When
  it is turned ON (in other words, set to a 1) the screen is normal. When
  bit 4 is set to 0 (turned OFF), the entire screen changes to border
  color.
    The following POKE blanks the screen. No data is lost, it just isn't
  displayed.

    POKE 53265,PEEK(53265)AND 239

  To bring back the screen. use the POKE shown below:

    POKE 53265,PEEK(53265)OR 16

  NOTE: Turning off the screen will speed up the processor slightly.
  This means that program RUNning is also sped up."
What is the purpose of the CLALL function?,"B-8. Function Name: CLALL

    Purpose: Close all files
    Call address: $FFE7 (hex) 65511 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: None
    Stack requirements: 11
    Registers affected: A, X

    Description: This routine closes all open files. When this routine is
  called, the pointers into the open file table are reset, closing all
  files. Also, the CLRCHN routine is automatically called to reset the I/O
  channels.

  How to Use:

    1) Call this routine.

  EXAMPLE:

    JSR CLALL   ;CLOSE ALL FILES AND SELECT DEFAULT I/O CHANNELS
    JMP RUN     ;BEGIN EXECUTION"
What is the purpose of the LISTEN function in a serial bus communication system?,"B-14. Function Name: LISTEN

    Purpose: Command a device on the serial bus to listen
    Call Address: $FFB1 (hex) 65457 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: None
    Registers affected: A

    Description: This routine will command a device on the serial bus to
  receive data. The accumulator must be loaded with a device number between
  0 and 31 before calling the routine. LISTEN will OR the number bit by bit
  to convert to a listen address, then transmits this data as a command on
  the serial bus. The specified device will then go into listen mode, and
  be ready to accept information.

  How to Use:
    1) Load the accumulator with the number of the device to command
       to LISTEN.
    2) Call this routine using the JSR instruction.

  EXAMPLE:
    ;COMMAND DEVICE #8 TO LISTEN
    LDA #8
    JSR LISTEN"
What is the purpose of the LOAD routine in the Commodore 64 KERNAL?,"B-15. Function Name: LOAD

    Purpose: Load RAM from device
    Call address: $FFD5 (hex) 65493 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: SETLFS, SETNAM
    Error returns: 0,4,5,8,9, READST
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine LOADs data bytes from any input device di-
  rectly into the memory of the Commodore 64. It can also be used for a
  verify operation, comparing data from a device with the data already in
  memory, while leaving the data stored in RAM unchanged.
    The accumulator (.A) must be set to 0 for a LOAD operation, or 1 for a
  verify, If the input device is OPENed with a secondary address (SA) of 0
  the header information from the device is ignored. In this case, the X
  and Y registers must contain the starting address for the load. If the
  device is addressed with a secondary address of 1, then the data is
  loaded into memory starting at the location specified by the header. This
  routine returns the address of the highest RAM location loaded.
    Before this routine can be called, the KERNAL SETLFS, and SETNAM
  routines must be called.


NOTE: You can NOT LOAD from the keyboard (0), RS-232 (2), or the screen (3).

  How to Use:

    0) Call the SETLFS, and SETNAM routines. If a relocated load is de-
       sired, use the SETLFS routine to send a secondary address of 0.
    1) Set the A register to 0 for load, 1 for verify.
    2) If a relocated load is desired, the X and Y registers must be set
       to the start address for the load.
    3) Call the routine using the JSR instruction."
What is the purpose of the CLOSE kernal function?,"B-9. Function Name: CLOSE

    Purpose: Close a logical file
    Call address: $FFC3 (hex) 65475 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: 0,240 (See READST)
    Stack requirements: 2+
    Registers affected: A, X, Y

    Description: This routine is used to close a logical file after all I/O
  operations have been completed on that file. This routine is called after
  the accumulator is loaded with the logical file number to be closed (the
  same number used when the file was opened using the OPEN routine).

 How to Use:

    1) Load the accumulator with the number of the logical file to be
       closed.
    2) Call this routine.

  EXAMPLE:

    ;CLOSE 15
    LDA #15
    JSR CLOSE"
What is the purpose of the raster register in the VIC-II chip?,"RASTER REGISTER

    The raster register is found in the VIC-II chip at location 53266
  ($D012). The raster register is a dual purpose register. When you read
  this register it returns the lower 8 bits of the current raster position.
  The raster position of the most significant bit is in register location
  53265 ($D011). You use the raster register to set up timing changes in
  your display so that you can get rid of screen flicker. The changes on
  your screen should be mode when the raster is not in the visible display
  area, which is when your dot positions fall between 51 and 251.
    When the raster register is written to (including the MSB) the number
  written to is saved for use with the raster compare function. When the
  actual raster value becomes the same as the number written to the raster
  register, a bit in the VIC-II chip interrupt register 53273 ($D019) is
  turned ON by setting it to 1.

   NOTE: If the proper interrupt bit is enabled (turned on), an interrupt
   (IRQ) will occur."
What determines the order in which sprites appear in a scene?,"SPRITE DISPLAY PRIORITIES

    Sprites have the ability to cross each other's paths, as well as cross
  in front of, or behind other objects on the screen. This can give you a
  truly three dimensional effect for games.
    Sprite to sprite priority is fixed. That means that sprite 0 has the
  highest priority, sprite 1 has the next priority, and so on, until we get
  to sprite 7, which has the lowest priority. In other words, if sprite 1
  and sprite 6 are positioned so that they cross each other, sprite 1 will
  be in front of sprite 6.
    So when you're planning which sprites will appear to be in the fore-
  ground of the picture, they must be assigned lower sprite numbers than
  those sprites you want to put towards the back of the scene. Those
  sprites will be given higher sprite numbers,

NOTE: A 'window' effect is possible. If a sprite with higher priority 
has 'holes' in it (areas where the dots are not set to 1 and thus     
turned ON), the sprite with the lower priority will show through. This
also happens with sprite and background data."
What is the purpose of the ROL instruction in 6502 assembly language?,"ROL          ROL Rotate one bit left (memory or accumulator)          ROL

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Accumulator   |   ROL A               |    2A   |    1    |    2     |
  |  Zero Page     |   ROL Oper            |    26   |    2    |    5     |
  |  Zero Page,X   |   ROL Oper,X          |    36   |    2    |    6     |
  |  Absolute      |   ROL Oper            |    2E   |    3    |    6     |
  |  Absolute,X    |   ROL Oper,X          |    3E   |    3    |    7     |"
What is the instruction that performs no operation and has an opcode?,"NOP                         NOP No operation                          NOP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   NOP                 |    EA   |    1    |    2     |"
Give a rapide overview of the memory map of the Commodore 64?,"SIMPLE MEMORY MAP OF THE COMMODORE 64


  ADDRESS                       DESCRIPTION                       
                                                                   
   0 & 1   -6510 Registers.                                                                                                    
    2      -Start of memory.                                       
    2-1023 -Memory used by the operating system.                   
 1024-2039 -Screen memory.                                         
 2040-2047 -SPRITE pointers.                                       
 2048-40959-This is YOUR memory. This is where your BASIC or machine language programs, or both, are stored.        
40960-49151-8K CBM BASIC Interpreter.                              
49152-53247-Special programs RAM area.                             
53248-53294-VIC-II.                                                
54272-55295-SID Registers.                                         
55296-56296-Color RAM.                                             
56320-57343-I/O Registers. (6526's)                                                                                                   
57344-65535-8K CBM KERNAL Operating System."
What information about the SID chip's parameters can be changed dynamically during a note or sound to create many interesting and fun effects?,"SOUND  ADVANCED TECHNIQUES

    The SID chip's parameters can be changed dynamically during a note or
  sound to create many interesting and fun effects. In order to make this
  easy to do, digitized outputs from oscillator three and envelope
  generator three are available for you in registers 27 and 28, respec-
  tively.
    The output of oscillator 3 (register 27) is directly related to the
  waveform selected. If you choose the sawtooth waveform of oscillator 3,
  this register will present a series of numbers incremented (increased
  step by step) from 0 to 255 at a rate determined by the frequency of
  oscillator 3. If you choose the triangle waveform, the output will incre-
  ment from 0 up to 255, then decrement (decrease step by step) back down
  to 0. If you choose the pulse wave, the output will jump back-and-forth
  between 0 and 255. Finally, choosing the noise waveform will give you a
  series of random numbers. When oscillator 3 is used for modulation, you
  usually do NOT want to hear its output. Setting bit 7 of register 24
  turns the audio output of voice 3 off. Register 27 always reflects the
  changing output of the oscillator and is not affected in any way by the
  envelope (ADSR) generator.
    Register 25 gives you access to the output of the envelope generator
  of oscillator 3. It functions in much the same fashion that the output of
  oscillator 3 does. The oscillator must be turned on to produce any output
  from this register.
    Vibrato (a rapid variation in frequency) can be achieved by adding the
  output of oscillator 3 to the frequency of another oscillator. Example
  Program 6 illustrates this idea."
What is the format of the OPEN statement parameters?,"TABLE of OPEN Statement Parameters:

    FORMAT: OPEN file#, device#, number, string


  | DEVICE | DEVICE# |       NUMBER        |            STRING            |
  |CASSETTE|    1    | 0 = Input           | File Name                    |
  |        |         | 1 = Output          |                              |
  |        |         | 2 = Output with EOT |                              |
  | MODEM  |    2    | 0                   | Control Registers            |
  | SCREEN |    3    | 0,1                 |                              |
  | PRINTER|  4 or 5 | 0 = Upper/Graphics  | Text Is PRINTed              |
  |        |         | 7 = Upper/Lower Case|                              |
  | DISK   | 8 to 11 | 2-14 = Data Channel | Drive #, File Name           |
  |        |         |                     | File Type, Read/Write        |
  |        |         | 15 = Command        | Command                      |
  |        |         |      Channel        |                              |"
How can I read the value of the joystick?,"A small machine code routine to read the joystick:


                      ; joystick - button read routine
                      ;
                      ; author - bill hindorff
                      ;
dx = $c110
dy = $c111

* = $c200

djrr    lda $dc00     ; get input from port a only
djrrb   ldy #0        ; this routine reads and decodes the
        ldx #0        ; joystick/firebutton input data in
        lsr a         ; the accumulator. this least significant
        bcs djr0      ; 5 bits contain the switch closure
        dey           ; information. if a switch is closed then it
djr0    lsr a         ; produces a zero bit. if a switch is open then
        bcs djr1      ; it produces a one bit. The joystick dir-
        iny           ; ections are right, left, forward, backward
djr1    lsr a         ; bit3=right, bit2=left, bit1=backward,
        bcs djr2      ; bit0=forward and bit4=fire button.
        dex           ; at rts time dx and dy contain 2's compliment
djr2    lsr a         ; direction numbers i.e. $ff=-1, $00=0, $01=1.
        bcs djr3      ; dx=1 (move right), dx=-1 (move left),
        inx           ; dx=0 (no x change). dy=-1 (move up screen),
djr3    lsr a         ; dy=0 (move down screen), dy=0 (no y change).
        stx dx        ; the forward joystick position corresponds
        sty dy        ; to move up the screen and the backward
        rts           ; position to move down screen.
                      ;
                      ; at rts time the carry flag contains the fire
                      ; button state. if c=1 then button not pressed.
                      ; if c=0 then pressed.
.end"
What is the recommended location for machine language routines on the Commodore 64?,"WHERE TO PUT MACHINE LANGUAGE ROUTINES

    The best place for machine language routines on the Commodore 64 is
  from $C000-$CFFF, assuming the routines are smaller than 4K bytes long.
  This section of memory is not disturbed by BASIC.
    If for some reason it's not possible or desirable to put the machine
  language routine at $C000, for instance if the routine is larger than 4K
  bytes, it then becomes necessary to reserve an area at the top of memory
  from BASIC for the routine. The top of memory is normally $9FFF. The top
  of memory can be changed through the KERNAL routine MEMTOP, or by the
  following BASIC statements:

    10 POKE51,L:POKE52,H:POKE55,1:POKE56,H:CLR

  Where H and L are the high and low portions, respectively, of the new
  top of memory. For example, to reserve the area from $9000 to $9FFF for
  machine language, use the following:

    10 POKE5110:POKE52,144:POKE5510:POKE56,144:CLR"
how can I send data to a modem?,"OUTPUT TO MODEM

    The modem is a simple device that can translate character codes into
  audio pulses and vice-versa, so that computers can communicate over
  telephone lines. The OPEN statement for the modem sets up the parameters
  to match the speed and format of the other computer you are communicating
  with. Two characters can be sent in the string at the end
  of the OPEN statement.
    The bit positions of the first character code determine the baud rate,
  number of data bits, and number of stop bits. The second code is op-
  tional, and its bits specify the parity and duplex of the transmission.
  See the RS-232 section or your VICMODEM manual for specific details on
  this device.

  EXAMPLE of OPEN Statement for Modem:

    OPEN 1,2,0,CHR$(6): REM 300 BAUD
    100 OPEN 2,2,0,CHR$(163) CHR$(112): REM 110 BAUD, ETC.

    Most computers use the American Standard Code for Information In-
  terchange, known as ASCII (pronounced ASK-KEY). This standard set of
  character codes is somewhat different from the codes used in the Com-
  modore 64. When communicating with other computers, the Commodore
  character codes must be translated into their ASCII counterparts. A table
  of standard ASCII codes is included in this book in Appendix C.
    Output to the modem is a fairly uncomplicated task, aside from the need
  for character translation. However, you must know the receiving device
  fairly well, especially when writing programs where your computer 'talks'
  to another computer without human intervention. An example of this would
  be a terminal program that automatically types in your account number and
  secret password. To do this successfully, you must carefully count the
  number of characters and RETURN characters. Otherwise, the computer
  receiving the characters won't know what to do with them."
What is the primary purpose of the X index register in a C64?,"THE X INDEX REGISTER

    This is a very important register. There are instructions for nearly
  all of the transformations you can make to the accumulator. But there are
  other instructions for things that only the X register can do. Various
  machine language instructions allow you to copy the contents of a memory
  location into the X register, copy the contents of the X register into a
  memory location, and modify the contents of the X, or some other register
  directly."
What is the purpose of the CHKIN routine in the KERNAL?,"B-2. Function Name: CHKIN

    Purpose: Open a channel for input
    Call address: $FFC6 (hex) 65478 (decimal)
    Communication registers: X
    Preparatory routines: (OPEN)
    Error returns:
    Stack requirements: None
    Registers affected: A, X


    Description: Any logical file that has already been opened by the
  KERNAL OPEN routine can be defined as an input channel by this routine.
  Naturally, the device on the channel must be an input device. Otherwise
  an error will occur, and the routine will abort.
    If you are getting data from anywhere other than the keyboard, this
  routine must be called before using either the CHRIN or the GETIN KERNAL
  routines for data input. If you want to use the input from the keyboard,
  and no other input channels are opened, then the calls to this routine,
  and to the OPEN routine are not needed.
    When this routine is used with a device on the serial bus, it auto-
  matically sends the talk address (and the secondary address if one was
  specified by the OPEN routine) over the bus.

  How to Use:

    0) OPEN the logical file (if necessary; see description above).
    1) Load the X register with number of the logical file to be used.
    2) Call this routine (using a JSR command).


  Possible errors are:

    #3: File not open
    #5: Device not present
    #6: File not an input file

  EXAMPLE:

    ;PREPARE FOR INPUT FROM LOGICAL FILE 2
    LDX #2
    JSR CHKIN"
What is the native language of the Commodore 64?,"WHAT IS MACHINE LANGUAGE?

    At the heart of every microcomputer, is a central microprocessor. It's
  a very special microchip which is the 'brain' of the computer. The
  Commodore 64 is no exception. Every microprocessor understands its own
  language of instructions. These instructions are called machine language
  instructions. To put it more precisely, machine language is the ONLY
  programming language that your Commodore 64 understands. It is the NATIVE
  language of the machine.
    If machine language is the only language that the Commodore 64
  understands, then how does it understand the CBM BASIC programming
  language? CBM BASIC is NOT the machine language of the Commodore 64.
  What, then, makes the Commodore 64 understand CBM BASIC instructions like
  PRINT and GOTO?
    To answer this question, you must first see what happens inside your
  Commodore 64. Apart from the microprocessor which is the brain of the
  Commodore 64, there is a machine language program which is stored in a
  special type of memory so that it can't be changed. And, more impor-
  tantly, it does not disappear when the Commodore 64 is turned off, unlike
  a program that you may have written. This machine language program is
  called the OPERATING SYSTEM of the Commodore 64. Your Commodore 64 knows
  what to do when it's turned on because its OPERATING SYSTEM (program) is
  automatically 'RUN.'"
What is the instruction that pulls the accumulator from the stack in 6502?,"PLA                 PLA Pull accumulator from stack                   PLA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PLA                 |    68   |    1    |    4     |"
What are the details fot the LDY instruction in the 6502 assembly language?,"LDY                   LDY Load index Y with memory                    LDY
                                                        N Z C I D V
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   LDY #Oper           |    A0   |    2    |    2     |
  |  Zero Page     |   LDY Oper            |    A4   |    2    |    3     |
  |  Zero Page,X   |   LDY Oper,X          |    B4   |    2    |    4     |
  |  Absolute      |   LDY Oper            |    AC   |    3    |    4     |
  |  Absolute,X    |   LDY Oper,X          |    BC   |    3    |    4*    |
  * Add 1 when page boundary is crossed."
What is stored in the VIC-II chip control register at location $D01F in HEX that indicates sprite to data collisions?,"SPRITE TO DATA COLLISIONS

    Sprite to data collisions are detected in the sprite to data collision
  register at location 53279 ($D01F in HEX) of the VIC-II chip control
  register.
    Each sprite has a bit in this register. If that bit is a 1 , then that
  sprite is involved in a collision. The bits in this register remain set
  until read (PEEKed). Once read, the register is automatically cleared, so
  it is a good idea to save the value in a variable until you are finished
  with it.

   NOTE: MULTI-COLOR data 01 is considered transparent for collisions,   
   even though it shows up on the screen. When setting up a background   
   screen, it is a good idea to make everything that should not cause a  
   collision 01 in multi-color mode."
"What are the two character sets available on the Commodore 64, and how can you switch between them?","The Commodore 64 has two complete character sets that you can use
  either from the keyboard or in your programs.
    In SET 1, the upper case alphabet and the numbers 0-9 are available
  without pressing the <SHIFT> key. If you hold down the <SHIFT> key
  while typing, the graphics characters on the RIGHT side of the front of
  the keys are used. If you hold down the <C=> key while typing, the
  graphics characters on the LEFT side of the front of the key are used.
  Holding down the <SHIFT> key while typing any character that doesn't
  have graphic symbols on the front of the key gives you the symbol on the
  top most part of the key.
    In SET 2, the lower case alphabet and the numbers 0-9 are available
  without pressing the <SHIFT> key. The upper case alphabet is available
  when you hold down the <SHIFT> key while typing. Again, the graphic
  symbols on the LEFT side of the front of the keys are displayed by press-
  ing the <C=> key, while the symbols on the top most part of any key
  without graphics characters are selected when you hold down the <SHIFT>
  key while typing.
    To switch from one character set to the other press the <C=> and
  the <SHIFT> keys together."
What is the purpose and functionality of the MEMTOP routine in kernal?,"B-17. Function Name: MEMTOP

    Purpose: Set the top of RAM
    Call address: $FF99 (hex) 65433 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: X, Y

    Description: This routine is used to set the top of RAM. When this
  routine is called with the carry bit of the accumulator set, the pointer
  to the top of RAM will be loaded into the X and Y registers. When this
  routine is called with the accumulator carry bit clear, the contents of
  the X and Y registers are loaded in the top of memory pointer, changing
  the top of memory.

  EXAMPLE:
    ;DEALLOCATE THE RS-232 BUFFER
    SEC
    JSR MEMTOP   ;READ TOP OF MEMORY
    DEX
    CLC
    JSR MEMTOP   ;SET NEW TOP OF MEMORY"
what is the purpose of the GETIN subroutine in kernal?,"B-11. Function Name: GETIN


    Purpose: Get a character
    Call address: $FFE4 (hex) 65508 (decimal)
    Communication registers: A
    Preparatory routines: CHKIN, OPEN
    Error returns: See READST
    Stack requirements: 7+
    Registers affected: A (X, Y)

    Description: If the channel is the keyboard, this subroutine removes
  one character from the keyboard queue and returns it as an ASCII value in
  the accumulator. If the queue is empty, the value returned in the
  accumulator will be zero. Characters are put into the queue automatically
  by an interrupt driven keyboard scan routine which calls the SCNKEY
  routine. The keyboard buffer can hold up to ten characters. After the
  buffer is filled, additional characters are ignored until at least one
  character has been removed from the queue. If the channel is RS-232, then
  only the A register is used and a single character is returned. See
  READST to check validity. If the channel is serial, cassette, or screen,
  call BASIN routine.


  How to Use:

    1) Call this routine using a JSR instruction.
    2) Check for a zero in the accumulator (empty buffer).
    3) Process the data.


  EXAMPLE:

         ;WAIT FOR A CHARACTER
    WAIT JSR GETIN
         CMP #0
         BEQ WAIT"
What is the purpose of the CLRCHN kernal routine?,"B-10. Function Name: CLRCHN

    Purpose: Clear I/O channels
    Call address: $FFCC (hex) 65484 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns:
    Stack requirements: 9
    Registers affected: A, X

    Description: This routine is called to clear all open channels and re-
  store the I/O channels to their original default values. It is usually
  called after opening other I/O channels (like a tape or disk drive) and
  using them for input/output operations. The default input device is 0
  (keyboard). The default output device is 3 (the Commodore 64 screen).
    If one of the channels to be closed is to the serial port, an UNTALK
  signal is sent first to clear the input channel or an UNLISTEN is sent to
  clear the output channel. By not calling this routine (and leaving lis-
  tener(s) active on the serial bus) several devices can receive the same
  data from the Commodore 64 at the same time. One way to take advantage
  of this would be to command the printer to TALK and the disk to LISTEN.
  This would allow direct printing of a disk file.
    This routine is automatically called when the KERNAL CLALL routine is
  executed.

  How to Use:
    1) Call this routine using the JSR instruction.

  EXAMPLE:
    JSR CLRCHN"
What is the purpose of the MEMBOT routine?,"B-16. Function Name: MEMBOT

    Purpose: Set bottom of memory
    Call address: $FF9C (hex) 65436 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: None
    Registers affected: X, Y

    Description: This routine is used to set the bottom of the memory. If
  the accumulator carry bit is set when this routine is called, a pointer
  to the lowest byte of RAM is returned in the X and Y registers. On the
  unexpanded Commodore 64 the initial value of this pointer is $0800
  (2048 in decimal). If the accumulator carry bit is clear (-O) when this
  routine is called, the values of the X and Y registers are transferred to
  the low and high bytes, respectively, of the pointer to the beginning of
  RAM.

  How to Use:
  TO READ THE BOTTOM OF RAM
    1) Set the carry.
    2) Call this routine.

  TO SET THE BOTTOM OF MEMORY
    1) Clear the carry.
    2) Call this routine.

  EXAMPLE:

    ;MOVE BOTTOM OF MEMORY UP 1 PAGE
    SEC         ;READ MEMORY BOTTOM
    JSR MEMBOT
    INY
    CLC         ;SET MEMORY BOTTOM TO NEW VALUE
    JSR MEMBOT"
What are the key considerations and limitations when positioning sprites horizontally in a graphics system?,"HORIZONTAL POSITIONING

    Positioning in the horizontal direction is more complicated because
  there are more than, 256 positions. This means that an extra bit, or 9th
  bit is used to control the X position. By adding the extra bit when
  necessary a sprite now has 512 possible positions in the left/right, X,
  direction. This makes more possible combinations than can be seen on the
  visible part of the screen. Each sprite can have a position from 0 to
  511. However, only those values between 24 and 343 are visible on the
  screen. If the X position of a sprite is greater than 255 (on the right
  side of the screen), the bit in the X MOST SIGNIFICANT BIT POSITION

  register must be set to a 1 (turned ON). If the X position of a sprite is
  less than 256 (on the left side of the screen), then the X MSB of that
  sprite must be 0 (turned OFF). Bits 0 to 7 of the X MSB register
  correspond to sprites 0 to 7, respectively."
how sprite to sprite collision works?,"SPRITE TO SPRITE COLLISIONS

    Sprite to sprite collisions are recognized by the computer, or flagged,
  in the sprite to sprite collision register at location 53278 ($D01E in
  HEX) in the VIC-II chip control register. Each sprite has a bit in this
  register. If that bit is a 1, then that sprite is involved in a
  collision. The bits in this register will remain set until read (PEEKed).
  Once read, the register is automatically cleared, so it is a good idea to
  save the value in a variable until you are finished with it.
  
   NOTE: Collisions can take place even when the sprites are off screen."
What are the two modes of BASIC operation provided by the Operating System?,"The Operating System gives you two modes of BASIC operation:
    1) DIRECT Mode
    2) PROGRAM Mode

    1) When you're using the DIRECT mode, BASIC statements don't have
       line numbers in front of the statement. They are executed whenever
       the <RETURN> key is pressed.
    2) The PROGRAM mode is the one you use for running programs.
       When using the PROGRAM mode, all of your BASIC statements must have
       line numbers in front of them. You can have more than one BASIC
       statement in a line of your program, but the number of statements is
       limited by the fact that you can only put 80 characters on a logical
       screen line. This means that if you are going to go over the 80
       character limit you have to put the entire BASIC statement that
       doesn't fit on a new line with a new line number.
         Always type NEW and hit <RETURN> before starting a new program."
What is the purpose of the LSR instruction in 6502?,"LSR          LSR Shift right one bit (memory or accumulator)          LSR

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Accumulator   |   LSR A               |    4A   |    1    |    2     |
  |  Zero Page     |   LSR Oper            |    46   |    2    |    5     |
  |  Zero Page,X   |   LSR Oper,X          |    56   |    2    |    6     |
  |  Absolute      |   LSR Oper            |    4E   |    3    |    6     |
  |  Absolute,X    |   LSR Oper,X          |    5E   |    3    |    7     |"
"What is the purpose of the instruction PLP"" in 6502?""","PLP               PLP Pull processor status from stack                PLA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PLP                 |    28   |    1    |    4     |"
What is the purpose of the CHKOUT  kernal routine?,"B-3. Function Name: CHKOUT

    Purpose: Open a channel for output
    Call address: $FFC9 (hex) 65481 (decimal)
    Communication registers: X
    Preparatory routines: (OPEN)
    Error returns: 0,3,5,7 (See READST)
    Stack requirements: 4+
    Registers affected: A, X

    Description: Any logical file number that has been created by the
  KERNAL routine OPEN can be defined as an output channel. Of course, the
  device you intend opening a channel to must be an output device.
  Otherwise an error will occur, and the routine will be aborted.
    This routine must be called before any data is sent to any output
  device unless you want to use the Commodore 64 screen as your output
  device. If screen output is desired, and there are no other output chan-
  nels already defined, then calls to this routine, and to the OPEN routine
  are not needed.
    When used to open a channel to a device on the serial bus, this routine
  will automatically send the LISTEN address specified by the OPEN routine
  (and a secondary address if there was one).

  How to Use:

REMEMBER: this routine is NOT NEEDED to send data to the screen.
    0) Use the KERNAL OPEN routine to specify a logical file number, a
       LISTEN address, and a secondary address (if needed).
    1) Load the X register with the logical file number used in the open
       statement.
    2) Call this routine (by using the JSR instruction).

  EXAMPLE:

    LDX #3        ;DEFINE LOGICAL FILE 3 AS AN OUTPUT CHANNEL
    JSR CHKOUT

    Possible errors are:
    #3: File not open
    #5: Device not present
    #7: Not an output file"
What is the primary function of the OPERATING SYSTEM in a Commodore 64 computer?,"The C64 OPERATING SYSTEM is in charge of 'organizing' all the memory in
  your machine for various tasks. It also looks at what characters you type
  on the keyboard and puts them onto the screen, plus a whole number of
  other functions. The OPERATING SYSTEM can be thought of as the
  'intelligence and personality' of the Commodore 64 (or any computer for
  that matter). So when you turn on your Commodore 64, the OPERATING SYSTEM
  takes control of your machine, and after it has done its housework, it
  then says:

    READY."
What is the primary purpose of the Y index register in a C64?,"THE Y INDEX REGISTER

    This is a very important register. There are instructions for nearly
  all of the transformations you can make to the accumulator, and the X
  register. But there are other instructions for things that only the Y
  register can do. Various machine language instructions allow you to copy
  the contents of a memory location into the Y register, copy the contents
  of the Y register into a memory location, and modify the contents of the
  Y, or some other register directly."
describe how the ligth pen works,"LIGHT PEN

    The light pen input latches the current screen position into a pair of
  registers (LPX, LPY) on a low-going edge. The X position register 19
  ($13) will contain the 8 MSB of the X position at the time of transition.
  Since the X position is defined by a 512-state counter (9 bits),
  resolution to 2 horizontal dots is provided. Similarly, the Y position is
  latched in its register 20 ($14), but here 8 bits provide single raster
  resolution within the visible display. The light pen latch may be
  triggered only once per frame, and subsequent triggers within the same
  frame will have no effect. Therefore, you must take several samples
  before turning the pen to the screen (3 or more samples average),
  depending upon the characteristics of your light pen."
What are some key considerations when working with cassette tapes for data storage?,"WORKING WITH CASSETTE TAPE

    Cassette tapes have an almost unlimited capacity for data. The longer
  the tape, the more information it can store. However, tapes are limited
  in time. The more data on the tape, the longer the time it takes to find
  the information.
    The programmer must try to minimize the time factor when working with
  tape storage. One common practice is to read the entire cassette data
  file into RAM, then process it, and then re-write all the data on the
  tape. This allows you to sort, edit, and examine your data. However, this
  limits the size of your files to the amount of available RAM.
    If your data file is larger than the available RAM, it is probably time
  to switch to using the floppy disk. The disk can read data at any
  position on the disk, without needing to read through all the other data.
  You can write data over old data without disturbing the rest of the file.
  That's why the disk is used for all business applications like ledgers
  and mailing lists.
    The PRINT# statement formats data just like the PRINT statement does.
  All punctuation works the same. But remember, you're not working with the
  screen now. The formatting must be done with the INPUT# statement
  constantly in mind.

    Consider the statement PRINT# 1, A$, B$, C$. When used with the screen,
  the commas between the variables provide enough blank space between items
  to format them into columns ten characters wide. On cassette, anywhere
  from 1 to 10 spaces will be added, depending on th length of the strings.
  This wastes space on your tape.
    Even worse is what happens when the INPUT# statement tries to read
  these strings. The statement INPUT# 1, A$, B$, C$ will discover no data
  for B$ and C$. A$ will contain all three variables, plus the spaces be-
  tween them. What happens? Here's a look at the tape file:

    A$='DOG' B$='CAT' C$='TREE'
    PRINT# 1, A$, B$, C$

    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
    D O G                 C  A  T                       T  R  E  E  RETURN

    The INPUT# statement works like the regular INPUT statement. When
  typing data into the INPUT statement, the data items are separated,
  either by hitting the <RETURN> key or using commas to separate them. The
  PRINT# statement puts a RETURN at the end of a line just like the PRINT
  statement. A$ fills up with all three values because there's no separator
  on the tape between them, only after all three.
    A proper separator would be a comma (,) or a RETURN on the tape. The
  RETURN code is automatically put at the end of a PRINT or PRINT#
  statement. One way to put the RETURN code between each item is to us only
  one item per PRINT# statement. A better way is to set a variable to the
  RETURN CHR$ code, which is CHR$(13), or use a comma. The statement for
  this is R$=',':PRINT#1, A$ R$ B$ R$ C$. Don't use commas or any other
  punctuation between the variable names, since the Commodore 64 can tell
  them apart and they'll only use up space in your program.
    A proper tape file looks like this:

    1 2 3 4 5 6 7 8 9 10 11 12 13

    D O G , C A T , T  R  E  E  RETURN

    The GET# statement will pick data from the tape one character at a
  time. It will receive each character, including the RETURN code and other
  punctuation. The CHR$(0) code is received as an empty string, not as a
  one character string with a code of 0. If you try to use the ASC function
  on an empty string, you get the error message ILLEGAL QUANTITY ERROR.

    The line GET# 1, A$: A= ASC(A$) is commonly used in programs to examine
  tape data. To avoid error messages, the line should be modified to
  GET#1, A$: A=ASC(A$+CHR$(0)). The CHR$(0) at the end acts as insurance
  against empty strings, but doesn't affect the ASC function when there are
  other characters in A$."
What are the zero-page memory locations used for in the RS-232 system interface?,"ZERO-PAGE MEMORY LOCATIONS AND USAGE FOR
  RS-232 SYSTEM INTERFACE

    $00A7-INBIT-Receiver input bit temp storage.
    $00A8-BITCI-Receiver bit count in.
    $00A9-RINONE-Receiver flag Start bit check.
    $00AA-RIDATA-Receiver byte buffer/assembly location.
    $00AB-RIPRTY-Receiver parity bit storage.
    $00B4-BITTS-Transmitter bit count out.
    $00B5-NXTBIT-Transmitter next bit to be sent.
    $00B6-RODATA-Transmitter byte buffer/disassembly location.


    All the above zero-page locations are used locally and are only given
  as a guide to understand the associated routines. These cannot be used
  directly by the BASIC or KERNAL level programmer to do RS-232 type
  things. The system RS-232 routines must be used."
What are the values that can be POKE'd into a color memory location to change a character's color?,"The actual values to POKE into a color memory location to change a
  character's color are:

             0  BLACK   4  PURPLE     8  ORANGE     12  GRAY 2
             1  WHITE   5  GREEN      9  BROWN      13  Light GREEN
             2  RED     6  BLUE      10  Light RED  14  Light BLUE
             3  CYAN    7  YELLOW    11  GRAY 1     15  GRAY 3

    For example, to change the color of a character located at the upper
  left-hand corner of the screen to red, type: POKE 55296,2."
Describe the multi-color character mode?,"MULTI-COLOR CHARACTER MODE (MCM = 1, BMM = ECM = 0 )

    Multi-color mode provides additional color flexibility allowing up to
  four colors within each character but with reduced resolution. The multi-
  color mode is selected by setting the MCM bit in register 22 ($16) to
  '1,' which causes the dot data stored in the character base to be
  interpreted in a different manner. If the MSB of the color nybble is a
  '0,' the character will be displayed as described in standard character
  mode, allowing the two modes to be inter-mixed (however, only the lower
  order 8 colors are available). When the MSB of the color nybble is a '1'
  (if MCM:MSB(CM) = 1) the character bits are interpreted in the multi-
  color mode:

                | CHARACTER  |
     FUNCTION   |  BIT PAIR  |               COLOR DISPLAYED
  --------------+------------+---------------------------------------------
    Background  |     00     |  Background #0 Color
                |            |  (register 33 ($21))
    Background  |     01     |  Background #1 Color
                |            |  (register 34 ($22)
    Foreground  |     10     |  Background #2 Color
                |            |  (register 35 ($23)
    Foreground  |     11     |  Color specified by 3 LSB
                |            |  of color nybble

  Since two bits are required to specify one dot color, the character is
  now displayed as a 4*8 matrix with each dot twice the horizontal size as
  in standard mode. Note, however, that each character region can now
  contain 4 different colors, two as foreground and two as background (see
  sprite priority)."
can to blank the screen?,"SCREEN BLANKING

    The display screen may be blanked by setting the DEN bit in register
  17 ($11) to a '0'. When the screen is blanked, the entire screen will be
  filled with the exterior color as set in register 32 ($20). When blanking
  is active, only transparent (Phase 1) memory accesses are required, per-
  mitting full processor utilization of the system bus. sprite data, however,
  will be accessed if the sprites are not also disabled. The DEN bit must be
  set to '1' for normal video display."
Describe the EOR 6502 intstruction,"EOR            EOR 'Exclusive-Or' memory with accumulator             EOR

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   EOR #Oper           |    49   |    2    |    2     |
  |  Zero Page     |   EOR Oper            |    45   |    2    |    3     |
  |  Zero Page,X   |   EOR Oper,X          |    55   |    2    |    4     |
  |  Absolute      |   EOR Oper            |    40   |    3    |    4     |
  |  Absolute,X    |   EOR Oper,X          |    50   |    3    |    4*    |
  |  Absolute,Y    |   EOR Oper,Y          |    59   |    3    |    4*    |
  |  (Indirect,X)  |   EOR (Oper,X)        |    41   |    2    |    6     |
  |  (Indirect),Y  |   EOR (Oper),Y        |    51   |    2    |    5*    |
  * Add 1 if page boundary is crossed."
WDetail the BPL 6502 instruction,"BPL                     BPL Branch on result plus                     BPL


 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
   Relative      |   BPL Oper            |    10   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
What is the primary difference between multi-color bit map mode and standard (HI-RES) bit mapped mode?,"MULTI-COLOR BET MAP MODE

    Like multi-color mode characters, multi-color bit map mode allows you
  to display up to four different colors in each 8 by 8 section of bit map.
  And as in multi-character mode, there is a sacrifice of horizontal
  resolution (from 320 dots to 160 dots).
    Multi-color bit map mode uses an 8K section of memory for the bit map.
  You select your colors for multi-color bit map mode from (1) the
  background color register 0, (the screen background color), (2) the video
  matrix (the upper 4 bits give one possible color, the lower 4 bits an-
  other), and (3) color memory.
    Multi-color bit mapped mode is turned ON by setting bit 5 of 53265
  ($D011) and bit 4 at location 53270 ($D016) to a 1. The following POKE
  does this:

    POKE 53265,PEEK(53625)OR 32: POKE 53270,PEEK(53270)OR 16
  
	Multi-color bit mapped mode is turned OFF by setting bit 5 of 53265
  ($D011) and bit 4 at location 53270 ($D016) to a 0. The following POKE
  does this:

    POKE 53265,PEEK(53265)AND 223: POKE 53270,PEEK(53270)AND 239

    As in standard (HI-RES) bit mapped mode, there is a one to one cor-
  respondence between the 8K section of memory being used for the display,
  and what is shown on the screen. However, the horizontal dots are two
  bits wide. Each 2 bits in the display memory area form a dot, which can
  have one of 4 colors."
What should be done to minimize noise in the SID Vcc line?,"VCC (Pin 25)

    As with the GND line, a separate +5 VDC line should be run between SID
  Vcc and the power supply in order to minimize noise. A bypass capacitor
  should be located close to the pin."
Can you describe the filter register of the SID?,"FILTER

  FC LO/FC HI (Registers $15,$16)

    Together these registers form an 11-bit number (bits 3-7 of FC LO are
  not used) which linearly controls the Cutoff (or Center) Frequency of the
  programmable Filter. The approximate Cutoff Frequency ranges from 30
  Hz to 12 KHz.

  RES/FILT (Register $17)

    Bits 4-7 of this register (RES0-RES3) control the resonance of the
  filter. Resonance is a peaking effect which emphasizes frequency com-
  ponents at the Cutoff Frequency of the Filter, causing a sharper sound.
  There are 16 resonance settings ranging linearly from no resonance (0) to
  maximum resonance (15 or $F). Bits 0-3 determine which signals will be
  routed through the Filter:
    FILT 1 (Bit 0): When set to a zero, Voice 1 appears directly at the
  audio output and the Filter has no effect on it. When set to a one, Voice
  1 will be processed through the Filter and the harmonic content of Voice
  1 will be altered according to the selected Filter parameters.
    FILT 2 (Bit 1): Same as bit 0 for Voice 2.
    FILT 3 (Bit 2): Same as bit 0 for Voice 3.
    FILTEX (Bit 3): Same as bit 0 for External audio input (pin 26)."
What is the MODE/VOL (Register $18) register?,"MODE/VOL (Register $18)

    Bits 4-7 of this register select various Filter mode and output
  options:
    LP (Bit 4): When set to a one, the Low-Pass output of the Filter is
  selected and sent to the audio output. For a given Filter input signal,
  all frequency components below the Filter Cutoff Frequency are passed
  unaltered, while all frequency components above the Cutoff are attenuated
  at a rate of 12 dB/Octave. The Low-Pass mode produces fullbodied sounds.
    BP (Bit 5): Same as bit 4 for the Bandpass output. All frequency
  components above and below the Cutoff are attenuated at a rate of 6
  dB/Octave. The Bandpass mode produces thin, open sounds.
    HP (Bit 6): Same as bit 4 for the High-Pass output. All frequency
  components above the Cutoff are passed unaltered, while all frequency
  components below the Cutoff are attenuated at a rate of 12 dB/Octave.
  The High-Pass mode produces tinny, buzzy sounds.
    3 OFF (Bit 7): When set to a one, the output of Voice 3 is disconnected
  from the direct audio path. Setting Voice 3 to bypass the Filter
  (FILT 3 = 0) and setting 3 OFF to a one prevents Voice 3 from reaching
  the audio output. This allows Voice 3 to be used for modulation purposes
  without any undesirable output.

  | NOTE: The Filter output modes ARE additive and multiple Filter modes  |
  | may be selected simultaneously. For example, both LP and HP modes can |
  | be selected to produce a Notch (or Band Reject) Filter response. In   |
  | order for the Filter to have any audible effect, at least one Filter  |
  | output must be selected and at least one Voice must be routed through |
  | the Filter. The Filter is, perhaps, the most important element in SID |
  | as it allows the generation of complex tone colors via subtractive    |
  | synthesis (the Filter is used to eliminate specific frequency         |
  | components from a harmonically rich input signal). The best results   |
  | are achieved by varying the Cutoff Frequency in real-time.            |


    Bits 0-3 (VOL0-VOL3) select 1 of 16 overall Volume levels for the final
  composite audio output. The output volume levels range from no output (0)
  to maximum volume (15 or $F) in 16 linear steps. This control can be used
  as a static volume control for balancing levels in multi-chip systems or
  for creating dynamic volume effects, such as Tremolo. Some Volume level
  other than zero must be selected in order for SID to produce any sound."
What is the purpose of the EXT IN pin on the SID chip?,"EXT IN (Pin 26)

    This analog input allows external audio signals to be mixed with the
  audio output of SID or processed through the Filter. Typical sources in-
  clude voice, guitar, and organ. The input impedance of this pin is on the
  order of 100 kohms. Any signal applied directly to the pin should ride at
  a DC level of 6 volts and should not exceed 3 volts p-p. In order to pre-

  vent any interference caused by DC level differences, external signals
  should be AC-coupled to EXT IN by an electrolytic capacitor in the 1-10
  uF range. As the direct audio path (FILTEX=0) has unity gain, EXT IN can
  be used to mix outputs of many SID chips by daisy-chaining. The number of
  chips that can be chained in this manner is determined by the amount of
  noise and distortion allowable at the final output. Note that the output
  Volume control will affect not only the three SID voices, but also any
  external inputs."
How is the bit map mode works on C64?,"There are two types of bit mapping available on the Commodore 64.
  They are:

    1) Standard (high-resolution) bit mapped mode (320-dot by 200-dot
       resolution)

    2) Multi-color bit mapped mode (160-dot by 200-dot resolution)

    Each is very similar to the character type it is named for: standard
  has greater resolution, but fewer color selections. On the other hand,
  multi-color bit mapping trades horizontal resolution for a greater number
  of colors in an 8-dot by 8-dot square.

  STANDARD HIGH-RESOLUTION BIT MAP MODE

    Standard bit map mode gives you a 320 horizontal dot by 200 vertical
  dot resolution, with a choice of 2 colors in each 8-dot by 8-dot section.
  Bit map mode is selected (turned ON) by setting bit 5 of the VIC-II
  control register to a 1 at location 53265 ($D011 in HEX). The following
  POKE will do this:

    POKE 53265,PEEK(53265)OR 32

    Bit map mode is turned OFF by setting bit 5 of the VIC-II control
  register to 0 at location 53265 ($D011), like this:

    POKE 53265,PEEK(53265)AND 223

    Before we get into the details of the bit map mode, there is one more
  issue to tackle, and that is where to locate the bit map area.

  HOW IT WORKS

    If you remember the PROGRAMMABLE CHARACTERS section you will recall
  that you were able to set the bit pattern of a character stored in RAM to
  almost anything you wanted. If at the same time you change the character
  that is displayed on the screen, you would be able to change a single
  dot, and watch it happen. This is the basis of bit-mapping. The entire
  screen is filled with programmable characters, and you make your changes
  directly into the memory that the programmable characters get their
  patterns from.
    Each of the locations in screen memory that were used to control what
  character was displayed, are now used for color information. For example,
  instead of POKEing a I in location 1024 to make an 'A' appear in the top
  left hand corner of the screen, location 1024 now controls the colors of
  the bits in that top left space.
    Colors of squares in bit map mode do not come from color memory, as
  they do in the character modes. Instead, colors are taken from screen
  memory. The upper 4 bits of screen memory become the color of any bit
  that is set to 1 in the 8 by 8 area controlled by that screen memory
  location. The lower 4 bits become the color of any bit that is set to
  a 0.

  EXAMPLE: Type the following:

  5 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
  10 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE

  Now RUN the program.
    Garbage appears on the screen, right? Just like the normal screen mode,
  you have to clear the HIGH-RESOLUTION (HI-RES) screen before you use it.
  Unfortunately, printing a CLR won't work in this case. Instead you have
  to clear out the section of memory that you're using for your
  programmable characters. Hit the <RUN/STOP> and <RESTORE> keys, then add
  the following lines to your program to clear the HI-RES screen:

  20 FORI=BASETOBASE+7999:POKEI,0:NEXT:REM CLEAR BIT
  30 FORI=1024TO2023:POKEI,3:NEXT:REM SET COLOR TO CYAN AND BLACK

    Now RUN the program again. You should see the screen clearing, then the
  greenish blue color, cyan, should cover the whole screen. What we want to
  do now is to turn the dots on and off on the HI-RES screen.

    To SET a dot (turn a dot ON) or UNSET a dot (turn a dot OFF) you must
  know how to find the correct bit in the character memory that you have to
  set to a 1. In other words, you have to find the character you need to
  change, the row of the character, and which bit of the row that you
  have to change. You need a formula to calculate this.
    We will use X and Y to stand for the horizontal and vertical positions
  of a dot, The dot where X=0 and Y=0 is at the upper-left of the display.
  Dots to the right have higher X values, and the dots toward the bottom
  have higher Y values."
What feature of the VIC-II chip allows sprites to be expanded in size?,"EXPANDED SPRITES

    The VIC-II chip has the ability to expand a sprite in the vertical
  direction, the horizontal direction, or both at once. When expanded, each
  dot in the sprite is twice as wide or twice as tall. Resolution doesn't
  actually increase... the sprite just gets bigger."
What is the purpose of the BRK instruction in the context of 66502?,"BRK                          BRK Force Break                          BRK

Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   BRK                 |    00   |    1    |    7     |
  1. A BRK command cannot be masked by setting I."
What is the assembly language form of the INC instruction?,"INC                    INC Increment memory by one                    INC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   INC Oper            |    E6   |    2    |    5     |
  |  Zero Page,X   |   INC Oper,X          |    F6   |    2    |    6     |
  |  Absolute      |   INC Oper            |    EE   |    3    |    6     |
  |  Absolute,X    |   INC Oper,X          |    FE   |    3    |    7     |"
How are sprites in memory?,"sprite MEMORY ACCESS

    The data for each sprite is Stored in 63 consecutive bytes of memory. Each
  block of sprite data is defined by a sprite pointer, located at the end of the
  VIDEO MATRIX. Only 1000 bytes of the video matrix are used in the normal
  display modes, allowing the video matrix locations 1016-1023 (VM base+
  $3F8 to VM base+$3FF) to be used for sprite pointers 0-7, respectively. The
  eight-bit sprite pointer from the video matrix together with the six bits
  from the sprite byte counter (to address 63 bytes) define the entire 14-bit
  address field:


     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
     MP7| MP6| MP5| MP4| MP3| MP2| MP1| MP0| MC5| MC4| MC3| MC2| MC1| MC0

  Where MPx are the sprite pointer bits from the video matrix and MCx are the
  internally generated sprite counter bits. The sprite pointers are read from the
  video matrix at the end of every raster line. When the Y position
  register of a sprite matches the current raster line count, the actual
  fetches of sprite data begin. Internal counters automatically step through
  the 63 bytes of sprite data, displaying three bytes on each raster line."
What is the purpose of the 6566/6567 in the character display mode?,"CHARACTER DISPLAY MODE

    In the character display mode, the 6566/6567 fetches CHARACTER POINTERs
  from the VIDEO MATRIX area of memory and translates the pointers to
  character dot location addresses in the 2048 byte CHARACTER BASE area of
  memory. The video matrix is comprised of 1000 consecutive locations in
  memory which each contain an eight-bit character pointer. The location of
  the video matrix within memory is defined by VM13-VM10 in register 24
  ($18) which are used as the 4 MSB of the video matrix address. The lower
  order 10 bits are provided by an internal counter (VC9-VC0) which steps
  through the 1000 character locations. Note that the 6566/6567 provides 14
  address outputs; therefore, additional system hardware may be required
  for complete system memory decodes.

                          CHARACTER POINTER ADDRESS

     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
  ------+----+----+----+----+----+----+----+----+----+----+----+----+------
    VM13|VM12|VM11|VM10| VC9| VC8| VC7| VC6| VC5| VC4| VC3| VC2| VC1| VC0


    The eight-bit character pointer permits up to 256 different character
  definitions to be available simultaneously. Each character is an 8*8 dot
  matrix stored in the character base as eight consecutive bytes. The loca-
  tion of the character base is defined by CB13-CB11 also in register 24
  ($18) which are used for the 3 most significant bits (MSB) of the char-
  acter base address. The 11 lower order addresses are formed by the 8-bit
  character pointer from the video matrix (D7-D0) which selects a
  particular character, and a 3-bit raster counter (RC2-RC0) which selects
  one of the eight character bytes. The resulting characters are formatted
  as 25 rows of 40 characters each. In addition to the 8-bit character
  pointer, a 4-bit COLOR NYBBLE is associated with each video matrix
  location (the video matrix memory must be 12 bits wide) which defines one
  of sixteen colors for each character.


                           CHARACTER DATA ADDRESS

     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
  ------+----+----+----+----+----+----+----+----+----+----+----+----+------
    CB13|CB12|CB11| D7 | D6 | D5 | D4 | D3 | D2 | D1 | D0 | RC2| RC1| RC0


  STANDARD CHARACTER MODE (MCM = BMM = ECM = 0)

    In the standard character mode, the 8 sequential bytes from the
  character base are displayed directly on the 8 lines in each character
  region. A '0' bit causes the background #0 color (from register 33 ($21))
  to be displayed while the color selected by the color nybble (foreground)
  is displayed for a '1' bit (see Color Code Table).

                | CHARACTER |
     FUNCTION   |    BIT    |               COLOR DISPLAYED
  --------------+-----------+----------------------------------------------
    Background  |     0     |  Background #0 color
                |           |  (register 33 ($21)
    Foreground  |     1     |  Color selected by 4-bit color nybble


    Therefore, each character has a unique color determined by the 4-bit
  color nybble (1 of 16) and all characters share the common background
  color."
What are the non-zero page memory locations and their usage for the RS-232 system interface?,"NONZERO-PAGE MEMORY LOCATIONS AND USAGE FOR
  RS-232 SYSTEM INTERFACE


    General RS-232 storage:

    $0293-M51CTR-Pseudo 6551 control register (see Figure 6-1).
    $0294-M51COR-Pseudo 6551 command register (see Figure 6-2) .
    $0295-M51AJB-Two bytes following the control and command registers in
          the file name field. These locations contain the baud rate for
          the start of the bit test during the interface activity, which,
          in turn, is used to calculate baud rate.
    $0297-RSSTAT-The RS-232 status register (see Figure 6-3).
    $0298-BITNUM-The number of bits to be sent/received.
    $0299-BAUDOF-Two bytes that are equal to the time of one bit cell.
          (Based on system clock/baud rate.)
    $029B-RIDBE-The byte index to the end of the receiver FIFO buffer.
    $029C-RIDBS-The byte index to the start of the receiver FIFO buffer.
    $029D-RODBS-The byte index to the start of the transmitter FIFO buffer.
    $029E-RODBE-The byte index to the end of the transmitter FIFO buffer.
    $02A1-ENABL-Holds current active interrupts in the CIA #2 ICR.
          When bit 4 is turned on means that the system is waiting for the
          Receiver Edge. When bit 1 is turned on then the system is
          receiving data. When bit 0 is turned on then the system is
          transmitting data."
What is the primary function of the serial bus in the Commodore 64?,"THE SERIAL BUS

    The serial bus is a daisy chain arrangement designed to let the Com-
  modore 64 communicate with devices such as the VIC-1541 DISK DRIVE and
  the VIC-1525 GRAPHICS PRINTER. The advantage of the serial bus is that
  more than one device can be connected to the port. Up to 5 devices can be
  connected to the serial bus at one time.
    There are three types of operation over a serial bus-CONTROL, TALK, and
  LISTEN. A CONTROLLER device is one which controls operation of the serial
  bus. A TALKER transmits data onto the bus. A LISTENER receives data from
  the bus.
    The Commodore 64 is the controller of the bus. It also acts as a TALKER
  (when sending data to the printer, for example) and as a LISTENER (when
  loading a program from the disk drive, for example). Other devices may be
  either LISTENERS (the printer), TALKERS, or both (the disk drive). Only
  the Commodore 64 can act as the controller.
    All devices connected on the serial bus will receive all the data
  transmitted over the bus. To allow the Commodore 64 to route data to its
  intended destination, each device has a bus ADDRESS. By using this device
  address, the Commodore 64 can control access to the bus. Addresses on the
  serial bus range from 4 to 31.
    The Commodore 64 can COMMAND a particular device to TALK or LISTEN.
  When the Commodore 64 commands a device to TALK, the device will begin
  putting data onto the serial bus. When the Commodore 64 commands a device
  to LISTEN, the device addressed will get ready to receive data (from the
  Commodore 64 or from another device on the bus). Only one device can TALK
  on the bus at a time; otherwise, the data will collide and the system
  will crash in confusion. However, any number of devices can LISTEN at the
  same time to one TALKER.

                         COMMON SERIAL BUS ADDRESSES
                    +--------+--------------------------+
                    | NUMBER |        DEVICE            |
                    +--------+--------------------------+
                    | 4 or 5 | VIC-1525 GRAPHIC PRINTER |
                    | 8      | VIC-1541 DISK DRIVE      |
                    +--------+--------------------------+

    Other device addresses are possible. Each device has its own address.
  Certain devices (like the Commodore 64 printer) provide a choice between
  two addresses for the convenience of the user.
    The SECONDARY ADDRESS is to let the Commodore 64 transmit setup
  information to a device. For example, to OPEN a connection on the bus to
  the printer, and have it print in UPPER/LOWER case, use the following

    OPEN 1,4,7

  where,
    1 is the logical file number (the number you PRINT# to),
    4 is the ADDRESS of the printer, and
    7 is the SECONDARY ADDRESS that tells the printer to go into UPPER/
      LOWER case mode.

    There are 6 lines used in serial bus operations - input and 3 output.
  The 3 input lines bring data, control, and timing signals into the Com-
  modore 64. The 3 output lines send data, control, and timing signals from
  the Commodore 64 to external devices on the serial bus.

  Serial I/O
                                                       ++ ++
  +-------+----------------------+                    / +-+ \
  |  Pin  |         Type         |                   /5     1\
  +-------+----------------------+                  +  O   O  +
  |   1   |  /SERIAL SRQ IN      |                  |    6    |
  |   2   |  GND                 |                  |    O    |
  |   3   |  SERIAL ATN OUT      |                  |         |
  |   4   |  SERIAL CLK IN/OUT   |                  +  O   O  +
  |   5   |  SERIAL DATA IN/OUT  |                   \4  O  2/
  |   6   |  /RESET              |                    \  3  /
  +-------+----------------------+                     +---+"
Describe how sprite priority works,"PRIORITY

    The priority of each sprite may be individually controlled with respect to
  the other displayed information from character or bit map modes. The
  priority of each sprite is set by the corresponding bit (MnDP) of register
  27 ($1B) as follows:

     REG BIT  |          PRIORITY TO CHARACTER OR BIT MAP DATA
        0     |  Non-transparent sprite data will be displayed (sprite in front)
        1     |  Non-transparent sprite data will be displayed only instead of
              |  Bkgd #0 or multi-color bit pair 01 (sprite behind)


                          sprite-DISPLAY DATA PRIORITY
                       |   MnDP = 1   |   MnDP = 0   |
                       |  spriten     |  Foreground  |
                       |  Foreground  |  spriten     |
                       |  Background  |  Background  |


  sprite data bits of '0' ('00' in multi-color mode) are transparent, always
  permitting any other information to be displayed.
    The sprites have a fixed priority with respect to each other, with sprite 0
  having the highest priority and sprite 7 the lowest. When sprite data (except
  transparent data) of two sprites are coincident, the data from the lower
  number sprite will be displayed. sprite vs. sprite data is prioritized before
  priority resolution with character or bit map data."
"What is the purpose of the instruction BNE"" in the given 6502 ASM language code?""","BNE                   BNE Branch on result not zero                   BNE


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles
 Relative      |   BMI Oper            |    D0   |    2    |    2*    
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
What is the assembly language instruction that decrements the index register Y by one?,"DEY                   DEY Decrement index Y by one                    DEY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   DEY                 |    88   |    1    |    2     |"
What is the command that turns off extended color mode in the VIC-II register?,"Extended color mode is turned OFF by setting bit 6 of the VIC-II regis-ter to a 0 at location 53265 ($D011). The following statement will do this:
    POKE 53265,PEEK(53265)AND 191"
Give the caracteristics of the sprite multi color mode,"SPRITE  MULTI-COLOR MODE

    Multi-color mode allows you to have up to 4 different colors in each
  sprite. However, just like other multi-color modes, horizontal resolution
  is cut in half. In other words, when you're working with sprite multi-
  color mode (like in multi-color character mode), instead of 24 dots
  across the sprite, there are 12 pairs of dots. Each pair of dots is
  called a BIT PAIR. Think of each bit pair (pair of dots) as a single dot
  in your overall sprite when it comes to choosing colors for the dots in
  your sprites. The table below gives you the bit pair values needed to
  turn ON each of the four colors you've chosen for your sprite:

    BIT PAIR                           DESCRIPTION
      00        TRANSPARENT, SCREEN COLOR
      01        SPRITE MULTI-COLOR REGISTER #0 (53285) ($D025)
      10        SPRITE COLOR REGISTER
      11        SPRITE MULTI-COLOR REGISTER #I (53286) ($D026)
 
  NOTE: The sprite foreground color is a 10. The character foreground   
   is a 11."
What is the purpose of the POTY sid register?,"POTY (Register $1A)

    Same as POTX for the pot tied to POTY (pin 23)."
What is the recommended resistance for the source resistor from the AUDIO OUT to ground for proper operation?,"AUDIO OUT (Pin 27)

    This open-source buffer is the final audio output of SID, comprised of
  the three SID voices, the Filter and any external input. The output level
  is set by the output Volume control and reaches a maximum of 2 volts p-p
  at a DC level of 6 volts. A source resistor from AUDIO OUT to ground is
  required for proper operation. The recommended resistance is 1 kohm for
  a standard output impedance.
    As the output of SID rides at a 6-volt DC level, it should be AC-
  coupled to any audio amplifier with an electrolytic capacitor in the 1-10
  uF range.

  VDD (Pin 28)

    As with Vcc, a separate +12 VDC line should be run to SID VDD and a
  bypass capacitor should be used.


  6581 SID CHARACTERISTICS


  ABSOLUTE MAXIMUM RATINGS

  |          RATING          |   SYMBOL   |      VALUE      |    UNITS    |
  |  Supply Voltage          |    VDD     |   -0.3 to +17   |     VDC     |
  |  Supply Voltage          |    VCC     |   -0.3 to +7    |     VDC     |
  |  Input Voltage (analog)  |    Vina    |   -0.3 to +17   |     VDC     |
  |  Input Voltage (digital) |    Vind    |   -0.3 to +7    |     VDC     |
  |  Operating Temperature   |    Ta      |      0 to +70   |   Celsius   |
  |  Storage Temperature     |    Tstg    |   -55 to +150   |   Celsius   |
  +--------------------------+------------+-----------------+-------------+"
What is the purpose of the POTX register in the SID?,"POTX (Register $19)

    This register allows the microprocessor to read the position of the
  potentiometer tied to POTX (pin 24), with values ranging from 0 at
  minimum resistance, to 255 ($FF) at maximum resistance. The value is
  always valid and is updated every 512 (02 clock cycles. See the Pin
  Description section for information on pot and capacitor values."
how do I set multi color mode on a sprite?,"SETTING A SPRITE TO MULTI-COLOR MODE

    To switch a sprite into multi-color mode you must turn ON the VIC-II
  control register at location 53276 ($D01C). The following POKE does this:

    POKE 53276,PEEK(53276)OR(2^SN)

  where SN is the sprite number (0 to 7).
    To switch a sprite out of multi-color mode you must turn OFF the VIC-II
  control register at location 53276 ($D01C). The following POKE does this:

    POKE 53276,PEEK(53276)AND(255-2^SN)

  where SN is the sprite number (0 to 7)."
What is the primary method used to achieve high-resolution displays on the Commodore 64?,"BIT MAPPED GRAPHICS

When writing games, plotting charts for business applications, or other types of programs, sooner or later you get to the point where you want
high-resolution displays.

The Commodore 64 has been designed to do just that: high resolution is available through bit mapping of the screen. Bit mapping is the method in which each possible dot (pixel) of resolution on the screen is assigned its own bit (location) in memory. If that memory bit is a one, the dot it is assigned to is on. If the bit is set to zero, the dot is off.
  
High-resolution graphic design has a couple of drawbacks, which is why it is not used all the time. First of all, it takes lots of memory to bit map the entire screen. This is because every pixel must have a memory bit to control it. You are going to need one bit of memory for each pixel (or one byte for 8 pixels). Since each character is 8 by 8, and there are 40 lines with 25 characters in each line, the resolution is 320 pixels (dots) by 200 pixels for the whole screen. That gives you 64000 separate dots, each of which requires a bit in memory. In other words, 8000 bytes of memory are needed to map the whole screen.

Generally, high-resolution operations are made of many short, simple, repetitive routines. Unfortunately, this kind of thing is usually rather slow if you are trying to write high-resolution routines in BASIC. How-ever, short, simple, repetitive routines are exactly what machine language does best. The solution is to either write your programs entirely in machine language, or call machine language, high-resolution sub-xroutines from your BASIC program using the SYS command from BASIC. That way you get both the ease of writing in BASIC, and the speed of machine language for graphics. The VSP cartridge is also available to add high-resolution commands to COMMODORE 64 BASIC.
  
All of the examples given in this section will be in BASIC to make themclear. Now to the technical details."
What is the purpose of the JSR instruction in the C64 machine language program?,"SUBROUTINES

    In machine language (in the same way as using BASIC), you can call
  subroutines. The instruction to call a subroutine is JSR (Jump to Sub-
  Routine), followed by the specified absolute address.
    Incorporated in the operating system, there is a machine language
  subroutine that will PRINT a character to the screen. The CBM ASCII code
  of the character should be in the accumulator before calling the
  subroutine. The address of this subroutine is $FFD2.
    Therefore, to print 'Hi' to the screen, the following program should be
  entered:

    .A 1400 LDA #$48     - load the CBM ASCII code of 'H'
    .A 1402 JSR $FFD2    -  print it
    .A 1405 LDA #$49     - load the CBM ASCII code of 'I'
    .A 1407 JSR $FFD2    -  print that too
    .A 140A LDA #$0D     - print a carriage return as well
    .A 140C JSR $FFD2
    .A 140F BRK          - return to 64MON
    .G 1400              - will print 'HI' and return to 64MON"
What is the assembly language instruction that decrements the value stored in X?,"DEX                   DEX Decrement index X by one                    DEX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   DEX                 |    CA   |    1    |    2     |"
WDescribe the caracteristics of BMI 6502 instruction?,"BMI                    BMI Branch on result minus                     BMI


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles
 Relative      |   BMI Oper            |    30   |    2    |    2*    
  * Add 1 if branch occurs to same page.
  * Add 1 if branch occurs to different page."
What are the primary functions and capabilities of the 6566/6567 devices?,"The 6566/6567 are multi-purpose color video controller devices for use
  in both computer video terminals and video game applications. Both
  devices contain 47 control registers which are accessed via a standard
  8-bit microprocessor bus (65XX) and will access up to 16K of memory for
  display information. The various operating modes and options within each
  mode are described."
What is the purpose of the COLLISION DETECTION system in a sprite-based graphics system?,"COLLISION DETECTION


    Two types of sprite collision (coincidence) are detected, sprite to sprite
  collision and sprite to display data collision:


    1) A collision between two sprites occurs when non-transparent output data
       of two sprites are coincident. Coincidence of sprite transparent areas
       will not generate a collision. When a collision occurs, the sprite bits
       (MnM) in the sprite-sprite COLLISION register 30 ($1E) will be set to '1'
       for both colliding spriteS. As a collision between two (or more) sprites
       occurs, the sprite-sprite collision bit for each collided sprite will be set.
       The collision bits remain set until a read of the collision
       register, when all bits are automatically cleared. sprites collisions
       are detected even if positioned off-screen.
    2) The second type of collision is a sprite-DATA collision between a sprite
       and foreground display data from the character or bit map modes. The
       sprite-DATA COLLISION register 31 ($1F) has a 'bit (MnD) for each sprite
       which is set to '1' when both the sprite and non-background display
       data are coincident. Again, the coincidence of only transparent data
       does not generate a collision. For special applications, the display
       data from the 0-1 multicolor bit pair also does not cause a
       collision. This feature permits their use as background display data
       without interfering with true sprite collisions. A sprite-DATA collision
       can occur off-screen in the horizontal direction if actual display
       data has been scrolled to an off-screen position (see scrolling).
       The sprite-DATA COLLISION register also automatically clears when read.
    The collision interrupt latches are set whenever the first bit of
   either register is set to '1'. Once any collision bit within a register
   is set high, subsequent collisions will not set the interrupt latch
   until that collision register has been cleared to all '0s' by a read."
What are the ASCII and CHR$ codes?,"ASCII AND CHR$ CODES

    This appendix shows you what characters will appear if you PRINT
  CHR$(X), for all possible values of X. It will also show the values ob-
  tained by typing PRINT ASC('x'), where x is any character you can type.
  This is useful in evaluating the character received in a GET statement,
  converting upper/lower case, and printing character based commands (like
  switch to upper/lower case) that could not be enclosed in quotes.


  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |
  |             0   |  {down}    17   |    '       34   |    3       51   |
  |             1   | {rvs on}   18   |    #       35   |    4       52   |
  |             2   |  {home}    19   |    $       36   |    5       53   |
  |             3   |  {del}     20   |    %       37   |    6       54   |
  |             4   |            21   |    &       38   |    7       55   |
  | {white}     5   |            22   |    '       39   |    8       56   |
  |             6   |            23   |    (       40   |    9       57   |
  |             7   |            24   |    )       41   |    :       58   |
  | disSHIFT+C= 8   |            25   |    *       42   |    ;       59   |
  | enaSHIFT+C= 9   |            26   |    +       43   |    <       60   |
  |            10   |            27   |    ,       44   |    =       61   |
  |            11   |  {red}     28   |    -       45   |    >       62   |
  |            12   | {right}    29   |    .       46   |    ?       63   |
  | return     13   | {green}    30   |    /       47   |    @       64   |
  | lower case 14   |  {blue}    31   |    0       48   |    A       65   |
  |            15   |  SPACE     32   |    1       49   |    B       66   |
  |            16   |    !       33   |    2       50   |    C       67   |
  |    D       68   |            97   |           126   | {grey 3}  155   |
  |    E       69   |            98   |           127   | {purple}  156   |
  |    F       70   |            99   |           128   | {left}    157   |
  |    G       71   |           100   | {orange}  129   | {yellow}  158   |
  |    H       72   |           101   |           130   |  {cyan}   159   |
  |    I       73   |           102   |           131   |  SPACE    160   |
  |    J       74   |           103   |           132   |           161   |
  |    K       75   |           104   |    f1     133   |           162   |
  |    L       76   |           105   |    f3     134   |           163   |
  |    M       77   |           106   |    f5     135   |           164   |
  |    N       78   |           107   |    f7     136   |           165   |
  |    O       79   |           108   |    f2     137   |           166   |
  |    P       80   |           109   |    f4     138   |           167   |
  |    Q       81   |           110   |    f6     139   |           168   |
  |    R       82   |           111   |    f8     140   |           169   |
  |    S       83   |           112   |shift+ret. 141   |           170   |
  |    T       84   |           113   |upper case 142   |           171   |
  |    U       85   |           114   |           143   |           172   |
  |    V       86   |           115   | {black}   144   |           173   |
  |    W       87   |           116   |   {up}    145   |           174   |
  |    X       88   |           117   | {rvs off} 146   |           175   |
  |    Y       89   |           118   | {clear}   147   |           176   |
  |    Z       90   |           119   |  {inst}   148   |           177   |
  |    [       91   |           120   | {brown}   149   |           178   |
  |  pound     92   |           121   | {lt. red} 150   |           179   |
  |    ]       93   |           122   | {grey 1}  151   |           180   |
  |    ^       94   |           123   | {grey 2}  152   |           181   |
  |{arrow left}95   |           124   | {lt.green}153   |           182   |
  |            96   |           125   | {lt.blue} 154   |           183   |
  |           184   |           186   |           188   |           190   |
  |           185   |           187   |           189   |           191   |


  CODES 192-223 SAME AS  96-127
  CODES 224-254 SAME AS 160-190
  CODE 255 SAME AS 126"
Describe how to position a sprite,"SPRITE POSlTlON

    Each sprite is positioned via its X and Y position register (see register
  map) with a resolution of 512 horizontal and 256 vertical positions. The
 position of a sprite is determined by the upper-left corner of the array. X
  locations 23 to 347 ($17-$157) and Y locations 50 to 249 ($32-$F9) are
  visible. Since not all available sprite positions are entirely visible on
  the screen, sprites may be moved smoothly on and off the display screen."
What are the key characteristics of the bit map mode in the 6566/6567?,"BIT MAP MODE

    In bit map mode, the 6566/6567 fetches data from memory in a different
  fashion, so that a one-to-one correspondence exists between each
  displayed dot and a memory bit. The bit map mode provides a screen
  resolution of 320H * 200V individually controlled display dots. Bit map
  mode is selected by setting the BMM bit in register 17 ($11) to a '1'.
  The VIDEO MATRIX is still accessed as in character mode, but the video
  matrix data is no longer interpreted as character pointers, but rather as
  color data. The VIDEO MATRIX COUNTER is then also used as an address to
  fetch the dot data for display from the 8000-byte DISPLAY BASE. The
  display base address is formed as follows:


     A13| A12| A11| A10| A09| A08| A07| A06| A05| A04| A03| A02| A01| A00
    CB13| VC9| VC8| VC7| VC6| VC5| VC4| VC3| VC2| VC1| VC0| RC2| RC1| RC0"
"What is the purpose of the BEQ"" instruction in the C64 assembly language code?""","BEQ                    BEQ Branch on result zero                      BEQ

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles
  Relative      |   BEQ Oper            |    F0   |    2    |    2*    
  * Add 1 if branch occurs to same  page.
  * Add 2 if branch occurs to next  page."
"What is the purpose of the Add 1"" and ""Add 2"" notes in the table?""","BVC                   BVC Branch on overflow clear                    BVC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Relative      |   BVC Oper            |    50   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
What are the CMP 6502 instruction details?,"CMP                CMP Compare memory and accumulator                 CMP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   CMP #Oper           |    C9   |    2    |    2     |
  |  Zero Page     |   CMP Oper            |    C5   |    2    |    3     |
  |  Zero Page,X   |   CMP Oper,X          |    D5   |    2    |    4     |
  |  Absolute      |   CMP Oper            |    CD   |    3    |    4     |
  |  Absolute,X    |   CMP Oper,X          |    DD   |    3    |    4*    |
  |  Absolute,Y    |   CMP Oper,Y          |    D9   |    3    |    4*    |
  |  (Indirect,X)  |   CMP (Oper,X)        |    C1   |    2    |    6     |
  |  (Indirect),Y  |   CMP (Oper),Y        |    D1   |    2    |    5*    |
  * Add 1 if page boundary is crossed."
how do I turn a sprite On ?,"TURNING SPRITES ON

    The VIC-II control register at location 53269 ($D015 in HEX) is known
  as the SPRITE ENABLE register. Each of the sprites has a bit in this
  register which controls whether that sprite is ON or OFF. The register
  looks like this:

                     $D015  7 6 5 4 3 2 1 0

    To turn on sprite 1, for example, it is necessary to turn that bit to
  a 1. The following POKE does this:

    POKE 53269.PEEK(53269)OR 2

  A more general statement would be the following:

    POKE 53269,PEEK(53269)OR (2^SN)

  where SN is the sprite number, from 0 to 7.

   NOTE: A sprite must be turned ON before it can be seen."
What is the command that turns on the Extended color mode in the VIC-II register?,"Extended color mode is turned ON by setting bit 6 of the VIC-II regis-ter to a 1 at location 53265 ($D011 in HEX). The following POKE does it:

    POKE 53265,PEEK(53265)OR 64"
What are the primary functions of the D0-D7 pins in the SID and microprocessor?,"D0-D7 (Pins 15-22)

    These bidirectional lines are used to transfer data between SID and the
  microprocessor. They are TTL compatible in the input mode and capable of
  driving 2 TTL loads in the output mode. The data buffers are usually in
  the high-impedance off state. During a Write operation, the data buffers
  remain in the off (input) state and the microprocessor supplies data to
  SID over these lines. During a Read operation, the data buffers turn on
  and SID supplies data to the microprocessor over these lines. The pins
  are normally connected to the corresponding data lines of the micro-
  processor.

  POTX,POTY (Pins 24,23)

    These pins are inputs to the A/D converters used to digitize the posi-
  tion of potentiometers. The conversion process is based on the time con-
  stant of a capacitor tied from the POT pin to ground, charged by a
  potentiometer tied from the POT pin to +5 volts. The component values are
  determined by:

                                RC = 4.7E-4

  Where R is the maximum resistance of the pot and C is the capacitor.
    The larger the capacitor, the smaller the POT value jitter. The recom-
  mended values for R and C are 470 komhs and 1000 pF. Note that a separate
  pot and cap are required for each POT pin."
What is the primary limitation of using extended background color mode in terms of character display?,"EXTENDED BACKGROUND COLOR MODE

Extended background color mode gives you control over the background color of each individual character, as well as over the foreground color.
For example, in this mode you could display a blue character with ayellow background on a white screen.
There are 4 registers available for extended background color mode.
Each of the registers can be set to any of the 16 colors.
Color memory is used to hold the foreground color in extended back-ground mode. It is used the same as in standard character mode.
Extended character mode places a limit on the number of different characters you can display, however. When extended color mode is on, only the first 64 characters in the character ROM (or the first 64 characters in your programmable character set) can be used. This is because two of the bits of the character code are used to select the background color.
It might work something like this:

The character code (the number you would POKE to the screen) of the letter 'A' is a 1. When extended color mode is on, if you POKED a 1 to the screen, an 'A' would appear. If you POKED a 65 to the screen normally, you would expect the character with character code (CHR$) 129 to appear, which is a reversed 'A.' This does NOT happen in extended color mode. Instead you get the same unreversed 'A' as before, but on a different background color."
What is the formula for calculating the start of the 64 bytes of the sprite definition block?,"If sprite pointer #0, at location 2040, contains the number 14, for
  example, this means that sprite 0 will be displayed using the 64 bytes
  beginning at location 14*64 = 896 which is in the cassette buffer. The
  following formula makes this clear:

    LOCATION = (BANK * 16384) + (SPRITE POINTER VALUE * 64)

  Where BANK is the 16K segment of memory that the VIC-II chip is looking
  at and is from 0 to 3.
    The above formula gives the start of the 64 bytes of the sprite
  definition block.
    When the VIC-II chip is looking at BANK 0 or BANK 2, there is a ROM
  IMAGE of the character set present in certain locations, as mentioned
  before. Sprite definitions can NOT be placed there. If for some reason
  you need more than 128 different sprite definitions, you should use one
  of the banks without the ROM IMAGE, 1 or 3."
how can I create a smooth scrolling with the VIC-II chip on C64?,"SMOOTH SCROLLING

    The VIC-II chip supports smooth scrolling in both the horizontal and
  vertical directions. Smooth scrolling is a one pixel movement of the
  entire screen in one direction. It can move either UP, or down, or left,
  or right. It is used to move new information smoothly onto the screen,
  while smoothly removing characters from the other side.
    While the VIC-II chip does much of the task for you, the actual scroll-
  ing must be done by a machine language program. The VIC-II chip features
  the ability to place the video screen in any of 8 horizontal positions,
  and 8 vertical positions. Positioning is controlled by the VIC-II
  scrolling registers. The VIC-II chip also has a 38 column mode, and a 24
  row mode. the smaller screen sizes are used to give you a place for your
  new data to scroll on from.

  The following are the steps for SMOOTH SCROLLING:
  1) Shrink the screen (the border will expand).
  2) Set the scrolling register to maximum (or minimum value depending upon
     the direction of your scroll).
  3) Place the new data on the proper (covered) portion of the screen.
  4) Increment (or decrement) the scrolling register until it reaches the
     maximum (or minimum) value.
  5) At this point, use your machine language routine to shift the entire
     screen one entire character in the direction of the scroll.
  6) Go back to step 2.

    To go into 38 column mode, bit 3 of location 53270 ($D016) must be set
  to a 0. The following POKE does this:

    POKE 53270,PEEK(53270)AND 247

    To return to 40 column mode, set bit 3 of location 53270 ($D016) to a
  1.The following POKE does this:

    POKE 53270,PEEK(53270)OR 8

    To go into 24 row mode, bit 3 of location 53265 ($D011) must be set to
  a 0. The following POKE will do this:

    POKE 53265,PEEK(53265)AND 247

    To return to 25 row mode, set bit 3 of location 53265 ($D011) to a 1.
  The following POKE does this:

    POKE 53265,PEEK(53265)OR 8

    When scrolling in the X direction, it is necessary to place the VIC-II
  chip into 38 column mode. This gives new data a place to scroll from.
  When scrolling LEFT, the new data should be placed on the right. When
  scrolling RIGHT the new data should be placed on the left. Please note
  that there are still 40 columns to screen memory, but only 38 are
  visible.
    When scrolling in the Y direction, it is necessary to place the VIC-II
  chip into 24 row mode. When scrolling UP, place the new data in the LAST
  row. When scrolling DOWN, place the new data on the FIRST row. Unlike X
  scrolling, where there are covered areas on each side of the screen,
  there is only one covered area in Y scrolling. When the Y scrolling
  register is set to 0, the first line is covered, ready for new data. When
  the Y scrolling register is set to 7 the last row is covered.
    For scrolling in the X direction, the scroll register is located in
  bits 2 to 0 of the VIC-II control register at location 53270 ($D016 in
  HEX). As always, it is important to affect only those bits. The following
  POKE does this:

    POKE 53270,(PEEK(53270)AND 248)+X

  where X is the X position of the screen from 0 to 7.
    For scrolling in the Y direction, the scroll register is located in
  bits 2 to 0 of the VIC-II control register at location 53265 ($D011 in
  HEX). As always, it is important to affect only those bits. The following
  POKE does this:

    POKE 53265,(PEEK(53265)AND 248)+Y

  where Y is the Y position of the screen from 0 to 7.
    To scroll text onto the screen from the bottom, you would step the low-
  order 3 bits of location 53265 from 0-7, put more data on the covered
  line at the bottom of the screen, and then repeat the process. To scroll
  characters onto the screen from left to right, you would step the low-
  order 3 bits of location 53270 from 0 to 7, print or POKE another column
  of new data into column 0 of the screen, then repeat the process.
    If you step the scroll bits by -1, your text will move in the opposite
  direction."
What are the details of the CPX 6502 instruction ?,"CPX                  CPX Compare Memory and Index X                   CPX
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   CPX *Oper           |    E0   |    2    |    2     |
  |  Zero Page     |   CPX Oper            |    E4   |    2    |    3     |
  |  Absolute      |   CPX Oper            |    EC   |    3    |    4     |"
What is the purpose of the BVS instruction in the 6502 assembly language?,"BVS                    BVS Branch on overflow set                     BVS


 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Relative      |   BVS Oper            |    70   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
What is the purpose of the BIT instruction in the 6510 assembly language code?,"BIT             BIT Test bits in memory with accumulator              BIT

  Bit 6 and 7 are transferred to the status register.   N Z C I D V
  If the result of A /\ M is zero then Z = 1, otherwise M7/ _ _ _ M6
  Z = 0

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Zero Page     |   BIT Oper            |    24   |    2    |    3     |
  Absolute      |   BIT Oper            |    2C   |    3    |    4     |"
What is the extended color mode?,"EXTENDED COLOR MODE (ECM = 1, Bmm = MCM = 0)

    The extended color mode allows the selection of individual, background
  colors for each character region with the normal 8*8 character
  resolution. This mode is selected by setting the ECM bit of register 17
  ($11) to '1'. The character dot data is displayed as in the standard mode
  (foreground color determined by the color nybble is displayed for a '1'

  data bit), but the 2 MSB of the character pointer are used to select the
  background color for each character region as follows:


       CHAR. POINTER  |
        MS BIT PAIR   |       BACKGROUND COLOR DISPLAYED FOR 0 BIT
  --------------------+----------------------------------------------------
           00         |  Background #0 color (register 33 ($21))
           01         |  Background #l color (register 34 ($22))
           10         |  Background #2 color (register 35 ($23))
           11         |  Background #3 color (register 36 ($24))

  Since the two MSB of the character pointers are used for color informa-
  tion, only 64 different character definitions are available. The 6566/
  6567 will force CB10 and CB9 to '0' regardless of the original pointer
  values, so that only the first 64 character definitions will be accessed.
  With extended color mode each character has one of sixteen individually
  defined foreground colors and one of the four available background
  colors.

  +-----------------------------------------------------------------------+
  | NOTE: Extended color mode and multi-color mode should not be enabled  |
  | simultaneously.                                                       |
  +-----------------------------------------------------------------------+"
Describe how to enable sprite?,"SPRITE  ENABLE

    Each sprite can be selectively enabled for display by setting its corre-
  sponding enable bit (MnE) to '1' in register 21 ($15). If the MnE bit is
  '0,' no sprite operations will occur involving the disabled sprite."
What is the purpose of the Commodore CP/M cartridge?,"Z-80 MICROPROCESSOR CARTRIDGE

  Peripherals are things like Datassette(TM) recorders, disk
  drives, printers, and modems. All these items can be added to your
  Commodore 64 through the various ports and sockets on the back of your
  machine. The thing that makes Commodore peripherals so good is the fact
  that our peripherals are 'intelligent.' That means that they don't take
  up valuable Random Access Memory space when they're in use. You're free
  to use all 64K of memory in your Commodore 64.
    Another advantage of your Commodore 64 is the fact most programs you
  write on your Commodore 64 today will be upwardly compatible with any new
  Commodore computer you buy in the future. This is partially because of
  the qualities of the computer's Operating System (OS).
    However, there is one thing that the Commodore OS can't do: make your
  programs compatible with a computer made by another company.
    Most of the time you won't even have to think about using another com-
  pany's computer, because your Commodore 64 is so easy to use. But for the
  occasional user who wants to take advantage of software that may not be
  available in Commodore 64 format we have created a Commodore CP/M(R)
  cartridge.
    CP/M(R) is not a 'computer dependent' operating system. Instead it uses
  some of the memory space normally available for programming to run its
  own operating system. There are advantages and disadvantages to this. The
  disadvantages are that the programs you write will have to be shorter
  than the programs you can write using the Commodore 64's built-in
  operating system. In addition, you can NOT use the Commodore 64's
  powerful screen editing capabilities. The advantages are that you can now
  use a large amount of software that has been specifically designed for
  CP/M(R) and the Z-80 microprocessor, and the programs that you write
  using the CP/M(R) operating system can be transported and run on any
  other computer that has CP/M(R) and a Z-80 card.
    By the way, most computers that have a Z-80 microprocessor require that
  you go inside the computer to actually install a Z-80 card. With this
  method you have to be very careful not to disturb the delicate circuitry
  that runs the rest of the computer. The Commodore CP/M& cartridge
  eliminates this hassle because our Z-80 cartridge plugs into the back of
  your Commodore 64 quickly and easily, without any messy wires that can
  cause problems later."
What is the function of the START bit in the 6256 CRA control register?,"6256 CONTROL REGISTERS

    There are two control registers in the 6526, CRA and CRB. CRA is
  associated with TIMER A and CRB is associated with TIMER B. The register
  format is as follows:

  CRA:
  Bit  Name    Function
   0  START    1=START TIMER A, 0=STOP TIMER A. This bit is automatically
               reset when underflow occurs during one-shot mode.
   1  PBON     1=TIMER A output appears on PB6, 0=PB6 normal operation.

   2  OUTMODE  1=TOGGLE, 0=PULSE
   3  RUNMODE  1=ONE-SHOT, 0=CONTINUOUS
   4  LOAD     1=FORCE LOAD (this is a STROBE input, there is no data
               storage, bit 4 will always read back a zero and writing a
               zero has no effect).
   5  INMODE   1=TIMER A counts positive CNT transitions, 0=TIMER A counts
               02 pulses.
   6  SPMODE   1=SERIAL PORT output (CNT sources shift clock),
               0=SERIAL PORT input (external shift clock required).
   7  TODIN    1=50 Hz clock required on TOD pin for accurate time,
               0=60 Hz clock required on TOD pin for accurate time.
  CRB:
  Bit  Name    Function
               (Bits CRB0-CRB4 are identical to CRA0-CRA4 for TIMER B with
               the exception that bit 1 controls the output of TIMER B on
               PB7).
  5,6 INMODE   Bits CRB5 and CRB6 select one of four input modes for
               TIMER B as:
               CRB6   CRB5
                0      0       TIMER B counts 02 pulses.
                0      1       TIMER B counts positive CNT transistions.
                1      0       TIMER B counts TIMER A underflow pulses.
                1      1       TIMER B counts TIMER A underflow pulses
                               while CNT is high.
  7   ALARM     1=writing to TOD registers sets ALARM, 0=writing to TOD
                registers sets TOD clock.

  

  All unused register bits are unaffected by a write and are forced to zero
  on a read.
  +-----------------------------------------------------------------------+
  | COMMODORE SEMICONDUCTOR GROUP reserves the right to make changes to   |
  | any products herein to improve reliability, function or design.       |
  | COMMODORE SEMICONDUCTOR GROUP does not assume any liability arising   |
  | out of the application or use of any product or circuit described     |
  | herein; neither does it convey any license under its patent rights nor|
  | the rights of others.                                                 |
  +-----------------------------------------------------------------------+"
What is the purpose of the SERIAL ATN OUT signal in the Commodore 64?,"SERIAL ATN OUT: (SERIAL ATTENTION OUT)

    The Commodore 64 uses this signal to start a command sequence for a
  device on the serial bus. When the Commodore 64 brings this signal LOW,
  all other devices on the bus start listening for the Commodore 64 to
  transmit an address. The device addressed must respond in a preset period
  of time; otherwise, the Commodore 64 will assume that the device
  addressed is not on the bus, and will return an error in the STATUS WORD."
What are the screen display codes?,"SCREEN DISPLAY CODES

    The following chart lists all of the characters built into the
  Commodore 64 character sets. It shows which numbers should be POKED into
  screen memory (locations 1024-2023) to get a desired character. Also
  shown is which character corresponds to a number PEEKed from the screen.
    Two character sets are available, but only one set at a time. This
  means that you cannot have characters from one set on the screen at the
  same time you have characters from the other set displayed. The sets are
  switched by holding down the <SHIFT> and <C=> keys simultaneously.
    From BASIC, POKE 53272,21 will switch to upper case mode and
  POKE 53272,23 switches to lower case.
    Any number on the chart may also be displayed in REVERSE. The reverse
  character code may be obtained by adding 128 to the values shown.
    If you want to display a solid circle at location 1504, POKE the code
  for the circle (81) into location 1504: POKE 1504,81.
    There is a corresponding memory location to control the color of each
  character displayed on the screen (locations 55296-56295). To change the
  color of the circle to yellow (color code 7) you would POKE the corre-
  sponding memory location (55776) with the character color: POKE 55776,7.
    Refer to Appendix D for the complete screen and color memory maps,
  along with color codes.

  | NOTE: The following POKEs display the same symbol in set 1 and 2: 1,  |
  | 27-64, 91-93, 96-104, 106-121, 123-127.                               |"
What is the purpose of the video matrix counter?,"VCx denotes the video matrix counter outputs, RCx denotes the 3-bit
  raster line counter and CB13 is from register 24 ($18). The video matrix
  counter steps through the same 40 locations for eight raster lines, con-
  tinuing to the next 40 locations every eighth line, while the raster
  counter increments once for each horizontal video line (raster line).
  This addressing results in each eight sequential memory locations being
  formatted as an 8*8 dot block on the video display."
Describe how color works for sprites,"COLOR

    Each sprite has a separate 4-bit register to determine the sprite color. The
  two sprite color modes are:

  STANDARD sprite (MnMC = 0)

    In the standard mode, a '0' bit of sprite data allows any background data
  to show through (transparent) and a '1' bit is displayed as the sprite color
  determined by the corresponding sprite Color register.

  MULTI-COLOR sprite (MnMC = 1)

    Each sprite can be individually selected as a multi-color sprite via MnMC
  bits in the sprite Multi-color register 28 ($1C). When the MnMC bit is '1',
  the corresponding sprite is displayed in the multi-color mode. In the multi-
  color mode, the sprite data is interpreted in pairs (similar to the other
  multi-color modes) as follows:

        BIT PAIR      |                   COLOR DISPLAYED
           00         |  Transparent
           01         |  sprite Multi-color #0 (register 37 ($25))
           10         |  sprite Color (registers 39-46 ($27-$2E))
           11         |  sprite Multi-color #1 (register 38 ($26))


  Since two bits of data are required for each color, the resolution of the
  sprite is reduced to 12X21, with each horizontal dot expanded to twice
  standard size so that the overall sprite size does not change. Note that up
  to 3 colors can be displayed in each sprite (in addition to transparent) but
  that two of the colors are shared among all the sprites in the multi-color
  mode."
What are the details for the 6502 DEC instruction?,"DEC                   DEC Decrement memory by one                     DEC

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   DEC Oper            |    C6   |    2    |    5     |
  |  Zero Page,X   |   DEC Oper,X          |    D6   |    2    |    6     |
  |  Absolute      |   DEC Oper            |    CE   |    3    |    6     |
  |  Absolute,X    |   DEC Oper,X          |    DE   |    3    |    7     |"
"What is the purpose of the instruction CLD"" in the 6502 assembly language code?""","CLD                      CLD Clear decimal mode                       CLD


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLD                 |    D8   |    1    |    2     |"
WHow do I set a sprite off?,"TURNING SPRITES OFF

A sprite is turned off by setting its bit in the VIC-II control register at 53269 ($D015 in HEX) to a 0. The following POKE will do this:

    POKE 53269,PEEK(53269)AND(255-2^SN)

where SN is the sprite number from 0 to 7."
What are the key features of sprites in the VIC-II chip?,"SPRITES

    A SPRITE is a special type of user definable character which can be
  displayed anywhere on the screen. Sprites are maintained directly by the
  VIC-II chip. And all you have to do is tell a sprite 'what to look like,'
  'what color to be,' and 'where to appear.' The VIC-II chip will do the
  rest! Sprites can be any of the 16 colors available.
    Sprites can be used with ANY of the other graphics modes, bit mapped,
  character, multi-color, etc., and they'll keep their shape in all of
  them. The sprite carries its own color definition, its own mode (HI-RES
  or multi-colored), and its own shape.
    Up to 8 sprites at a time can be maintained by the VIC-II chip auto-
  matically. More sprites can be displayed using RASTER INTERRUPT
  techniques.

    The features of SPRITES include:

    1) 24 horizontal dot by 21 vertical dot size.
    2) Individual color control for each sprite.
    3) Sprite multi-color mode.
    4) Magnification (2x) in horizontal, vertical, or both directions.
    5) Selectable sprite to background priority.
    6) Fixed sprite to sprite priorities.
    7) Sprite to sprite collision detection.
    8) Sprite to background collision detection."
What is the primary function of the OSC 3 register in a sid synthesizer?,"OSC 3/RANDOM (Register $1B)

    This register allows the microprocessor to read the upper 8 output bits
  of Oscillator 3. The character of the numbers generated is directly re-
  lated to the waveform selected. If the Sawtooth waveform of Oscillator 3
  is selected, this register will present a series of numbers incrementing
  from 0 to 255 ($FF) at a rate determined by the frequency of Oscillator
  3. If the Triangle waveform is selected, the output will increment from 0
  up to 255, then decrement down to 0. If the Pulse waveform is selected,
  the output will jump between 0 and 255. Selecting the Noise waveform
  will produce a series of random numbers, therefore, this register can be
  used as a random number generator for games. There are numerous timing
  and sequencing applications for the OSC 3 register, however, the chief
  function is probably that of a modulation generator. The numbers
  generated by this register can be added, via software, to the Oscillator
  or Filter Frequency registers or the Pulse Width registers in real-time.
  Many dynamic effects can be generated in this manner. Siren-like sounds
  can be created by adding the OSC 3 Sawtooth output to the frequency
  control of another oscillator. Synthesizer 'Sample and Hold' effects can
  be produced by adding the OSC 3 Noise output to the Filter Frequency
  control registers. Vibrato can be produced by setting Oscillator 3 to a
  frequency around 7 Hz and adding the OSC 3 Triangle output (with proper
  scaling) to the Frequency control of another oscillator. An unlimited
  range of effects are available by altering the frequency of Oscillator 3
  and scaling the OSC 3 output. Normally, when Oscillator 3 is used for
  modulation, the audio output of Voice 3 should be eliminated (3 OFF = 1)."
What is the SID CONTROL REGISTER (Register 04)?,"CONTROL REGISTER (Register 04)

    This register contains eight control bits which select various options
  on Oscillator 1.
    GATE (Bit 0): The GATE bit controls the Envelope Generator for Voice 1.
  When this bit is set to a one, the Envelope Generator is Gated
  (triggered) and the ATTACK/DECAY/SUSTAIN cycle is initiated. When the bit
  is reset to a zero, the RELEASE cycle begins. The Envelope Generator
  controls the amplitude of Oscillator I appearing at the audio output,
  therefore, the GATE bit must be set (along with suitable envelope pa-
  rameters) for the selected output of Oscillator 1 to be audible. A de-
  tailed discussion of the Envelope Generator can be found at the end of
  this Appendix.
    SYNC (Bit 1): The SYNC bit, when set to a one, synchronizes the
  fundamental frequency of Oscillator 1 with the fundamental frequency of
  Oscillator 3, producing 'Hard Sync' effects.
    Varying the frequency of Oscillator 1 with respect to Oscillator 3 pro-
  duces a wide range of complex harmonic structures from Voice I at the
  frequency of Oscillator 3. In order for sync to occur, Oscillator 3 must
  be set to some frequency other than zero but preferably lower than the
  frequency of Oscillator 1. No other parameters of Voice 3 have any effect
  on sync.
    RING MOD (Bit 2): The RING MOD bit, when set to a one, replaces the
  Triangle waveform output of Oscillator 1 with a 'Ring Modulated'
  combination of Oscillators 1 and 3. Varying the frequency of Oscillator 1
  with respect to Oscillator 3 produces a wide range of non-harmonic
  overtone structures for creating bell or gong sounds and for special ef-
  fects. In order for ring modulation to be audible, the Triangle waveform
  of Oscillator 1 must be selected and Oscillator 3 must be set to some
  frequency other than zero. No other parameters of Voice 3 have any effect
  on ring modulation.
    TEST (Bit 3): The TEST bit, when set to a one, resets and locks Oscil-
  lator 1 at zero until the TEST bit is cleared. The Noise waveform output
  of Oscillator 1 is also reset and the Pulse waveform output is held at a
  DC level. Normally this bit is used for testing purposes, however, it can
  be used to synchronize Oscillator 1 to external events, allowing the
  generation of highly complex waveforms under real-time software control.
  (Bit 4): When set to a one, the Triangle waveform output of Oscillator
  1 is selected. The Triangle waveform is low in harmonics and has a
  mellow, flute-like quality.
    (Bit 5): When set to a one, the Sawtooth waveform output of Oscillator
  1 is selected. The Sawtooth waveform is rich in even and odd harmonics
  and has a bright, brassy quality.
    (Bit 6): When set to a one, the Pulse waveform output of Oscillator 1
  is selected. The harmonic content of this waveform can be adjusted by the
  Pulse Width registers, producing tone qualities ranging from a bright,
  hollow square wave to a nasal, reedy pulse. Sweeping the pulse width in
  real-time produces a dynamic 'phasing' effect which adds a sense of
  motion to the sound. Rapidly jumping between different pulse widths can
  produce interesting harmonic sequences.
    NOISE (Bit 7): When set to a one, the Noise output waveform of
  Oscillator 1 is selected. This output is a random signal which changes at
  the frequency of Oscillator 1. The sound quality can be varied from a low
  rumbling to hissing white noise via the Oscillator 1 Frequency registers.
  Noise is useful in creating explosions, gunshots, jet engines, wind, surf
  and other unpitched sounds, as well as snore drums and cymbals. Sweeping
  the oscillator frequency with Noise selected produces a dramatic rushing
  effect.
    One of the output waveforms must be selected for Oscillator 1 to be
  audible, however, it is NOT necessary to de-select waveforms to silence
  the output of Voice 1. The amplitude of Voice 1 at the final output is a
  function of the Envelope Generator only.


  +-----------------------------------------------------------------------+
  | NOTE: The oscillator output waveforms are NOT additive. If more than  |
  | one output waveform is selected simultaneously, the result will be a  |
  | logical ANDing of the waveforms. Although this technique can be used  |
  | to generate additional waveforms beyond the four listed above, it must|
  | be used with care. If any other waveform is selected while Noise is   |
  | on, the Noise output can 'lock up ' If this occurs, the Noise output  |
  | will remain silent until reset by the TEST bit or by bringing RES     |
  | (pin 5) low.                                                          |
  +-----------------------------------------------------------------------+"
What features does the VIC-II chip support in terms of sprite capabilities?,"These special sprite abilities make it simple to program many arcade
  style games. Because the sprites are maintained by hardware, it is even
  possible to write a good quality game in BASIC!
    There are 8 sprites supported directly by the VIC-II chip. They are
  numbered from 0 to 7. Each of the sprites has it own definition location,
  position registers and color register, and has its own bits for enable
  and collision detection."
What are the memory locations of the color registers on C64?,"SPRITE COLORS

    A sprite can be any of the 16 colors generated by the VIC-II chip. Each
  of the sprites has its own sprite color register. These are the memory
  locations of the color registers:


        53287   ($D027)     description:    SPRITE 0 COLOR REGISTER
        53288   ($D028)     description:    SPRITE 1 COLOR REGISTER
        53289   ($D029)     description:    SPRITE 2 COLOR REGISTER
        53290   ($D02A)     description:    SPRITE 3 COLOR REGISTER
        53291   ($D02B)     description:    SPRITE 4 COLOR REGISTER
        53292   ($D02C)     description:    SPRITE 5 COLOR REGISTER
        53293   ($D02D)     description:    SPRITE 6 COLOR REGISTER
        53294   ($D02E)     description:    SPRITE 7 COLOR REGISTER

    All dots in the sprite will be displayed in the color contained in the
  sprite color register. The rest of the sprite will be transparent, and
  will show whatever is behind the sprite."
What is the purpose of the CLC instruction in the assembly language?,"CLC                       CLC Clear carry flag                        CLC

Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLC                 |    18   |    1    |    2     |"
What is the assembly language form of the CPY instruction in the Zero Page addressing mode?,"CPY                  CPY Compare memory and index Y                   CPY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Immediate     |   CPY *Oper           |    C0   |    2    |    2     |
  |  Zero Page     |   CPY Oper            |    C4   |    2    |    3     |
  |  Absolute      |   CPY Oper            |    CC   |    3    |    4     |"
How to control the sprite magnification?,"MAGNIFICATION

    Each sprite can be selectively expanded (2X) in both the horizontal and
  vertical directions. Two registers contain the control bits (MnXE,MnYE)
  for the magnification control.


    REGISTER  |                        FUNCTION
     23 ($17) | Horizontal expand MnXE-'1'=expand; '0'=normal
     29 ($1D) | Vertical expand MnYE-'1'=expand; '0'=normal

  When sprites are expanded, no increase in resolution is realized. The same
  24*21 array (12X21 if multi-colored) is displayed, but the overall sprite
  dimension is doubled in the desired direction (the smallest sprite dot may
  be up to 4X standard dot dimension if a sprite is both multi-colored and
  expanded)."
What is the purpose of the color nybble in standard bit map mode?,"STANDARD BIT MAP MODE (BMM =1, MCM = 0)

    When standard bit map mode is in use, the color information is derived
  only from the data stored in the video matrix (the color nybble is
  disregarded). The 8 bits are divided into two 4-bit nybbles which allow
  two colors to be independently selected in each 8*8 dot block. When a bit
  in the display memory is a '0' the color of the output dot is set by the
  least significant (lower) nybble (LSN). Similarly, a display memory bit
  of '1' selects the output color determined by the MSN (upper nybble).

      BIT    |            DISPLAY COLOR
       0     |   Lower nybble of video matrix pointer
       1     |   Upper nybble of video matrix pointer"
What is the purpose of the SRQ?,"SERIAL SRQ IN: (SERIAL SERVICE REQUEST IN)

    Any device on the serial bus can bring this signal LOW when it requires
  attention from the Commodore 64. The Commodore 64 will then take care of
  the device. (See Figure 6-4)."
describe the 6526 Interrupt Control Register?,"Interrupt Control (ICR)

    There are five sources of interrupts on the 6526: underflow from TIMER
  A, underflow from TIMER B, TOD ALARM, Serial Port full/empty and /FLAG.
  A single register provides masking and interrupt information. The
  interrupt Control Register consists of a write-only MASK register and a
  read-only DATA register. Any interrupt will set the corresponding bit in
  the DATA register. Any interrupt which is enabled by the MASK register
  will set the IR bit (MSB) of the DATA register and bring the /IRQ pin
  low. In a multi-chip system, the IR bit can be polled to detect which
  chip has generated an interrupt request. The interrupt DATA register is
  cleared and the /IRQ line returns high following a read of the DATA
  register. Since each interrupt sets an interrupt bit regardless of the
  MASK, and each interrupt bit can be selectively masked to prevent the
  generation of a processor interrupt, it is possible to intermix polled
  interrupts with true interrupts. However, polling the IR bit will cause
  the DATA register to clear, therefore, it is up to the user to preserve
  the information contained in the DATA register if any polled interrupts
  were present.
    The MASK register provides convenient control of individual mask bits.
  When writing to the MASK register, if bit 7 (SET/CLEAR) of the data
written is a ZERO, any mask bit written with a one will be cleared, while
  those mask bits written with a zero will be unaffected. If bit 7 of the
  data written is a ONE, any mask bit written with a one will be set, while
  those mask bits written with a zero will be unaffected. In order for an
  interrupt flag to set IR and generate an Interrupt Request, the corre-
  sponding MASK bit must be set."
What are the details 6510 microprocessor chip?,"6510 MICROPROCESSOR CHIP
  SPECIFICATIONS

  DESCRIPTION

    The 6510 is a low-cost microcomputer system capable of solving a broad
  range of small-systems and peripheral-control problems at minimum cost to
  the user.
    An 8-bit Bi-Directional I/O Port is located on-chip with the Output
  Register at Address 0000 and the Data-Direction Register at Address 0001.
  The I/O Port is bit-by-bit programmable.
    The Three-State sixteen-bit Address Bus allows Direct Memory Accessing
  (DMA) and multiprocessor systems sharing a common memory.
    The internal processor architecture is identical to the MOS Technology
  6502 to provide software compatibility.


  FEATURES OF THE 6510...

  o Eight-Bit Bi-Directional I/O Port
  o Single +5-volt supply
  o N-channel, silicon gate, depletion load technology
  o Eight-bit parallel processing
  o 56 Instructions
  o Decimal and binary arithmetic
  o Thirteen addressing modes
  o True indexing capability
  o Programmable stack pointer
  o Variable length stack
  o Interrupt capability
  o Eight-Bit Bi-Directional Data Bus
  o Addressable memory range of up to 64K bytes
  o Direct memory access capability
  o Bus compatible with M6800
  o Pipeline architecture
  o 1-MHz and 2-MHz operation
  o Use with any type or speed memory"
What is the 6526 handshaking?,"6256 Handshaking

    Handshaking on data transfers can be accomplished using the /PC output
  pin and the FLAG input pin. PC will go low for one cycle following a read
  or write of PORT B. This signal can be used to indicate 'data ready' at
  PORT B or 'data accepted' from PORT B. Handshaking on 16-bit data
  transfers (using both PORT A and PORT B) is possible by always reading or
  writing PORT A first. /FLAG is a negative edge sensitive input which can
  be used for receiving the /PC output from another 6526, or as a general
  purpose interrupt input. Any negative transition of /FLAG will set the
  /FLAG interrupt bit.


  Interval Timers (Timer A, Timer B)

    Each interval timer consists of a 16-bit read-only Timer Counter and a
  16-bit write-only Timer Latch. Data written to the timer are latched in
  the Timer Latch, while data read from the timer are the present contents
  of the Time Counter. The timers can be used independently or linked for
  extended operations. The various timer modes allow generation of long
  time delays, variable width pulses, pulse trains and variable frequency
  waveforms. Utilizing the CNT input, the timers can count external pulses
  or measure frequency, pulse width and delay times of external signals.
  Each timer has an associated control register, providing independent
  control of the following functions:

  Start/Stop

    A control bit allows the timer to be started or stopped by the micro-
  processor at any time.

  PB On/Off:

    A control bit allows the timer output to appear on a PORT B output line
  (PB6 for TIMER A and PB7 for TIMER B). This function overrides the DDRB
  control bit and forces the appropriate PB line to an output.

  Toggle/Pulse

    A control bit selects the output applied to PORT B. On every timer
  underflow the output can either toggle or generate a single positive
  pulse of one cycle duration. The Toggle output is set high whenever the
  timer is started and is set low by /RES.

  One-Shot/Continuous

    A control bit selects either timer mode. In one-shot mode, the timer
  will count down from the latched value to zero, generate an interrupt,
  reload the latched value, then stop. In continuous mode, the timer will
  count from the latched value to zero, generate' an interrupt, reload the
  latched value and repeat the procedure continuously.

  Force Load

    A strobe bit allows the timer latch to be loaded into the timer counter
  at any time, whether the timer is running or not.

  Input Mode:

    Control bits allow selection of the clock used to decrement the timer.
  TIMER A can count 02 clock pulses or external pulses applied to the CNT
  pin. TIMER B can count (02 pulses, external CNT pulses, TIMER A underflow
  pulses or TIMER A underflow pulses while the CNT pin is held high.

    The timer latch is loaded into the timer on any timer underflow, on a
  force load or following a write to the high byte of the prescaler while
  the timer is stopped. If the timer is running, a write to the high byte
  will load the timer latch, but not reload the counter."
describe the BCS (Branch on Carry Set) operation?,"BCS                      BCS Branch on carry set                      BCS

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Relative      |   BCS Oper            |    B0   |    2    |    2*    |
  * Add 1 if branch occurs to same  page.
  * Add 2 if branch occurs to next  page."
What is the purpose of the stack in the 6510 microprocessor?,"THE STACK

    The 6510 microprocessor has what is known as a stack. This is used by
  both the programmer and the microprocessor to temporarily remember
  things, and to remember, for example, an order of events. The GOSUB
  statement in BASIC, which allows the programmer to call a subroutine,
  must remember where it is being called from, so that when the RETURN
  statement is executed in the subroutine, the BASIC interpreter 'knows'
  where to go back to continue executing. When a GOSUB statement is
  encountered in a program by the BASIC interpreter, the BASIC interpreter
  'pushes' its current position onto the stack before going to do the
  subroutine, and when a RETURN is executed, the interpreter 'pulls' off
  the stack the information that tells it where it was before the
  subroutine call was made. The interpreter uses instructions like PHA,
  which pushes the contents of the accumulator onto the stack, and PLA (the
  reverse) which pulls a value off the stack and into the accumulator. The
  status register can also be pushed and pulled with the PHP and PLP,
  respectively.

    The stack is 256 bytes long, and is located in page one of memory. It
  is therefore from $01 00 to $01 FF. It is organized backwards in memory.
  In other words, the first position in the stack is at $01 FF, and the
  last is at $0100. Another register in the 651 0 microprocessor is called
  the stack pointer, and it always points to the next available location in
  the stack. When something is pushed onto the stack, it is placed where
  the stack pointer points to, and the stack pointer is moved down to the
  next position (decremented). When something is pulled off the stack, the
  stack pointer is incremented, and the byte pointed to by the stack
  pointer is placed into the specified register.

  The implied mode means that information isimplied by an instruction itself. In other words, what registers, flags,
  and memory the instruction is referring to. The examples we have seen are
  PHA, PLA, PHP, and PLP, which refer to stack processing and the
  accumulator and status registers, respectively.


NOTE: The X register will be referred to as X from now on, and similarly A (accumulator), Y (Y index register), S (stack pointer), and P (processor status).           |"
how do i set the multi color mode?,"MULTI-COLOR MODE BIT

    To turn on multi-color character mode, set bit 4 of the VIC-II control
  register at 53270 ($D016) to a 1 by using the following POKE:

    POKE 53270,PEEK(53270)OR 16

    To turn off multi-color character mode, set bit 4 of location 53270 to
  a 0 by the following POKE:

    POKE 53270,PEEK(53270)AND 239

    Multi-color mode is set on or off for each space on the screen, so that
  multi-color graphics can be mixed with high-resolution (hi-res) graphics.
  This is controlled by bit 3 in color memory. Color memory begins at
  location 55296 ($D800 in HEX). If the number in color memory is less than
  8 (0-7) the corresponding space on the video screen will be standard
  hi-res, in the color (0-7) you've chosen. If the number located in color
  memory is greater or equal
 to 8 (from 8 to 15), then that space will be displayed in multi-color mode.

    By POKEing a number into color memory, you can change the color of the
  character in that position on the screen. POKEing a number from 0 to 7
  gives the normal character colors. POKEing a number between 8 and 15 puts
  the space into multi-color mode. In other words, turning BIT 3 ON in
  color memory, sets MULTI-COLOR MODE. Turning BIT 3 OFF in color memory,
  sets the normal, HIGH-RESOLUTION mode.
    Once multi-color mode is set in a space, the bits in the character
  determine which colors are displayed for the dots. 

    In normal or high-resolution mode, the screen color is displayed
  everywhere there is a 0 bit, and the character color is displayed where
  the bit is a 1. Multi-color mode uses the bits in pairs

  The bit pairs determine
  this, according to the following chart:


  BIT PAIR - COLOR REGISTER - LOCATION
  00 - Background #0 color (screen color) - 53281 ($D021) 
  01 - Background #l color - 53282 ($D022) 
  10 - Background #2 color - 53283 ($D023) 
  11 - Color specified by the lower 3 bits in color memory - color RAM"
What is the purpose of the raster register in a display system?,"RASTER REGISTER

    The raster register is a dual-function register. A read of the raster
  register 18 ($12) returns the lower 8 bits of the current raster position
  (the MSB-RC8 is located in register 17 ($11)). The raster register can be
  interrogated to implement display changes outside the visible area to
  prevent display flicker. The visible display window is from raster 51
  through raster 251 ($033-$0FB). A write to the raster bits (including
  RC8) is latched for use in an internal raster compare. When the current
  raster matches the written value, the raster interrupt latch is set."
What are the key components of the 6581 synthesizer chip?,"DESCRIPTION

    The 6581 consists of three synthesizer 'voices' which can be used
  independently or in conjunction with each other (or external audio
  sources) to create complex sounds. Each voice consists of a Tone
  Oscillator/Waveform Generator, an Envelope Generator and an Amplitude
  Modulator. The Tone Oscillator controls the pitch of the voice over a
  wide range. The Oscillator produces four waveforms at the selected
  frequency, with the unique harmonic content of each waveform providing
  simple control of tone color. The volume dynamics of the oscillator are
  controlled by the Amplitude Modulator under the direction of the Envelope
  Generator. When triggered, the Envelope Generator creates an amplitude
  envelope with programmable rates of increasing and decreasing volume. In
  addition to the three voices, a programmable Filter is provided for
  generating complex, dynamic tone colors via subtractive synthesis.
    SID allows the microprocessor to read the changing output of the third
  Oscillator and third Envelope Generator. These outputs can be used as a
  source of modulation information for creating vibrato, frequency/filter
  sweeps and similar effects. The third oscillator can also act as a random
  number generator for games. Two A/D converters are provided for inter-
  facing SID with potentiometers. These can be used for 'paddles' in a
  game environment or as front panel controls in a music synthesizer. SID
  can process external audio signals, allowing multiple SID chips to be
  daisy-chained or mixed in complex polyphonic systems."
"What is the purpose of the command `POKE 53270, PEEK(53270) OR 16` in the context of changing character colors?","By using the <C=> key and the COLOR keys the characters can be changed to any color, including multi-color characters. For example, type this command:

 POKE 53270,PEEK(53270)OR 16:PRINT'<CTRL+3>';: rem lt.red/ multi-color red

 The word READY and anything else you type will be displayed in multi-color mode. Another color control can set you back to regular text."
Can you talk about the zero page addressing mode?,"ADDRESSING MODES

  ZERO PAGE

  Absolute addresses are expressed in terms of a high
  and a low order byte. The high order byte is often referred to as the
  page of memory. For example, the address $1637 is in page $16 (22), and
  $0277 is in page $02 (2). There is, however, a special mode of addressing
  known as zero page addressing and is, as the name implies, associated
  with the addressing of memory locations in page zero. These addresses,
  therefore, ALWAYS have a high order byte of zero. The zero page mode of
  addressing only expects one byte to describe the address, rather than two
  when using an absolute address. The zero page addressing mode tells the
  microprocessor to assume that the high order address is zero. Therefore
  zero page addressing can reference memory locations whose addresses are
  between $0000 and $00FF. This may not seem too important at the moment,
  but you'll need the principles of zero page addressing soon."
Describe the BCC (Branch if Carry Clear) instruction?,"BCC                     BCC Branch on Carry Clear                     BCC


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Relative      |   BCC Oper            |    90   |    2    |    2*    |
  * Add 1 if branch occurs to same page.
  * Add 2 if branch occurs to different page."
What is the CP/M?,"USING COMMODORE CP/M(R)

    The Commodore Z-80 cartridge let's you run programs designed for a Z-80
  microprocessor on your Commodore 64. The cartridge is provided with a
  diskette containing the Commodore CP/M(R) operating system.

  RUNNING COMMODORE CP/M(R)

    To run CP/M(R):

      1) LOAD the CP/M(R) program from your disk drive.
      2) Type RUN.
      3) Hit the <RETURN> key.
    At this point the 64K bytes of RAM in the Commodore 64 are accessible
  by the built-in 6510 central processor, OR 48K bytes of RAM are available
  for the Z-80 central processor. You can shift back and forth between
  these two processors, but you can NOT use them at the same time in a
  single program. This is possible because of your Commodore 64's
  sophisticated timing mechanism.
    Below is the memory address translation that is performed on the Z-80
  cartridge. You should notice that by adding 4096 bytes to the memory
  locations used in CP/M(R) $1000 (hex) you equal the memory addresses of
  the normal Commodore 64 operating system. The correspondence between Z-80
  and 6510 memory addresses is as follows:"
What are the error messages generated by the Commodore-64?,"ERROR MESSAGES

    This appendix contains a complete list of the error messages generated
  by the Commodore-64, with a description of causes.


  BAD DATA            String data was received from an open file, but the
                      program was expecting numeric data.
  BAD SUBSCRIPT       The program was trying to reference an element of an
                      array whose number is outside of the range specified
                      in the DIM statement.
  BREAK               Program execution was stopped because you hit the
                      <STOP> key.
  CAN'T CONTINUE      The CONT command will not work, either because the
                      program was never RUN, there has been an error, or
                      a line has been edited.
  DEVICE NOT PRESENT  The required I/O device was not available for an
                      OPEN, CLOSE, CMD, PRINT#, INPUT#, or GET#.
  DIVISION BY ZERO    Division by zero is a mathematical oddity and not
                      allowed.
  EXTRA IGNORED       Too many items of data were typed in response to an
                      INPUT statement. Only the first few items were
                      accepted.
  FILE NOT FOUND      If you were looking for a file on tape, and END-OF-
                      TAPE marker was found. If you were looking on disk,
                      no file with that name exists.
  FILE NOT OPEN       The file specified in a CLOSE, CMD, PRINT#, INPUT#,
                      or GET#, must first be OPENed.
  FILE OPEN           An attempt was made to open a file using the number
                      of an already open file.
  FORMULA TOO COMPLEX The string expression being evaluated should be split
                      into at least two parts for the system to work with,
                      or a formula has too many parentheses.
  ILLEGAL DIRECT      The INPUT statement can only be used within a pro-
                      gram, and not in direct mode.
  ILLEGAL QUANTITY    A number used as the argument of a function or
                      statement is out of the allowable range.
  LOAD                There is a problem with the program on tape.
  NEXT WITHOUT FOR    This is caused by either incorrectly nesting loops or
                      having a variable name in a NEXT statement that
                      doesn't correspond with one in a FOR statement.
  NOT INPUT FILE      An attempt was made to INPUT or GET data from a file
                      which was specified to be for output only.
  NOT OUTPUT FILE     An attempt was mode to PRINT data to a file which was
                      specified as input only.
  OUT OF DATA         A READ statement was executed but there is no data
                      left unREAD in a DATA statement.
  OUT OF MEMORY       There is no more RAM available for program or
                      variables. This may also occur when too many FOR
                      loops have been nested, or when there are too many
                      GOSUBs in effect.
  OVERFLOW            The result of a computation is larger than the
                      largest number allowed, which is 1.70141884E+38.
  REDIM'D ARRAY       An array may only be DiMensioned once. If an array
                      variable is used before that array is DIM'D, an
                      automatic DIM operation is performed on that array
                      setting the number of elements to ten, and any
                      subsequent DIMs will cause this error.
  REDO FROM START     Character data was typed in during an INPUT statement
                      when numeric data was expected. Just re-type the
                      entry so that it is correct, and the program will
                      continue by itself.
  RETURN WITHOUT GOSUB  A RETURN statement was encountered, and no GOSUB
                      command has been issued.
  STRING TOO LONG     A string can contain up to 255 characters.
  ?SYNTAX ERROR       A statement is unrecognizable by the Commodore 64. A
                      missing or extra parenthesis, misspelled keywords,
                      etc.
  TYPE MISMATCH       This error occurs when a number is used in place of a
                      string, or vice-versa.
  UNDEF'D FUNCTION    A user defined function was referenced, but it has
                      never been defined using the DEF FN statement.
  UNDEF'D STATEMENT   An attempt was made to GOTO or GOSUB or RUN a line
                      number that doesn't exist.
  VERIFY              The program on tape or disk does not match the
                      program currently in memory."
What is the primary function of the Time of Day (TOD) clock?,"Time of Day Clock (TOD)

    The TOD clock is a special purpose timer for real-time applications.
  TOD consists of a 24-hour (AM/PM) clock with 1/10th second resolution. It
  is organized into 4 registers: 10ths of seconds, Seconds, Minutes and
  Hours. The AM/PM flag is in the MSB of the Hours register for easy bit
  testing. Each register reads out in BCD format to simplify conversion for
  driving displays, etc. The clock requires an external 60 Hz or 50 Hz
  (programmable) TTL level input on the TOD pin for accurate time-keeping.
  In addition to time-keeping, a programmable ALARM is provided for
  generating an interrupt at a desired time. The ALARM registers or located
  at the same addresses as the corresponding TOD registers. Access to the
  ALARM is governed by a Control Register bit. The ALARM is write-only; any
  read of a TOD address will read time regardless of the state of the ALARM
  access bit.
    A specific sequence of events must be followed for proper setting and
  reading of TOD. TOD is automatically stopped whenever a write to the
  Hours register occurs. The clock will not start again until after a write
  to the 10ths of seconds register. This assures TOD will always start at
  the desired time. Since a carry from one stage to the next can occur at
  any time with respect to a read operation, a latching function is
  included to keep all Time Of Day information constant during a read
  sequence. All four TOD registers latch on a read of Hours and remain
  latched until after a read of 10ths of seconds. The TOD clock continues
  to count when the output registers are latched. If only one register is
  to be read, there is no carry problem and the register can be read 'on
  the fly,' provided that any read of Hours is followed by a read of 10ths
  of seconds to disable the latching."
What is the maximum number of unique sprites that can be displayed simultaneously?,"SPRITES

    The movable object block (sprite) is a special type of character which can
  be displayed at any one position on the screen without the block
  constraints inherent in character and bit map mode. Up to 8 unique sprites
  can be displayed simultaneously, each defined by 63 bytes in memory which
  are displayed as a 24*21 dot array (shown below). A number of special
  features make sprites especially suited for video graphics and game
  applications.


                              sprite DISPLAY BLOCK
                        |  BYTE  |  BYTE  |  BYTE  |
                        |   00   |   01   |   02   |
                        |   03   |   04   |   05   |
                        |    .   |    .   |    .   |
                        |    .   |    .   |    .   |
                        |    .   |    .   |    .   |
                        |   57   |   58   |   59   |
                        |   60   |   61   |   62   |"
Can you describe the LDA?,"LDA - LOAD THE ACCUMULATOR

    In 6510 assembly language, mnemonics are always three characters. LDA
  represents 'load accumulator with...', and what the accumulator should be
  loaded with is decided by the parameter(s) associated with that
  instruction. The assembler knows which token is represented by each
  mnemonic, and when it 'assembles' an instruction, it simply puts into
  memory (at whatever address has been specified), the token, and what
  parameters, are given. Some assemblers give error messages, or warnings
  when you try to assemble something that either the assembler, or the 6510
  microprocessor, cannot do.
    If you put a '#' symbol in front of the parameter associated with the
  instruction, this means that you want the register specified in the
  instruction to be loaded with the 'value' after the '#'. For example:

    LDA #$05  <----[ $=HEX ]

  This instruction will put $05 (decimal 5) into the accumulator register.
  The assembler will put into the specified address for this instruction,
  $A9 (which is the token for this particular instruction, in this mode),
  and it will put $05 into the next location after the location containing
  the instruction ($A9).
    If the parameter to be used by an instruction has '#' before it; i.e.,
  the parameter is a 'value,' rather than the contents of a memory loca-
  tion, or another register, the instruction is said to be in the
  'immediate' mode. To put this into perspective, let's compare this with
  another mode:
    If you want to put the contents of memory location $102E into the
  accumulator, you're using the 'absolute' mode of instruction:

    LDA $102E

  The assembler can distinguish between the two different modes because the
  latter does not have a '#' before the parameter. The 6510 microprocessor
  can distinguish between the immediate mode, and the absolute mode of the
  LDA instruction, because they have slightly different tokens. LDA
  (immediate) has $A9 as its token, and LDA (absolute), has $AD as its
  token."
What is the  instruction that clears the interrupt disable bit?,"CLI                  CLI Clear interrupt disable bit                  CLI


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLI                 |    58   |    1    |    2     |"
What is the maximum addressable memory location that a sprite pointer can point to?,"SPRITE POINTERS

    Even though each sprite takes only 63 bytes to define, one more byte
  is needed as a place holder at the end of each sprite. Each sprite, then,
  takes up 64 bytes. This makes it easy to calculate where in memory your
  sprite definition is, since 64 bytes is an even number and in binary it's
  an even power.
    Each of the 8 sprites has a byte associated with it called the SPRITE
  POINTER. The sprite pointers control where each sprite definition is lo-
  cated in memory. These 8 bytes are always located as the lost 8 bytes
  of the 1K chunk of screen memory. Normally, on the Commodore 64, this
  means they begin at location 2040 ($07F8 in HEX). However, if you move
  the screen, the location of your sprite pointers will also move.
    Each sprite pointer can hold a number from 0 to 255. This number points
  to the definition for that sprite. Since each sprite definition takes
  64 bytes, that means that the pointer can 'see' anywhere in the 16K
  block of memory that the VIC-II chip can access (since 256*64=16K)."
What is the primary advantage of using multi-color mode graphics over standard high-resolution graphics?,"MULTI-COLOR MODE GRAPHICS

    Standard high-resolution graphics give you control of very small dots
  on the screen. Each dot in character memory can have 2 possible values,
  1 for on and 0 for off. When a dot is off, the color of the screen is
  used in the space reserved for that dot. If the dot is on, the dot is
  colored with the character color you have chosen for that screen posi-
  tion. When you're using standard high-resolution graphics, all the dots
  within each 8X8 character can either have background color or foreground
  color. In some ways this limits the color resolution within that space.
  For example, problems may occur when two different colored lines cross.
    Multi-color mode gives you a solution to this problem. Each dot in
  multi-color mode can be one of 4 colors: screen color (background color
  register #0), the color in background register #1, the color in back-
  ground color register #2, or character color. The only sacrifice is in
  the horizontal resolution, because each multi-color mode dot is twice as
  wide as a high-resolution dot. This minimal loss of resolution is more
  than compensated for by the extra abilities of multi-color mode."
What is the purpose of the interrupt register?,"INTERRUPT REGISTER

    The interrupt register shows the status of the four sources of
  interrupt. An interrupt latch in register 25 ($19) is set to '1' when an
  interrupt source has generated an interrupt request. The four sources of
  interrupt are:

   LATCH |ENABLE|
    BIT  | BIT  |                       WHEN SET
    IRST | ERST | Set when (raster count) = (stored raster count)
    IMDC | EMDC | Set by sprite-DATA collision register (first collision only)
    IMMC | EMMC | Set by sprite-sprite collision register (first collision only)
    ILP  | ELP  | Set by negative transition of LP input (once per frame)
    IRQ  |      | Set high by latch set and enabled (invert of /IRQ output)

    To enable an interrupt request to set the /IRQ output to '0', the
  corresponding interrupt enable bit in register 26 ($1A) must be set to
  '1'. Once an interrupt latch has been set, the latch may be cleared only
  by writing a '1' to the desired latch in the interrupt register. This
  feature allows selective handling of video interrupts without software
  required to 'remember' active interrupts."
given the SID register description,"SID REGISTER DESCRIPTION

  VOICE 1

  FREQ LO/FREQ HI (Registers 00,01)

    Together these registers form a 16-bit number which linearly controls
  the frequency of Oscillator 1 . The frequency is determined by the
  following equation:

                       Fout = (Fn*Fclk/16777216) Hz

    Where Fn is the 16-bit number in the Frequency registers and Fclk is
  the system clock applied to the 02 input (pin 6). For a standard 1.0-MHz
  clock, the frequency is given by:

                       Fout = (Fn*0.059604645) Hz

    A complete table of values for generating 8 octaves of the equally
  tempered musical scale with concert A (440 Hz) tuning is provided in
  Appendix E. It should be noted that the frequency resolution of SID is
  sufficient for any tuning scale and allows sweeping from note to note
  (portamento) with no discernable frequency steps."
What is the primary function of the built-in dynamic RAM refresh controller in the 6566/6567 devices?,"DYNAMIC RAM REFRESH

    A dynamic ram refresh controller is built in to the 6566/6567 devices.
  Five 8-bit row addresses are refreshed every raster line. This rate
  guarantees a maximum delay of 2.02 ms between the refresh of any single
  row address in a 128 refresh scheme. (The maximum delay is 3.66 ms in a
  256 address refresh scheme.) This refresh is totally transparent to the
  system, since the refresh occurs during Phase 1 of the system clock. The
  6567 generates both /RAS and /CAS which are normally connected directly
  to the dynamic rams. /RAS and /CAS are generated for every Phase 2 and
  every video data access (including refresh) so that external clock
  generation is not required.


  RESET"
What is the size of a standard (HI-RES) sprite in terms of dots?,"DEFINING A SPRITE

    Sprites are defined like programmable characters are defined. However,
  since the size of the sprite is larger, more bytes are needed. A sprite
  is 24 by 21 dots, or 504 dots. This works out to 63 bytes (504/8 bits)

    A way to view how a sprite is created is to take a look at the
  sprite definition block on the bit level. 

  In a standard (HI-RES) sprite, each bit set to I is displayed in that
  sprite's foreground color. Each bit set to 0 is transparent and will
  display whatever data is behind it. This is similar to a standard
  character.
    Multi-color sprites are similar to multi-color characters. Horizontal
  resolution is traded for extra color resolution. The resolution of the
  sprite becomes 12 horizontal dots by 21 vertical dots. Each dot in the
  sprite becomes twice as wide, but the number of colors displayable in the
  sprite is increased to 4."
What is the assembly language instruction that sets the carry flag to 0 and clears the overflow flag?,"CLV                      CLV Clear overflow flag                      CLV


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Implied       |   CLV                 |    B8   |    1    |    2     |"
What is the instruction that performs a bitwise left shift of the value in the specified memory location or accumulator by one bit?,"ASL          ASL Shift Left One Bit (Memory or Accumulator)           ASL

 Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  Accumulator   |   ASL A               |    0A   |    1    |    2     |
  Zero Page     |   ASL Oper            |    06   |    2    |    5     |
  Zero Page,X   |   ASL Oper,X          |    16   |    2    |    6     |
  Absolute      |   ASL Oper            |    0E   |    3    |    6     |
  Absolute, X   |   ASL Oper,X          |    1E   |    3    |    7     |"
What is the list of user-callable kernel routines in the KERNAL?,"USER CALLABLE KERNAL ROUTINES
  
  
  NOM - ADDRESS - FUNCTION
  | ACPTR  |  $FFA5  |  65445  |  Input byte from serial port             |
  | CHKIN  |  $FFC6  |  65478  |  Open channel for input                  |
  | CHKOUT |  $FFC9  |  65481  |  Open channel for output                 |
  | CHRIN  |  $FFCF  |  65487  |  Input character from channel            |
  | CHROUT |  $FFD2  |  65490  |  Output character to channel             |
  | CIOUT  |  $FFA8  |  65448  |  Output byte to serial port              |
  | CINT   |  $FF81  |  65409  |  Initialize screen editor                |
  | CLALL  |  $FFE7  |  65511  |  Close all channels and files            |
  | CLOSE  |  $FFC3  |  65475  |  Close a specified logical file          |
  | CLRCHN |  $FFCC  |  65484  |  Close input and output channels         |
  | GETIN  |  $FFE4  |  65508  |  Get character from keyboard queue       |
  |        |         |         |  (keyboard buffer)                       |
  | IOBASE |  $FFF3  |  65523  |  Returns base address of I/O devices     |
  | IOINIT |  $FF84  |  65412  |  Initialize input/output                 |
  | LISTEN |  $FFB1  |  65457  |  Command devices on the serial bus to    |
  |        |         |         |  LISTEN                                  |
  | IOBASE |  $FFF3  |  65523  |  Returns base address of I/O devices     |
  | IOINIT |  $FF84  |  65412  |  Initialize input/output                 |
  | LISTEN |  $FFB1  |  65457  |  Command devices on the serial bus to    |
  |        |         |         |  LISTEN                                  |
  | LOAD   |  $FFD5  |  65493  |  Load RAM from a device                  |
  | MEMBOT |  $FF9C  |  65436  |  Read/set the bottom of memory           |
  | MEMTOP |  $FF99  |  65433  |  Read/set the top of memory              |
  | OPEN   |  $FFC0  |  65472  |  Open a logical file                     |
  | PLOT   |  $FFF0  |  65520  |  Read/set X,Y cursor position            |
  | RAMTAS |  $FF87  |  65415  |  Initialize RAM, allocate tape buffer,   |
  |        |         |         |  set screen $0400                        |
  | RDTIM  |  $FFDE  |  65502  |  Read real time clock                    |
  | READST |  $FFB7  |  65463  |  Read I/O status word                    |
  | RESTOR |  $FF8A  |  65418  |  Restore default I/O vectors             |
  | SAVE   |  $FFD8  |  65496  |  Save RAM to device                      |
  | SCNKEY |  $FF9F  |  65439  |  Scan keyboard                           |
  | SCREEN |  $FFED  |  65517  |  Return X,Y organization of screen       |
  | SECOND |  $FF93  |  65427  |  Send secondary address after LISTEN     |
  | SETLFS |  $FFBA  |  65466  |  Set logical, first, and second addresses|
  | SETMSG |  $FF90  |  65424  |  Control KERNAL messages                 |
  | SETNAM |  $FFBD  |  65469  |  Set file name                           |
  | SETTIM |  $FFDB  |  65499  |  Set real time clock                     |
  | SETTMO |  $FFA2  |  65442  |  Set timeout on serial bus               |
  | STOP   |  $FFE1  |  65505  |  Scan stop key                           |
  | TALK   |  $FFB4  |  65460  |  Command serial bus device to TALK       |
  | TKSA   |  $FF96  |  65430  |  Send secondary address after TALK       |
  | UDTIM  |  $FFEA  |  65514  |  Increment real time clock               |
  | UNLSN  |  $FFAE  |  65454  |  Command serial bus to UNLISTEN          |
  | UNTLK  |  $FFAB  |  65451  |  Command serial bus to UNTALK            |
  | VECTOR |  $FF8D  |  65421  |  Read/set vectored I/O                   |"
Describe the multicolor Bitmap mode,"MULTI-COLOR BIT MAP MODE (BMM = MCM = 1)

    Multi-colored bit map mode is selected by setting the MCM bit in
  register 22 ($16) to a '1' in conjunction with the BMM bit. Multi-color
  mode uses the same memory access sequences as standard bit map mode, but
  interprets the dot data as follows:

        BIT PAIR      |                   DISPLAY COLOR
           00         |  Background #0 color (register 33 ($21))
           01         |  Upper nybble of video matrix pointer
           10         |  Lower nybble of video matrix pointer
           11         |  Video matrix color nybble

  Note that the color nybble (DB11-DB8) IS used for the multi-color bit map
  mode. Again, as two bits are used to select one dot color, the horizontal
  dot size is doubled, resulting in a screen resolution of 160H*200V.
  Utilizing multi-color bit map mode, three independently selected colors
  can be displayed in each 8*8 block in addition to the background color."
What is the primary function of the Serial Port (SDR)?,"Serial Port (SDR)

    The serial port is a buffered, 8-bit synchronous shift register system.
  A control bit selects input or output mode. In input mode, data on the SP
  pin is shifted into the shift register on the rising edge of the signal
  applied to the CNT pin. After 8 CNT pulses, the data in the shift
  register is dumped into the Serial Data Register and an interrupt is
  generated. In the output mode, TIMER A is used for the baud rate
  generator. Data is shifted out on the SP pin at 1/2 the underflow rate of
  TIMER A. The maximum baud rate possible is 02 divided by 4, but the
  maximum useable baud rate will be determined by line loading and the
  speed at which the receiver responds to input data. Transmission will
  start following a write to the Serial Data Register (provided TIMER A is
  running and in continuous mode). The clock signal derived from TIMER A
  appears as an output on the CNT pin. The data in the Serial Data Register
  will be loaded into the shift register then shift out to the SP pin when
  a CNT pulse occurs. Data shifted out becomes valid on the falling edge of
  CNT and remains valid until the next falling edge. After 8 CNT pulses, an
  interrupt is generated to indicate more data can be sent. If the Serial
  Data Register was loaded with new information prior to this interrupt,
  the new data will automatically be loaded into the shift register and
  transmission will continue. If the microprocessor stays one byte ahead of
  the shift register, transmission will be continuous. If no further data
  is to be transmitted, after the 8th CNT pulse, CNT will return high and
  SP will remain at the level of the last data bit transmitted. SDR data is
  shifted out MSB first and serial input data should also appear in this
  format.
    The bidirectional capability of the Serial Port and CNT clock allows
  many 6526 devices to be connected to a common serial communication bus on
  which one 6526 acts as a master, sourcing data and shift clock, while all
  other 6526 chips act as slaves. Both CNT and SP outputs are open drain to
  allow such a common bus. Protocol for master/slave selection can be
  transmitted over the serial bus, or via dedicated handshaking lines."
What is the meaning of each bit in the PROCESSOR STATUS REG 'P' register?,"Status Register
                        +-+-+-+-+-+-+-+-+
                        |N|V| |B|D|I|Z|C|  PROCESSOR STATUS REG 'P'
                        +-+-+-+-+-+-+-+-+
                         | |   | | | | |
                         | |   | | | | +>  CARRY         1=TRUE
                         | |   | | | +-->  ZERO          1=RESULT ZERO
                         | |   | | +---->  IRQ DISABLE   1=DISABLE
                         | |   | +------>  DECIMAL MODE  1=TRUE
                         | |   +-------->  BRK COMMAND
                         | |
                         | +------------>  OVERFLOW      1=TRUE
                         +-------------->  NEGATIVE      1=NEG"
What is the number of rows and columns displayed on the screen when the RSEL bit is set to 1 and the CSEL bit is set to 1?,"ROW/COLUMN SELECT

    The normal display consists of 25 rows of 40 characters (or character
  regions) per row. For special display purposes, the display window may be
  reduced to 24 rows and 38 characters. There is no change in the format of
  the displayed information, except that characters (bits) adjacent to the
  exterior border area will now be covered by the border. The select bits
  operate as follows:


    RSEL |      NUMBER OF ROWS        |  CSEL |     NUMBER OF COLUMNS
     0   |          24 rows           |   0   |         38 columns
     1   |          25 rows           |   1   |         40 columns

  The RSEL bit is in register 17 ($11) and the CSEL bit is in register 22
  ($16). For standard display the larger display window is normally used,
  while the smaller display window is normally used in conjunction with
  scrolling."
What is the assembly language instruction that increments the index Y by one?,"INY                    INY Increment Index Y by one                   INY


  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   INY                 |    C8   |    1    |    2     |"
What is the indirect indexed addressing mode?,"INDIRECT INDEXED

    This only allows usage of the Y register as the index. The actual ad-
  dress can only be in zero page, and the mode of instruction is called
  indirect because the zero page address specified in the instruction con-
  tains the low byte of the actual address, and the next byte to it
  contains the high order byte.

 EXAMPLE:

    Let us suppose that location $02 contains $45, and location $03 con-
  tains $1E. If the instruction to load the accumulator in the indirect
  indexed mode is executed and the specified zero page address is $02, then
  the actual address will be:

    Low order = contents of $02
    High order = contents of $03
    Y register = $00

  Thus the actual address = $1E45 + Y = $1E45.
    The title of this mode does in fact imply an indirect principle,
  although this may be difficult to grasp at first sight. Let's look at it
  another way:
    'I am going to deliver this letter to the post office at address $02,
  MEMORY ST., and the address on the letter is $05 houses past $1600,
  MEMORY street.' This is equivalent to the code:

    LDA #$00      - load low order actual base address
    STA $02       - set the low byte of the indirect address
    LDA #$16      - load high order indirect address
    STA $03       - set the high byte of the indirect address
    LDY #$05      - set the indirect index (Y)
    LDA ($02),Y   - load indirectly indexed by Y"
What is the primary strategy for approaching a large task in machine language programming?,"APPROACHING A LARGE TASK

    When approaching a large task in machine language, a certain amount of
  subconscious thought has usually taken place. You think about how certain
  processes are carried out in machine language. When the task is started,
  it is usually a good idea to write it out on paper. Use block diagrams of
  memory usage, functional modules of code required, and a program flow.
  Let's say that you wanted to write a roulette game in machine language.
  You could outline it something like this:

    o Display title
    o Ask if player requires instructions
    o YES - display them-Go to START
    o NO - Go to START
    o START Initialize everything
    o MAIN display roulette table
    o Take in bets
    o Spin wheel
    o Slow wheel to stop
    o Check bets with result
    o Inform player
    o Player any money left?
    o YES - Go to MAIN
    o NO - Inform user!, and go to START


    This is the main outline. As each module is approached, you can break
  it down further. If you look at a large indigestable problem as something
  that can be broken down into small enough pieces to be eaten, then you'll
  be able to approach something that seems impossible, and have it all fall
  into place.
    This process only improves with practice, so KEEP TRYING."
How do I unexpand a sprite in horizontal direction ?,"To unexpand a sprite in the horizontal direction, the corresponding bit
  in the VIC-II control register at location 53277 ($D01D in HEX) must be
  turned OFF (set to a 0). The following POKE 'unexpands' a sprite in the
  X direction:

    POKE 53277,PEEK(53277)AND (255-2^SN)

  where SN is the sprite number from 0 to 7.
    To expand a sprite in the vertical direction, the corresponding bit in
  the VIC-II control register at location 53271 ($D017 in HEX) must be
  turned ON (set to a 1). The following POKE expands a sprite in the Y
  direction:

    POKE 53271,PEEK(53271)OR(2^SN)

  where SN is the sprite number from 0 to 7.

     
   To expand a sprite in the horizontal direction, the corresponding bit
  in the VIC-II control register at location 53277 ($D01D in HEX) must be
  turned ON (set to a 1). The following POKE expands a sprite in the X
  direction:

    POKE 53277,PEEK(53277)OR(2^SN)

  where SN is the sprite number from 0 to 7."
What is the condition required for accessing the device registers?,"DATA BUS (DB7-DB0)

    The eight data bus pins are the bidirectional data port, controlled by
  /CS, RW, and Phase 0. The data bus can only be accessed while AEC and
  Phase 0 are high and /CS is low.

  CHIP SELECT (/CS)

    The chip select pin, /CS, is brought low to enable access to the device
  registers in conjunction with the address and RW pins. /CS low is recog-
  nized only while AEC and Phase 0 are high."
What is the primary function of the 6581 Sound Interface Device (SID)?,"6581 SOUND INTERFACE DEVICE (SID)
  CHIP SPECIFICATIONS
  CONCEPT

    The 6581 Sound Interface Device (SID) is a single-chip, 3-voice elec-
  tronic music synthesizer/sound effects generator compatible with the 65XX
  and similar microprocessor families. SID provides wide-range, high-
  resolution control of pitch (frequency), tone color (harmonic content),
  and dynamics (volume). Specialized control circuitry minimizes software
  overhead, facilitating use in arcade/home video games and low-cost
  musical instruments.


  FEATURES

  o 3 TONE OSCILLATORS
        Range: 0-4 kHz
  o 4 WAVEFORMS PER OSCILLATOR
        Triangle, Sawtooth,
        Variable Pulse, Noise
  o 3 AMPLITUDE MODULATORS
        Range: 48 dB
  o 3 ENVELOPE GENERATORS
        Exponential response
        Attack Rate: 2 ms-8 s
        Decay Rate: 6 ms-24 s
        Sustain Level: 0-peak volume
        Release Rate: 6 ms-24 s
  o OSCILLATOR SYNCHRONIZATION
  o RING MODULATION
  o PROGRAMMABLE FILTER
        Cutoff range: 30 Hz-12 kHz
        12 dB/octave Rolloff
        Low pass, Bandpass,
        High pass, Notch outputs
        Variable Resonance
  o MASTER VOLUME CONTROL
  o 2 A/D POT INTERFACES
  o RANDOM NUMBER/MODULATION GENERATOR
  o EXTERNAL AUDIO INPUT"
How do you unexpand a sprite in the vertical direction?,"To unexpand a sprite in the vertical direction, the corresponding bit
  in the VIC-II control register at location 53271 ($D017 in HEX) must be
  turned OFF (set to a 0). The following POKE 'unexpands' a sprite in the
  Y direction:

    POKE 53271,PEEK(53271)AND (255-2^SN)

  where SN is the sprite number from 0 to 7."
What is the standard character mode ?,"STANDARD CHARACTER MODE

    Standard character mode is the mode the Commodore 64 is in when you
  first turn it on. It is the mode you will generally program in.
    Characters can be taken from ROM or from RAM, but normally they are
  taken from ROM. When you want special graphics characters for a program,
  all you have to do is define the new character shapes in RAM, and tell
  the VIC-II chip to get its character information from there instead of
  the character ROM. This is covered in more detail in the next section.
    In order to display characters on the screen in color, the VIC-II chip
  accesses the screen memory to determine the character code for that
  location on the screen. At the same time, it accesses the color memory to
  determine what color you want for the character displayed. The character
  code is translated by the VIC-II into the starting address of the 8-byte
  block holding your character pattern. The 8-byte block is located in
  character memory.
    The translation isn't too complicated, but a number of items are com-
  bined to generate the desired address. First the character code you use
  to POKE screen memory is multiplied by 8. Next add the start of char-
  acter memory (see CHARACTER MEMORY section). Then the Bank Select Bits
  are taken into account by adding in the base address (see VIDEO BANK
  SELECTION section). Below is a simple formula to illustrate what happens:
  CHARACTER ADDRESS = SCREEN CODE*8+(CHARACTER SET*2048)+(BANK*16384)"
What are some essential tips and strategies for a beginner to learn and master machine language programming?,"USEFUL TIPS FOR THE BEGINNER

    One of the best ways to learn machine language is to look at other
  peoples' machine language programs. These are published all the time in
  magazines and newsletters. Look at them even if the article is for a
  different computer, which also uses the 6510 (or 6502) microprocessor.
  You should make sure that you thoroughly understand the code that you
  look at. This will require perseveres I ce, especially when you see a new
  technique that you have never come across before. This can be infuriat-
  ing, but if patience prevails, you will be the victor.
    Having looked at other machine language programs, you MUST write your
  own. These may be utilities for your BASIC programs, or they may be an
  all machine language program.
    You should also use the utilities that are available, either IN your
  computer, or in a program, that aid you in writing, editing, or tracking
  down errors in a machine language program. An example would be the
  KERNAL, which allows you to check the keyboard, print text, control
  peripheral devices like disk drives, printers, modems, etc., manage
  memory and the screen. It is extremely powerful and it is advised
  strongly that it is used (refer to KERNAL section, Page 268).
    Advantages of writing programs in machine language:

    1. Speed - Machine language is hundreds, and in some cases thousands of
       times faster than a high level language such as BASIC.

    2. Tightness - A machine language program can be made totally
       'watertight,' i.e., the user can be made to do ONLY what the program
        allows, and no more. With a high level language, you are relying on
        the user not 'crashing' the BASIC interpreter by entering, for
        example, a zero which later causes a:


  ?DIVISION BY ZERO ERROR IN LINE 830

  READY.


  In essence, the computer can only be maximized by the machine language
  programmer."
What is indexing in the context of the 6510 microprocessor?,"INDEXING

    Indexing plays an extremely important part in the running of the 6510
  microprocessor. It can be defined as 'creating an actual address from a
  base address plus the contents of either the X or Y index registers.'
    For example, if X contains $05, and the microprocessor executes an LDA
  instruction in the 'absolute X indexed mode' with base address (e.g.,
  $9000), then the actual location that is loaded into the A register is
  $9000 + $05 = $9005. The mnemonic format of an absolute indexed
  instruction is the same as an absolute instruction except a ',X' or ',Y'
  denoting the index is added to the address.

  EXAMPLE:

    LDA $9000,X

    There are absolute indexed, zero page indexed, indirect indexed, and
  indexed indirect modes of addressing available on the 6510
  microprocessor."
What is the assembly language instruction that increments the index register by one?,"INX                    INX Increment Index X by one                   INX
                                                        N Z C I D V
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   INX                 |    E8   |    1    |    2     |"
How can I scroll the screen?,"SCROLLING

    The display data may be scrolled up to one entire character space in
  both the horizontal and vertical direction. When used in conjunction with
  the smaller display window (above), scrolling can be used to create a
  smooth panning motion of display data while updating the system memory
  only when a new character row (or column) is required. Scrolling is also
  used to center a fixed display within the display window.

           BITS         |      REGISTER      |          FUNCTION
         X2,X1,X0       |      22 ($16)      |     Horizontal Position
         Y2,Y1,Y0       |      17 ($11)      |     Vertical Position"
What is the list of instructions in the 6502 microprocessor?,"INSTRUCTION SET - ALPHABETIC SEQUENCE

          ADC   Add Memory to Accumulator with Carry
          AND   'AND' Memory with Accumulator
          ASL   Shift left One Bit (Memory or Accumulator)
          BCC   Branch on Carry Clear
          BCS   Branch on Carry Set
          BEQ   Branch on Result Zero
          BIT   Test Bits in Memory with Accumulator
          BMI   Branch on Result Minus
          BNE   Branch on Result not Zero
          BPL   Branch on Result Plus
          BRK   Force Break
          BVC   Branch on Overflow Clear
          BVS   Branch on Overflow Set
          CLC   Clear Carry Flag
          CLD   Clear Decimal Mode
          CLI   Clear Interrupt Disable Bit
          CLV   Clear Overflow Flag
          CMP   Compare Memory and Accumulator
          CPX   Compare Memory and Index X
          CPY   Compare Memory and Index Y
          DEC   Decrement Memory by One
          DEX   Decrement Index X by One
          DEY   Decrement Index Y by One
          EOR   'Exclusive-OR' Memory with Accumulator
          INC   Increment Memory by One
          INX   Increment Index X by one
          INY   Increment Index Y by one
          JMP   Jump to New location
          JSR   Jump to New Location Saving Return Address
          LDA   Load Accumulator with Memory
          LDX   Load Index X with Memory
          LDY   Load Index Y with Memory
          LSR   Shift One Bit Right (Memory or Accumulator)
          NOP   No Operation
          ORA   'OR' Memory with Accumulator
          PHA   Push Accumulator on Stack
          PHP   Push Processor Status on Stack
          PLA   Pull Accumulator from Stack
          PLP   Pull Processor Status from Stack
          ROL   Rotate One Bit Left (Memory or Accumulator)
          ROR   Rotate One Bit Right (Memory or Accumulator)
          RTI   Return from Interrupt
          RTS   Return from Subroutine
          SBC   Subtract Memory from Accumulator with Borrow
          SEC   Set Carry Flag
          SED   Set Decimal Mode
          SEI   Set Interrupt Disable Status
          STA   Store Accumulator in Memory
          STX   Store Index X in Memory
          STY   Store Index Y in Merrory
          TAX   Transfer Accumulator to Index X
          TAY   Transfer Accumulator to Index Y
          TSX   Transfer Stack Pointer to Index X
          TXA   Transfer Index X to Accumulator
          TXS   Transfer Index X to Stack Register
          TYA   Transfer Index Y to Accumulator"
What is the purpose of the Reset signal in the 6510 microprocessor?,"SIGNAL DESCRIPTION

  Clocks (01, 02)

    The 6510 requires a two-phase non-overlapping clock that runs at the
  Vcc voltage level.

  Address Bus (A0-A15)

    These outputs are TTL compatible, capable of driving one standard TTL
  load and 130 pf.

  Data Bus (D0-D7)

    Eight pins are used for the data bus. This is a Bi-Directional bus,
  transferring data to and from the device and peripherals. The outputs are
  tri-state buffers capable of driving one standard TTL load and 130 pf.

  Reset

    This input is used to reset or start the microprocessor from a power
  down condition. During the time that this line is held low, writing to or
  from the microprocessor is inhibited. When a positive edge is detected on
  the input, the microprocessor will immediately begin the reset sequence.
    After a system initialization time of six clock cycles, the mask
  interrupt flag will be set and the microprocessor will load the program
  counter from the memory vector locations FFFC and FFFD. This is the start
  location for program control.
    After Vcc reaches 4.75 volts in a power-up routine, reset must be held
  low for at least two clock cycles. At this time the R/W signal will
  become valid.
    When the reset signal goes high following these two clock cycles, the
  microprocessor will proceed with the normal reset procedure detailed
  above.

  Interrupt Request (/IRQ)

    This TTL level input requests that an interrupt sequence begin within
  the microprocessor. The microprocessor will complete the current in-
  struction being executed before recognizing the request. At that time,
  the interrupt mask bit in the Status Code Register will be examined. If
  the interrupt mask flag is not set, the microprocessor will begin an

   interrupt sequence. The Program Counter and Processor Status Register are
  stored in the stack. The microprocessor will then set the interrupt mask
  flag high so that no further interrupts may occur. At the end of this
  cycle, the program counter low will be loaded from address FFFE, and
  program counter high from location FFFF, therefore transferring program
  control to the memory vector located at these addresses.

  Address Enable Control (AEC)

    The Address Bus is valid only when the Address Enable Control line is
  high. When low, the Address Bus is in a high-impedance state. This
  feature allows easy DMA and multiprocessor systems.

  I/O Port (P0-P7)

    Six pins are used for the peripheral port, which can transfer data to
  or from peripheral devices. The Output Register is located in RAM at
  address 0001, and the Data Direction Register is at Address 0000. The
  outputs are capable at driving one standard TTL load and 130 pf.

  Read/Write (R/W)

    This signal is generated by the microprocessor to control the direction
  of data transfers on the Data Bus. This line is high except when the
  microprocessor is writing to memory or a peripheral device."
What are the key features of the 6526 Complex Interface Adapter (CIA) chip?,"6526 COMPLEX INTERFACE ADAPTER
  (CIA) CHIP SPECIFICATIONS

  DESCRIPTION

    The 6526 Complex Interface Adapter (CIA) is a 65XX bus compatible
  peripheral interface device with extremely flexible timing and I/O
  capabilities.


  FEATURES

  o 16 Individually programmable 110 lines
  o 8 or 16-Bit handshaking on read or write
  o 2 independent, linkable 16-Bit interval timers
  o 24-hour (AM/PM) time of day clock with programmable alarm
  o 8-Bit shift register for serial I/O
  o 2 TTL load capability
  o CMOS compatible I/O lines
  o 1 or 2 MHz operation available"
What is the purpose of the Indexed Indirect addressing mode in 6502 assembly language?,"INDEXED INDIRECT

    Indexed indirect only allows usage of the X register as the index. This
  is the some as indirect indexed, except it is the zero page address of
  the pointer that is indexed, rather than the actual base address.
  Therefore, the actual base address IS the actual address because the
  index has already been used for the indirect. Index indirect would also
  be used if a table of indirect pointers were located in zero page memory,
  and the X register could then specify which indirect pointer to use.

 EXAMPLE:

    Let us suppose that location $02 contains $45, and location $03 con-
  tains $10. If the instruction to load the accumulator in the indexed
  indirect mode is executed and the specified zero page address is $02,
  then the actual address will be:

    Low order = contents of ($02+X)
    High order = contents of ($03+X)
    X register = $00

  Thus the actual pointer is in = $02 + X = $02.
    Therefore, the actual address is the indirect address contained in $02
  which is again $1045.
    The title of this mode does in fact imply the principle, although it
  may be difficult to grasp at first sight. Look at it this way:
    'I am going to deliver this letter to the fourth post office at address
  $01,MEMORY ST., and the address on the letter will then be delivered to
  $1600, MEMORY street.' This is equivalent to the code:


    LDA #$00    - load low order actual base address
    STA $06     - set the low byte of the indirect address
    LDA #$16    - load high order indirect address
    STA $07     - set the high byte of the indirect address
    LDX #$05    - set the indirect index (X)
    LDA ($02,X) - load indirectly indexed by X"
How can you create your own character sets on the Commodore 64?,"PROGRAMMABLE CHARACTERS

    Since the characters are stored in ROM, it would seem that there is no
  way to change them for customizing characters. However, the memory
  location that tells the VIC-II chip where to find the characters is a
  programmable register which can be changed to point to many sections of
  memory. By changing the character memory pointer to point to RAM, the
  character set may be programmed for any need.
    If you want your character set to be located in RAM, there are a few
  VERY IMPORTANT things to take into account when you decide to actually
  program your own character sets. In addition, there are two other
  important points you must know to create your own special characters:

    1) It is an all or nothing process. Generally, if you use your own
       character set by telling the VIC-II chip to get the character
       information from the area you have prepared in RAM, the standard
     Commodore 64 characters are unavailable to you. To solve this, you
     must copy any letters, numbers, or standard Commodore 64 graphics you
     intend to use into your own character memory in RAM. You can pick and
     choose, take only the ones you want, and don't even have to keep them
     in order!

    2) Your character set takes memory space away from your BASIC program.
       Of course, with 38K available for a BASIC program, most applications
       won't have problems.
   WARNING: You must be careful to protect the character set from being  
   overwritten by your BASIC program, which also uses the RAM.           

    There are two locations in the Commodore 64 to start your character set
  that should NOT be used with BASIC: location 0 and location 2048. The
  first should not be used because the system stores important data on
  page 0. The second can't be used because that is where your BASIC program
  starts! However, there are 6 other starting positions for your custom
  character set.
    The best place to put your character set for use with BASIC while
  experimenting is beginning at 12288 ($3000 in HEX). This is done by
  POKEing the low 4 bits of location 53272 with 12."
What is the purpose of the AEC signal in the 6566/6567 video controller devices?,"THEORY OF OPERATION

  SYSTEM INTERFACE

    The 6566/6567 video controller devices interact with the system data
  bus in a special way. A 65XX system requires the system buses only during
  the Phase 2 (clock high) portion of the cycle. The 6566/6567 devices take
  advantage of this feature by normally accessing system memory during the
  Phase 1 (clock low) portion of the clock cycle. Therefore, operations
  such as character data fetches and memory refresh are totally transparent
  to the processor and do not reduce the processor throughput. The video
  chips provide the interface control signals required to maintain this bus
  sharing.
    The video devices provide the signal AEC (address enable control) which
  is used to disable the processor address bus drivers allowing the video
  device to access the address bus. AEC is active low which, permits direct
  connection to the AEC input of the 65XX family. The AEC signal is
normally activated during Phase 1 so that processor operation is not
  affected. Because of this bus 'sharing', all memory accesses must be
  completed in 1/2 cycle. Since the video chips provide a 1-MHz clock
  (which must be used as system Phase 2), a memory cycle is 500 ns
  including address setup, data access and, data setup to the reading
  device.
    Certain operations of the 6566/6567 require data at a faster rate than
  available by reading only during the Phase 1 time; specifically, the ac-
  cess of character pointers from the video matrix and the fetch of sprite
  data. Therefore, the processor must be disabled and the data accessed
  during the Phase 2 clock. This is accomplished via the BA (bus available)
  signal. The BA line is normally high but is brought low during Phase 1 to
  indicate that the video chip will require a Phase 2 data access. Three
  Phase-2 times are allowed after BA low for the processor to complete any
  current memory accesses. On the fourth Phase 2 after BA low, the AEC
  signal will remain low during Phase 2 as the video chip fetches data. The
  BA line is normally connected to the RDY input of a 65XX processor. The
  character pointer fetches occur every eighth raster line during the
  display window and require 40 consecutive Phase 2 accesses to fetch the
  video matrix pointers. The sprite data fetches require 4 memory accesses as
  follows:


     PHASE 1   | sprite Pointer |   CONDITION: Every raster
     PHASE  2   | sprite Byte 1  | CONDITION : Each raster while sprite is displayed
     PHASE  1   | sprite Byte 2  | CONDITION :  Each raster while sprite is displayed
     PHASE  2   | sprite Byte 3  | CONDITION : Each raster while sprite is displayed


  The sprite pointers are fetched every other Phase 1 at the end of each
  raster line. As required, the additional cycles are used for sprite data
  fetches. Again, all necessary bus control is provided by the 6566/6567
  devices."
What are the key differences in address output configurations between the 6566 and 6567 video interface chips?,"MEMORY INTERFACE

    The two versions of the video interface chip, 6566 and 6567, differ in
  address output configurations. The 6566 has thirteen fully decoded
  addresses for direct connection to the system address bus. The 6567 has
  multiplexed addresses for direct connection to 64K dynamic RAMS. The
  least significant address bits, A06-A00, are present on A06-A00 while
  /RAS is brought low, while the most significant bits, A13-A08, are pres-
  ent on A05-A00 while /CAS is brought low. The pins A11-A07 on the 6567
  are static address outputs to allow direct connection of these bits to a
  conventional 16K (2K*8) ROM. (The lower order addresses require external
  latching.)"
How are characters defined on the Commodore 64?,"CHARACTER DEFINITIONS

    Each character is formed in an 8 by 8 grid of dots, where each dot may
  be either on or off. The Commodore 64 character images are stored in the
  Character Generator ROM chip. The characters are stored as a set of 8
  bytes for each character, with each byte representing the dot pattern of
  a row in the character, and each bit representing a dot. A zero bit means
  that dot is off, and a one bit means the dot is on.
    The character memory in ROM begins at location 53248 (when the I/O
  is switched off). The first 8 bytes from location 53248 ($D000) to 53255
  ($D007) contain the pattern for the @ sign, which has a character code
  value of zero in the screen memory. The next 8 bytes, from location
  53256 ($D008) to 53263 ($D00F), contain the information for forming the
  letter A.

    Each complete character set takes up 2K (2048 bits) of memory, 8 bytes
  per character and 256 characters. Since there are two character sets, one
  for upper case and graphics and the other with upper and lower case, the
  character generator ROM takes up a total of 4K locations."
Wcan you talk about branches and testing in 6502 and 6510?,"BRANCHES AND TESTING

    Another very important principle in machine language is the ability to
  test, and detect certain conditions, in a similar fashion to the 'IF...
  THEN, IF... GOTO' structure in CBM BASIC.
    The various flags in the status register are affected by different in-
  structions in different ways. For example, there is a flag that is set
  when an instruction has caused a zero result, and is reset when a result
  is not zero. The instruction:

    LDA #$00

  will cause the zero result flag to be set, because the instruction has
  resulted in the accumulator containing a zero.
    There are a set of instructions that will, given a particular
  condition, branch to another part of the program. An example of a branch
  instruction is BEQ, which means Branch if result EQual to zero. The
  branch instructions branch if the condition is true, and if not, the
  program continues onto the next instruction, as if nothing had occurred.
  The branch instructions branch not by the result of the previous
  instructions), but by internally examining the status register. As was
  just mentioned, there is a zero result flag in the status register. The
  BEQ instruction branches if the zero result flag (known as Z) is set.
  Every branch instruction has an opposite branch instruction. The BEQ
  instruction has an opposite instruction BNE, which means Branch on result
  Not Equal to zero (i.e., Z not set).
  
    The index registers have a number of associated instructions which
  modify their contents. For example, the INX instruction INcrements the X
  index register. If the X register contained $FF before it was incremented
  (the maximum number the X register can contain), it will 'wrap around'
  back to zero. If you wanted a program to continue to do something until
  you had performed the increment of the X index that pushed it around to
  zero, you could use the BNE instruction to continue 'looping' around,
  until X became zero.
  
    The reverse of INX, is DEX, which is DEcrement the X index register. If
  the X index register is zero, DEX wraps around to $FF. Similarly, there
  are INY and DEY for the Y index register.
 But what if a program didn't want to wait until X or Y had reached (or
  not reached) zero? Well there are comparison instructions, CPX and CPY,
  which allow the machine language programmer to test the index registers
  with specific values, or even the contents of memory locations. If you
  wanted to see if the X register contained $40, you would use the
  instruction:

    CPX #$40         - compare X with the 'value' $40.
    BEQ              - branch to somewhere else in the
    (some other        program, if this condition is 'true.'
     part of the
     program)


  The compare, and branch instructions play a major part in any machine
  language program.
    The operand specified in a branch instruction when using 64MON is the
  address of the part of the program that the branch goes to when the
  proper conditions are met. However, the operand is only an offset, which
  gets you from where the program currently is to the address specified.
  This offset is just one byte, and therefore the range that a branch
  instruction can branch to is limited. It can branch from 128 bytes back-
  ward, to 127 bytes forward.

 
  NOTE: This is a total range of 255 bytes which is, of course, the
  maximum range of values one byte can contain.
  
    64MON will tell you if you 'branch out of range' by refusing to 'as-
  semble' that particular instruction. But don't worry about that now be-
  cause it's unlikely that you will have such branches for quite a while.
  The branch is a 'quick' instruction by machine language standards because
  of the 'offset' principle as opposed to an absolute address. 64MON allows
  you to type in an absolute address, and it calculates the correct offset.
  This is just one of the 'comforts' of using an assembler."
What is the purpose of the ADC instruction in the given table?,"ADC               Add memory to accumulator with carry                ADC


Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
 Immediate     |   ADC #Oper           |    69   |    2    |    2     |
 Zero Page     |   ADC Oper            |    65   |    2    |    3     |
 Zero Page,X   |   ADC Oper,X          |    75   |    2    |    4     |
 Absolute      |   ADC Oper            |    60   |    3    |    4     |
 Absolute,X    |   ADC Oper,X          |    70   |    3    |    4*    |
 Absolute,Y    |   ADC Oper,Y          |    79   |    3    |    4*    |
 (Indirect,X)  |   ADC (Oper,X)        |    61   |    2    |    6     |
 (Indirect),Y  |   ADC (Oper),Y        |    71   |    2    |    5*    |
   * Add 1 if page boundary is crossed."
What are the 6526 interface signals?,"6526 INTERFACE SIGNALS

  02-Clock Input

    The 02 clock is a TTL compatible input used for internal device opera-
  tion and as a timing reference for communicating with the system data
  bus.

  /CS-Chip Select Input

    The /CS input controls the activity of the 6526. A low level on /CS
  while 02 is high causes the device to respond to signals on the R/W and
  address (RS) lines. A high on /CS prevents these lines from controlling
  the 6526. The /CS line is normally activated (low) at 02 by the
  appropriate address combination.

  R/W-Read/Write Input

    The R/W signal is normally supplied by the microprocessor and controls
  the direction of data transfers of the 6526. A high on R/W indicates
  a read (data transfer out of the 6526), while a low indicates a write
  (data transfer into the 6526).

  RS3-RS0-Address Inputs

    The address inputs select the internal registers as described by the
  Register Map.

  DB7-DB0-Data Bus Inputs/Outputs

    The eight data bus pins transfer information between the 6526 and the
  system data bus. These pins are high impedance inputs unless CS is low
  and R/W and 02 are high to read the device. During this read, the data
  bus output buffers are enabled, driving the data from the selected
  register onto the system data bus.

  IRQ-Interrupt Request Output

    IRQ is an open drain output normally connected to the processor inter-
  rupt input. An external pullup resistor holds the signal high, allowing
  multiple IRQ outputs to be connected together. The IRQ output is normally
  off (high impedance) and is activated low as indicated in the functional
  description.

  /RES-Reset Input

    A low on the RES pin resets all internal registers. The port pins are
  set as inputs and port registers to zero (although a read of the ports
  will return all highs because of passive pullups). The timer control
  registers are set to zero and the timer latches to all ones. All other
  registers are reset to zero."
What are the 9 addressing modes supported by the 6502/ 6510 CPU?,"ADDRESSING MODES

  ACCUMULATOR ADDRESSING - This form of addressing is represented with a
  one byte instruction, implying an operation on the accumulator.

  IMMEDIATE ADDRESSING - In immediate addressing, the operand is contained
  in the second byte of the instruction, with no further memory addressing
  required.

  ABSOLUTE ADDRESSING - In absolute addressing, the second byte of the
  instruction specifies the eight low order bits of the effective address
  while the third byte specifies the eight high order bits. Thus, the
  absolute addressing mode allows access to the entire 64K bytes of
  addressable memory.

  ZERO PAGE ADDRESSING - The zero page instructions allow for shorter code
  and execution times by only fetching the second byte of the instruction
  and assuming a zero high address byte. Careful use of the zero page can
  result in significant increase in code efficiency.

  INDEXED ZERO PAGE ADDRESSING - (X, Y indexing)-This form of addressing is
  used in conjunction with the index register and is referred to as 'Zero
  Page, X' or 'Zero Page, Y.' The effective address is calculated by adding
  the second byte to the contents of the index register. Since this is a
  form of 'Zero Page' addressing, the content of the second byte references
  a location in page zero. Additionally, due to the 'Zero Page' addressing
  nature of this mode, no carry is added to the high order 8 bits of memory
  and crossing of page boundaries does not occur.

  INDEXED ABSOLUTE ADDRESSING - (X, Y indexing)-This form of addressing is
  used in conjunction with X and Y index register and is referred to as
  'Absolute, X,' and 'Absolute, Y.' The effective address is formed by
  adding the contents of X and Y to the address contained in the second and
  third bytes of the instruction. This mode allows the index register to
  contain the index or count value and the instruction to contain the base
  address. This type of indexing allows any location referencing and the
  index to modify multiple fields resulting in reduced coding and execution
  time.

  IMPLIED ADDRESSING - In the implied addressing mode, the address
  containing the operand is implicitly stated in the operation code of the
  instruction.

  RELATIVE ADDRESSING - Relative addressing is used only with branch
  instructions and establishes a destination for the conditional branch.
  The second byte of the instruction becomes the operand which is an
  'Offset' added to the contents of the lower eight bits of the program
  counter when the counter is set at the next instruction. The range of the
  offset is -128 to +127 bytes from the next instruction.

  INDEXED INDIRECT ADDRESSING - In indexed indirect addressing (referred to
  as [Indirect, X]), the second byte of the instruction is added to the
  contents of the X index register, discarding the carry. The result of
  this addition points to a memory location on page zero whose contents is
  the low order eight bits of the effective address. The next memory loca-
  tion in page zero contains the high order eight bits of the effective ad-
  dress. Both memory locations specifying the high and low order bytes of

  the effective address must be in page zero.

  INDIRECT INDEXED ADDRESSING - In indirect indexed addressing (referred to
  as [Indirect], Y), the second byte of the instruction points to a memory
  location in page zero. The contents of this memory location is added to
  the contents of the Y index register, the result being the low order
  eight bits of the effective address. The carry from this addition is
  added to the contents of the next page zero memory location, the result
  being the high order eight bits of the effective address.

  ABSOLUTE INDIRECT - The second byte of the instruction contains the low
  order eight bits of a memory location. The high order eight bits of that
  memory location is contained in the third byte of the instruction. The
  contents of the fully specified memory location is the low order byte of
  the effective address. The next memory location contains the high order
  byte of the effective address which is loaded into the sixteen bits of
  the program counter."
What is the purpose of the SCREEN kernal function in Commodore 64 programming?,"B-26. Function Name: SCREEN

    Purpose: Return screen format
    Call address: $FFED (hex) 65517 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Stack requirements: 2
    Registers affected: X, Y

    Description: This routine returns the format of the screen, e.g., 40
  columns in X and 25 lines in Y. The routine can be used to determine what
  machine a program is running on. This function has been implemented on
  the Commodore 64 to help upward compatibility of your programs.
  How to Use:

    1) Call this routine.

  EXAMPLE:

    JSR SCREEN
    STX MAXCOL
    STY MAXROW"
Give the list of kernal error codes?,"KERNAL ERROR CODES

    The following is a list of error messages which can occur when using
  the KERNAL routines. If an error occurs during a KERNAL routine , the
  carry bit of the accumulator is set, and the number of the error message
  is returned in the accumulator.

  | NOTE: Some KERNAL I/O routines do not use these codes for error       |
  | messages. Instead, errors are identified using the KERNAL READST      |
  | routine.                                                              |


ERROR VALUES
  | NUMBER|                          MEANING                              |
  |   0   |  Routine terminated by the <STOP> key                         |
  |   1   |  Too many open files                                          |
  |   2   |  File already open                                            |
  |   3   |  File not open                                                |
  |   4   |  File not found                                               |
  |   5   |  Device not present                                           |
  |   6   |  File is not an input file                                    |
  |   7   |  File is not an output file                                   |
  |   8   |  File name is missing                                         |
  |   9   |  Illegal device number                                        |
  |  240  |  Top-of-memory change RS-232 buffer allocation/deallocation   |"
What are the five main activities performed by the KERNAL during its power-up sequence?,"KERNAL POWER-UP ACTIVITIES

  1) On power-up, the KERNAL first resets the stack pointer, and clears
     decimal mode.
  2) The KERNAL then checks for the presence of an autostart ROM cartridge
     at location $8000 HEX (32768 decimal). If this is present, normal
     initialization is suspended, and control is transferred to the car-
     tridge code. If an autostart ROM is not present, normal system ini-
     tialization continues.
  3) Next, the KERNAL initializes all INPUT/OUTPUT devices. The serial bus
     is initialized. Both 6526 CIA chips are set to the proper values for
     keyboard scanning, and the 60-Hz timer is activated. The SID chip is
     cleared. The BASIC memory map is selected and the cassette motor is
     switched off.
  4) Next, the KERNAL performs a RAM test, setting the top and bottom of
     memory pointers. Also, page zero is initialized, and the tape buffer
     is set up.
       The RAM TEST routine is a nondestructive test starting at location
     $0300 and working upward. Once the test has found the first non-RAM
     location, the top of RAM has its pointer set. The bottom of memory is
     always set to $0800, and the screen setup is always set at $0400.
  5) Finally, the KERNAL performs these other activities. I/O vectors are
     set to default values. The indirect jump table in low memory is estab-
     lished. The screen is then cleared, and all screen editor variables
     reset. Then the indirect at $A000 is used to start BASIC."
What is the detail for the instruction STA?,"STA                  STA Store accumulator in memory                  STA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   STA Oper            |    85   |    2    |    3     |
  |  Zero Page,X   |   STA Oper,X          |    95   |    2    |    4     |
  |  Absolute      |   STA Oper            |    80   |    3    |    4     |
  |  Absolute,X    |   STA Oper,X          |    90   |    3    |    5     |
  |  Absolute,Y    |   STA Oper, Y         |    99   |    3    |    5     |
  |  (Indirect,X)  |   STA (Oper,X)        |    81   |    2    |    6     |
  |  (Indirect),Y  |   STA (Oper),Y        |    91   |    2    |    6     |"
What is the purpose of the instruction PHA in 6502?,"PHA                   PHA Push accumulator on stack                   PHA

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PHA                 |    48   |    1    |    3     |"
What feature of the VIC-II chip allows for the detection of collisions between sprites and background data?,"COLLISION DETECTS

    One of the more interesting aspects of the VIC-II chip is its collision
  detection abilities. Collisions can be detected between sprites, or be-
  tween sprites and background data. A collision occurs when a non-zero
  part of a sprite overlaps a non-zero portion of another sprite or char-
  acters on the screen."
What is the primary way to access and modify the memory locations used for music synthesis in the Commodore 64?,"Your Commodore computer is equipped with one of the most sophisticated
  electronic music synthesizers available on any computer. It comes
  complete with three voices, totally addressable, ATTACK/DECAY/SUSTAIN/
  RELEASE (ADSR), filtering, modulation, and 'white noise.' All of these
  capabilities are directly available for you through a few easy to use
  BASIC and/or assembly language statements and functions. This means that
  you can make very complex sounds and songs using programs that are
  relatively simple to design.
    This section of your Programmer's Reference Guide has been created to
  help you explore all the capabilities of the 6581 'SID' chip, the sound
  and music synthesizer inside your Commodore computer. We'll explain both
  the theory behind musical ideas and the practical aspects of turning
  those ideas into real finished songs on your Commodore computer.
    You need not be an experienced programmer nor a music expert to achieve
  exciting results from the music synthesizer. This section is full of
  programming examples with complete explanations to get you started.
    You get to the sound generator by POKEing into specified memory
  locations. A full list of the locations used is provided in Appendix O.
  We will go through each concept, step by step. By the end you should be
  able to create an almost infinite variety of sounds, and be ready to
  perform experiments with sound on your own.
    Each section of this chapter begins by giving you an example and a full
  line-by-line description of each program, which will show you how to use
  the characteristic being discussed. The technical explanation is for you
  to read whenever you are curious about what is actually going on. The
  workhorse of your sound programs is the POKE statement. POKE sets the
  indicated memory location (MEM) equal to a specified value (NUM).
    POKE MEM,NUM
    The memory locations (MEM) used for music synthesis start at 54272
  ($D400) in the Commodore 64. The memory locations 54272 to 54296
  inclusive are the POKE locations you need to remember when you're using
  the 6581 (SID) chip register map. Another way to use the locations above
  is to remember only location 54272 and then add a number from 0 through
  24 to it. By doing this you can POKE all the locations from 54272 to
  54296 that you need from the SID chip. The numbers (NUM) that you use in
  your POKE statement must be between 0 and 255, inclusive.
    When you've had a little more practice with making music, then you can
  get a little more involved, by using the PEEK function. PEEK is a
  function that is equal to the value currently in the indicated memory
  location.
    X=PEEK(MEM)

    The value of the variable X is set equal to the current contents of
  memory location MEM.
    Of course, your programs include other BASIC commands, but for a full
  explanation of them, refer to the BASIC Statements section of this
  manual."
HWhat is the process for positioning a sprite beyond the 255th pixel across the screen in a Commodore 64 game?,"POKEING AN X POSITION: The possible values of X are 0 to 255, counting
  from left to right. Values 0 to 23 place all or part of the sprite OUT OF
  THE VIEWING AREA off the left side of the screen... values 24 to 255
  place the sprite IN THE VIEWING AREA up to the 255th position (see next
  paragraph for settings beyond the 255th X position). To place the sprite
  at one of these positions, just type the X-POSITION POKE for the sprite
  you're using. For example, to POKE sprite I at the farthest left X
  position IN THE VIEWING AREA, type: POKE V+2,24.

    X VALUES BEYOND THE 255TH POSITION: To get beyond the 255th position
  across the screen, you need to make a SECOND POKE using the numbers in
  the 'RIGHT X' row of the chart (Figure 3-5). Normally, the horizontal (X)
  numbering would continue past the 255th position to 256, 257, etc., but
  because registers only contain 8 bits we must use a 'second register' to
  access the RIGHT SIDE of the screen and start our X numbering over again
  at 0. So to get beyond X position 255, you must POKE V+16 and a number
  (depending on the sprite). This gives you 65 additional X positions
  (renumbered from 0 to 65) in the viewing area on the RIGHT side of the
  viewing screen. (You can actually POKE the right side X value as high as
  255, which takes you off the right edge of the viewing screen.)

    POKEING A Y POSITION: The possible values of Y are 0 to 255, counting
  from top to bottom. Values 0 to 49 place all or part of the sprite OUT
  OF THE VIEWING AREA off the TOP of the screen. Values 50 to 229 place the
  sprite IN THE VIEWING AREA. Values 230 to 255 place all or part of the
  sprite OUT OF THE VIEWING AREA off the BOTTOM of the screen.

    Let's see how this X-Y positioning works, using sprite 1. Type this
  program:
start tok64 page159.prg
  10 print'{clear}':v=53248:pokev+21,2:poke2041,13
  20 fors=832to895:pokes,255:next:pokev+40,7
  30 pokev+2,24
  40 pokev+3,50
stop tok64

  This simple program establishes sprite 1 as a solid box and positions it
  at the upper left corner of the screen. Now change line 40 to read:

    40 POKE V+3,229

  This moves the sprite to the bottom left corner of the screen. Now let's
  test the RIGHT X LIMIT of the sprite. Change line 30 as shown:

    30 POKE V+2,255

  This moves the sprite to the RIGHT but reaches the RIGHT X LIMIT, which
  is 255. At this point, the 'most significant bit' in register 16 must be
  SET. In other words, you must type POKE V+ 16 and the number shown in the
  'RIGHT X' column in the X-Y POKE CHART above to RESTART the X position
  counter at the 256th pixel/position on the screen. Change line 30 as
  follows:

    30 POKE V+16,PEEK(V+16)OR 2:POKE V+2,0

  POKE V+16,2 sets the most significant bit of the X position for sprite 1
  and restarts it at the 256th pixel/position on the screen. POKE V+2,0
  displays the sprite at the NEW POSITION ZERO, which is now reset to the
  256th pixel.
    To get back to the left side of the screen, you must reset the most
  significant bit of the X position counter to 0 by typing (for sprite 1):

    POKE V+16, PEEK(V+16)AND 253

    TO SUMMARIZE how the X positioning works... POKE the X POSITION for any
  sprite with a number from 0 to 255. To access a position beyond the 255th
  position/pixel across the screen, you must use an additional POKE (V+16)
  which sets the most significant bit of the X position and start counting
  from 0 again at the 256th pixel across the screen.

  This POKE starts the X numbering over again from 0 at the 256th position
  (Example: POKE V+16,PEEK(V+16)OR 1 and POKE V,1 must be included to place
  sprite 0 at the 257th pixel across the screen.) To get back to the left
  side X positions you have to TURN OFF the control setting by typing
  POKE V+16,PEEK(V+16)AND 254."
How do you control sprite to background priority?,"Sprite to background priority is controllable by the SPRITE-BACK-GROUND priority register located at 53275 ($D01B).
  Each sprite has a bit in this register. If that bit is 0, that sprite has a higher priority
  than the background on the screen. In other words, the sprite appears in
  front of background data. If that bit is a 1, that sprite has a lower
  priority than the background. Then the sprite appears behind the back-
  ground data."
What is the PHP instruction in 6502?,"PHP                 PHP Push processor status on stack                PHP

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   PHP                 |    08   |    1    |    3     |"
What is the instruction for storing the value in the X register in memory?,"STX                    STX Store index X in memory                    STX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   STX Oper            |    86   |    2    |    3     |
  |  Zero Page,Y   |   STX Oper,Y          |    96   |    2    |    4     |
  |  Absolute      |   STX Oper            |    8E   |    3    |    4     |"
What are the three simple steps to follow when using the KERNAL?,"HOW TO USE THE KERNAL


    When writing machine language programs it is often convenient to use
  the routines which are already part of the operating system for input/
  output, access to the system clock, memory management, and other similar
  operations. It is an unnecessary duplication of effort to write these
  routines over and over again, so easy access to the operating system
  helps speed machine language programming.
    As mentioned before, the KERNAL is a jump table. This is just a col-
  lection of JMP instructions to many operating system routines.
    To use a KERNAL routine you must first make all of the preparations
  that the routine demands. If one routine says that you must call another
  KERNAL routine first, then that routine must be called. If the routine
  expects you to put a number in the accumulator, then that number must be
  there. Otherwise your routines have little chance of working the way you
  expect them to work.
    After all preparations are made, you must call the routine by means of
  the JSR instruction. All KERNAL routines you can access are structured as
  SUBROUTINES, and must end with an RTS instruction. When the KERNAL
  routine has finished its task, control is returned to your program at the
  instruction after the JSR.
    Many of the KERNAL routines return error codes in the status word or
  the accumulator if you have problems in the routine. Good programming
  practice and the success of your machine language programs demand that
  you handle this properly. If you ignore an error return, the rest of your
  program might 'bomb.'
    That's all there is to do when you're using the KERNAL. Just these
  three simple steps:

    1) Set up
    2) Call the routine
    3) Error handling

    The following conventions are used in describing the KERNAL routines:

  - FUNCTION NAME: Name of the KERNAL routine.

  - CALL ADDRESS: This is the call address of the KERNAL routine, given in
    hexadecimal.

  - COMMUNICATION REGISTERS: Registers listed under this heading are used
    to pass parameters to and from the KERNAL routines.

  - PREPARATORY ROUTINES: Certain KERNAL routines require that data be set
    up before they can operate. The routines needed are listed here.

  - ERROR RETURNS: A return from a KERNAL routine with the CARRY set
    indicates that an error was encountered in processing. The accumulator
    will contain the number of the error.

  - STACK REQUIREMENTS: This is the actual number of stack bytes used by
    the KERNAL routine.

  - REGISTERS AFFECTED: All registers used by the KERNAL routine are listed
    here.

  - DESCRIPTION: A short tutorial on the function of the KERNAL routine is
    given here.

                       USER CALLABLE KERNAL ROUTINES
  +--------+-------------------+------------------------------------------+
  |        |      ADDRESS      |                                          |
  |  NAME  +---------+---------+                 FUNCTION                 |
  |        |   HEX   | DECIMAL |                                          |
  +--------+---------+---------+------------------------------------------+"
On can I mix 6502 assembler and Basic on the Commodore 64?,"There are several methods of using BASIC and machine language on the
  Commodore 64, including special statements as part of CBM BASIC as well
  as key locations in the machine. There are five main ways to use machine
  language routines from BASIC on the Commodore 64. They are:


                1) The BASIC SYS statement
                2) The BASIC USR function
                3) Changing one of the RAM I/O vectors
                4) Changing one of the RAM interrupt vectors
                5) Changing the CHRGET routine


    1) The BASIC statement SYS X causes a JUMP to a machine language
       subroutine located at address X. The routine must end with an RTS
       (ReTurn from Subroutine) instruction. This will transfer control
       back to BASIC.
         Parameters are generally passed between the machine language
       routine and the BASIC program using the BASIC PEEK and POKE
       statements, and their machine language equivalents.
         The SYS command is the most useful method of combining BASIC with
       machine language. PEEKs and POKEs make multiple parameter passing
       easy. There can be many SYS statements in a program, each to a
       different (or even the same) machine language routine.

    2) The BASIC function USR(X) transfers control to the machine language
       subroutine located at the address stored in locations 785 and 786.
       (The address is stored in standard low-byte/high-byte format.) The
       value X is evaluated and passed to the machine language subroutine
       through floating point accumulator #1, located beginning at address
       $61 (see memory map for more details). A value may be returned back
       to the BASIC program by placing it in the floating point
       accumulator. The machine language routine must end with an RTS
       instruction to return to BASIC.
         This statement is different from the SYS, because you have to set
       up an indirect vector. Also different is the format through which
       the variable is passed (floating point format). The indirect vector
       must be changed if more than one machine language routine is used.


    3) Any of the inpUt/OUtPUT or BASIC internal routines accessed through
       the vector table located on page 3 (see ADDRESSING MODES, ZERO PAGE)
       can be replaced, or amended by user code. Each 2-byte vector
       consists of a low byte and a high byte address which is used by the
       operating system.
         The KERNAL VECTOR routine is the most reliable way to change any
       of the vectors, but a single vector can be changed by POKES. A new
       vector will point to a user prepared routine which is meant to
       replace or augment the standard system routine. When the appropriate
       BASIC command is executed, the user routine will be executed. If
       after executing the user routine, it is necessary to execute the
       normal system routine, the user program must JMP (JUMP) to the
       address formerly contained in the vector. If not, the routine must
       end with a RTS to transfer control back to BASIC.

    4) The HARDWARE INTERRUPT (IRQ) VECTOR can be changed. Every 1/60th of
       a second, the operating system transfers control to the routine
       specified by this vector. The KERNAL normally uses this for timing,
       keyboard scanning, etc. If this technique is used, you should always
       transfer control to the normal IRQ handling routine, unless the
       replacement routine is prepared to handle the CIA chip. (REMEMBER to
       end the routine with an RTI (ReTurn from Interrupt) if the CIA is
       handled by the routine).
         This method is useful for tasks which must happen concurrently
       with a BASIC program, but has the drawback of being more difficult.


NOTE: ALWAYS DISABLE INTERRUPTS BEFORE CHANGING THIS VECTOR!

    5) The CHRGET routine is used by BASIC to get each character/token.
       This makes it simple to add new BASIC commands. Naturally, each new
       command must be executed by a user written machine language
       subroutine. A common way to use this method is to specify a
       character (@ for example) which will occur before any of the new
       commands. The new CHRGET routine will search for the special
       character. If none is present, control is passed to the normal BASIC
       CHRGET routine. If the special character is present, the new command
       is interpreted and executed by your machine language program. This
       minimizes the extra execution time added by the need to search for
       additional commands. This technique is often called a wedge."
What is the purpose of the kernal SECOND routine in a computer system?,"B-27. Function Name: SECOND

    Purpose: Send secondary address for LISTEN
    Call address: $FF93 (hex) 65427 (decimal)
    Communication registers: A
    Preparatory routines: LISTEN
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine is used to send a secondary address to an
  I/O device after a call to the LISTEN routine is made, and the device is
  commanded to LISTEN. The routine canNOT be used to send a secondary
  address after a call to the TALK routine.
    A secondary address is usually used to give setup information to a
  device before I/O operations begin.
    When a secondary address is to be sent to a device on the serial bus,
  the address must first be ORed with $60.

  How to Use:

    1) load the accumulator with the secondary address to be sent.
    2) Call this routine.

  EXAMPLE:

    ;ADDRESS DEVICE #8 WITH COMMAND (SECONDARY ADDRESS) #15
    LDA #8
    JSR LISTEN
    LDA #15
    JSR SECOND"
What is the purpose of the VECTOR kernal function?,"Function Name: VECTOR

    Purpose: Manage RAM vectors
    Call address: $FF8D (hex) 65421 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y


    Description: This routine manages all system vector jump addresses
  stored in RAM. Calling this routine with the the accumulator carry bit
  set stores the current contents of the RAM vectors in a list pointed to
  by the X and Y registers. When this routine is called with the carry
  clear, the user list pointed to by the X and Y registers is transferred
  to the system RAM vectors. The RAM vectors are listed in the memory map.


 NOTE: This routine requires caution in its use. The best way to use it
 is to first read the entire vector contents into the user area, alter 
 the desired vectors, and then copy the contents back to the system    
 vectors.                                                              

  How to Use:

  READ THE SYSTEM RAM VECTORS

    1) Set the carry.
    2) Set the X and y registers to the address to put the vectors.
    3) Call this routine.

  LOAD THE SYSTEM RAM VECTORS

    1) Clear the carry bit.
    2) Set the X and Y registers to the address of the vector list in RAM
       that must be loaded.
    3) Call this routine.


  EXAMPLE:
    ;CHANGE THE INPUT ROUTINES TO NEW SYSTEM
    LDX #<USER
    LDY #>USER
    SEC
    JSR VECTOR      ;READ OLD VECTORS
    LDA #<MYINP     ;CHANGE INPUT
    STA USER+10
    LDA #>MYINP
    STA USER+11
    LDX #<USER
    LDY #>USER
    CLC
    JSR VECTOR      ;ALTER SYSTEM
    ...
    USER *=*+26"
What is the purpose of the SCNKEY kernal function in the Commodore 64?,"B-25. Function Name: SCNKEY

    Purpose: Scan the keyboard
    Call address: $FF9F (hex) 65439 (decimal)
    Communication registers: None
    Preparatory routines: IOINIT
    Error returns: None
    Stack requirements: 5
    Registers affected: A, X, Y

    Description: This routine scans the Commodore 64 keyboard and checks
  for pressed keys. It is the same routine called by the interrupt handler.
  If a key is down, its ASCII value is placed in the keyboard queue. This
  routine is called only if the normal IRQ interrupt is bypassed.

  How to Use:

  1) Call this routine.

  EXAMPLE:

    GET  JSR SCNKEY      ;SCAN KEYBOARD
         JSR GETIN       ;GET CHARACTER
         CMP #0          ;IS IT NULL?
         BEQ GET         ;YES... SCAN AGAIN
         JSR CHROUT      ;PRINT IT"
What is the purpose of the two 9-pin Game Ports on the Commodore 64?,"THE GAME PORTS

    The Commodore 64 has two 9-pin Game Ports which allow the use of
  joysticks, paddies, or a light pen. Each port will accept either one joy-
  stick or one paddle pair. A light pen can be plugged into Port A (only)
  for special graphic control, etc. This section gives you examples of how
  to use the joysticks and paddies from both BASIC and machine language.
    The digital joystick is connected to CIA #1 (MOS 6526 Complex Interface
  Adapter). This input/output device also handles the paddle fire buttons
  and keyboard scanning. The 6526 CIA chip has 16 registers which are in
  memory locations 56320 through 56335 inclusive ($DC00 to $DC0F). Port A
  data appears at location 56320 (DC00) and Port B data is found at
  location 56321 ($DC01).
    A digital joystick has five distinct switches, four of the switches are
  used for direction and one of the switches is used for the fire button.



    These switches correspond to the lower 5 bits of the data in location
  56320 or 56321. Normally the bit is set to a one if a direction is NOT
  chosen or the fire button is NOT pressed. When the fire button is
  pressed, the bit (bit 4 in this case) changes to a 0. 
  
  
  
  
  To read the
  joystick from BASIC, the following subroutine should be used:


start tok64 page344.prg
  10 fork=0to10:rem set up direction string
  20 readdr$(k):next
  30 data'','n','s','','w','nw'
  40 data'sw','','e','ne','se'
  50 print'going...';
  60 gosub100:rem read the joystick
  65 ifdr$(jv)=''then80:rem check if a direction was chosen
  70 printdr$(jv);' ';:rem output which direction
  80 iffr=16then60:rem check if fire button was pushed
  90 print'-----f-----i-----r-----e-----!!!':goto60
  100 jv=peek(56320):rem get joystick value
  110 fr=jvand16:rem form fire button status
  120 jv=15-(jvand15):rem form direction value
  130 return
stop tok64

  +-----------------------------------------------------------------------+
  | NOTE: For the second joystick, set JV = PEEK (56321).                 |
  +-----------------------------------------------------------------------+

    The values for JV correspond to these directions:

                       +-------------+---------------+
                       | JV EQUAL TO |   DIRECTION   |
                       +-------------+---------------+
                       |      0      |          NONE |
                       |      1      |            UP |
                       |      2      |          DOWN |
                       |      3      |             - |
                       |      4      |          LEFT |
                       |      5      |     UP & LEFT |
                       |      6      |   DOWN & LEFT |
                       |      7      |             - |
                       |      8      |         RIGHT |
                       |      9      |    UP & RIGHT |
                       |     10      |  DOWN & RIGHT |
                       +-------------+---------------+"
What is the purpose of the instruction TAX in the 6502 assembly language?,"TAX                TAX Transfer accumulator to index X                TAX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TAX                 |    AA   |    1    |    2     |"
WHAT DOES MACHINE CODE LOOK LIKE?,"WHAT DOES MACHINE CODE LOOK LIKE?

    You should be familiar with the PEEK and POKE commands in the CBM BASIC
  language for changing memory locations. You've probably used them for
  graphics on the screen, and for sound effects. Each memory location has
  its own number which identifies it. This number is known as the 'address'
  of a memory location. If you imagine the memory in the Commodore 64 as a
  street of buildings, then the number on each door is, of course, the
  address. Now let's look at which parts of the street are used for what
  purposes."
What is the purpose of the ACPTR  kernal routine in a Commodore 64 system?,"Description: This is the routine to use when you want to get informa-
  tion from a device on the serial bus, like a disk. This routine gets a
  byte of data off the serial bus using full handshaking. The data is
  returned in the accumulator. To prepare for this routine the TALK routine
  must be called first to command the device on the serial bus to send data
  through the bus. If the input device needs a secondary command, it must
  be sent by using the TKSA KERNAL routine before calling this routine.
  Errors are returned in the status word. The READST routine is used to
  read the status word.


  How to Use:

    0) Command a device on the serial bus to prepare to send data to
       the Commodore 64. (Use the TALK and TKSA KERNAL routines.)
    1) Call this routine (using JSR).
    2) Store or otherwise use the data.


  EXAMPLE:

    ;GET A BYTE FROM THE BUS
    JSR ACPTR
    STA DATA"
how do I display a sprite beyond the 255TH X-POSITION?,"DISPLAYING A SPRITE BEYOND THE 255TH X-POSITION

    Displaying a sprite beyond the 255th X position requires a special POKE
  which SETS the most significant bit of the X position and starts over at
  the 256th pixel position across the screen. Here's how it works...
    First, you POKE V+16 with the number for the sprite you're using (check
  the 'RIGHT X' row in the X-Y chart... we'll use sprite 0). Now we assign
  an X position, keeping in mind that the X counter starts over from 0 at
  the 256th position on the screen. Change line 50 to read as follows:
    50 POKE V+16,1:POKE V,24:POKE V+1,75

  This line POKEs V+ 16 with the number required to 'open up' the right
  side of the screen... the new X position 24 for sprite 0 now begins 24
  pixels to the RIGHT of position 255. To check the right edge of the
  screen, change line 60 to:

    60 POKE V+16,1:POKE V,65:POKE V+1,75

    Some experimentation with the settings in the sprite chart will give
  you the settings you need to position and move sprites on the left and
  right sides of the screen. The section on 'moving sprites' will also
  increase your understanding of how sprite positioning works."
What is the range of values that the volume control can be set to?,"VOLUME CONTROL

    Chip register 24 contains the overall volume control. The volume can be
  set anywhere between 0 and 15. The other four bits are used for purposes
  we'll get into later. For now it is enough to know volume is 0 to 15.
  Look at line 30 to see how it's set in Example Program 1."
What is the purpose of the IOBASE routine in the Commodore 64 KERNAL?,"B-12. Function Name: IOBASE

    Purpose: Define I/O memory page
    Call address: $FFF3 (hex) 65523 (decimal)
    Communication registers: X, Y
    Preparatory routines: None
    Error returns:
    Stack requirements: 2
    Registers affected: X, Y


    Description: This routine sets the X and Y registers to the address of
  the memory section where the memory mapped 110 devices are located. This
  address can then be used with an offset to access the memory mapped I/O
  devices in the Commodore 64. The offset is the number of locations from
  the beginning of the page on which the I/O register you want is located.
  The X register contains the low order address byte, while the Y register
  contains the high order address byte.
    This routine exists to provide compatibility between the Commodore 64,
  VIC-20, and future models of the Commodore 64. If the J/0 locations for
  a machine language program are set by a call to this routine, they should
  still remain compatible with future versions of the Commodore 64, the
  KERNAL and BASIC.


  How to Use:

    1) Call this routine by using the JSR instruction.
    2) Store the X and the Y registers in consecutive locations.
    3) Load the Y register with the offset.
    4) Access that I/O location.

  EXAMPLE:

    ;SET THE DATA DIRECTION REGISTER OF THE USER PORT TO 0 (INPUT)
    JSR IOBASE
    STX POINT       ;SET BASE REGISTERS
    STY POINT+1
    LDY #2
    LDA #0          ;OFFSET FOR DDR OF THE USER PORT
    STA (POINT),Y   ;SET DDR TO 0"
What is the purpose of the IOINIT function?,"B-13. Function Name: IOINIT

    Purpose: Initialize I/O devices
    Call Address: $FF84 (hex) 65412 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns:
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine initializes all input/output devices and
  routines. It is normally called as part of the initialization procedure
  of a Commodore 64 program cartridge.

  EXAMPLE:
    JSR IOINIT"
What determines the order in which sprites appear on the screen when they overlap?,"SPRITE PRIORITIES

    You can actually make different sprites seem to move IN FRONT OF or
  BEHIND each other on the screen. This incredible three dimensional illu-
  sion is achieved by the built-in SPRITE PRIORITIES which determine which
  sprites have priority over the others when 2 or more sprites OVERLAP on
  the screen.
    The rule is 'first come, first served' which means lower-numbered
  sprites AUTOMATICALLY have priority over higher-numbered sprites. For
  example, if you display sprite 0 and sprite 1 so they overlap on the
  screen, sprite 0 will appear to be IN FRONT OF sprite 1. Actually, sprite
  0 always supersedes all the other sprites because it's the lowest num-
  bered sprite. In comparison, sprite 1 has priority over sprites 2-7;
  sprite 2 has priority over sprites 3-7, etc. Sprite 7 (the last sprite)
  has LESS PRIORITY than any of the other sprites, and will always appear
  to be displayed 'BEHIND' any other sprites which overlap its position.
    To illustrate how priorities work, change lines 50, 60, and 70 in the
  program above to the following:


  50 POKEV,24:POKEV+1,50:POKEV+16,0
  60 POKEV+2,34:POKEV+3,60
  70 POKEV+4,44:POKEV+5,70


  You should see a white sprite on top of a yellow sprite on top of an
  orange sprite. Of course, now that you see how priorities work, you can
  also MOVE SPRITES and take advantage of these priorities in your ani-
  mation."
What is the primary function of the built-in program that interprets and executes CBM BASIC commands on the Commodore 64?,"The C64 OPERATING SYSTEM of the Commodore 64 then allows you to type on the
  keyboard, and use the built-in SCREEN EDITOR on the Commodore 64. The
  SCREEN EDITOR allows you to move the cursor, DELete, INSert, etc., and
  is, in fact, only one part of the operating system that is built in for
  your convenience.
    All of the commands that are available in CBM BASIC are simply
  recognized by another huge machine language program built into your
  Commodore 64. This huge program 'RUNS' the appropriate piece of machine
  language depending on which CBM BASIC command is being executed. This
  program is called the BASIC INTERPRETER, because it interprets each
  command, one by one, unless it encounters a command it does not
  understand, and then the familiar message appears:

    ?SYNTAX ERROR

    READY."
What is the purpose of the ACPTR kernal function?,"Function Name: ACPTR

    Purpose: Get data from the serial bus
    Call address: $FFA5 (hex) 65445 (decimal)
    Communication registers: A
    Preparatory routines: TALK, TKSA
    Error returns: See READST
    Stack requirements: 13
    Registers affected: A, X"
What is the assembly language instruction that stores the value in the accumulator into memory at the specified address?,"STY                    STY Store index Y in memory                    STY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Zero Page     |   STY Oper            |    84   |    2    |    3     |
  |  Zero Page,X   |   STY Oper,X          |    94   |    2    |    4     |
  |  Absolute      |   STY Oper            |    8C   |    3    |    4     |"
What forms of data storage do floppy diskettes allow?,"DATA STORAGE ON FLOPPY DISKETTES

    Diskettes allow 3 different forms of data storage. Sequential files are
  similar to those on tape, but several can can be used at the same time.
  Relative files let you organize the data into records, and then read and
  replace individual records within the file. Random files let you work
  with data anywhere on the disk. They are organized into 256 byte sections
  called blocks.
    The PRINT# statement's limitations are discussed in the section on
  cassette tape. The same limitations to format apply on the disk. RETURNs
  or commas are needed to separate your data. The CHR$(0) is still read by
  the GET# statement as an empty string.
    Relative and random files both make use of separate data and command
  'channels.' Data written to the disk goes through the data channel, where
  it is stored in a temporary buffer in the disk's RAM. When the record or
  block is complete, a command is sent through the command channel that
  tells the drive where to put the data, and the entire buffer is written.
    Applications that require large amounts of data to be processed are
  best stored in relative disk files. These will use the least amount of
  time and provide the best flexibility for the programmer. Your disk drive
  manual gives a complete programming guide to use of disk files."
HWhat is the purpose of the SAVE routine in the  kernal?,"B-24. Function Name: SAVE

    Purpose: Save memory to a device
    Call address: $FFD8 (hex) 65496 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: SETLFS, SETNAM
    Error returns: 5,8,9, READST
    Stack requirements: None
    Registers affected: A, X, Y

    Description: This routine saves a section of memory. Memory is saved
  from an indirect address on page 0 specified by the accumulator to the
  address stored in the X and Y registers. It is then sent to a logical
  file on an input/output device. The SETLFS and SETNAM routines must be
  used before calling this routine. However, a file name is not required to
  SAVE to device 1 (the Datassette(TM) recorder). Any attempt to save to
  other devices without using a file name results in an error.

  
  NOTE: Device 0 (the keyboard), device 2 (RS-232), and device 3 (the 
  screen) cannot be SAVEd to. If the attempt is made, an error occurs,
  and the SAVE is stopped.                                            

  How to Use:

    0) Use the SETLFS routine and the SETNAM routine (unless a SAVE with no
       file name is desired on 'a save to the tape recorder'),
    1) Load two consecutive locations on page 0 with a pointer to the start
       of your save (in standard 6502 low byte first, high byte next
       format).
    2) Load the accumulator with the single byte page zero offset to the
       pointer.
    3) Load the X and Y registers with the low byte and high byte re-
       spectively of the location of the end of the save.
    4) Call this routine.

  EXAMPLE:

    LDA #1              ;DEVICE = 1:CASSETTE
    JSR SETLFS
    LDA #0              ;NO FILE NAME
    JSR SETNAM
    LDA PROG            ;LOAD START ADDRESS OF SAVE
    STA TXTTAB          ;(LOW BYTE)
    LDA PROG+1
    STA TXTTA B+1       ;(HIGH BYTE)
    LDX VARTAB          ;LOAD X WITH LOW BYTE OF END OF SAVE
    LDY VARTAB+1        ;LOAD Y WITH HIGH BYTE
    LDA #<TXTTAB        ;LOAD ACCUMULATOR WITH PAGE 0 OFFSET
    JSR SAVE"
What is the purpose of the UNTLK kernal function?,"Function Name: UNTLK

    Purpose: Send an UNTALK command
    Call address: $FFAB (hex) 65451 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine transmits an UNTALK command on the serial
  bus. All devices previously set to TALK will stop sending data when this
  command is received.

  How to Use:
    1) Call this routine.

  EXAMPLE:
    JSR UNTALK"
What happens when you close an RS-232 data channel?,"CLOSING AN RS-232 DATA CHANNEL

    Closing an RS-232 file discards all data in the buffers at the time of
  execution (whether or not it had been transmitted or printed out), stops
  all RS-232 transmitting and receiving, sets the RTS and transmitted data
  (Sout) lines high, and removes both RS-232 buffers.


  BASIC SYNTAX:

    CLOSE lfn


  KERNAL ENTRY:

    CLOSE ($FFC3)-See Memory Map for more information on entry and exit
  conditions.

  | NOTE: Care should be taken to ensure all data is transmitted before   |
  | closing the channel. A way to check this from BASIC is:               |
  |                                                                       |
  | 100 SS=ST: IF(SS=0 OR SS=8) THEN 100                                  |
  | 110 CLOSE lfn                                                         |"
What is the purpose of the TALK kernal function?,"Function Name: TALK

    Purpose: Command a device on the serial bus to TALK
    Call address: $FFB4 (hex) 65460 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: To use this routine the accumulator must first be loaded
  with a device number between 0 and 31. When called, this routine then
  ORs bit by bit to convert this device number to a talk address. Then this
  data is transmitted as a command on the serial bus.

  How to Use:

    1) Load the accumulator with the device number.
    2) Call this routine.

  EXAMPLE:

    ;COMMAND DEVICE #4 TO TALK
    LDA #4
    JSR TALK"
What is the purpose of the SETLFS kernal routine?,"B-28. Function Name: SETLFS

    Purpose: Set up a logical file
    Call address: $FFBA (hex) 65466 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: None


    Description: This routine sets the logical file number, device address,
  and secondary address (command number) for other KERNAL routines.
    The logical file number is used by the system as a key to the file
  table created by the OPEN file routine. Device addresses can range from 0
  to 31. The following codes are used by the Commodore 64 to stand for the
  CBM devices listed below:


                  ADDRESS          DEVICE

                     0            Keyboard
                     1            Datassette(TM)
                     2            RS-232C device
                     3            CRT display
                     4            Serial bus printer
                     8            CBM serial bus disk drive


    Device numbers 4 or greater automatically refer to devices on the
  serial bus.
    A command to the device is sent as a secondary address on the serial
  bus after the device number is sent during the serial attention
  handshaking sequence. If no secondary address is to be sent, the Y index
  register should be set to 255.

  How to Use:

    1) Load the accumulator with the logical file number.
    2) Load the X index register with the device number.
    3) Load the Y index register with the command.


  EXAMPLE:

    FOR LOGICAL FILE 32, DEVICE #4, AND NO COMMAND:
    LDA #32
    LDX #4
    LDY #255
    JSR SETLFS"
What is a common method used to write machine language programs?,"HOW DO YOU WRITE MACHINE LANGUAGE PROGRAMS?

    Since machine language programs reside in memory, and there is no
  facility in your Commodore 64 for writing and editing machine language
  programs, you must use either a program to do this, or write for yourself
  a BASIC program that 'allows' you to write machine language.
    The most common methods used to write machine language programs are
  assembler programs. These packages allow you to write machine language
  instructions in a standardized mnemonic format, which makes the machine
  language program a lot more readable than a stream of numbers! Let's
  review: A program that allows you to write machine language programs in
  mnemonic format is called an assembler. Incidentally, a program that
  displays a machine language program in mnemonic format is called a
  disassembler. Available for your Commodore 64 is a machine language
  monitor cartridge (with assembler/disassembler, etc.) made by Commodore."
What is the assembly language instruction that transfers the value of the index register X to the accumulator in 6502?,"TXA                TXA Transfer index X to accumulator                TXA
  
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TXA                 |    8A   |    1    |    2     |"
What is the breakdown of the Commodore 64's memory map?,"I/O BREAKDOWN

    D000-D3FF   VIC (Video Controller)                     1 K Bytes
    D400-D7FF   SID (Sound Synthesizer)                    1 K Bytes
    D800-DBFF   Color RAM                                  1 K Nybbles
    DC00-DCFF   CIA1 (Keyboard)                            256 Bytes
    DD00-DDFF   CIA2 (Serial Bus, User Port/RS-232)        256 Bytes
    DE00-DEFF   Open I/O slot #l (CP/M Enable)             256 Bytes
    DF00-DFFF   Open I/O slot #2 (Disk)                    256 Bytes

    The two open I/O slots are for general purpose user I/O, special pur-
  pose I/O cartridges (such as IEEE), and have been tentatively designated
  for enabling the Z-80 cartridge (CP/M option) and for interfacing to a
  low-cost high-speed disk system.
    The system provides for 'auto-start' of the program in a Commodore 64
  Expansion Cartridge. The cartridge program is started if the first nine
  bytes of the cartridge ROM starting at location 32768 ($8000) contain
  specific data. The first two bytes must hold the Cold Start vector to be
  used by the cartridge program. The next two bytes at 32770 ($8002) must
  be the Warm Start vector used by the cartridge program. The next three
  bytes must be the letters, CBM, with bit 7 set in each letter. The last
  two bytes must be the digits '80' in PET ASCII."
What is the method for turning on and off individual sprites without affecting others?,"SPRITEMAKING NOTES

            Alternative Sprite Memory Pointers and Memory Locations
                            Using Cassette Buffer
  
  TURNING ON SPRITES:

    You can turn on any individual sprite by using POKE V+21 and the number
  from the chart... BUT... turning on just ONE sprite will turn OFF any
  others. To turn on TWO OR MORE sprites, ADD TOGETHER the numbers of the
  sprites you want to turn on (Example: POKE V+21, 6 turns on sprites 1 and
  2). Here is a method you can use to turn one sprite off and on without
  affecting any of the others (useful for animation).

  EXAMPLE:

    To turn off just sprite 0 type: POKE V+21,PEEK V+21AND(255-1). Change
  the number 1 in (255-1) to 1,2,4,8,16,32,64, or 128 (for sprites 0-7). To
  re-enable the sprite and not affect the other sprites currently turned
  on, POKE V+21, PEEK(V+21)OR 1 and change the OR 1 to OR 2 (sprite 2), OR
  4 (sprite 3), etc."
What is the purpose of the RESTOR kernal function?,"B-23. Function Name: RESTOR

    Purpose: Restore default system and interrupt vectors
    Call address: $FF8A (hex) 65418 (decimal)
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X, Y

    Description: This routine restores the default values of all system
  vectors used in KERNAL and BASIC routines and interrupts. (See the Memory
  Map for the default vector contents). The KERNAL VECTOR routine is used
  to read and alter individual system vectors.

  How to Use:
    1) Call this routine.

  EXAMPLE:
    JSR RESTOR"
How you detect when a sprite collides with another?,"SPRITE COLLISION:

    You can detect whether a sprite has collided with another sprite by
  using this line: IF PEEK(V+30)ANDX=XTHEN [insert action here]. This line
  checks to see if a particular sprite has collided with ANY OTHER SPRITE,
  where X equals 1 for sprite 0, 2 for sprite 1, 4 for sprite 2, 8 for
  sprite 3, 16 for sprite 4, 32 for sprite 5, 64 for sprite 6, and 128 for
  sprite 7. To check to see if the sprite has collided with a 'BACKGROUND
  CHARACTER' use this line: IF PEEK(V+31)ANDX=XTHEN [insert action here]."
What is the range of memory locations where color memory is always located?,"COLOR MEMORY

    Color memory can NOT move. It is always located at locations 55296
  ($D800) through 56295 ($DBE7). Screen memory (the 1000 locations starting
  at 1024) and color memory are used differently in the different graphics
  modes. A picture created in one mode will often look completely different
  when displayed in another graphics mode."
What is the primary requirement for creating multi-colored sprites in a specific mode?,"USING MULTI-COLOR:

    You can create multi-colored sprites although using multi-color mode
  requires that you use PAIRS of pixels instead of individual pixels in
  your sprite picture (in other words each colored 'dot' or 'block' in the
  sprite will consist of two pixels side by side). You have 4 colors to
  choose from: Sprite Color (chart,above), Multi-Color 1, Multi-Color 2 and
  'Background Color' (background is achieved by using zero settings which
  let the background color 'show through'). Consider one horizontal 8-pixel
  block in a sprite picture. The color of each PAIR of pixels is determined
  according to whether the left, right, or both pixels are solid."
What is the Kernal?,"THE KERNAL


    One of the problems facing programmers in the microcomputer field is
  the question of what to do when changes are made to the operating system
  of the computer by the company. Machine language programs which took much
  time to develop might no longer work, forcing major revisions in the
  program. To alleviate this problem, Commodore has developed a method of
  protecting software writers called the KERNAL.
    Essentially, the KERNAL is a standardized JUMP TABLE to the input,
  output, and memory management routines in the operating system. The
  locations of each routine in ROM may change as the system is upgraded.
  But the KERNAL jump table will always be changed to match. If your
  machine language routines only use the system ROM routines through the
  KERNAL, it will take much less work to modify them, should that need ever
  arise.
    The KERNAL is the operating system of the Commodore 64 computer. All
  input, output, and memory management is controlled by the KERNAL.
    To simplify the machine language programs you write, and to make sure
  that future versions of the Commodore 64 operating system don't make your
  machine language programs obsolete, the KERNAL contains a jump table for
  you to use. By taking advantage of the 39 input/output routines and other
  utilities available to you from the table, not only do you save time, you
  also make it easier to translate your programs from one Commodore
  computer to another.
    The jump table is located on the last page of memory, in read-only
  memory (ROM).
    To use the KERNAL jump table, first you set up the parameters that the
  KERNAL routine needs to work. Then JSR (Jump to SubRoutine) to the proper
  place in the KERNAL jump table. After performing its function, the KERNAL
  transfers control back to your machine language program. Depending on
  which KERNAL routine you are using, certain registers may pass parameters
  back to your program. The particular registers for each KERNAL routine
  may be found in the individual descriptions of the KERNAL subroutines.

    A good question at this point is why use the jump table at all? Why not
  just JSR directly to the KERNAL subroutine involved? The jump table is
  used so that if the KERNAL or BASIC is changed, your machine language
  programs will still work. In future operating systems the routines may
  have their memory locations moved around to a different position in the
  memory map... but the jump table will still work correctly!"
What is 64Mon?,"64MON

    The 64MON cartridge available from your local dealer, is a program that
  allows you to escape from the world of CBM BASIC, into the land of
  machine language. It can display the contents of the internal registers
  in the 6510 microprocessor, and it allows you to display portions of mem-
  ory, and change them on the screen, using the screen editor. It also has
  a built-in assembler and disassembler, as well as many other features
  that allow you to write and edit machine language programs easily. You
  don't HAVE to use an assembler to write machine language, but the task is
  considerably easier with it. If you wish to write machine language
  programs, it is strongly suggested that you purchase an assembler of some
  sort. Without an assembler you will probably have to 'POKE' the machine
  language program into memory, which is totally unadvisable. This manual
  will give its examples in the format that 64MON uses, from now on. Nearly
  all assembler formats are the same, therefore the machine language
  examples shown will almost certainly be compatible with any assembler.
  But before explaining any of the other features of 64MON, the hexadecimal
  numbering system must be explained."
What is the purpose of the 6502 instruction TXS?,"TXS              TXS Transfer index X to stack pointer                TXS
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TXS                 |    9A   |    1    |    2     |"
What is the purpose of the SETMSG kernal routine?,"B-29. Function Name: SETMSG

    Purpose: Control system message output
    Call address: $FF90 (hex) 65424 (decimal)
    Communication registers: A
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A

    Description: This routine controls the printing of error and control
  messages by the KERNAL. Either print error messages or print control mes-
  sages can be selected by setting the accumulator when the routine is
  called. FILE NOT FOUND is an example of an error message. PRESS PLAY ON
  CASSETTE is an example of a control message.
    Bits 6 and 7 of this value determine where the message will come from.
  If bit 7 is 1, one of the error messages from the KERNAL is printed. If
  bit 6 is set, control messages are printed.

  How to Use:

    1) Set accumulator to desired value.
    2) Call this routine.

  EXAMPLE:

    LDA #$40
    JSR SETMSG          ;TURN ON CONTROL MESSAGES
    LDA #$80
    JSR SETMSG          ;TURN ON ERROR MESSAGES
    LDA #0
    JSR SETMSG          ;TURN OFF ALL KERNAL MESSAGES"
What is the purpose of the TKSA kernal function in a serial communication protocol?,"Function Name: TKSA

    Purpose: Send a secondary address to a device commanded to TALK
    Call address: $FF96 (hex) 65430 (decimal)
    Communication registers: A
    Preparatory routines: TALK
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine transmits a secondary address on the serial
  bus for a TALK device. This routine must be called with a number between
  0 and 31 in the accumulator. The routine sends this number as a secondary
  address command over the serial bus. This routine can only be called
  after a call to the TALK routine. It will not work after a LISTEN.

  How to Use:

    0) Use the TALK routine.
    1) Load the accumulator with the secondary address.
    2) Call this routine.

  EXAMPLE:

    ;TELL DEVICE #4 TO TALK WITH COMMAND #7
    LDA #4
    JSR TALK
    LDA #7
    JSR TALKSA"
What is the purpose of the two-byte pointers $00F7 and $00F9 in the system?,"RECEIVER/TRANSMITTER BUFFER BASE LOCATION POINTERS


    $00F7-REBUF-A two-byte pointer to the Receiver Buffer base location.
    $00F9-ROBUF-A two-byte pointer to the Transmitter Buffer base location.

    The two locations above are set up by the OPEN KERNAL routine, each
  pointing to a different 256-byte buffer. They are de-allocated by writing
  a zero into the high order bytes ($00F8 and $00FA), which is done by the
  CLOSE KERNAL entry. They may also be allocated/de-allocated by the
  machine language programmer for his/her own purposes, removing/creating
  only the buffer(s) required. When using a machine language program that
  allocates these buffers, care must be taken to make sure that the top of
  memory pointers stay correct, especially if BASIC programs are expected
  to run at the same time."
What is the purpose of the SETTIM kernal function?,"B-31. Function Name: SETTIM

    Purpose: Set the system clock
    Call address: $FFDB (hex) 65499 (decimal)
    Communication registers: A, X, Y
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: None

    Description: A system clock is maintained by an interrupt routine that
  updates the clock every 1/60th of a second (one 'jiffy'). The clock is
  three bytes long, which gives it the capability to count up to 5,184,000
  jiffies (24 hours). At that point the clock resets to zero. Before
  calling this routine to set the clock, the accumulator must contain the
  most significant byte, the X index register the next most significant
  byte, and the Y index register the least significant byte of the initial
  time setting (in jiffies).

  How to Use:
    1) Load the accumulator with the MSB of the 3-byte number to set the
       clock.
    2) Load the X register with the next byte.
    3) Load the Y register with the LSB.
    4) Call this routine.

  EXAMPLE:
   ;SET THE CLOCK TO 10 MINUTES = 3600 JIFFIES
   LDA #0               ;MOST SIGNIFICANT
   LDX #>3600
   LDY #<3600           ;LEAST SIGNIFICANT
   JSR SETTIM"
What is the purpose of the UNLSN kernal function?,"Function Name: UNLSN

    Purpose: Send an UNLISTEN command
    Call address: $FFAE (hex) 65454 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: See READST
    Stack requirements: 8
    Registers affected: A

    Description: This routine commands all devices on the serial bus to
  stop receiving data from the Commodore 64 (i.e., UNLISTEN). Calling this
  routine results in an UNLISTEN command being transmitted on the serial
  bus. Only devices previously commanded to listen are affected. This
  routine is normally used after the Commodore 64 is finished sending data
  to external devices. Sending the UNLISTEN commands the listening devices
  to get off the serial bus so it can be used for other purposes.

  How to Use:
    1) Call this routine.

  EXAMPLE:
    JSR UNLSN"
What is the instruction for disabling the interrupt in the 6502 microprocessor?,"SEI                 SEI Set interrupt disable status                  SED

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   SEI                 |    78   |    1    |    2     |"
What is the purpose of the TSX instruction in the 6502 assembly ?,"TSX              TSX Transfer stack pointer to index X                TSX

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TSX                 |    BA   |    1    |    2     |"
What are some important considerations when setting sprite pointer settings in RAM memory?,"DIFFERENT SPRITE POINTER SETTINGS:

    These sprite pointer settings are RECOMMENDATIONS ONLY.
    Caution: you can set your sprite pointers anywhere in RAM memory but if
  you set them too 'low' in memory a long BASIC program may overwrite your
  sprite data, or vice versa. To protect an especially LONG BASIC PROGRAM
  from overwriting sprite data, you may want to set the sprites at a higher
  area of memory (for example, 2040,192 for sprite 0 at locations 12288 to
  12350... 2041,193 at locations 12352 to 12414 for sprite 1 and so on...
  by adjusting the memory locations from which sprites get their 'data,'
  you can define as many as 64 different sprites plus a sizable BASIC
  program. To do this, define several sprite 'shapes' in your DATA
  statements and then redefine a particular sprite by changing the
  'pointer' so the sprite you are using is 'pointed' at different areas of
  memory containing different sprite picture data. See the 'Dancing Mouse'
  to see how this works. If you want two or more sprites to have THE SAME
  SHAPE (you can still change position and color of each sprite), use the
  same sprite pointer and memory location for the sprites you want to match
  (for example, you can point sprites 0 and 1 to the same location by using
  POKE 2040,192 and POKE 2041, 192)."
"What is the purpose of crunching"" a program in the context of sprite programming?""","CRUNCHING YOUR SPRITE PROGRAMS                                        

                                                                         
   Here's a helpful 'crunching' tip: The program described above is      
   already short, but it can be made even shorter by 'crunching' it      
   smaller. In our example we list the key sprite settings on separate   
   program lines so you can see what's happening in the program. In      
   actual practice, a good programmer would probably write this program  
   as a TWO LINE PROGRAM... by 'crunching' it as follows:                
                                                                         
   10 PRINTCHR$(147):V=53248:POKEV+21,1:POKE2040.13:POKEV+39,1           
   20 FORS=832TO894:POKES,255:NEXT:POKEV,24:POKEV+1,100                  
                                                                         
   For more tips on how to crunch your programs so they fit in less      
  memory and run more efficiently, see the 'crunching guide' on Page 24."
Ho do you position a sprite on the screen?,"POSITIONING SPRITES ON THE SCREEN

    The entire display screen is divided into a grid of X and Y coordi-
  nates, like a graph. The X COORDINATE is the HORIZONTAL position across
  the screen and the Y COORDINATE is the VERTICAL position up and down (see
  Figure 3-4).
    To position any sprite on the screen, you must POKE TWO SETTINGS...
  the X position and the Y position... these tell the computer where to
  display the UPPER LEFT HAND CORNER of the sprite. Remember that a sprite
  consists of 504 individual pixels, 24 across by 21 down... so if you POKE
  a sprite onto the upper left corner of your screen, the sprite will be
  displayed as a graphic image 24 pixels ACROSS and 21 pixels DOWN starting
  at the X-Y position you defined. The sprite will be displayed based on
  the upper left corner of the entire sprite, even if you define the sprite
  using only a small part of the 24X21-pixel sprite area.
    To understand how X-Y positioning works, study the following diagram
  (Figure 3-5), which shows the X and Y numbers in relation to your display
  screen. Note that the GREY AREA in the diagram shows your television
  viewing area... the white area represents positions which are OFF your
  viewing screen...

    To display a sprite in a given location, You must POKE the X and Y
  settings for each SPRITE... remembering that every sprite has its own
  unique X POKE and Y POKE."
What is the step-by-step guide for creating a sprite?,"CREATING A SPRITE... STEP BY STEP

    To make this as easy as possible for you, we've put together this
  simple step by step guide to help you draw your own sprites.

  STEP 1:

  Write the spritemaking program shown here ON A PIECE OF PAPER... note
  that line 100 starts a special DATA section of your program which will
  contain the 63 numbers you need to create your sprite.

  STEP 2:

  Color in the pixels on the spritemaking grid on Page 162 (or use a piece
  of graph paper... remember, a sprite has 24 squares across and 21 squares
  down). We suggest you use a pencil and draw lightly so you can reuse this
  grid. You can create any image you like, but for our example we'll draw
  a simple box.

  STEP 3:

  Look at the first EIGHT pixels. Each column of pixels has a number (128,
  64, 32, 16, 8, 4, 2, 1). The special type of addition we are going to
  show you is a type of BINARY ARITHMETIC which is used by most computers
  as a special way of counting. 
  STEP 4:

  Add up the numbers of the SOLID pixels. This first group of eight pixels
  is completely solid, so the total number is 255.

  STEP 5:

  Enter that number as the FIRST DATA STATEMENT in line 100 of the
  Spritemaking Program below. Enter 255 for the second and third groups
  of eight.

  STEP 6:

  Look at the FIRST EIGHT PIXELS IN THE SECOND ROW of the sprite. Add up
  the values of the solid pixels. Since only one of these pixels is solid,
  the total value is 128. Enter this as the first DATA number in line 101.


  STEP 7:

  Add up the values of the next group of eight pixels (which is 0 because
  they're all BLANK) and enter in line 101. Now move to the next group of
  pixels and repeat the process for each GROUP OF EIGHT PIXELS (there are
  3 groups across each row, and 21 rows). This will give you a total of 63
  numbers. Each number represents ONE group of 8 pixels, and 63 groups of
  eight equals 504 total individual pixels. Perhaps a better way of looking
  at the program is like this... each line in the program represents ONE
  ROW in the sprite. Each of the 3 numbers in each row represents ONE GROUP
  OF EIGHT PIXELS. And each number tells the computer which pixels to make
  SOLID and which pixels to leave blank.

  STEP 8:

  CRUNCH YOUR PROGRAM INTO A SMALLER SPACE BY RUNNING TOGETHER ALL THE DATA
  STATEMENTS, AS SHOWN IN THE SAMPLE PROGRAM BELOW. Note that we asked you
  to write your sprite program on a piece of paper. We did this for a good
  reason. The DATA STATEMENT LINES 100-120 in the program in STEP 1 are
  only there to help you see which numbers relate to which groups of pixels
  in your sprite. Your final program should be 'crunched' like this:

start tok64 page165.prg
  10 print'{clear}':poke53280,5:poke53281,6
  20 v=53248:pokev+34,3
  30 poke 53269,4:poke2042,13
  40 forn=0to62:readq:poke832+n,q:next
  100 data255,255,255,128,0,1,128,0,1,128,0,1,144,0,1,144,0,1,144,0,1,144,0
  101 data1,144,0,1,144,0,1,144,0,1,144,0,1,144,0,1,144,0,1,128,0,1,128,0,1
  102 data128,0,1,128,0,1,128,0,1,128,0,1,255,255,255
  200 x=200:y=100:poke53252,x:poke53253,y
stop tok64"
What is the priority of a sprite that will always appear in front of or on top of all other sprites?,"SPRITE PRIORITY:

    Priority means one sprite will appear to move 'in front of' or 'behind'
  another sprite on the display screen. Sprites with more priority always
  appear to move 'in front of' or 'on top of' sprites with less priority.
  The rule is that lower numbered sprites have priority over higher
  numbered sprites. Sprite 0 has priority over all other sprites. Sprite 7
  has no priority in relation to the other sprites. Sprite 1 has priority
  over sprites 2-7, etc. If you put two sprites in the some position, the
  sprite with the higher priority will appear IN FRONT OF the sprite with
  the lower priority. The sprite with lower priority will either be
  obscured, or will 'show through' (from 'behind') the sprite with higher
  priority."
What is the instruction that transfers the accumulator to index Y in 6502?,"TAY                TAY Transfer accumulator to index Y                TAY

  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   TAY                 |    A8   |    1    |    2     |"
Can you talk about the C64 memory management?,"MEMORY MANAGEMENT ON THE
  COMMODORE 64

    The Commodore 64 has 64K bytes of RAM. It also has 20K bytes of ROM,
  containing BASIC, the operating system, and the standard character set.
  It also accesses input/output devices as a 4K chunk of memory. How is
  this all possible on a computer with a 16-bit address bus, that is
  normally only capable of addressing 64K?
    The secret is in the 6510 processor chip itself. On the chip is an
  input/output port. This port is used to control whether RAM or ROM or I/O
  will appear in certain portions of the system's memory. The port is also
  used to control the Datassette(TM), so it is important to affect only the
  proper bits.
    The 6510 input/output port appears at location 1. The data direction
  register for this port appears at location 0. The port is controlled like
  any of the other input/output ports in the system... the data direction
  controls whether a given bit will be an input or an output, and the
  actual data transfer occurs through the port itself. The lines in the
  6510 control port are defined as follows:


  |  NAME   |BIT| DIRECTION  |                 DESCRIPTION                |
  |  LORAM  | 0 |   OUTPUT   | Control for RAM/ROM at $A000-$BFFF         |
  |  HIRAM  | 1 |   OUTPUT   | Control for RAM/ROM at $E000-$FFFF         |
  |  CHAREN | 2 |   OUTPUT   | Control for I/O/ROM at $D000-$DFFF         |
  |         | 3 |   OUTPUT   | Cassette write line                        |
  |         | 4 |   INPUT    | Cassette switch sense (0=play button down) |
  |         | 5 |   OUTPUT   | Cassette motor control (0=motor spins)     |


    The proper value for the data direction register is as follows:

                              BITS 5 4 3 2 1 0
                              ----------------
                                   1 0 1 1 1 1

  (where 1 is an output, and 0 is an input).

    This gives a value of 47 decimal. The Commodore 64 automatically sets
  the data direction register to this value.
    The control lines, in general, perform the function given in their de-
  scriptions. However, a combination of control lines are occasionally used
  to get a particular memory configuration.
    LORAM (bit 0) can generally be thought of as a control line which banks
  the 8K byte BASIC ROM in and out of the microprocessor address space.
  Normally, this line is HIGH for BASIC operation. If this line is
  programmed LOW, the BASIC ROM will disappear from the memory map and be
  replaced by 8K bytes of RAM from $A000-$BFFF.
    HIRAM (bit 1) can generally be thought of as a control line which banks
  the 8K byte KERNAL ROM in and out of the microprocessor address space.
  Normally, this line is HIGH for BASIC operation. If this line is
  programmed LOW, the KERNAL ROM will disappear from the memory map and be
  replaced by 8K bytes of RAM from $E000-$FFFF.
    CHAREN (bit 2) is used only to bank the 4K byte character generator ROM
  in or out of the microprocessor address space. From the processor point
  of view, the character ROM occupies the same address space as the I/O
  devices ($D000-$DFFF). When the CHAREN line is set to 1 (as is normal),
  the I/O devices appear in the microprocessor address space, and the
  character ROM is not accessable. When the CHAREN bit is cleared to 0, the
  character ROM appears in the processor address space, and the I/O devices
  are not accessable. (The microprocessor only needs to access the
  character ROM when downloading the character set from ROM to RAM. Special
  care is needed for this... see the section on PROGRAMMABLE CHARACTERS in
  the GRAPHICS chapter). CHAREN can be overridden by other control lines in
  certain memory configurations. CHAREN will have no effect on any memory
  configuration without I/O devices. RAM will appear from $D000-$DFFF
  instead.


  | NOTE: In any memory map containing ROM, a WRITE (a POKE) to a ROM     |
  | location will store data in the RAM 'under' the ROM. Writing to a ROM |
  | location stores data in the 'hidden' RAM. For example, this allows a  |
  | hi-resolution screen to be kept underneath a ROM, and be changed      |
  | without having to bank the screen back into the processor address     |
  | space. Of course a READ of a ROM location will return the contents of |
  | the ROM, not the 'hidden' RAM.                                        |"
What is the OP CODE for the instruction SED in 6502?,"SED                       SED Set decimal mode                        SED
 
  | Addressing Mode| Assembly Language Form| OP CODE |No. Bytes|No. Cycles|
  |  Implied       |   SED                 |    F8   |    1    |    2     |"
What is the purpose of the UDTIM kernal function?,"Function Name: UDTIM

    Purpose: Update the system clock
    Call address: $FFEA (hex) 65514 (decimal)
    Communication registers: None
    Preparatory routines: None
    Error returns: None
    Stack requirements: 2
    Registers affected: A, X

    Description: This routine updates the system clock. Normally this
  routine is called by the normal KERNAL interrupt routine every 1/60th of
  a second. If the user program processes its own interrupts this routine
  must be called to update the time. In addition, the <STOP> key routine
  must be called, if the <STOP> key is to remain functional.

  How to Use:
    1) Call this routine.

  EXAMPLE:

    JSR UDTIM"
What is the purpose of the SETNAM kernal routine?,"B-30. Function Name: SETNAM

    Purpose: Set file name
    Call address: $FFBD (hex) 65469 (decimal)
    Communication registers: A, X, Y
    Preparatory routines:
    Stack requirements: 2
    Registers affected:

    Description: This routine is used to set up the file name for the OPEN,
  SAVE, or LOAD routines. The accumulator must be loaded with the length of
  the file name. The X and Y registers must be loaded with the address of
  the file name, in standard 6502 low-byte/high-byte format. The address
  can be any valid memory address in the system where a string of
  characters for the file name is stored. If no file name is desired, the
  accumulator must be set to 0, representing a zero file length. The X and
  Y registers can be set to any memory address in that case.

  How to Use:

    1) Load the accumulator with the length of the file name.
    2) Load the X index register with the low order address of the file
       name.
    3) Load the Y index register with the high order address.
    4) Call this routine.

  EXAMPLE:

    LDA #NAME2-NAME     ;LOAD LENGTH OF FILE NAME
    LDX #<NAME          ;LOAD ADDRESS OF FILE NAME
    LDY #>NAME
    JSR SETNAM"